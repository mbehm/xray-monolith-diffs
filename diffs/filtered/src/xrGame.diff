diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/account_manager.cpp xray-monolith/src/xrGame/account_manager.cpp
--- coc-1.4-xray-64/src/xrGame/account_manager.cpp	2023-10-20 20:54:50.750326600 +0100
+++ xray-monolith/src/xrGame/account_manager.cpp	2023-10-20 20:54:32.698035500 +0100
@@ -2,3 +2,2 @@
 #include "account_manager.h"
-#include "gamespy/GameSpy_GP.h"
 
@@ -242,14 +241,14 @@
 	
-	GPResult tmp_res = m_gamespy_gp->NewUser(
-		nick,
-		unique_nick,
-		email,
-		password,
-		&account_manager::new_user_cb,
-		this
-	);
-	if (tmp_res != GP_NO_ERROR)
-	{
-		m_account_creation_cb(false, CGameSpy_GP::TryToTranslate(tmp_res).c_str());
-	}	
+		//GPResult tmp_res = m_gamespy_gp->NewUser(
+		//	nick,
+		//	unique_nick,
+		//	email,
+		//	password,
+		//	&account_manager::new_user_cb,
+		//	this
+		//);
+		//if (tmp_res != GP_NO_ERROR)
+		//{
+		//	m_account_creation_cb(false, CGameSpy_GP::TryToTranslate(tmp_res).c_str());
+		//}	
 }
@@ -261,23 +260,24 @@
 		m_profile_deleting_cb.bind(this, &account_manager::only_log_profdel_cb);
-	} else
-	{
-		m_profile_deleting_cb = dpcb;
 	}
-
-	login_manager* tmp_lmngr = MainMenu()->GetLoginMngr();
-	VERIFY(tmp_lmngr);
-	if (!tmp_lmngr->get_current_profile())
+		else
 	{
-		m_profile_deleting_cb(false, "mp_gp_not_logged_in");
-		return;
+			m_profile_deleting_cb = dpcb;
 	}
 	
-	GPResult tmp_res = m_gamespy_gp->DeleteProfile(
-		&account_manager::delete_profile_cb,
-		this
-	);
-	if (tmp_res != GP_NO_ERROR)
-	{
-		m_profile_deleting_cb(false, CGameSpy_GP::TryToTranslate(tmp_res).c_str());
-	}
+		//login_manager* tmp_lmngr = MainMenu()->GetLoginMngr();
+		//VERIFY(tmp_lmngr);
+		//if (!tmp_lmngr->get_current_profile())
+		//{
+		//	m_profile_deleting_cb(false, "mp_gp_not_logged_in");
+		//	return;
+		//}
+
+		//GPResult tmp_res = m_gamespy_gp->DeleteProfile(
+		//	&account_manager::delete_profile_cb,
+		//	this
+		//);
+		//if (tmp_res != GP_NO_ERROR)
+		//{
+		//	m_profile_deleting_cb(false, CGameSpy_GP::TryToTranslate(tmp_res).c_str());
+		//}
 }
@@ -321,16 +322,15 @@
 
-	GPResult tmp_res = m_gamespy_gp->GetUserNicks(
-		args.m_t1.c_str(),
-		args.m_t2.c_str(),
-		&account_manager::user_nicks_cb,
-		this
-	);
-
-	if (tmp_res != GP_NO_ERROR)
-	{
-		m_account_profiles_cb.clear();
-		profiles_cb(0, CGameSpy_GP::TryToTranslate(tmp_res).c_str());
-		return;
-	}
-
+		//GPResult tmp_res = m_gamespy_gp->GetUserNicks(
+		//	args.m_t1.c_str(),
+		//	args.m_t2.c_str(),
+		//	&account_manager::user_nicks_cb,
+		//	this
+		//);
+
+		//if (tmp_res != GP_NO_ERROR)
+		//{
+		//	m_account_profiles_cb.clear();
+		//	profiles_cb(0, CGameSpy_GP::TryToTranslate(tmp_res).c_str());
+		//	return;
+		//}
 }
@@ -378,16 +378,16 @@
 	
-	GPResult tmp_res = m_gamespy_gp->ProfileSearch(
-		shared_str(),
-		shared_str(),
-		email.m_t1.c_str(),
-		&account_manager::search_profile_cb,
-		this
-	);
-
-	if (tmp_res != GP_NO_ERROR)
-	{
-		m_found_email_cb.clear();
-		found_email_cb(false, CGameSpy_GP::TryToTranslate(tmp_res).c_str());
-		return;
-	}
+		//GPResult tmp_res = m_gamespy_gp->ProfileSearch(
+		//	shared_str(),
+		//	shared_str(),
+		//	email.m_t1.c_str(),
+		//	&account_manager::search_profile_cb,
+		//	this
+		//);
+
+		//if (tmp_res != GP_NO_ERROR)
+		//{
+		//	m_found_email_cb.clear();
+		//	found_email_cb(false, CGameSpy_GP::TryToTranslate(tmp_res).c_str());
+		//	return;
+		//}
 }
@@ -429,14 +429,14 @@
 
-	GPResult tmp_res = m_gamespy_gp->SuggestUNicks(
-		unick.m_t1,
-		&account_manager::unicks_suggestion_cb,
-		this
-	);
-	
-	if (tmp_res != GP_NO_ERROR)
-	{
-		sncb(0, CGameSpy_GP::TryToTranslate(tmp_res).c_str());
-		m_suggest_nicks_cb.clear();
-		return;
-	}
+		//GPResult tmp_res = m_gamespy_gp->SuggestUNicks(
+		//	unick.m_t1,
+		//	&account_manager::unicks_suggestion_cb,
+		//	this
+		//);
+		//
+		//if (tmp_res != GP_NO_ERROR)
+		//{
+		//	sncb(0, CGameSpy_GP::TryToTranslate(tmp_res).c_str());
+		//	m_suggest_nicks_cb.clear();
+		//	return;
+		//}
 }
@@ -465,13 +463,13 @@
 {
-	GPNewUserResponseArg* creation_resp = static_cast<GPNewUserResponseArg*>(arg);
-	VERIFY(creation_resp != NULL);
-	account_manager* tmp_inst = static_cast<account_manager*>(param);
-	VERIFY(tmp_inst);
-	VERIFY(tmp_inst->m_account_creation_cb);
-	if (creation_resp->result != GP_NO_ERROR)
-	{
-		tmp_inst->m_account_creation_cb(false, CGameSpy_GP::TryToTranslate(creation_resp->result).c_str());
-		return;
-	}
-	tmp_inst->m_account_creation_cb(true, "");
+		//GPNewUserResponseArg* creation_resp = static_cast<GPNewUserResponseArg*>(arg);
+		//VERIFY(creation_resp != NULL);
+		//account_manager* tmp_inst = static_cast<account_manager*>(param);
+		//VERIFY(tmp_inst);
+		//VERIFY(tmp_inst->m_account_creation_cb);
+		//if (creation_resp->result != GP_NO_ERROR)
+		//{
+		//	tmp_inst->m_account_creation_cb(false, CGameSpy_GP::TryToTranslate(creation_resp->result).c_str());
+		//	return;
+		//}
+		//tmp_inst->m_account_creation_cb(true, "");
 }
@@ -482,23 +480,23 @@
 {
-	account_manager* tmp_inst			= static_cast<account_manager*>(param);
-	VERIFY(tmp_inst);
-	GPGetUserNicksResponseArg* tmp_arg	= static_cast<GPGetUserNicksResponseArg*>(arg);
-	
-	account_profiles_cb	tmp_cb = tmp_inst->m_account_profiles_cb;
-	tmp_inst->m_account_profiles_cb.clear();
-
-	if (tmp_arg->result != GP_NO_ERROR)
-	{
-		tmp_cb(0, CGameSpy_GP::TryToTranslate(tmp_arg->result).c_str());
-		return;
-	}
-
-	for (int i = 0; i < tmp_arg->numNicks; ++i)
-	{
-		tmp_inst->m_result_profiles.push_back(tmp_arg->nicks[i]);
-		tmp_inst->m_result_profiles_ptrs.push_back(
-			tmp_inst->m_result_profiles.back().c_str()
-		);
-	}
-	tmp_cb(tmp_arg->numNicks, "");
+		//account_manager* tmp_inst			= static_cast<account_manager*>(param);
+		//VERIFY(tmp_inst);
+		//GPGetUserNicksResponseArg* tmp_arg	= static_cast<GPGetUserNicksResponseArg*>(arg);
+		//
+		//account_profiles_cb	tmp_cb = tmp_inst->m_account_profiles_cb;
+		//tmp_inst->m_account_profiles_cb.clear();
+
+		//if (tmp_arg->result != GP_NO_ERROR)
+		//{
+		//	tmp_cb(0, CGameSpy_GP::TryToTranslate(tmp_arg->result).c_str());
+		//	return;
+		//}
+
+		//for (int i = 0; i < tmp_arg->numNicks; ++i)
+		//{
+		//	tmp_inst->m_result_profiles.push_back(tmp_arg->nicks[i]);
+		//	tmp_inst->m_result_profiles_ptrs.push_back(
+		//		tmp_inst->m_result_profiles.back().c_str()
+		//	);
+		//}
+		//tmp_cb(tmp_arg->numNicks, "");
 }
@@ -509,21 +507,21 @@
 {
-	account_manager* tmp_inst				= static_cast<account_manager*>(param);
-	VERIFY(tmp_inst);
-	GPSuggestUniqueNickResponseArg*	tmp_arg = static_cast<GPSuggestUniqueNickResponseArg*>(arg);
-	VERIFY(tmp_arg);
-	suggest_nicks_cb tmp_cb = tmp_inst->m_suggest_nicks_cb;
-	tmp_inst->m_suggest_nicks_cb.clear();
-
-	if (tmp_arg->result != GP_NO_ERROR)
-	{
-		tmp_cb(0, CGameSpy_GP::TryToTranslate(tmp_arg->result).c_str());
-		return;
-	}
-
-	for (int i = 0; i < tmp_arg->numSuggestedNicks; ++i)
-	{
-		tmp_inst->m_suggested_nicks.push_back		(tmp_arg->suggestedNicks[i]);
-		tmp_inst->m_suggested_nicks_ptrs.push_back	(tmp_inst->m_suggested_nicks.back().c_str());
-	}
-	tmp_cb(tmp_arg->numSuggestedNicks, "");
+		//account_manager* tmp_inst				= static_cast<account_manager*>(param);
+		//VERIFY(tmp_inst);
+		//GPSuggestUniqueNickResponseArg*	tmp_arg = static_cast<GPSuggestUniqueNickResponseArg*>(arg);
+		//VERIFY(tmp_arg);
+		//suggest_nicks_cb tmp_cb = tmp_inst->m_suggest_nicks_cb;
+		//tmp_inst->m_suggest_nicks_cb.clear();
+
+		//if (tmp_arg->result != GP_NO_ERROR)
+		//{
+		//	tmp_cb(0, CGameSpy_GP::TryToTranslate(tmp_arg->result).c_str());
+		//	return;
+		//}
+
+		//for (int i = 0; i < tmp_arg->numSuggestedNicks; ++i)
+		//{
+		//	tmp_inst->m_suggested_nicks.push_back		(tmp_arg->suggestedNicks[i]);
+		//	tmp_inst->m_suggested_nicks_ptrs.push_back	(tmp_inst->m_suggested_nicks.back().c_str());
+		//}
+		//tmp_cb(tmp_arg->numSuggestedNicks, "");
 }
@@ -534,15 +532,15 @@
 {
-	account_manager* tmp_inst				= static_cast<account_manager*>(param);
-	VERIFY(tmp_inst);
-	GPDeleteProfileResponseArg* tmp_arg		= static_cast<GPDeleteProfileResponseArg*>(arg);
-	if (tmp_arg->result != GP_NO_ERROR)
-	{
-		tmp_inst->m_profile_deleting_cb(false, CGameSpy_GP::TryToTranslate(tmp_arg->result).c_str());
-		return;
-	}
-	VERIFY(tmp_inst->m_gamespy_gp);
-	login_manager*	tmp_lmngr				= MainMenu()->GetLoginMngr();
-	VERIFY(tmp_lmngr);
-	tmp_lmngr->delete_profile_obj			();
-	tmp_inst->m_profile_deleting_cb			(true, "");
+		//account_manager* tmp_inst				= static_cast<account_manager*>(param);
+		//VERIFY(tmp_inst);
+		//GPDeleteProfileResponseArg* tmp_arg		= static_cast<GPDeleteProfileResponseArg*>(arg);
+		//if (tmp_arg->result != GP_NO_ERROR)
+		//{
+		//	tmp_inst->m_profile_deleting_cb(false, CGameSpy_GP::TryToTranslate(tmp_arg->result).c_str());
+		//	return;
+		//}
+		//VERIFY(tmp_inst->m_gamespy_gp);
+		//login_manager*	tmp_lmngr				= MainMenu()->GetLoginMngr();
+		//VERIFY(tmp_lmngr);
+		//tmp_lmngr->delete_profile_obj			();
+		//tmp_inst->m_profile_deleting_cb			(true, "");
 }
@@ -553,24 +551,23 @@
 {
-	account_manager* tmp_inst				= static_cast<account_manager*>(param);
-	VERIFY(tmp_inst);
-	GPProfileSearchResponseArg* tmp_arg		= static_cast<GPProfileSearchResponseArg*>(arg);
-	
-	found_email_cb	tmp_cb = tmp_inst->m_found_email_cb;
-	tmp_inst->m_found_email_cb.clear();
-
-	if (tmp_arg->result != GP_NO_ERROR)
-	{
-		tmp_cb(false, CGameSpy_GP::TryToTranslate(tmp_arg->result).c_str());
-		return;
-	}
-	if (tmp_arg->numMatches == 0)
-	{
-		tmp_cb(false, "");
-		return;
+		//account_manager* tmp_inst				= static_cast<account_manager*>(param);
+		//VERIFY(tmp_inst);
+		//GPProfileSearchResponseArg* tmp_arg		= static_cast<GPProfileSearchResponseArg*>(arg);
+		//
+		//found_email_cb	tmp_cb = tmp_inst->m_found_email_cb;
+		//tmp_inst->m_found_email_cb.clear();
+
+		//if (tmp_arg->result != GP_NO_ERROR)
+		//{
+		//	tmp_cb(false, CGameSpy_GP::TryToTranslate(tmp_arg->result).c_str());
+		//	return;
+		//}
+		//if (tmp_arg->numMatches == 0)
+		//{
+		//	tmp_cb(false, "");
+		//	return;
+		//}
+		//GPProfileSearchMatch*	first_match		= tmp_arg->matches;
+		//VERIFY(first_match->nick);
+		//tmp_cb(true, first_match->nick);
 	}
-	GPProfileSearchMatch*	first_match		= tmp_arg->matches;
-	VERIFY(first_match->nick);
-	tmp_cb(true, first_match->nick);
-}
-
 } //namespace gamespy_gp
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/account_manager.h xray-monolith/src/xrGame/account_manager.h
--- coc-1.4-xray-64/src/xrGame/account_manager.h	2023-10-20 20:54:50.751326600 +0100
+++ xray-monolith/src/xrGame/account_manager.h	2023-10-20 20:54:32.699035600 +0100
@@ -5,3 +5,2 @@
 #include "mixed_delegate.h"
-#include "GameSpy/GameSpy_FuncDefs.h"
 #include "script_export_space.h"
@@ -11,2 +10,6 @@
 
+/**/
+struct GPConnection; // HACK, FAKE STRUCT TO PRETEND GAMESPY EXISTS
+/**/
+
 namespace gamespy_gp
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/account_manager_console.cpp xray-monolith/src/xrGame/account_manager_console.cpp
--- coc-1.4-xray-64/src/xrGame/account_manager_console.cpp	2023-10-20 20:54:50.751326600 +0100
+++ xray-monolith/src/xrGame/account_manager_console.cpp	2023-10-20 20:54:32.699035600 +0100
@@ -2,5 +2,2 @@
 #include "account_manager_console.h"
-#include "gamespy/GameSpy_Full.h"
-#include "gamespy/GameSpy_GP.h"
-#include "gamespy/GameSpy_SAKE.h"
 #include "account_manager.h"
@@ -31,21 +28,21 @@
 	
-	VERIFY(MainMenu() && MainMenu()->GetGS());
-	CGameSpy_GP* tmp_gp = MainMenu()->GetGS()->GetGameSpyGP();
-	VERIFY(tmp_gp);
-	gamespy_gp::account_manager* tmp_acc_mngr = MainMenu()->GetAccountMngr();
-
-	gamespy_gp::new_profile_data	prof_data;
-
-	prof_data.nick					= tmp_nick;
-	prof_data.unique_nick			= tmp_unick;
-	prof_data.email					= tmp_email;
-	prof_data.password				= tmp_password;
-
-	tmp_acc_mngr->create_profile(
-		tmp_nick,
-		tmp_unick,
-		tmp_email,
-		tmp_password,
-		gamespy_gp::account_operation_cb()
-	);
+	//VERIFY(MainMenu() && MainMenu()->GetGS());
+	//CGameSpy_GP* tmp_gp = MainMenu()->GetGS()->GetGameSpyGP();
+	//VERIFY(tmp_gp);
+	//gamespy_gp::account_manager* tmp_acc_mngr = MainMenu()->GetAccountMngr();
+
+	//gamespy_gp::new_profile_data	prof_data;
+
+	//prof_data.nick					= tmp_nick;
+	//prof_data.unique_nick			= tmp_unick;
+	//prof_data.email					= tmp_email;
+	//prof_data.password				= tmp_password;
+
+	//tmp_acc_mngr->create_profile(
+	//	tmp_nick,
+	//	tmp_unick,
+	//	tmp_email,
+	//	tmp_password,
+	//	gamespy_gp::account_operation_cb()
+	//);
 }
@@ -68,11 +65,11 @@
 	
-	VERIFY(MainMenu() && MainMenu()->GetGS());
-	CGameSpy_GP* tmp_gp = MainMenu()->GetGS()->GetGameSpyGP();
-	VERIFY(tmp_gp);
-	gamespy_gp::account_manager* tmp_acc_mngr = MainMenu()->GetAccountMngr();
-	tmp_acc_mngr->get_account_profiles(
-		tmp_email,
-		tmp_password,
-		gamespy_gp::account_profiles_cb()
-	);
+	//VERIFY(MainMenu() && MainMenu()->GetGS());
+	//CGameSpy_GP* tmp_gp = MainMenu()->GetGS()->GetGameSpyGP();
+	//VERIFY(tmp_gp);
+	//gamespy_gp::account_manager* tmp_acc_mngr = MainMenu()->GetAccountMngr();
+	//tmp_acc_mngr->get_account_profiles(
+	//	tmp_email,
+	//	tmp_password,
+	//	gamespy_gp::account_profiles_cb()
+	//);
 }
@@ -98,8 +95,8 @@
 	
-	VERIFY(MainMenu() && MainMenu()->GetGS());
-	CGameSpy_GP* tmp_gp = MainMenu()->GetGS()->GetGameSpyGP();
-	VERIFY(tmp_gp);
-	gamespy_gp::login_manager*	tmp_lmngr = MainMenu()->GetLoginMngr();
-	VERIFY(tmp_lmngr);
-	tmp_lmngr->login(tmp_email, tmp_nick, tmp_password, gamespy_gp::login_operation_cb());
+	//VERIFY(MainMenu() && MainMenu()->GetGS());
+	//CGameSpy_GP* tmp_gp = MainMenu()->GetGS()->GetGameSpyGP();
+	//VERIFY(tmp_gp);
+	//gamespy_gp::login_manager*	tmp_lmngr = MainMenu()->GetLoginMngr();
+	//VERIFY(tmp_lmngr);
+	//tmp_lmngr->login(tmp_email, tmp_nick, tmp_password, gamespy_gp::login_operation_cb());
 }
@@ -108,7 +105,6 @@
 {
-	
-	VERIFY(MainMenu() && MainMenu()->GetGS());
-	gamespy_gp::login_manager*	tmp_lmngr = MainMenu()->GetLoginMngr();
-	VERIFY(tmp_lmngr);
-	tmp_lmngr->logout();
+	//VERIFY(MainMenu() && MainMenu()->GetGS());
+	//gamespy_gp::login_manager*	tmp_lmngr = MainMenu()->GetLoginMngr();
+	//VERIFY(tmp_lmngr);
+	//tmp_lmngr->logout();
 }
@@ -132,43 +128,43 @@
 {
-	VERIFY(MainMenu() && MainMenu()->GetGS());
-	gamespy_gp::login_manager*	tmp_lmngr	= MainMenu()->GetLoginMngr();
-	gamespy_gp::profile const * tmp_profile = tmp_lmngr->get_current_profile();
-	if (tmp_profile)
-	{
-		Msg("- Current profile:");
-		Msg("- ProfileID  : %u", tmp_profile->m_profile_id);
-		Msg("- UniqueNick : %s", tmp_profile->m_unique_nick.c_str());
-
-		gamespy_profile::profile_store* tmp_store = MainMenu()->GetProfileStore();
-		if (!tmp_store)
-		{
-			Msg("! No profile store available");
-			return;
-		}
-		
-		Msg("- Player awards:");
-		gamespy_profile::all_awards_t const & tmp_awards = tmp_store->get_awards();
-		for (gamespy_profile::all_awards_t::const_iterator i = tmp_awards.begin(),
-			ie = tmp_awards.end(); i < ie; ++i)
-		{
-			string64 rdate_str;
-			rdate_str[0]	= 0;
-			print_time		(i->second.m_last_reward_date, rdate_str);
-			Msg("- (award: %s), (count: %u), (last reward date: %s)",
-				gamespy_profile::get_award_name(static_cast<gamespy_profile::enum_awards_t>(i->first)),
-				i->second.m_count,
-				rdate_str);
-		}
-
-		Msg("- Best player scores:");
-		gamespy_profile::all_best_scores_t const & tmp_best_scores = tmp_store->get_best_scores();
-		for (gamespy_profile::all_best_scores_t::const_iterator i = tmp_best_scores.begin(),
-			ie = tmp_best_scores.end(); i < ie; ++i)
-		{
-			Msg("- (score: %s), (score: %d)", 
-				gamespy_profile::get_best_score_name(static_cast<gamespy_profile::enum_best_score_type>(i->first)),
-				i->second
-			);
-		}
-	} else
+	//VERIFY(MainMenu() && MainMenu()->GetGS());
+	//gamespy_gp::login_manager*	tmp_lmngr	= MainMenu()->GetLoginMngr();
+	//gamespy_gp::profile const * tmp_profile = tmp_lmngr->get_current_profile();
+	//if (tmp_profile)
+	//{
+	//	Msg("- Current profile:");
+	//	Msg("- ProfileID  : %u", tmp_profile->m_profile_id);
+	//	Msg("- UniqueNick : %s", tmp_profile->m_unique_nick.c_str());
+
+	//	gamespy_profile::profile_store* tmp_store = MainMenu()->GetProfileStore();
+	//	if (!tmp_store)
+	//	{
+	//		Msg("! No profile store available");
+	//		return;
+	//	}
+	//	
+	//	Msg("- Player awards:");
+	//	gamespy_profile::all_awards_t const & tmp_awards = tmp_store->get_awards();
+	//	for (gamespy_profile::all_awards_t::const_iterator i = tmp_awards.begin(),
+	//		ie = tmp_awards.end(); i < ie; ++i)
+	//	{
+	//		string64 rdate_str;
+	//		rdate_str[0]	= 0;
+	//		print_time		(i->second.m_last_reward_date, rdate_str);
+	//		Msg("- (award: %s), (count: %u), (last reward date: %s)",
+	//			gamespy_profile::get_award_name(static_cast<gamespy_profile::enum_awards_t>(i->first)),
+	//			i->second.m_count,
+	//			rdate_str);
+	//	}
+
+	//	Msg("- Best player scores:");
+	//	gamespy_profile::all_best_scores_t const & tmp_best_scores = tmp_store->get_best_scores();
+	//	for (gamespy_profile::all_best_scores_t::const_iterator i = tmp_best_scores.begin(),
+	//		ie = tmp_best_scores.end(); i < ie; ++i)
+	//	{
+	//		Msg("- (score: %s), (score: %d)", 
+	//			gamespy_profile::get_best_score_name(static_cast<gamespy_profile::enum_best_score_type>(i->first)),
+	//			i->second
+	//		);
+	//	}
+	//} else
 	{
@@ -180,9 +176,8 @@
 {
-	
-	VERIFY(MainMenu() && MainMenu()->GetGS());
-	string256	tmp_unick;
-	sscanf_s(args, "%s", tmp_unick, sizeof(tmp_unick));
-	gamespy_gp::account_manager* tmp_amngr = MainMenu()->GetAccountMngr();
-	VERIFY(tmp_amngr);
-	tmp_amngr->suggest_unique_nicks(tmp_unick, gamespy_gp::suggest_nicks_cb());
+	//VERIFY(MainMenu() && MainMenu()->GetGS());
+	//string256	tmp_unick;
+	//sscanf_s(args, "%s", tmp_unick, sizeof(tmp_unick));
+	//gamespy_gp::account_manager* tmp_amngr = MainMenu()->GetAccountMngr();
+	//VERIFY(tmp_amngr);
+	//tmp_amngr->suggest_unique_nicks(tmp_unick, gamespy_gp::suggest_nicks_cb());
 }
@@ -191,8 +186,8 @@
 {
-	VERIFY(MainMenu() && MainMenu()->GetGS());
-	gamespy_gp::login_manager::unique_nick_t	tmp_unick;
-	sscanf_s(args, "%s", tmp_unick, sizeof(tmp_unick));
-	gamespy_gp::login_manager*	tmp_lmngr = MainMenu()->GetLoginMngr();
-	VERIFY(tmp_lmngr);
-	tmp_lmngr->set_unique_nick(tmp_unick, gamespy_gp::login_operation_cb());
+	//VERIFY(MainMenu() && MainMenu()->GetGS());
+	//gamespy_gp::login_manager::unique_nick_t	tmp_unick;
+	//sscanf_s(args, "%s", tmp_unick, sizeof(tmp_unick));
+	//gamespy_gp::login_manager*	tmp_lmngr = MainMenu()->GetLoginMngr();
+	//VERIFY(tmp_lmngr);
+	//tmp_lmngr->set_unique_nick(tmp_unick, gamespy_gp::login_operation_cb());
 }
@@ -202,7 +197,6 @@
 {
-	
-	VERIFY(MainMenu() && MainMenu()->GetGS());
-	gamespy_gp::account_manager* tmp_amngr = MainMenu()->GetAccountMngr();
-	VERIFY(tmp_amngr);
-	tmp_amngr->delete_profile(gamespy_gp::account_operation_cb());
+	//VERIFY(MainMenu() && MainMenu()->GetGS());
+	//gamespy_gp::account_manager* tmp_amngr = MainMenu()->GetAccountMngr();
+	//VERIFY(tmp_amngr);
+	//tmp_amngr->delete_profile(gamespy_gp::account_operation_cb());
 }
@@ -213,75 +207,75 @@
 {
-	VERIFY(MainMenu());
-	gamespy_gp::login_manager* tmp_lmngr			= MainMenu()->GetLoginMngr();
-	VERIFY(tmp_lmngr);
-	gamespy_profile::profile_store* tmp_prof_store	= MainMenu()->GetProfileStore();
-	VERIFY(tmp_prof_store);
-	
-	gamespy_gp::profile const * tmp_curr_prof	= tmp_lmngr->get_current_profile();
-	if (!tmp_curr_prof)
-	{
-		Msg("- No profile. You are not loged in.");
-		return;
-	}
-
-	string256	tmp_command;
-	sscanf_s(args, "%s", tmp_command, sizeof(tmp_command));
-	if (!xr_strcmp(tmp_command, "load"))
-	{
-		/*tmp_prof_store->set_current_profile(
-			tmp_curr_prof->m_profile_id,
-			tmp_curr_prof->m_login_ticket.c_str()
-		);
-		parameters_tuple1<gamespy_profile::store_operation_cb> tmp_args;
-		tmp_prof_store->load_profile(tmp_args);*/
-		tmp_prof_store->load_current_profile(
-			gamespy_profile::store_operation_cb(),
-			gamespy_profile::store_operation_cb());
-	} else if (!xr_strcmp(tmp_command, "reward"))
-	{
-		gamespy_profile::stats_submitter* tmp_ssubmitter = MainMenu()->GetStatsSubmitter();
-		VERIFY(tmp_ssubmitter);
-		char const *	tmp_reward_id_str	= args + xr_strlen(tmp_command);
-		int tmp_award_id					= 0;
-
-		if (!sscanf_s(tmp_reward_id_str, "%u", &tmp_award_id))
-		{
-			Msg("! Bad award id");
-			return;
-		}
-		tmp_ssubmitter->reward_with_award(
-			static_cast<gamespy_profile::enum_awards_t>(tmp_award_id),
-			1,
-			tmp_curr_prof,
-			gamespy_profile::store_operation_cb()
-		);
-	} else if (!xr_strcmp(tmp_command, "bestscore"))
-	{
-		gamespy_profile::stats_submitter* tmp_ssubmitter = MainMenu()->GetStatsSubmitter();
-		VERIFY(tmp_ssubmitter);
-		char const * tmp_scores_str = args + xr_strlen(tmp_command);
-		unsigned int score_id		= 0;
-		int score_value				= 0;
-		if (sscanf_s(tmp_scores_str, "%u %u", &score_id, &score_value) != 2)
-		{
-			Msg("! Not enough parameters");
-			return;
-		}
-		if (score_id >= gamespy_profile::bst_score_types_count)
-		{
-			Msg("! Bad scoreid");
-		}
-		debug_best_scores.clear();
-		debug_best_scores.insert(
-			std::make_pair(
-				static_cast<gamespy_profile::enum_best_score_type>(score_id),
-				score_value
-			)
-		);
-		tmp_ssubmitter->set_best_scores(
-			&debug_best_scores,
-			tmp_curr_prof,
-			gamespy_profile::store_operation_cb()
-		);
-	}
+	//VERIFY(MainMenu());
+	//gamespy_gp::login_manager* tmp_lmngr			= MainMenu()->GetLoginMngr();
+	//VERIFY(tmp_lmngr);
+	//gamespy_profile::profile_store* tmp_prof_store	= MainMenu()->GetProfileStore();
+	//VERIFY(tmp_prof_store);
+	//
+	//gamespy_gp::profile const * tmp_curr_prof	= tmp_lmngr->get_current_profile();
+	//if (!tmp_curr_prof)
+	//{
+	//	Msg("- No profile. You are not loged in.");
+	//	return;
+	//}
+
+	//string256	tmp_command;
+	//sscanf_s(args, "%s", tmp_command, sizeof(tmp_command));
+	//if (!xr_strcmp(tmp_command, "load"))
+	//{
+	//	/*tmp_prof_store->set_current_profile(
+	//		tmp_curr_prof->m_profile_id,
+	//		tmp_curr_prof->m_login_ticket.c_str()
+	//	);
+	//	parameters_tuple1<gamespy_profile::store_operation_cb> tmp_args;
+	//	tmp_prof_store->load_profile(tmp_args);*/
+	//	tmp_prof_store->load_current_profile(
+	//		gamespy_profile::store_operation_cb(),
+	//		gamespy_profile::store_operation_cb());
+	//} else if (!xr_strcmp(tmp_command, "reward"))
+	//{
+	//	gamespy_profile::stats_submitter* tmp_ssubmitter = MainMenu()->GetStatsSubmitter();
+	//	VERIFY(tmp_ssubmitter);
+	//	char const *	tmp_reward_id_str	= args + xr_strlen(tmp_command);
+	//	int tmp_award_id					= 0;
+
+	//	if (!sscanf_s(tmp_reward_id_str, "%u", &tmp_award_id))
+	//	{
+	//		Msg("! Bad award id");
+	//		return;
+	//	}
+	//	tmp_ssubmitter->reward_with_award(
+	//		static_cast<gamespy_profile::enum_awards_t>(tmp_award_id),
+	//		1,
+	//		tmp_curr_prof,
+	//		gamespy_profile::store_operation_cb()
+	//	);
+	//} else if (!xr_strcmp(tmp_command, "bestscore"))
+	//{
+	//	gamespy_profile::stats_submitter* tmp_ssubmitter = MainMenu()->GetStatsSubmitter();
+	//	VERIFY(tmp_ssubmitter);
+	//	char const * tmp_scores_str = args + xr_strlen(tmp_command);
+	//	unsigned int score_id		= 0;
+	//	int score_value				= 0;
+	//	if (sscanf_s(tmp_scores_str, "%u %u", &score_id, &score_value) != 2)
+	//	{
+	//		Msg("! Not enough parameters");
+	//		return;
+	//	}
+	//	if (score_id >= gamespy_profile::bst_score_types_count)
+	//	{
+	//		Msg("! Bad scoreid");
+	//	}
+	//	debug_best_scores.clear();
+	//	debug_best_scores.insert(
+	//		std::make_pair(
+	//			static_cast<gamespy_profile::enum_best_score_type>(score_id),
+	//			score_value
+	//		)
+	//	);
+	//	tmp_ssubmitter->set_best_scores(
+	//		&debug_best_scores,
+	//		tmp_curr_prof,
+	//		gamespy_profile::store_operation_cb()
+	//	);
+	//}
 }
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/action_planner_inline.h xray-monolith/src/xrGame/action_planner_inline.h
--- coc-1.4-xray-64/src/xrGame/action_planner_inline.h	2023-10-20 20:54:50.756326700 +0100
+++ xray-monolith/src/xrGame/action_planner_inline.h	2023-10-20 20:54:32.703037800 +0100
@@ -176,2 +181,3 @@
 {
+#ifdef DEBUG
 	VERIFY2					(
@@ -184,2 +190,3 @@
 	);
+#endif
 	action->add_condition	(CWorldProperty(condition_id,condition_value));
@@ -190,2 +197,3 @@
 {
+#ifdef DEBUG
 	VERIFY2					(
@@ -198,2 +206,3 @@
 	);
+#endif
 	action->add_effect		(CWorldProperty(condition_id,condition_value));
@@ -224,2 +233,3 @@
 {
+#ifdef DEBUG
 	VERIFY2					(
@@ -232,2 +242,3 @@
 	);
+#endif
 	inherited::add_operator	(operator_id,_operator);
@@ -242,2 +253,3 @@
 {
+#ifdef DEBUG
 	VERIFY2					(
@@ -250,2 +262,3 @@
 	);
+#endif
 	inherited::remove_operator	(operator_id);
@@ -256,2 +269,3 @@
 {
+#ifdef DEBUG
 	VERIFY2						(
@@ -264,2 +278,3 @@
 	);
+#endif
 	inherited::add_evaluator	(condition_id,evaluator);
@@ -271,2 +286,3 @@
 {
+#ifdef DEBUG
 	VERIFY2						(
@@ -279,2 +295,3 @@
 	);
+#endif
 	inherited::remove_evaluator	(condition_id);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Actor.cpp xray-monolith/src/xrGame/Actor.cpp
--- coc-1.4-xray-64/src/xrGame/Actor.cpp	2023-10-20 20:54:50.560337900 +0100
+++ xray-monolith/src/xrGame/Actor.cpp	2023-10-20 20:54:32.545039200 +0100
@@ -1,2 +1,2 @@
-#include "pch_script.h"
+ï»¿#include "pch_script.h"
 #include "Actor_Flags.h"
@@ -18,3 +18,3 @@
 #include "EffectorZoomInertion.h"
-#include "SleepEffector.h"
+//#include "SleepEffector.h"
 #include "character_info.h"
@@ -78,3 +78,6 @@
 
+#include "ActorNightVision.h"
+#include "Flashlight.h"
 //Alundaio
+#include "ActorBackpack.h"
 #include "script_hit.h"
@@ -84,2 +87,6 @@
 
+//Rezy
+#include "xrEngine\x_ray.h"
+#include "ui/UIHudStatesWnd.h"
+
 const u32		patch_frames = 50;
@@ -142,5 +147,9 @@
     fCurAVelocity = 0.0f;
-    // ýôôåêòîðû
+	fFPCamYawMagnitude = 0.0f; //--#SM+#--
+	fFPCamPitchMagnitude = 0.0f; //--#SM+#--
+	// Ã½Ã´Ã´Ã¥ÃªÃ²Ã®Ã°Ã»
     pCamBobbing = 0;
 
+	cam_freelook = eflDisabled;
+	freelook_cam_control = 0.f;
 
@@ -167,8 +176,4 @@
 
-//Alundaio
-#ifdef ACTOR_FEEL_GRENADE
     m_fFeelGrenadeRadius = 10.0f;
     m_fFeelGrenadeTime = 1.0f;
-#endif
-//-Alundaio
 
@@ -182,3 +187,3 @@
 
-    //ðàçðåøèòü èñïîëüçîâàíèå ïîÿñà â inventory
+	//Ã°Ã Ã§Ã°Ã¥Ã¸Ã¨Ã²Ã¼ Ã¨Ã±Ã¯Ã®Ã«Ã¼Ã§Ã®Ã¢Ã Ã­Ã¨Ã¥ Ã¯Ã®Ã¿Ã±Ã  Ã¢ inventory
     inventory().SetBeltUseful(true);
@@ -230,3 +235,17 @@
 	// Alex ADD: for smooth crouch fix
-	CurrentHeight = 0.f;
+	CurrentHeight = -1.f;
+
+	m_night_vision = NULL;
+	m_bNightVisionAllow = true;
+	m_bNightVisionOn = false;
+
+	//Discord
+	discord_gameinfo.ingame = true;
+
+	//Safemode (lower weapon)
+	m_bSafemode = false;
+
+	m_bDelayDrawPickupItems = false;
+
+	m_FPCam = NULL;
 }
@@ -259,2 +278,7 @@
 	//-Alundaio
+
+	xr_delete(m_night_vision);
+
+	//Discord
+	discord_gameinfo.ingame = false;
 }
@@ -387,3 +415,3 @@
     m_fRun_StrafeFactor = READ_IF_EXISTS(pSettings, r_float, section, "run_strafe_coef", 1.0f);
-
+	m_fSprint_StrafeFactor = READ_IF_EXISTS(pSettings, r_float, section, "sprint_strafe_coef", 1.0f);
 
@@ -395,5 +423,2 @@
     m_fPickupInfoRadius = pSettings->r_float(section, "pickup_info_radius");
-
-//Alundaio
-#ifdef ACTOR_FEEL_GRENADE
     m_fFeelGrenadeRadius = pSettings->r_float(section, "feel_grenade_radius");
@@ -401,3 +426,2 @@
     m_fFeelGrenadeTime *= 1000.0f;
-#endif
 
@@ -444,3 +474,3 @@
 
-    // íàñòðîéêè äèñïåðñèè ñòðåëüáû
+	// Ã­Ã Ã±Ã²Ã°Ã®Ã©ÃªÃ¨ Ã¤Ã¨Ã±Ã¯Ã¥Ã°Ã±Ã¨Ã¨ Ã±Ã²Ã°Ã¥Ã«Ã¼Ã¡Ã»
     m_fDispBase = pSettings->r_float(section, "disp_base");
@@ -475,5 +507,2 @@
     m_sHeadShotParticle = READ_IF_EXISTS(pSettings, r_string, section, "HeadShotParticle", 0);
-
-	// Alex ADD: for smooth crouch fix
-	CurrentHeight = CameraHeight();
 }
@@ -528,3 +556,3 @@
             {
-                // âû÷èñëèòü ïîçèöèþ è íàïðàâëåííîñòü ïàðòèêëà
+				// Ã¢Ã»Ã·Ã¨Ã±Ã«Ã¨Ã²Ã¼ Ã¯Ã®Ã§Ã¨Ã¶Ã¨Ã¾ Ã¨ Ã­Ã Ã¯Ã°Ã Ã¢Ã«Ã¥Ã­Ã­Ã®Ã±Ã²Ã¼ Ã¯Ã Ã°Ã²Ã¨ÃªÃ«Ã 
                 Fmatrix pos;
@@ -533,3 +561,3 @@
 
-                // óñòàíîâèòü particles
+				// Ã³Ã±Ã²Ã Ã­Ã®Ã¢Ã¨Ã²Ã¼ particles
                 CParticlesObject* ps = NULL;
@@ -595,4 +624,3 @@
     {
-        bool const is_special_burn_hit_2_self = (pHDS->who == this) && (pHDS->boneID == BI_NONE) &&
-            ((pHDS->hit_type == ALife::eHitTypeBurn) || (pHDS->hit_type == ALife::eHitTypeLightBurn));
+		bool const is_special_burn_hit_2_self = (pHDS->who == this) && (pHDS->boneID == BI_NONE);
         if (!is_special_burn_hit_2_self)
@@ -621,14 +649,5 @@
         {
-            float hit_power = HitArtefactsOnBelt(HDS.damage(), HDS.hit_type);
-            HDS.power = hit_power;
-            HDS.add_wound = true;
             if (g_Alive())
             {
-				CScriptHit tLuaHit;
-
-				tLuaHit.m_fPower = HDS.power;
-				tLuaHit.m_fImpulse = HDS.impulse;
-				tLuaHit.m_tDirection = HDS.direction();
-				tLuaHit.m_tHitType = HDS.hit_type;
-				tLuaHit.m_tpDraftsman = smart_cast<const CGameObject*>(HDS.who)->lua_game_object();
+				CScriptHit tLuaHit(&HDS);
 
@@ -641,8 +660,5 @@
 
-				HDS.power = tLuaHit.m_fPower;
-				HDS.impulse = tLuaHit.m_fImpulse;
-				HDS.dir = tLuaHit.m_tDirection;
-				HDS.hit_type = (ALife::EHitType)(tLuaHit.m_tHitType);
-				//HDS.who = smart_cast<CObject*>(tLuaHit.m_tpDraftsman->object());
-				//HDS.whoID = tLuaHit.m_tpDraftsman->ID();
+				HDS.ApplyScriptHit(&tLuaHit);
+				HDS.power = HitArtefactsOnBelt(HDS.damage(), HDS.hit_type);
+				HDS.add_wound = true;
 				
@@ -813,3 +831,6 @@
 }
+
 void start_tutorial(LPCSTR name);
+extern BOOL firstPersonDeath;
+
 void CActor::Die(CObject* who)
@@ -863,3 +884,3 @@
 
-        ///!!! ÷èñòêà ïîÿñà
+		///!!! Ã·Ã¨Ã±Ã²ÃªÃ  Ã¯Ã®Ã¿Ã±Ã 
         TIItemContainer &l_blist = inventory().m_belt;
@@ -904,7 +925,21 @@
     {
-#ifdef FP_DEATH
+		// demonized: First Person Death
+		if (firstPersonDeath) {
         cam_Set(eacFirstEye);
-#else
+			initFPCam();
+			Fvector pos = Device.vCameraPosition;
+			Fvector hpb;
+			hpb.set(
+				Device.vCameraDirection.getH(),
+				Device.vCameraDirection.getP(),
+				0
+			);
+			m_FPCam->m_Position.set(pos);
+			m_FPCam->m_HPB.set(hpb);
+			m_FPCam->m_Camera.setHPB(hpb.x, hpb.y, hpb.z).translate_over(pos);
+			m_FPCam->m_customSmoothing = 0;
+		}
+		else
         cam_Set(eacFreeLook);
-#endif // FP_DEATH
+
         CurrentGameUI()->HideShownDialogs();
@@ -1029,3 +1062,5 @@
 }
+
 float g_fov = 55.0f;
+extern float g_ironsights_factor;
 
@@ -1043,2 +1078,5 @@
     {
+		if (pWeapon->GetZoomFactor() == 0)
+			return atan(tan(g_fov * (0.5 * PI / 180)) / g_ironsights_factor) / (0.5 * PI / 180);
+		else
         return pWeapon->GetZoomFactor() * (0.75f);
@@ -1051,2 +1089,4 @@
 
+#include "UI\UIInventoryUtilities.h"
+
 void CActor::UpdateCL()
@@ -1055,6 +1095,8 @@
     {
-        if (CurrentGameUI() && NULL == CurrentGameUI()->TopInputReceiver())
+		if (CurrentGameUI() && (!CurrentGameUI()->TopInputReceiver() || (CurrentGameUI()->TopInputReceiver() && !CurrentGameUI()->TopInputReceiver()->StopAnyMove())) && !m_holder)
         {
-            int dik = get_action_dik(kUSE, 0);
-            if (dik && pInput->iGetAsyncKeyState(dik))
+			const bool allowed = psActorFlags.test(AF_MULTI_ITEM_PICKUP);
+
+			auto dik = get_action_dik(kUSE, 0);
+			if (dik && pInput->iGetAsyncKeyState(dik) && allowed)
                 m_bPickupMode = true;
@@ -1062,5 +1104,9 @@
             dik = get_action_dik(kUSE, 1);
-            if (dik && pInput->iGetAsyncKeyState(dik))
+			if (dik && pInput->iGetAsyncKeyState(dik) && allowed)
                 m_bPickupMode = true;
         }
+		else
+		{
+			m_bPickupMode = false;
+		}
     }
@@ -1088,7 +1135,7 @@
 
-
+	pickup_result_t pickup_result = {true, false};
     if (g_Alive())
-        PickupModeUpdate();
+		pickup_result = PickupModeUpdate();
 
-    PickupModeUpdate_COD();
+	PickupModeUpdate_COD(pickup_result);
 
@@ -1124,2 +1171,3 @@
 
+			if (!Device.m_SecondViewport.IsSVPFrame())
             HUD().SetCrosshairDisp(fire_disp_full, 0.02f);
@@ -1138,5 +1187,12 @@
 
+			psHUD_Flags.set(HUD_DRAW_RT, pWeapon->show_indicators());
 
+			// Update SecondVP with Weapon Data
+			pWeapon->UpdateSecondVP();
 
-            psHUD_Flags.set(HUD_DRAW_RT, pWeapon->show_indicators());
+			// Apply Weapon Data in Shaders
+			g_pGamePersistent->m_pGShaderConstants->hud_params.x = pWeapon->GetZRotatingFactor();
+			g_pGamePersistent->m_pGShaderConstants->hud_params.y = pWeapon->GetSecondVPZoomFactor();
+			g_pGamePersistent->m_pGShaderConstants->hud_params.z = pWeapon->m_nearwall_last_hud_fov;
+			g_pGamePersistent->m_pGShaderConstants->hud_params.w = Device.m_SecondViewport.IsSVPFrame();
         }
@@ -1150,2 +1205,9 @@
             HUD().ShowCrosshair(false);
+
+			// Clearing Weapons Information in Shaders
+			g_pGamePersistent->m_pGShaderConstants->hud_params.set(0.f, 0.f, 0.f, 0.f);
+			g_pGamePersistent->m_pGShaderConstants->m_blender_mode.set(0.f, 0.f, 0.f, 0.f);
+
+			// Turn off SecondVP
+			Device.m_SecondViewport.SetSVPActive(false);			
         }
@@ -1173,8 +1235,3 @@
     Fmatrix							trans;
-    if (cam_Active() == cam_FirstEye())
-    {
         Cameras().hud_camera_Matrix(trans);
-    }
-    else
-        Cameras().camera_Matrix(trans);
 
@@ -1183,3 +1240,319 @@
 
+	if (psActorFlags.test(AF_MULTI_ITEM_PICKUP))
     m_bPickupMode = false;
+
+	//Discord
+	if (psDeviceFlags2.test(rsDiscord))
+	{
+		//God
+		bool isGodmode = psActorFlags.test(AF_GODMODE);
+		discord_gameinfo.godmode = isGodmode;
+
+		if (!isGodmode)
+		{
+			int disc_cur_health = roundf(GetfHealth() * 100);
+			if (disc_cur_health <= 0)
+				discord_gameinfo.health = NULL;
+			else
+				discord_gameinfo.health = disc_cur_health;
+		}
+
+		//Current Time
+		str_c current_time = InventoryUtilities::GetGameTimeAsString(InventoryUtilities::etpTimeToMinutes).c_str();
+		discord_gameinfo.currenttime = current_time;
+
+		// Update once after a loadscreen
+		if (!discord_gameinfo.loadscreen && discord_gameinfo.ex_update)
+		{
+			//Update Iron Man state and lives
+			luabind::functor<bool> ironman_enabled;
+			if (ai().script_engine().functor("_g.IsHardcoreMode", ironman_enabled))
+			{
+				if (ironman_enabled && ironman_enabled())
+					discord_gameinfo.ironman = true;
+				else
+					discord_gameinfo.ironman = false;
+			}
+
+			if (discord_gameinfo.ironman)
+			{
+				//Lives left
+				luabind::functor<int> ironman_lives;
+				if (ai().script_engine().functor("ironman_manager.get_lives_left", ironman_lives))
+				{
+					if (ironman_lives)
+					{
+						int lives_left = ironman_lives();
+						discord_gameinfo.lives_left = lives_left;
+					}
+				}
+			}
+
+			//Level
+			if (g_pGameLevel && g_pGameLevel->name() != NULL)
+			{
+				snprintf(discord_gameinfo.level_name, 128, xr_ToUTF8(*CStringTable().translate(g_pGameLevel->name())));
+				srand(time(0));
+				int level_icon_id = rand() % 3 + 1;
+				discord_gameinfo.level_icon_index = level_icon_id;
+				discord_gameinfo.level = g_pGameLevel->name().c_str();
+			}
+
+			//Story Mode
+			luabind::functor<bool> game_mode;
+			if (ai().script_engine().functor("_g.IsStoryMode", game_mode) && game_mode())
+				snprintf(discord_gameinfo.gamemode, 128, xr_ToUTF8(*CStringTable().translate("st_cap_check_story")));
+
+			//Warfare
+			else if (ai().script_engine().functor("_g.IsWarfare", game_mode) && game_mode())
+				snprintf(discord_gameinfo.gamemode, 128, xr_ToUTF8(*CStringTable().translate("st_cap_check_warfare")));
+
+			//Azazel Mode
+			else if (ai().script_engine().functor("_g.IsAzazelMode", game_mode) && game_mode())
+			{
+				snprintf(discord_gameinfo.gamemode, 128, xr_ToUTF8(*CStringTable().translate("st_cap_check_azazel_mode")));
+
+				luabind::functor<int> possessed_lives;
+				if (ai().script_engine().functor("azazel_mode.get_possessed_lives", possessed_lives))
+				{
+					int lives_possessed = possessed_lives();
+					discord_gameinfo.possessed_lives = lives_possessed;
+				}
+			}
+
+			//Survival Mode
+			else if (ai().script_engine().functor("_g.IsSurvivalMode", game_mode) && game_mode())
+				snprintf(discord_gameinfo.gamemode, 128, xr_ToUTF8(*CStringTable().translate("st_cap_check_survival")));
+			
+			//Freeplay Mode
+			else
+				snprintf(discord_gameinfo.gamemode, 128, xr_ToUTF8(*CStringTable().translate("st_cap_check_freeplay")));
+
+			//Update Active Task
+			Level().GameTaskManager().RPC_UpdateTaskName();
+
+			//Update Faction, Rank and Reputation
+			RPC_UpdateFaction();
+			RPC_UpdateRank();
+			RPC_UpdateReputation();
+
+			discord_gameinfo.ex_update = false;
+		}
+	}
+
+	//for LV shaders
+	g_pGamePersistent->actor_data.health = GetfHealth();
+	g_pGamePersistent->actor_data.stamina = conditions().GetPower();
+	g_pGamePersistent->actor_data.bleeding = conditions().BleedingSpeed();
+	//g_pGamePersistent->actor_data.helmet = !GetOutfit()->bIsHelmetAvaliable || inventory().ItemFromSlot(HELMET_SLOT) ? 1 : 0;
+
+	// Update environment radiation value if hud is not shown
+	if (!psHUD_Flags.test(HUD_DRAW))
+		CurrentGameUI()->UIMainIngameWnd->get_hud_states()->UpdateZones();
+}
+
+void CActor::set_safemode(bool status)
+{
+	if (is_safemode() != status)
+	{
+		m_bSafemode = status;
+		g_player_hud->OnMovementChanged(mcAnyMove);
+		g_player_hud->updateMovementLayerState();
+
+		CWeapon* wep = smart_cast<CWeapon*>(inventory().ActiveItem());
+		status ? callback(GameObject::eOnWeaponLowered)(wep ? wep->lua_game_object(): nullptr) : callback(GameObject::eOnWeaponRaised)(wep ? wep->lua_game_object() : nullptr);
+	}
+}
+
+void CActor::RPC_UpdateFaction()
+{
+	//Update player's REAL Faction
+	luabind::functor<LPCSTR> real_faction;
+	if (ai().script_engine().functor("_g.get_actor_true_community", real_faction))
+	{
+		if (real_faction)
+		{
+			LPCSTR faction_name = real_faction();
+			discord_gameinfo.faction = faction_name;
+			char buffer[128];
+			sprintf(buffer, "st_faction_%s", faction_name);
+			snprintf(discord_gameinfo.faction_name, 128, xr_ToUTF8(*CStringTable().translate(buffer)));
+		}
+	}
+}
+
+void CActor::RPC_UpdateRank()
+{
+	//Rank		
+	luabind::functor<LPCSTR> actor_rank;
+	if (ai().script_engine().functor("ranks.get_player_rank_name", actor_rank))
+	{
+		if (actor_rank)
+		{
+			LPCSTR rank = actor_rank();
+			char rank_name[100];
+			sprintf(rank_name, "st_rank_%s", rank);
+			snprintf(discord_gameinfo.rank_name, 128, xr_ToUTF8(*CStringTable().translate(rank_name)));
+		}
+	}
+}
+
+void CActor::RPC_UpdateReputation()
+{
+	//Reputation		
+	luabind::functor<int> actor_rep_val;
+	if (ai().script_engine().functor("ranks.get_player_reputation", actor_rep_val))
+	{
+		if (actor_rep_val)
+		{
+			int reputation = actor_rep_val();
+			luabind::functor<LPCSTR> actor_rep;
+			if (ai().script_engine().functor("alun_utils.get_reputation_name", actor_rep))
+			{
+				if (actor_rep)
+				{
+					LPCSTR reputation_name = actor_rep(reputation);
+					if (reputation_name)
+						snprintf(discord_gameinfo.reputation, 128, xr_ToUTF8(*CStringTable().translate(reputation_name)));
+				}
+			}
+		}
+	}
+}
+
+#include "../xrphysics/actorcameracollision.h"
+bool CActor::use_HolderEx(CHolderCustom* object, bool bForce)
+{
+	if (m_holder)
+	{
+		if (!m_holder->ExitLocked() || bForce)
+		{
+			if (!object || (m_holder == object)) {
+
+				CGameObject* go = smart_cast<CGameObject*>(m_holder);
+				CPhysicsShellHolder* pholder = smart_cast<CPhysicsShellHolder*>(go);
+				if (pholder)
+				{
+					pholder->PPhysicsShell()->SplitterHolderDeactivate();
+					if (!character_physics_support()->movement()->ActivateBoxDynamic(0))
+					{
+						pholder->PPhysicsShell()->SplitterHolderActivate();
+						return true;
+					}
+					pholder->PPhysicsShell()->SplitterHolderActivate();
+				}
+
+				SetWeaponHideState(INV_STATE_BLOCK_ALL, false);
+
+				if (go)
+					this->callback(GameObject::eDetachVehicle)(go->lua_game_object());
+
+				m_holder->detach_Actor();
+
+				character_physics_support()->movement()->CreateCharacter();
+				character_physics_support()->movement()->SetPosition(m_holder->ExitPosition());
+				character_physics_support()->movement()->SetVelocity(m_holder->ExitVelocity());
+
+				r_model_yaw = -m_holder->Camera()->yaw;
+				r_torso.yaw = r_model_yaw;
+				r_model_yaw_dest = r_model_yaw;
+
+				cam_Active()->Direction().set(m_holder->Camera()->Direction());
+
+				SetCallbacks();
+
+				m_holder = NULL;
+				m_holderID = u16(-1);
+
+				IKinematicsAnimated* V = smart_cast<IKinematicsAnimated*>(Visual()); R_ASSERT(V);
+				V->PlayCycle(m_anims->m_normal.legs_idle);
+				V->PlayCycle(m_anims->m_normal.m_torso_idle);
+
+				IKinematics* pK = smart_cast<IKinematics*>(Visual());
+				u16 head_bone = pK->LL_BoneID("bip01_head");
+				pK->LL_GetBoneInstance(u16(head_bone)).set_callback(bctPhysics, HeadCallback, this);
+			}
+		}
+		return true;
+	}
+	else
+	{
+		if (object && !object->EnterLocked() || bForce)
+		{
+			Fvector center;	Center(center);
+			if (bForce || object->Use(Device.vCameraPosition, Device.vCameraDirection, center) && object->attach_Actor(this))
+			{
+				inventory().SetActiveSlot(NO_ACTIVE_SLOT);
+				SetWeaponHideState(INV_STATE_BLOCK_ALL, true);
+
+				// destroy actor character
+				character_physics_support()->movement()->DestroyCharacter();
+
+				m_holder = object;
+				CObject* oHolder = smart_cast<CObject*>(object);
+				m_holderID = oHolder->ID();
+
+				if (pCamBobbing) {
+					Cameras().RemoveCamEffector(eCEBobbing);
+					pCamBobbing = NULL;
+				}
+
+				if (actor_camera_shell)
+					destroy_physics_shell(actor_camera_shell);
+
+				IKinematics* pK = smart_cast<IKinematics*>(Visual());
+				u16 head_bone = pK->LL_BoneID("bip01_head");
+				pK->LL_GetBoneInstance(u16(head_bone)).set_callback(bctPhysics, VehicleHeadCallback, this);
+
+				CCar* car = smart_cast<CCar*>(object);
+				if (car)
+				{
+					u16 anim_type = car->DriverAnimationType();
+					SVehicleAnimCollection& anims = m_vehicle_anims->m_vehicles_type_collections[anim_type];
+					IKinematicsAnimated* V = smart_cast<IKinematicsAnimated*>(Visual()); R_ASSERT(V);
+					V->PlayCycle(anims.idles[0], FALSE);
+					CStepManager::on_animation_start(MotionID(), 0);
+				}
+
+				CGameObject* go = smart_cast<CGameObject*>(object);
+				if (go)
+					this->callback(GameObject::eAttachVehicle)(go->lua_game_object());
+
+				return true;
+			}
+		}
+	}
+	return false;
+}
+
+void CActor::on_requested_spawn(CObject *object)
+{
+	CHolderCustom* oHolder = smart_cast<CHolderCustom*>(object);
+	if (!oHolder) return;
+
+	CGameObject* go = smart_cast<CGameObject*>(object);
+	CPhysicsShellHolder* pholder = smart_cast<CPhysicsShellHolder*>(go);
+	if (pholder)
+	{
+		pholder->PPhysicsShell()->SplitterHolderDeactivate();
+		if (!character_physics_support()->movement()->ActivateBoxDynamic(0))
+		{
+			pholder->PPhysicsShell()->SplitterHolderActivate();
+			return;
+		}
+		pholder->PPhysicsShell()->SplitterHolderActivate();
+	}
+
+	character_physics_support()->movement()->CreateCharacter();
+	character_physics_support()->movement()->SetPosition(oHolder->ExitPosition());
+	character_physics_support()->movement()->SetVelocity(oHolder->ExitVelocity());
+
+	m_holder = NULL;
+	m_holderID = (u16)(-1);
+
+	use_HolderEx(oHolder, true);
+
+	Fvector xyz;
+	object->XFORM().getXYZi(xyz);
+	r_torso.yaw = xyz.y;
 }
@@ -1234,3 +1609,2 @@
             g_player_hud->detach_all_items();
-            //Msg("---No hud view found, all items detached.");
         }
@@ -1284,6 +1658,5 @@
         feel_touch_update(C, R);
-//Alundaio
-#ifdef ACTOR_FEEL_GRENADE
+
+		if (psDeviceFlags2.test(rsFeelGrenade))
         Feel_Grenade_Update(m_fFeelGrenadeRadius);
-#endif
 
@@ -1301,7 +1674,4 @@
         {
-            mstate_wishful &= ~mcAccel;
             mstate_wishful &= ~mcLStrafe;
             mstate_wishful &= ~mcRStrafe;
-            mstate_wishful &= ~mcLLookout;
-            mstate_wishful &= ~mcRLookout;
             mstate_wishful &= ~mcFwd;
@@ -1310,2 +1680,25 @@
                 mstate_wishful &= ~mcCrouch;
+			if (!psActorFlags.test(AF_WALK_TOGGLE))
+				mstate_wishful &= ~mcAccel;
+			if (!psActorFlags.test(AF_SPRINT_TOGGLE))
+				mstate_wishful &= ~mcSprint;
+			if (!psActorFlags.test(AF_LOOKOUT_TOGGLE) || cam_freelook != eflDisabled)
+			{
+				mstate_wishful &= ~mcLLookout;
+				mstate_wishful &= ~mcRLookout;
+			}
+
+			if (cam_freelook == eflEnabled)
+			{
+				if (psActorFlags.test(AF_FREELOOK_TOGGLE))
+				{
+					if (!CanUseFreelook())
+						cam_UnsetFreelook();
+				}
+				else
+				{
+					if (!CanUseFreelook() || !pInput->iGetAsyncKeyState(get_action_dik(kFREELOOK)))
+						cam_UnsetFreelook();
+				}
+			}
         }
@@ -1346,3 +1736,3 @@
 
-    //ýôôåêòîð âêëþ÷àåìûé ïðè õîäüáå
+	//Ã½Ã´Ã´Ã¥ÃªÃ²Ã®Ã° Ã¢ÃªÃ«Ã¾Ã·Ã Ã¥Ã¬Ã»Ã© Ã¯Ã°Ã¨ ÃµÃ®Ã¤Ã¼Ã¡Ã¥
     if (!pCamBobbing)
@@ -1354,3 +1744,3 @@
 
-    //çâóê òÿæåëîãî äûõàíèÿ ïðè óòàëîñòè è õðîìàíèè
+	//Ã§Ã¢Ã³Ãª Ã²Ã¿Ã¦Ã¥Ã«Ã®Ã£Ã® Ã¤Ã»ÃµÃ Ã­Ã¨Ã¿ Ã¯Ã°Ã¨ Ã³Ã²Ã Ã«Ã®Ã±Ã²Ã¨ Ã¨ ÃµÃ°Ã®Ã¬Ã Ã­Ã¨Ã¨
     if (this == Level().CurrentControlEntity() && !g_dedicated_server)
@@ -1422,3 +1812,3 @@
 
-    //åñëè â ðåæèìå HUD, òî ñàìà ìîäåëü àêòåðà íå ðèñóåòñÿ
+	//Ã¥Ã±Ã«Ã¨ Ã¢ Ã°Ã¥Ã¦Ã¨Ã¬Ã¥ HUD, Ã²Ã® Ã±Ã Ã¬Ã  Ã¬Ã®Ã¤Ã¥Ã«Ã¼ Ã ÃªÃ²Ã¥Ã°Ã  Ã­Ã¥ Ã°Ã¨Ã±Ã³Ã¥Ã²Ã±Ã¿
     if (!character_physics_support()->IsRemoved())
@@ -1426,3 +1816,3 @@
 
-    //÷òî àêòåð âèäèò ïåðåä ñîáîé
+	//Ã·Ã²Ã® Ã ÃªÃ²Ã¥Ã° Ã¢Ã¨Ã¤Ã¨Ã² Ã¯Ã¥Ã°Ã¥Ã¤ Ã±Ã®Ã¡Ã®Ã©
     collide::rq_result& RQ = HUD().GetCurrentRayQuery();
@@ -1501,3 +1893,3 @@
 
-    //äëÿ ñâîéñò àðòåôàêòîâ, íàõîäÿùèõñÿ íà ïîÿñå
+	//Ã¤Ã«Ã¿ Ã±Ã¢Ã®Ã©Ã±Ã² Ã Ã°Ã²Ã¥Ã´Ã ÃªÃ²Ã®Ã¢, Ã­Ã ÃµÃ®Ã¤Ã¿Ã¹Ã¨ÃµÃ±Ã¿ Ã­Ã  Ã¯Ã®Ã¿Ã±Ã¥
     UpdateArtefactsOnBeltAndOutfit();
@@ -1511,2 +1904,8 @@
     inherited::renderable_Render();
+
+	//Alun: Due to glitchy shadows this is forced
+	CFlashlight* flashlight = smart_cast<CFlashlight*>(inventory().ItemFromSlot(DETECTOR_SLOT));
+	if (flashlight && flashlight->torch_active())
+		return;
+
     //if(1/*!HUDview()*/) //Swartz: replaced by block below for actor shadow
@@ -1572,3 +1970,4 @@
     R_ASSERT(IsFocused());
-    if (!((mstate_real & mcLookout) && !IsGameTypeSingle()))
+	//demonized: disable hud when FPCam is on
+	if (!((mstate_real & mcLookout) && !IsGameTypeSingle()) && (!m_FPCam || m_FPCam->hudEnabled))
         g_player_hud->render_hud();
@@ -1879,11 +2282,22 @@
     CCustomOutfit* outfit = GetOutfit();
-    if (outfit)
+	CHelmet* pHelmet = smart_cast<CHelmet*>(inventory().ItemFromSlot(HELMET_SLOT));
+	if (outfit || pHelmet)
     {
-        conditions().ChangeBleeding(outfit->m_fBleedingRestoreSpeed  * f_update_time);
-        conditions().ChangeHealth(outfit->m_fHealthRestoreSpeed    * f_update_time);
-        conditions().ChangePower(outfit->m_fPowerRestoreSpeed     * f_update_time);
-        conditions().ChangeSatiety(outfit->m_fSatietyRestoreSpeed   * f_update_time);
-        conditions().ChangeRadiation(outfit->m_fRadiationRestoreSpeed * f_update_time);
+		conditions().ChangeBleeding(
+			((outfit ? outfit->m_fBleedingRestoreSpeed : 0.f) + (pHelmet ? pHelmet->m_fBleedingRestoreSpeed : 0.f)) *
+			f_update_time);
+		conditions().ChangeHealth(
+			((outfit ? outfit->m_fHealthRestoreSpeed : 0.f) + (pHelmet ? pHelmet->m_fHealthRestoreSpeed : 0.f)) *
+			f_update_time);
+		conditions().ChangePower(
+			((outfit ? outfit->m_fPowerRestoreSpeed : 0.f) + (pHelmet ? pHelmet->m_fPowerRestoreSpeed : 0.f)) *
+			f_update_time);
+		conditions().ChangeSatiety(
+			((outfit ? outfit->m_fSatietyRestoreSpeed : 0.f) + (pHelmet ? pHelmet->m_fSatietyRestoreSpeed : 0.f)) *
+			f_update_time);
+		conditions().ChangeRadiation(
+			((outfit ? outfit->m_fRadiationRestoreSpeed : 0.f) + (pHelmet ? pHelmet->m_fRadiationRestoreSpeed : 0.f)) *
+			f_update_time);
     }
-    else
+	/* else
     {
@@ -1898,3 +2312,3 @@
         }
-    }
+	 }*/
 }
@@ -1903,2 +2317,17 @@
 {
+	luabind::functor<luabind::object> funct;
+	if (ai().script_engine().functor("_G.CActor__HitArtefactsOnBelt", funct))
+	{
+		luabind::object table = luabind::newtable(ai().script_engine().lua());
+		table["override"] = false;
+		table["hit_power"] = hit_power;
+
+		luabind::object output = funct(table, hit_power, hit_type);
+		if (output && output.type() == LUA_TTABLE)
+		{
+			if (luabind::object_cast<bool>(output["override"]))
+				return luabind::object_cast<float>(output["hit_power"]);
+		}
+	}
+
     TIItemContainer::iterator it = inventory().m_belt.begin();
@@ -1958,4 +2387,4 @@
 {
-    inherited::spawn_supplies();
-    CInventoryOwner::spawn_supplies();
+	//inherited::spawn_supplies();
+	//CInventoryOwner::spawn_supplies();
 }
@@ -2036,7 +2465,8 @@
 
-    //ìîæíî ëè ïðèñîåäèíÿòü îáúåêòû òàêîãî òèïà
-    if (m_attach_item_sections.end() == std::find(m_attach_item_sections.begin(), m_attach_item_sections.end(), inventory_item->object().cNameSect()))
+	//Ã¬Ã®Ã¦Ã­Ã® Ã«Ã¨ Ã¯Ã°Ã¨Ã±Ã®Ã¥Ã¤Ã¨Ã­Ã¿Ã²Ã¼ Ã®Ã¡ÃºÃ¥ÃªÃ²Ã» Ã²Ã ÃªÃ®Ã£Ã® Ã²Ã¨Ã¯Ã 
+	if (m_attach_item_sections.end() == std::find(m_attach_item_sections.begin(), m_attach_item_sections.end(),
+	                                              inventory_item->object().cNameSect()))
         return false;
 
-    //åñëè óæå åñòü ïðèñîåäèííåíûé îáúåò òàêîãî òèïà 
+	//Ã¥Ã±Ã«Ã¨ Ã³Ã¦Ã¥ Ã¥Ã±Ã²Ã¼ Ã¯Ã°Ã¨Ã±Ã®Ã¥Ã¤Ã¨Ã­Ã­Ã¥Ã­Ã»Ã© Ã®Ã¡ÃºÃ¥Ã² Ã²Ã ÃªÃ®Ã£Ã® Ã²Ã¨Ã¯Ã  
     if (attached(inventory_item->object().cNameSect()))
@@ -2216 +2650,81 @@
 }
+
+void CActor::SwitchNightVision(bool vision_on, bool use_sounds, bool send_event)
+{
+	m_bNightVisionOn = vision_on;
+
+	if (!m_night_vision)
+		m_night_vision = xr_new<CNightVisionEffector>(cNameSect());
+
+	bool bIsActiveNow = m_night_vision->IsActive();
+
+	CHelmet* pHelmet = smart_cast<CHelmet*>(inventory().ItemFromSlot(HELMET_SLOT));
+	if (pHelmet && pHelmet->m_NightVisionSect.size())
+	{
+		if (m_bNightVisionAllow)
+		{
+			if (m_bNightVisionOn && !bIsActiveNow)
+			{
+				m_night_vision->Start(pHelmet->m_NightVisionSect, this, use_sounds);
+			}
+		}
+		else
+		{
+			m_night_vision->OnDisabled(this, use_sounds);
+			m_bNightVisionOn = false;
+		}
+	}
+	else
+	{
+		CCustomOutfit* pOutfit = smart_cast<CCustomOutfit*>(inventory().ItemFromSlot(OUTFIT_SLOT));
+		if (pOutfit && pOutfit->m_NightVisionSect.size())
+		{
+			if (m_bNightVisionAllow)
+			{
+				if (m_bNightVisionOn && !bIsActiveNow)
+				{
+					m_night_vision->Start(pOutfit->m_NightVisionSect, this, use_sounds);
+				}
+			}
+			else
+			{
+				m_night_vision->OnDisabled(this, use_sounds);
+				m_bNightVisionOn = false;
+			}
+		}
+	}
+
+	if (!m_bNightVisionOn && bIsActiveNow)
+	{
+		m_night_vision->Stop(100000.0f, use_sounds);
+	}
+
+	//Alun: Update flags and send message they were changed
+	if (send_event)
+	{
+		m_trader_flags.set(CSE_ALifeTraderAbstract::eTraderFlagNightVisionActive, m_bNightVisionOn);
+		CGameObject* object = smart_cast<CGameObject*>(this);
+		NET_Packet packet;
+		object->u_EventGen(packet, GE_TRADER_FLAGS, object->ID());
+		packet.w_u32(m_trader_flags.get());
+		object->u_EventSend(packet);
+		//Msg("GE_TRADER_FLAGS event sent %d", m_trader_flags.get());
+	}
+}
+
+// demonized: First Person Death
+void CActor::initFPCam()
+{
+	if (!m_FPCam) {
+		m_FPCam = xr_new<CFPCamEffector>();
+		Cameras().AddCamEffector(m_FPCam);
+	}
+}
+
+void CActor::removeFPCam() 
+{
+	if (m_FPCam) {
+		Cameras().RemoveCamEffector(m_FPCam);
+		m_FPCam = NULL;
+	}
+}
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Actor.h xray-monolith/src/xrGame/Actor.h
--- coc-1.4-xray-64/src/xrGame/Actor.h	2023-10-20 20:54:50.561326800 +0100
+++ xray-monolith/src/xrGame/Actor.h	2023-10-20 20:54:32.545039200 +0100
@@ -62,2 +62,5 @@
 
+class CNightVisionEffector;
+class CFPCamEffector;
+
 class	CActor: 
@@ -81,2 +84,10 @@
 
+// demonized: First Person Death
+public:
+	CFPCamEffector* m_FPCam;
+
+public:
+	void initFPCam();
+	void removeFPCam();
+
 public:
@@ -175,9 +189,6 @@
             void						HitSector		(CObject* who, CObject* weapon);
-            void						HitMark			(float P, Fvector dir,			CObject* who, s16 element, Fvector position_in_bone_space, float impulse,  ALife::EHitType hit_type);
+	void HitMark(float P, Fvector dir, CObject* who, s16 element, Fvector position_in_bone_space, float impulse,
+	             ALife::EHitType hit_type);
 
-//Alundaio
-#ifdef	ACTOR_FEEL_GRENADE
             void						Feel_Grenade_Update( float rad );
-#endif
-//-Alundaio
 
@@ -259,3 +270,2 @@
     bool					use_Holder				(CHolderCustom* holder);
-    bool					use_Vehicle				(CHolderCustom* object);
     void					ActorUse				();
@@ -322,2 +337,8 @@
     //-Swartz
+
+	// Rezy - Freelook
+	u8 cam_freelook;
+	float freelook_cam_control;
+	float old_torso_yaw;
+
 protected:
@@ -329,2 +350,6 @@
     void					cam_UnsetLadder			();
+	void camUpdateFreelook(float dt);
+	void cam_SetFreelook();
+	void cam_UnsetFreelook();
+	bool CanUseFreelook();
     float					currentFOV				();
@@ -344,2 +369,5 @@
     static float			f_Ladder_cam_limit;
+public: //--#SM+#--
+	float fFPCamYawMagnitude;
+	float fFPCamPitchMagnitude;
 public:
@@ -371,18 +399,20 @@
     
-//	shared_str				m_quick_use_slots[4];
-    //ðåæèì ïîäáèðàíèÿ ïðåäìåòîâ
     bool					m_bPickupMode;
-    //ðàññòîÿíèå (â ìåòðàõ) íà êîòîðîì àêòåð ÷óâñòâóåò ãðàíàòó (ëþáóþ)
-//Alundaio
-#ifdef	ACTOR_FEEL_GRENADE
+
     float					m_fFeelGrenadeRadius;
-    float					m_fFeelGrenadeTime; 	//âðåìÿ ãðàíàòû (ñåê) ïîñëå êîòîðîãî àêòåð ÷óâñòâóåò ãðàíàòó
-#endif
-//-Alundaio
-    //ðàññòîÿíèå ïîäñâåòêè ïðåäìåòîâ
+    float					m_fFeelGrenadeTime;
     float					m_fPickupInfoRadius;
-
-    void					PickupModeUpdate	();
+protected:
+	struct pickup_result_t
+	{
+		bool allow_pickup;
+		bool callback_handled;
+	};
+	pickup_result_t PickupModeUpdate();
     void					PickupInfoDraw		(CObject* object);
-    void					PickupModeUpdate_COD ();
+	void PickupModeUpdate_COD(pickup_result_t pickup_state);
+
+public:
+	void DrawPickupItems();
+	bool m_bDelayDrawPickupItems;
 
@@ -411,2 +441,3 @@
     void					StopAnyMove				();
+	void StopSprint() { mstate_wishful &= ~mcSprint; }
 
@@ -436,2 +467,6 @@
     float					m_fRun_StrafeFactor;
+	float m_fSprint_StrafeFactor;
+
+	// demonized: lookout modifier
+	float m_fLookoutFactor = 1;
 
@@ -789,2 +830,21 @@
       
+public:
+	void SwitchNightVision(bool light_on, bool use_sounds = true, bool send_event = true);
+
+	bool GetNightVisionStatus() { return m_bNightVisionOn; }
+	void SetNightVisionAllowed(bool bAllow) { m_bNightVisionAllow = bAllow; }
+	CNightVisionEffector* GetNightVision() { return m_night_vision; }
+protected:
+	bool m_bNightVisionOn;
+	bool m_bNightVisionAllow;
+	bool m_bSafemode;
+public:
+	bool is_safemode() { return m_bSafemode; }
+	void set_safemode(bool status);
+
+	void RPC_UpdateFaction();
+	void RPC_UpdateRank();
+	void RPC_UpdateReputation();
+
+	CNightVisionEffector* m_night_vision;
 DECLARE_SCRIPT_REGISTER_FUNCTION
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/actor_anim_defs.h xray-monolith/src/xrGame/actor_anim_defs.h
--- coc-1.4-xray-64/src/xrGame/actor_anim_defs.h	2023-10-20 20:54:50.757326700 +0100
+++ xray-monolith/src/xrGame/actor_anim_defs.h	2023-10-20 20:54:32.705035600 +0100
@@ -33,2 +35,4 @@
 	MotionID	all_attack_2;
+
+	MotionID safemode;
 	void		Create								(IKinematicsAnimated* K, LPCSTR base0, LPCSTR base1);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/actor_communication.cpp xray-monolith/src/xrGame/actor_communication.cpp
--- coc-1.4-xray-64/src/xrGame/actor_communication.cpp	2023-10-20 20:54:50.758328000 +0100
+++ xray-monolith/src/xrGame/actor_communication.cpp	2023-10-20 20:54:32.705035600 +0100
@@ -31,2 +31,3 @@
 #include "ai/trader/ai_trader.h"
+#include "Flashlight.h"
 
@@ -138,12 +139,8 @@
 {
-	PIItem det_active					= inventory().ItemFromSlot(DETECTOR_SLOT);
-	if(det_active)
-	{
-		CCustomDetector* det			= smart_cast<CCustomDetector*>(det_active);
-		det->HideDetector				(true);
-	}
-
-
-	CGameObject* GO = smart_cast<CGameObject*>(talk_partner); VERIFY(GO);
+	CGameObject* GO = smart_cast<CGameObject*>(talk_partner);
+	VERIFY(GO);
 	CInventoryOwner::StartTalk(talk_partner);
+
+	if (cam_freelook == eflEnabled || cam_freelook == eflEnabling)
+		cam_UnsetFreelook();
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/actor_defs.h xray-monolith/src/xrGame/actor_defs.h
--- coc-1.4-xray-64/src/xrGame/actor_defs.h	2023-10-20 20:54:50.758328000 +0100
+++ xray-monolith/src/xrGame/actor_defs.h	2023-10-20 20:54:32.706035500 +0100
@@ -61,2 +64,10 @@
 
+	enum EFreelookStates
+	{
+		eflDisabled,
+		eflEnabled,
+		eflEnabling,
+		eflDisabling,
+	};
+
 typedef const char*		EActorSleep;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Actor_Events.cpp xray-monolith/src/xrGame/Actor_Events.cpp
--- coc-1.4-xray-64/src/xrGame/Actor_Events.cpp	2023-10-20 20:54:50.567338100 +0100
+++ xray-monolith/src/xrGame/Actor_Events.cpp	2023-10-20 20:54:32.551037300 +0100
@@ -23,2 +23,4 @@
 #endif
+#include "3rd party/luabind/luabind/luabind.hpp"
+#include "script_game_object.h"
 
@@ -241,7 +252,15 @@
 			case GEG_PLAYER_ITEM_EAT:	 
+				luabind::functor<bool> funct;
+				if (iitem && ai().script_engine().functor("_G.CInventory__eat", funct))
+				{
+					CGameObject* GO = iitem->cast_game_object();
+					if (GO && funct(GO->lua_game_object()))
+					{
 				inventory().Eat( iitem );
 				break;//2
+					}
+				}
 			}//switch
-
-		}break;//1
+		}
+		break; //1
 	case GEG_PLAYER_ACTIVATE_SLOT:
@@ -259,3 +278,3 @@
 			m_block_sprint_counter = m_block_sprint_counter+cmd;
-			Msg("m_block_sprint_counter=%d",m_block_sprint_counter);
+			//Msg("m_block_sprint_counter=%d", m_block_sprint_counter);
 			if(m_block_sprint_counter>0)
@@ -264,3 +283,6 @@
 			}
-		}break;
+			else
+				m_block_sprint_counter = 0;
+		}
+		break;
 
@@ -284,4 +308,4 @@
 			conditions().ClearWounds();
-			ClearBloodWounds();
-		}break;
+		}
+		break;
 	case GE_ACTOR_MAX_HEALTH:
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Actor_Feel.cpp xray-monolith/src/xrGame/Actor_Feel.cpp
--- coc-1.4-xray-64/src/xrGame/Actor_Feel.cpp	2023-10-20 20:54:50.567338100 +0100
+++ xray-monolith/src/xrGame/Actor_Feel.cpp	2023-10-20 20:54:32.551037300 +0100
@@ -19,2 +19,3 @@
 #include "hudmanager.h"
+#include "ui\UIPdaWnd.h"
 
@@ -117,15 +121,23 @@
 
-void CActor::PickupModeUpdate()
+CActor::pickup_result_t CActor::PickupModeUpdate()
 {
-	if(!m_bPickupMode)				return; // kUSE key pressed
-	if(!IsGameTypeSingle())			return;
+	if (!m_bPickupMode) return {true, false}; // kUSE key pressed
+	if (!IsGameTypeSingle()) return {true, false};
 
 	//ïîäáèðàíèå îáúåêòà
-	if(	m_pObjectWeLookingAt									&& 
-		m_pObjectWeLookingAt->cast_inventory_item()				&& 
-		m_pObjectWeLookingAt->cast_inventory_item()->Useful()	&&
-		m_pUsableObject											&& 
-		!m_pUsableObject->nonscript_usable()					&&
-		!Level().m_feel_deny.is_object_denied(m_pObjectWeLookingAt) )
-	{
+	bool callback_handled = false;
+	if (m_pObjectWeLookingAt && m_pObjectWeLookingAt->cast_inventory_item() &&
+		m_pObjectWeLookingAt->cast_inventory_item()->Useful() && m_pUsableObject &&
+		m_pUsableObject->nonscript_usable() && !Level().m_feel_deny.is_object_denied(m_pObjectWeLookingAt))
+	{
+		//Tronex: ability to prevent item picking up if the export returns false
+		luabind::functor<bool> func;
+		if (ai().script_engine().functor("bind_stalker_ext.actor_on_item_before_pickup", func))
+		{
+			callback_handled = true;
+			bool allow_pickup = func(m_pObjectWeLookingAt->lua_game_object());
+			if (!allow_pickup)
+				return {false, callback_handled};
+		}
+		
 		m_pUsableObject->use(this);
@@ -136,2 +148,12 @@
 	
+	if (!CurrentGameUI()->GetPdaMenu().IsShown())
+		DrawPickupItems();
+	else
+		m_bDelayDrawPickupItems = true;
+
+	return {true, callback_handled};
+}
+
+void CActor::DrawPickupItems()
+{
 	CFrustum frustum;
@@ -147,10 +169,10 @@
 #include "../xrEngine/CameraBase.h"
-BOOL	g_b_COD_PickUpMode = TRUE;
-void	CActor::PickupModeUpdate_COD	()
+
+void CActor::PickupModeUpdate_COD(pickup_result_t pickup_result)
 {
-	if (Level().CurrentViewEntity() != this || !g_b_COD_PickUpMode) return;
+	if (Level().CurrentViewEntity() != this) return;
 		
-	if (!g_Alive() || eacFirstEye != cam_active) 
+	if (!g_Alive() || eacFirstEye != cam_active || !psDeviceFlags2.test(rsCODPickup))
 	{
-		CurrentGameUI()->UIMainIngameWnd->SetPickUpItem(NULL);
+		CurrentGameUI()->UIMainIngameWnd->SetPickUpItem(nullptr);
 		return;
@@ -221,2 +243,16 @@
 	{
+		//Tronex: ability to prevent item picking up if the export returns false
+		if (!pickup_result.callback_handled)
+		{
+			luabind::functor<bool> func;
+			if (ai().script_engine().functor("bind_stalker_ext.actor_on_item_before_pickup", func))
+			{
+				bool allow_pickup = func(pNearestItem->cast_game_object()->lua_game_object());
+				pickup_result = { allow_pickup, true };
+			}
+		}
+
+		if (!pickup_result.allow_pickup)
+			return;
+
 		CUsableScriptObject*	pUsableObject = smart_cast<CUsableScriptObject*>(pNearestItem);
@@ -225,3 +261,5 @@
 
-		//ïîäáèðàíèå îáúåêòà
+		if (!psActorFlags.test(AF_MULTI_ITEM_PICKUP))
+			m_bPickupMode = false;
+
 		Game().SendPickUpEvent(ID(), pNearestItem->object().ID());
@@ -311,4 +349,2 @@
 
-//Alundaio: Put this behind define so that it can be disabled
-#ifdef	ACTOR_FEEL_GRENADE
 void CActor::Feel_Grenade_Update( float rad )
@@ -351,3 +387 @@
 }
-#endif
-
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Actor_Flags.h xray-monolith/src/xrGame/Actor_Flags.h
--- coc-1.4-xray-64/src/xrGame/Actor_Flags.h	2023-10-20 20:54:50.567338100 +0100
+++ xray-monolith/src/xrGame/Actor_Flags.h	2023-10-20 20:54:32.552038700 +0100
@@ -13,3 +14,12 @@
 		AF_CROUCH_TOGGLE	=(1<<10),
-		AF_USE_TRACERS		=(1<<11)
+	AF_USE_TRACERS =(1 << 11),
+	AF_FIREPOS =(1 << 12),
+	AF_MULTI_ITEM_PICKUP= (1 << 13),
+	AF_WALK_TOGGLE = (1 << 14),
+	AF_SPRINT_TOGGLE = (1 << 15),
+	AF_LOOKOUT_TOGGLE = (1 << 16),
+	AF_FREELOOK_TOGGLE = (1 << 17),
+	AF_SIMPLE_PDA = (1 << 18),
+	AF_AIM_TOGGLE = (1 << 19),
+	AF_3D_PDA = (1 << 20)
 };
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Actor_Movement.cpp xray-monolith/src/xrGame/Actor_Movement.cpp
--- coc-1.4-xray-64/src/xrGame/Actor_Movement.cpp	2023-10-20 20:54:50.568327400 +0100
+++ xray-monolith/src/xrGame/Actor_Movement.cpp	2023-10-20 20:54:32.552038700 +0100
@@ -40,4 +39,17 @@
 	// Lookout
-	if (mstate_wf&mcLookout)	mstate_real		|= mstate_wf&mcLookout;
-	else						mstate_real		&= ~mcLookout;
+	if (((mstate_wf & mcLLookout) && (mstate_wf & mcRLookout)) || ((mstate_real & mcLLookout) && (mstate_real & mcRLookout)))
+	{
+		// It's impossible to perform right and left lookouts in the same time
+		mstate_real &= ~mcLookout;
+	}
+	else if (mstate_wf & mcLookout)
+	{
+		// Activate one of lookouts
+		mstate_real |= mstate_wf & mcLookout;
+	}
+	else
+	{
+		// No lookouts needed
+		mstate_real &= ~mcLookout;
+	}
 	
@@ -66,2 +86,6 @@
 			}
+
+			luabind::functor<bool> on_land;
+			if (ai().script_engine().functor("_G.CActor_on_land", on_land))
+				on_land(character_physics_support()->movement()->GetContactSpeed());
 		}
@@ -75,3 +99,4 @@
 	// Çàæàëî-ëè ìåíÿ/óïåðñÿ - íå äâèãàþñü
-	if (((character_physics_support()->movement()->GetVelocityActual()<0.2f)&&(!(mstate_real&(mcFall|mcJump)))) || character_physics_support()->movement()->bSleep) 
+	if (((character_physics_support()->movement()->GetVelocityActual() < 0.2f) && (!(mstate_real & (mcFall | mcJump | mcLanding | mcLanding2)) || (!(mstate_real & mcClimb) && character_physics_support()->movement()->Environment() == CPHMovementControl::peAtWall)))
+		|| character_physics_support()->movement()->bSleep)
 	{
@@ -126,3 +155,3 @@
 		{
-			SetWeaponHideState		(INV_STATE_LADDER, bOnClimbNow );
+			SetWeaponHideState(/*INV_STATE_LADDER*/ INV_STATE_BLOCK_ALL, bOnClimbNow);
 		};
@@ -160,4 +190,4 @@
 	if (mstate_wf&mcBack)		vControlAccel.z += -1;
-	if (mstate_wf&mcLStrafe)	vControlAccel.x += -1;
-	if (mstate_wf&mcRStrafe)	vControlAccel.x +=  1;
+	if (mstate_wf & mcLStrafe) mstate_wf & mcSprint ? vControlAccel.x += -0.5 : vControlAccel.x += -1;
+	if (mstate_wf & mcRStrafe) mstate_wf & mcSprint ? vControlAccel.x += 0.5 : vControlAccel.x += 1;
 
@@ -196,2 +226,5 @@
 
+			luabind::functor<bool> on_jump;
+			if (ai().script_engine().functor("_G.CActor_on_jump", on_jump))
+				on_jump();
 
@@ -230,5 +265,7 @@
 			mstate_real&=~mcSprint;
-		if(!(mstate_real&(mcFwd|mcLStrafe|mcRStrafe))||mstate_real&(mcCrouch|mcClimb)|| !isActorAccelerated(mstate_wf, IsZoomAimingMode()))
+		if (!(mstate_real & (mcFwd)) || mstate_real & (mcCrouch | mcClimb) || !isActorAccelerated(
+			mstate_wf, IsZoomAimingMode()))
 		{
 			mstate_real&=~mcSprint;
+			if (!(mstate_real & (mcCrouch) && !(mstate_wf & mcCrouch)))
 			mstate_wishful&=~mcSprint;
@@ -250,3 +287,3 @@
 				scale	=	m_fWalkAccel/scale;
-				if (bAccelerated)
+				if (bAccelerated && !IsZoomAimingMode())
 					if (mstate_real&mcBack)
@@ -267,3 +302,5 @@
 				{
-					if (bAccelerated)
+					if (mstate_real & mcSprint)
+						scale *= m_fSprint_StrafeFactor;
+					else if (bAccelerated)
 						scale *= m_fRun_StrafeFactor;
@@ -299,4 +332,7 @@
 		if(state_anm)
-		{ //play moving cam effect
+		{
+			//play moving cam effect
 			CActor*	control_entity		= static_cast_checked<CActor*>(Level().CurrentControlEntity());
+			if (control_entity)
+			{
 			R_ASSERT2					(control_entity, "current control entity is NULL");
@@ -325,2 +361,3 @@
 	}
+	}
 	//transform local dir to world dir
@@ -391,2 +428,5 @@
 		
+		// demonized: add lookout modifier
+		tgt_roll *= m_fLookoutFactor;
+
 		if( (mstate_rl&mcLLookout) && (mstate_rl&mcRLookout) )
@@ -394,4 +434,5 @@
 	}
-	if (!fsimilar(tgt_roll,r_torso_tgt_roll,EPS)){
-		angle_lerp		(r_torso_tgt_roll,tgt_roll,PI_MUL_2,dt);
+	if (!fsimilar(tgt_roll, r_torso_tgt_roll, EPS))
+	{
+		r_torso_tgt_roll = angle_inertion_var(r_torso_tgt_roll, tgt_roll, 0.f, CurrentHeight * PI_MUL_2, PI_DIV_2, dt);
 		r_torso_tgt_roll= angle_normalize_signed(r_torso_tgt_roll);
@@ -449,2 +493,4 @@
 	{
+		if (cam_freelook == eflDisabled)
+		{
 		r_torso.yaw		=	cam_Active()->GetWorldYaw	();
@@ -454,2 +500,11 @@
 	{
+			CCameraBase* C = cam_Active();
+			r_torso.yaw = angle_lerp(cam_Active()->GetWorldYaw(), -old_torso_yaw, freelook_cam_control);
+			float old_pitch = cam_Active()->GetWorldPitch();
+			float new_pitch = old_pitch > 0.f ? old_pitch * .6f : old_pitch *.8f;
+			r_torso.pitch = angle_lerp(old_pitch, new_pitch, freelook_cam_control);
+		}
+	}
+	else
+	{
 		r_torso.yaw		=	cam_FirstEye()->GetWorldYaw	();
@@ -472,9 +528,13 @@
 	// åñëè åñòü äâèæåíèå - âûðîâíÿòü ìîäåëü ïî êàìåðå
-	if (mstate_rl&mcAnyMove)	{
+	if (mstate_rl & mcAnyMove)
+	{
 		r_model_yaw		= angle_normalize(r_torso.yaw);
 		mstate_real		&=~mcTurn;
-	} else {
+	}
+	else
+	{
 		// if camera rotated more than 45 degrees - align model with it
 		float ty = angle_normalize(r_torso.yaw);
-		if (_abs(r_model_yaw-ty)>PI_DIV_4)	{
+		if (_abs(r_model_yaw - ty) > PI_DIV_4 - 30)
+		{
 			r_model_yaw_dest = ty;
@@ -547,5 +609,7 @@
 						&& CanRun()
-						&& !(mstate_real&mcLStrafe || mstate_real&mcRStrafe)
-						&& InventoryAllowSprint()
-						;
+		/*&& !(mstate_real&mcLStrafe || mstate_real&mcRStrafe)*/
+		&& InventoryAllowSprint();
+
+	if ((mstate_real & mcLStrafe || mstate_real & mcRStrafe) && !(mstate_real & mcFwd))
+		can_Sprint = false;
 
@@ -621,11 +686,19 @@
 }
+
 #include "artefact.h"
+#include "ActorBackpack.h"
+
 float CActor::get_additional_weight() const
 {
-	float res = 0.0f ;
+	float res = conditions().GetCarryWeightBoost();
+
 	CCustomOutfit* outfit	= GetOutfit();
 	if ( outfit )
-	{
+
 		res				+= outfit->m_additional_weight;
-	}
+
+
+	CBackpack* pBackpack = smart_cast<CBackpack*>(inventory().ItemFromSlot(BACKPACK_SLOT));
+	if (pBackpack)
+		res += pBackpack->m_additional_weight;
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Actor_Network.cpp xray-monolith/src/xrGame/Actor_Network.cpp
--- coc-1.4-xray-64/src/xrGame/Actor_Network.cpp	2023-10-20 20:54:50.568327400 +0100
+++ xray-monolith/src/xrGame/Actor_Network.cpp	2023-10-20 20:54:32.553039000 +0100
@@ -483,3 +488,5 @@
 			{
+#ifdef DEBUG
 				VERIFY(valid_pos(N_A.State.position,ph_boundaries()));
+#endif
 				NET_A.push_back			(N_A);
@@ -703,2 +709,6 @@
 	};
+
+	//Alun: In theory it will call SwitchNightVision 'true' when outfit or helmet spawn and moved to slot if m_bNightVisionOn is true
+	m_bNightVisionOn = !!m_trader_flags.test(CSE_ALifeTraderAbstract::eTraderFlagNightVisionActive);
+
 	return					TRUE;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/actor_script.cpp xray-monolith/src/xrGame/actor_script.cpp
--- coc-1.4-xray-64/src/xrGame/actor_script.cpp	2023-10-20 20:54:50.763326500 +0100
+++ xray-monolith/src/xrGame/actor_script.cpp	2023-10-20 20:54:32.711036300 +0100
@@ -11,2 +11,3 @@
 #include "level_changer.h"
+#include "ActorCondition.h"
 
@@ -17,2 +18,4 @@
 {
+	CActorCondition::script_register(L);
+	
 	module(L)
@@ -21,3 +24,5 @@
 			.def(constructor<>())
-			
+			.def("conditions", &CActor::conditions)
+			.def("inventory_disabled", &CActor::inventory_disabled)
+			.def("set_inventory_disabled", &CActor::set_inventory_disabled)
 #ifndef	BENCHMARK_BUILD
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Actor_Weapon.cpp xray-monolith/src/xrGame/Actor_Weapon.cpp
--- coc-1.4-xray-64/src/xrGame/Actor_Weapon.cpp	2023-10-20 20:54:50.569340400 +0100
+++ xray-monolith/src/xrGame/Actor_Weapon.cpp	2023-10-20 20:54:32.553039000 +0100
@@ -18,2 +18,6 @@
 #include "Artefact.h"
+#include "../xrEngine/CameraBase.h"
+#include "player_hud.h"
+#include "HUDManager.h"
+#include "WeaponKnife.h"
 
@@ -33,3 +37,6 @@
 	}
-	float dispersion = m_fDispBase*GetWeaponParam(W, Get_PDM_Base(), 1.0f);
+	float dispersion = m_fDispBase * GetWeaponParam(W, Get_PDM_Base(), 1.0f) *
+		GetWeaponParam(W, Get_Silencer_PDM_Base(), 1.0f) * GetWeaponParam(W, Get_Scope_PDM_Base(), 1.0f) *
+		GetWeaponParam(W, Get_Launcher_PDM_Base(), 1.0f);
+
 
@@ -39,5 +46,13 @@
 		//fAVelocity = angle velocity
-		dispersion *= ( 1.0f + (state.fAVelocity/VEL_A_MAX) * m_fDispVelFactor * GetWeaponParam(W, Get_PDM_Vel_F(), 1.0f) );
+		dispersion *= (1.0f + (state.fAVelocity / VEL_A_MAX) * m_fDispVelFactor * GetWeaponParam(
+				W, Get_PDM_Vel_F(), 1.0f) *
+			GetWeaponParam(W, Get_Silencer_PDM_Vel(), 1.0f) * GetWeaponParam(W, Get_Scope_PDM_Vel(), 1.0f) *
+			GetWeaponParam(W, Get_Launcher_PDM_Vel(), 1.0f));
+
 		//fVelocity = linear velocity
-		dispersion *= ( 1.0f + (state.fVelocity/VEL_MAX) * m_fDispVelFactor * GetWeaponParam(W, Get_PDM_Vel_F(), 1.0f) );
+		dispersion *= (1.0f + (state.fVelocity / VEL_MAX) * m_fDispVelFactor * GetWeaponParam(W, Get_PDM_Vel_F(), 1.0f)
+			*
+			GetWeaponParam(W, Get_Silencer_PDM_Vel(), 1.0f) * GetWeaponParam(W, Get_Scope_PDM_Vel(), 1.0f) *
+			GetWeaponParam(W, Get_Launcher_PDM_Vel(), 1.0f));
+
 
@@ -46,3 +61,5 @@
 		{
-			dispersion *= ( 1.0f + m_fDispAccelFactor * GetWeaponParam(W, Get_PDM_Accel_F(), 1.0f) );
+			dispersion *= (1.0f + m_fDispAccelFactor * GetWeaponParam(W, Get_PDM_Accel_F(), 1.0f) *
+				GetWeaponParam(W, Get_Silencer_PDM_Accel(), 1.0f) * GetWeaponParam(W, Get_Scope_PDM_Accel(), 1.0f) *
+				GetWeaponParam(W, Get_Launcher_PDM_Accel(), 1.0f));
 		}
@@ -58,2 +75,6 @@
 	}
+
+	if (W && W->m_lastCartridge.param_s.buckShot > 1)
+		dispersion *= GetWeaponParam(W, Get_PDM_BuckShot(), 1.0f);
+
 	return dispersion;
@@ -67,2 +88,3 @@
 
+	CWeapon* pWeapon = smart_cast<CWeapon*>(inventory().ActiveItem());
 	const CMissile	*pMissile = smart_cast <const CMissile*> (pHudItem);
@@ -74,2 +96,42 @@
 	}
+	else if (pWeapon && pWeapon->HudItemData() && !smart_cast<CWeaponKnife*>(pWeapon))
+	{
+		const Fmatrix& fire_mat = pWeapon->get_ParticlesXFORM();
+		//collide::rq_result& RQ = pWeapon->GetRQ();
+		//float dist = RQ.range / 3.f;
+
+		if (cam_freelook != eflDisabled)
+		{
+			Fvector dir;
+			float pitch = fire_mat.k.getP();
+			dir.setHP(-angle_normalize_signed(old_torso_yaw), pitch > 0.f ? ((pWeapon->GetState() == CWeapon::eFire || cam_freelook == eflDisabling) ? pitch : pitch * .6f) : pitch * .8f);
+			fire_dir = dir;
+		}
+		else if ((psActorFlags.test(AF_FIREPOS) || (mstate_real & mcAnyMove)) && (pWeapon->GetZRotatingFactor() != 1.f /*|| dist < 1.f*/))
+		{
+			//correct barrel direction
+			fire_dir = fire_mat.k; //pWeapon->get_lastFD() doesn't seem to work, returns (0,0,1) for all weapons except pistols/shotguns
+
+			/* disabled for now, bugs :(
+			//correct barrel position
+			Fvector pos = pWeapon->get_LastFP();
+			Fvector offs;
+			float zoff = pWeapon->HudItemData()->m_item_transform.c.z;
+			zoff -= pos.z;
+			fire_mat.transform_tiny(offs, { 0, 0, -.5f }); //otherwise you can shoot through thin walls
+			pos.add(offs);
+			fire_pos = pos;
+			const Fmatrix& fire_mat2 = pWeapon->HudItemData()->m_model->LL_GetTransform(pWeapon->HudItemData()->m_measures.m_fire_bone);
+			Fvector offs = g_player_hud->m_adjust_mode ? g_player_hud->m_adjust_firepoint_shell[0][0] : pWeapon->HudItemData()->m_measures.m_fire_point_offset;
+			offs.z -= 1.f;
+			fire_mat2.transform_tiny(fire_pos, offs);
+			pWeapon->HudItemData()->m_item_transform.transform_tiny(fire_pos);
+
+			//fire_pos = pWeapon->get_LastFP();
+
+			//use barrel position instead of camera position even for zoomed weapon if close to a wall
+			if (pWeapon->IsZoomed())
+				fire_pos.lerp(fire_pos, Cameras().Position(), dist);*/
+		}
+	}
 }
@@ -224,2 +289,5 @@
 		}
+		else {
+			effector->UpdateCameraRecoil(camera_recoil);
+		}
 	}
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ActorAnimation.cpp xray-monolith/src/xrGame/ActorAnimation.cpp
--- coc-1.4-xray-64/src/xrGame/ActorAnimation.cpp	2023-10-20 20:54:50.561326800 +0100
+++ xray-monolith/src/xrGame/ActorAnimation.cpp	2023-10-20 20:54:32.546036500 +0100
@@ -22,2 +22,4 @@
 #include "player_hud.h"
+#include "WeaponKnife.h"
+#include "Pda.h"
 
@@ -76,7 +84,17 @@
 }
+
+#include "../xrEngine/CameraBase.h"
+
 void  CActor::HeadCallback(CBoneInstance* B)
 {
-	CActor*	A			= static_cast<CActor*>(B->callback_param());	VERIFY	(A);
+	CActor* A = static_cast<CActor*>(B->callback_param());
+	VERIFY(A);
 	Fmatrix				spin;
-	float				bone_yaw	= angle_normalize_signed(A->r_torso.yaw - A->r_model_yaw - A->r_model_yaw_delta)*y_head_factor;
+	float bone_yaw;
+
+	if (A->cam_freelook != eflDisabled)
+		bone_yaw = angle_normalize_signed(-A->cam_FirstEye()->yaw - A->r_model_yaw - A->r_model_yaw_delta) * .35f;
+	else
+		bone_yaw = angle_normalize_signed(A->r_torso.yaw - A->r_model_yaw - A->r_model_yaw_delta) * y_head_factor;
+
 	float				bone_pitch	= angle_normalize_signed(A->r_torso.pitch)*p_head_factor;
@@ -123,2 +142,3 @@
 	all_attack_2	= K->ID_Cycle_Safe(strconcat(sizeof(buf),buf,base0,"_all",base1,"_attack_2"));
+	safemode = K->ID_Cycle_Safe(strconcat(sizeof(buf), buf, base0, "_torso", base1, "_idle_1"));
 }
@@ -271,2 +293,5 @@
 	CCar*	car			= smart_cast<CCar*>(m_holder);
+	if (!car)
+		return;
+
 	u16 anim_type       = car->DriverAnimationType();
@@ -346,4 +372,2 @@
 
-	//STorsoWpn* __TW = &ST->m_torso[4]; //Alundaio: Animation Set knife/grenade running animation without weapon by XEM #100
-
 	bool bAccelerated = isActorAccelerated(mstate_rl, IsZoomAimingMode());
@@ -391,2 +418,4 @@
 	{	
+		if (mstate_rl & mcAnyMove)
+		{
 		if ((mstate_rl&mcSprint) != (mstate_old&mcSprint))
@@ -394,7 +423,15 @@
 			g_player_hud->OnMovementChanged(mcSprint);
-		}else
-		if ((mstate_rl&mcAnyMove) != (mstate_old&mcAnyMove))
+			}
+			else if ((mstate_rl & mcCrouch) != (mstate_old & mcCrouch))
 		{
-			g_player_hud->OnMovementChanged(mcAnyMove);
+				g_player_hud->OnMovementChanged(mcCrouch);
+			}
+			else if ((mstate_rl & mcAccel) != (mstate_old & mcAccel) && !Actor()->IsZoomAimingMode())
+			{
+				g_player_hud->OnMovementChanged(mcAccel);
+			}
 		}
+
+		if (!(mstate_old & mcAnyMove) && (mstate_rl & mcAnyMove) || (mstate_old & mcAnyMove) && !(mstate_rl & mcAnyMove))
+			g_player_hud->OnMovementChanged(mcAnyMove);
 	};
@@ -415,7 +452,5 @@
 		CHudItem		*H = smart_cast<CHudItem*>(_i);
-		CWeapon			*W = smart_cast<CWeapon*>(_i);
-		CMissile		*M = smart_cast<CMissile*>(_i);
-		CArtefact		*A = smart_cast<CArtefact*>(_i);
 					
-		if (H) {
+		if (H)
+		{
 			VERIFY(H->animation_slot() <= _total_anim_slots_);
@@ -436,8 +471,12 @@
 				{
+					CWeapon* W = smart_cast<CWeapon*>(_i);
+					CPda* P = smart_cast<CPda*>(_i);
+					CMissile* M = smart_cast<CMissile*>(_i);
+					CArtefact* A = smart_cast<CArtefact*>(_i);
+
 					if (W) 
 					{
-						bool K	=inventory().GetActiveSlot() == KNIFE_SLOT;
 						bool R3 = W->IsTriStateReload();
 						
-						if(K)
+						if (smart_cast<CWeaponKnife*>(W))
 						{
@@ -471,5 +515,8 @@
 							{
-							case CWeapon::eIdle:		M_torso	= W->IsZoomed()?TW->zoom:TW->moving[moving_idx];	break;
-							case CWeapon::eFire:		M_torso	= W->IsZoomed()?TW->attack_zoom:TW->attack;				break;
-							case CWeapon::eFire2:		M_torso	= W->IsZoomed()?TW->attack_zoom:TW->attack;				break;
+							case CWeapon::eIdle: M_torso = W->IsZoomed() ? TW->zoom : (m_bSafemode && moving_idx != STorsoWpn::eSprint) ? TW->safemode : TW->moving[moving_idx];
+								break;
+							case CWeapon::eFire: M_torso = W->IsZoomed() ? TW->attack_zoom : TW->attack;
+								break;
+							case CWeapon::eFire2: M_torso = W->IsZoomed() ? TW->attack_zoom : TW->attack;
+								break;
 							case CWeapon::eReload:	
@@ -482,14 +529,24 @@
 									{
-										case CWeapon::eSubstateReloadBegin:			M_torso	= TW->reload;	break;
-										case CWeapon::eSubstateReloadInProcess:		M_torso	= TW->reload_1; break;
-										case CWeapon::eSubstateReloadEnd:			M_torso	= TW->reload_2; break;
-										default:									M_torso	= TW->reload;	break;
-									}
-								}break;
-
-							case CWeapon::eShowing:	M_torso	= TW->draw;					break;
-							case CWeapon::eHiding:	M_torso	= TW->holster;				break;
-							default				 :  M_torso	= TW->moving[moving_idx];	break;
+									case CWeapon::eSubstateReloadBegin: M_torso = TW->reload;
+										break;
+									case CWeapon::eSubstateReloadInProcess: M_torso = TW->reload_1;
+										break;
+									case CWeapon::eSubstateReloadEnd: M_torso = TW->reload_2;
+										break;
+									default: M_torso = TW->reload;
+										break;
+									}
+								}
+								break;
+
+							case CWeapon::eShowing: M_torso = TW->draw;
+								break;
+							case CWeapon::eHiding: M_torso = TW->holster;
+								break;
+							default: M_torso = TW->moving[moving_idx];
+								break;
 							}
 						}
+						if (!M_torso)
+							M_torso = ST->m_torso[4].moving[moving_idx]; //Alundaio: Fix torso animations for binoc
 					}
@@ -530,9 +603,25 @@
 							{
-								case CArtefact::eIdle		: M_torso	= TW->moving[moving_idx];	break; 
-								case CArtefact::eShowing	: M_torso	= TW->draw;					break; 
-								case CArtefact::eHiding		: M_torso	= TW->holster;				break; 
-								case CArtefact::eActivating : M_torso	= TW->zoom;					break; 
+						case CArtefact::eIdle: M_torso = TW->moving[moving_idx];
+							break;
+						case CArtefact::eShowing: M_torso = TW->draw;
+							break;
+						case CArtefact::eHiding: M_torso = TW->holster;
+							break;
+						case CArtefact::eActivating: M_torso = TW->zoom;
+							break;
 								default						: M_torso	= TW->moving[moving_idx];
 							}
-					
+					}
+					else if (P)
+					{
+						switch (P->GetState())
+						{
+						case CPda::eIdle: M_torso = P->m_bZoomed ? TW->zoom : (moving_idx == STorsoWpn::eSprint ? ST->m_torso[0].moving[moving_idx] : ST->m_torso[4].moving[moving_idx]);
+							break;
+						case CPda::eShowing: M_torso = TW->draw;
+							break;
+						case CPda::eHiding: M_torso = TW->holster;
+							break;
+						default: M_torso = ST->m_torso[4].moving[moving_idx];
+							break;
 					}
@@ -542,2 +631,10 @@
 	}
+		else if (!m_bAnimTorsoPlayed)
+		{
+			if (moving_idx == STorsoWpn::eSprint)
+				M_torso = ST->m_torso[0].moving[moving_idx];
+			else
+				M_torso = ST->m_torso[4].moving[moving_idx]; //Alundaio: Fix torso animations for no weapon
+		}
+	}
 	MotionID		mid = smart_cast<IKinematicsAnimated*>(Visual())->ID_Cycle("norm_idle_0");
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ActorCameras.cpp xray-monolith/src/xrGame/ActorCameras.cpp
--- coc-1.4-xray-64/src/xrGame/ActorCameras.cpp	2023-10-20 20:54:50.562338100 +0100
+++ xray-monolith/src/xrGame/ActorCameras.cpp	2023-10-20 20:54:32.547037100 +0100
@@ -1,2 +1,2 @@
-#include "stdafx.h"
+ï»¿#include "stdafx.h"
 #include "Actor.h"
@@ -13,3 +13,3 @@
 
-#include "SleepEffector.h"
+//#include "SleepEffector.h"
 #include "ActorEffector.h"
@@ -27,2 +27,10 @@
 #include "GamePersistent.h"
+#include "player_hud.h"
+#include "Missile.h"
+
+#include "EffectorBobbing.h"
+class CFPCamEffector;
+
+ENGINE_API extern float psHUD_FOV;
+ENGINE_API extern float psHUD_FOV_def;
 
@@ -35,3 +43,7 @@
 }
+
 float CActor::f_Ladder_cam_limit=1.f;
+float f_Freelook_cam_limit = PI_DIV_2; // 1.45f;
+float f_Freelook_cam_limit_p = .75f;
+
 void CActor::cam_SetLadder()
@@ -49,4 +61,3 @@
 		float hi			= (yaw+f_Ladder_cam_limit);
-		C->lim_yaw[0]		= lo;
-		C->lim_yaw[1]		= hi;
+		C->lim_yaw.set(lo, hi);
 		C->bClampYaw		= true;
@@ -58,6 +70,9 @@
 															return;
-	if(cameras[eacFirstEye]->bClampYaw) return;
+
+	CCameraBase* C = cameras[eacFirstEye];
+
+	if (C->bClampYaw) return;
 	float yaw				= (-XFORM().k.getH());
 
-	float & cam_yaw			= cameras[eacFirstEye]->yaw;
+	float& cam_yaw = C->yaw;
 	float delta				= angle_difference_signed(yaw,cam_yaw);
@@ -69,6 +84,7 @@
 		float hi							= (yaw+f_Ladder_cam_limit);
-		cameras[eacFirstEye]->lim_yaw[0]	= lo;
-		cameras[eacFirstEye]->lim_yaw[1]	= hi;
-		cameras[eacFirstEye]->bClampYaw		= true;
-	}else{
+		C->lim_yaw.set(lo, hi);
+		C->bClampYaw = true;
+	}
+	else
+	{
 		cam_yaw								+= delta * _min(dt*10.f,1.f) ;
@@ -79,4 +95,4 @@
 	{
-		float &cam_pitch					= cameras[eacFirstEye]->pitch;
-		const float ldown_pitch				= cameras[eacFirstEye]->lim_pitch.y;
+		float& cam_pitch = C->pitch;
+		const float ldown_pitch = C->lim_pitch.y;
 		float delta							= angle_difference_signed(ldown_pitch,cam_pitch);
@@ -90,6 +106,154 @@
 	CCameraBase* C			= cameras[eacFirstEye];
-	C->lim_yaw[0]			= 0;
-	C->lim_yaw[1]			= 0;
+	C->lim_yaw.set(0, 0);
 	C->bClampYaw			= false;
 }
+
+void CActor::cam_SetFreelook()
+{
+	cam_freelook = eflEnabling;
+}
+
+void CActor::camUpdateFreelook(float dt)
+{
+	CCameraBase* C = cameras[eacFirstEye];
+
+	switch (cam_freelook)
+	{
+	case eflEnabled:
+	case eflDisabled:
+	{
+		return;
+	}
+	break;
+	case eflEnabling:
+	{
+		if (!C->bClampYaw)
+		{
+			float& cam_yaw = C->yaw;
+			old_torso_yaw = -r_torso.yaw;
+			float lo = (cam_yaw - f_Freelook_cam_limit);
+			float hi = (cam_yaw + f_Freelook_cam_limit);
+			C->lim_yaw.set(lo, hi);
+			C->bClampYaw = true;
+		}
+
+		if (C->lim_pitch.similar({ -1.5, 1.5 }))
+		{
+			float& cam_pitch = C->pitch;
+
+			// Fix camera jump if freelook key is pressed right after loading a save.
+			if (abs(cam_pitch) > 1.5f)
+			{
+				while (cam_pitch < C->lim_pitch[0])
+					cam_pitch += PI_MUL_2;
+				while (cam_pitch > C->lim_pitch[1])
+					cam_pitch -= PI_MUL_2;
+			}
+
+			if (cam_pitch < -f_Freelook_cam_limit_p)
+			{
+				float diff_p = angle_difference(cam_pitch, -f_Freelook_cam_limit_p + .05f);
+				if (diff_p < .025)
+					cam_pitch = -f_Freelook_cam_limit_p + .005f;
+				else
+					cam_pitch += diff_p * _min(dt * 10.f, .5f);
+				clamp(cam_pitch, C->lim_pitch.x, -f_Freelook_cam_limit_p);
+			}
+			else if (cam_pitch > f_Freelook_cam_limit_p)
+			{
+				float diff_p = angle_difference(cam_pitch, f_Freelook_cam_limit_p - .05f);
+				if (diff_p < .025)
+					cam_pitch = f_Freelook_cam_limit_p - .005f;
+				else
+					cam_pitch -= diff_p * _min(dt * 10.f, .5f);
+				clamp(cam_pitch, f_Freelook_cam_limit_p, C->lim_pitch.y);
+			}
+			else
+			{
+				C->lim_pitch.set(-f_Freelook_cam_limit_p, f_Freelook_cam_limit_p);
+				cam_freelook = eflEnabled;
+			}
+		}
+	}
+	break;
+	case eflDisabling:
+	{
+
+		if (C->bClampYaw)
+		{
+			float& cam_yaw = C->yaw;
+			float delta = angle_difference_signed(old_torso_yaw, cam_yaw);
+
+			if (abs(delta) < 0.05f)
+			{
+				C->lim_yaw.set(0, 0);
+				C->bClampYaw = false;
+			}
+			else
+			{
+				cam_yaw += delta * _min(dt * 10.f, 1.f);
+			}
+		}
+
+		if (!C->lim_pitch.similar({ -1.5, 1.5 }))
+		{
+			float& cam_pitch = C->pitch;
+			float delta = angle_difference_signed(0.f, cam_pitch);
+
+			if (abs(delta) < 0.05f)
+			{
+				C->lim_pitch = { -1.5, 1.5 };
+			}
+			else
+			{
+				cam_pitch += delta * _min(dt * 10.f, 1.f);
+			}
+		}
+
+		if (!C->bClampYaw && C->lim_pitch.similar({ -1.5, 1.5 }))
+		{
+			cam_freelook = eflDisabled;
+		}
+	}
+	break;
+	}
+}
+
+void CActor::cam_UnsetFreelook()
+{
+	cam_freelook = eflDisabling;
+}
+
+bool CActor::CanUseFreelook()
+{
+	if (cam_active != eacFirstEye)
+		return false;
+
+	if (g_player_hud->script_anim_part == 2)
+		return false;
+
+	Estate state = character_physics_support()->movement()->ElevatorState()->State();
+	if ((state != clbNoLadder && state != clbNone && state != clbNoState) || m_holder)
+		return false;
+
+	if (inventory().ActiveItem())
+	{
+		CWeapon* wep = inventory().ActiveItem()->cast_weapon();
+		CMissile* msl = inventory().ActiveItem()->cast_missile();
+		if (msl && msl->GetState() > CHudItem::eLastBaseState)
+			return false;
+		else if (wep)
+		{
+			if (wep->IsZoomed())
+				return false;
+
+			u32 state = wep->GetState();
+			if (state == CWeapon::eFire || state == CWeapon::eFire2 || state == CWeapon::eReload || state == CWeapon::eSwitch || state == CWeapon::eSwitchMode)
+				return false;
+		}
+	}
+
+	return true;
+}
+
 float cammera_into_collision_shift = 0.05f;
@@ -256,3 +426,4 @@
 						da		*= r_torso.roll/_abs(r_torso.roll);
-					for (float angle=0.f; _abs(angle)<_abs(alpha); angle+=da)
+				float angle = 0.f;
+				for (; _abs(angle) < _abs(alpha); angle += da)
 					{
@@ -285,2 +459,10 @@
 
+BOOL firstPersonDeath = TRUE;
+float offsetH = 0;
+float offsetP = 0;
+float offsetB = 0;
+float offsetX = 0;
+float offsetY = 0;
+float offsetZ = 0;
+float viewportNearOffset = 0;
 void CActor::cam_Update(float dt, float fFOV)
@@ -289,4 +471,33 @@
 
+	// HUD FOV Update
+	if (this == Level().CurrentControlEntity())
+	{
+		if (eacFirstEye == cam_active)
+		{
+			CHudItem* pItem = smart_cast<CHudItem*>(inventory().ActiveItem());
+			CHudItem* pDevice = smart_cast<CHudItem*>(inventory().ItemFromSlot(DETECTOR_SLOT));
+
+			if (pItem && pItem->HudItemData() && pDevice && pDevice->HudItemData())
+				psHUD_FOV = fminf(pItem->GetHudFov(), pDevice->GetHudFov());
+			else if (pItem && pItem->HudItemData())
+				psHUD_FOV = pItem->GetHudFov();
+			else if (pDevice && pDevice->HudItemData())
+				psHUD_FOV = pDevice->GetHudFov();
+			else
+				psHUD_FOV = psHUD_FOV_def;
+		}
+		else
+			psHUD_FOV = psHUD_FOV_def;
+	}
+
+	if (cam_freelook != eflDisabled && cam_active != eacFreeLook)
+		camUpdateFreelook(dt);
+
 	if( (mstate_real & mcClimb) && (cam_active!=eacFreeLook) )
+	{
+		if (cam_freelook != eflDisabled)
+			cam_UnsetFreelook();
 		camUpdateLadder(dt);
+	}
+		
 	on_weapon_shot_update();
@@ -315,5 +526,9 @@
 
+	if (CurrentHeight < 0.0f)
+		CurrentHeight = CameraHeight();
+
 	if (CurrentHeight != CameraHeight())
 	{
-		CurrentHeight = (CurrentHeight * (1.0f - HeightInterpolationSpeed*dt)) + (CameraHeight() * HeightInterpolationSpeed*dt);
+		CurrentHeight = (CurrentHeight * (1.0f - HeightInterpolationSpeed * dt)) + (CameraHeight() *
+			HeightInterpolationSpeed * dt);
 	}
@@ -372,2 +591,49 @@
 	
+	if (cam_active == eacFirstEye) {
+		if (firstPersonDeath && !g_Alive() && m_FPCam) {
+			IKinematics* k = Visual()->dcast_PKinematics();
+
+			// Get eye bone position
+			CBoneInstance& eyeBone = k->LL_GetBoneInstance(m_eye_right);
+			Fmatrix matrix = Fidentity;
+			matrix.mul_43(XFORM(), eyeBone.mTransform);
+			Fvector camPos = (matrix.c);
+
+			// Get head bone direction, works better for first person death
+			CBoneInstance& headBone = k->LL_GetBoneInstance(m_head);
+			Fmatrix matrixDir = Fidentity;
+			Fvector camDir;
+			matrixDir.mul_43(XFORM(), headBone.mTransform);
+			matrixDir.getHPB(camDir);
+
+			// Adjust camera direction
+			Fvector adjustedCamDir;
+			adjustedCamDir.set(camDir).setHP(
+				camDir.x + deg2rad(8.f) + deg2rad(offsetH),
+				camDir.y - deg2rad(20.f) + deg2rad(offsetP)
+			);
+			camDir.set(
+				adjustedCamDir.getH(),
+				adjustedCamDir.getP(),
+				camDir.z + deg2rad(90.f) + deg2rad(offsetB)
+			);
+			if (camDir.x < 0) {
+				camDir.x = PI_MUL_2 + camDir.x;
+			}
+
+			Fvector dir, dirUp, dirRight;
+			dir.setHP(camDir.x, camDir.y);
+			Fvector::generate_orthonormal_basis_normalized(dir, dirUp, dirRight);
+
+			camPos.mad(dir, -0.04 + offsetZ);
+			camPos.mad(dirUp, offsetY);
+			camPos.mad(dirRight, -0.01 + offsetX);
+
+			m_FPCam->m_HPB.set(camDir);
+			m_FPCam->m_Position.set(camPos);
+			_viewport_near = VIEWPORT_NEAR - 0.08 + viewportNearOffset;
+			//Cameras().ApplyDevice(_viewport_near);
+		}
+	}
+
 	//Alundaio -psp always
@@ -385,2 +651,18 @@
 
+	// ÐÑÑÑÐ¸ÑÑÐ²Ð°ÐµÐ¼ ÑÐ°Ð·Ð½Ð¸ÑÑ Ð¼ÐµÐ¶Ð´Ñ Ð¿ÑÐµÐ´ÑÐ´ÑÑÐ¸Ð¼ Ð¸ ÑÐµÐºÑÑÐ¸Ð¼ Yaw \ Pitch Ð¾Ñ 1-Ð³Ð¾ Ð»Ð¸ÑÐ° //--#SM+ Begin#--
+	float& cam_yaw_cur = cameras[eacFirstEye]->yaw;
+	float& cam_pitch_cur = cameras[eacFirstEye]->pitch;
+
+	static bool freelook_last_frame;
+	static float cam_yaw_prev = cam_yaw_cur;
+	static float cam_pitch_prev = cam_pitch_cur;
+
+	fFPCamYawMagnitude = freelook_last_frame ? 0.f : (1.f - freelook_cam_control) * (angle_difference_signed(cam_yaw_prev, cam_yaw_cur) / Device.fTimeDelta); // L+ / R-
+	fFPCamPitchMagnitude = freelook_last_frame ? 0.f : (1.f - freelook_cam_control) * (angle_difference_signed(cam_pitch_prev, cam_pitch_cur) / Device.fTimeDelta); //U+ / D-
+
+	freelook_last_frame = cam_freelook == eflDisabling;
+	cam_yaw_prev = cam_yaw_cur;
+	cam_pitch_prev = cam_pitch_cur;
+	//--#SM+ End#--
+
 #ifdef DEBUG
@@ -396,3 +678,4 @@
 		Level().Cameras().UpdateFromCamera	(C);
-		if(eacFirstEye == cam_active && !Level().Cameras().GetCamEffector(cefDemo)){
+		if (eacFirstEye == cam_active && !Level().Cameras().GetCamEffector(cefDemo) && !Device.m_SecondViewport.IsSVPActive())
+		{
 			Cameras().ApplyDevice	(_viewport_near);
@@ -408,3 +691,3 @@
 
-	CCameraBase* pACam = cam_FirstEye();
+	CCameraBase* pACam = cam_Active();
 	if (!pACam) return;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ActorCondition.cpp xray-monolith/src/xrGame/ActorCondition.cpp
--- coc-1.4-xray-64/src/xrGame/ActorCondition.cpp	2023-10-20 20:54:50.563337900 +0100
+++ xray-monolith/src/xrGame/ActorCondition.cpp	2023-10-20 20:54:32.547037100 +0100
@@ -6,3 +6,3 @@
 #include "level.h"
-#include "sleepeffector.h"
+//#include "sleepeffector.h"
 #include "game_base_space.h"
@@ -48,2 +48,6 @@
 	m_fSatiety					= 1.0f;
+	m_fSatietyChange = 0.0f;
+
+	m_MaxWalkWeight = 50.0f;
+	m_CarryWeightBoost = 0.0f;
 
@@ -84,2 +88,3 @@
 	LPCSTR						section = READ_IF_EXISTS(pSettings,r_string,entity_section,"condition_sect",entity_section);
+	m_change_v_sleep.load(section, "_sleep");
 
@@ -113,4 +118,6 @@
 	m_fPowerLeakSpeed			= pSettings->r_float(section,"max_power_leak_speed");
+	m_fPowerLeakSpeedSleep = pSettings->r_float(section, "max_power_leak_speed_sleep");
 	
 	m_fV_Alcohol				= pSettings->r_float(section,"alcohol_v");
+	m_fV_AlcoholSleep = pSettings->r_float(section, "alcohol_v_sleep");
 
@@ -119,6 +126,10 @@
 	m_fV_Satiety				= pSettings->r_float(section,"satiety_v");		
+	m_fV_SatietySleep = pSettings->r_float(section, "satiety_v_sleep");
 	m_fV_SatietyPower			= pSettings->r_float(section,"satiety_power_v");
+	m_fV_SatietyPowerSleep = pSettings->r_float(section, "satiety_power_v_sleep");
 	m_fV_SatietyHealth			= pSettings->r_float(section,"satiety_health_v");
+	m_fV_SatietyHealthSleep = pSettings->r_float(section, "satiety_health_v_sleep");
 	
 	m_MaxWalkWeight				= pSettings->r_float(section,"max_walk_weight");
+	m_CarryWeightBoost = 0.0f;
 
@@ -180,2 +197,4 @@
 {
+	float v_alcohol = IsSleeping() ? m_fV_AlcoholSleep : m_fV_Alcohol;
+	
 	if(psActorFlags.test(AF_GODMODE_RT))
@@ -185,3 +204,3 @@
 
-		m_fAlcohol		+= m_fV_Alcohol*m_fDeltaTime;
+		m_fAlcohol += v_alcohol * m_fDeltaTime;
 		clamp			(m_fAlcohol,			0.0f,		1.0f);
@@ -194,2 +213,6 @@
 	}
+	else if (GodMode())
+	{
+		UpdateBoosters();
+	}
 
@@ -225,3 +248,4 @@
 		}
-		SetMaxPower		(GetMaxPower() - m_fPowerLeakSpeed * m_fDeltaTime * k_max_power);
+		float power_leak_speed = IsSleeping() ? m_fPowerLeakSpeedSleep : m_fPowerLeakSpeed;
+		SetMaxPower(GetMaxPower() - power_leak_speed * m_fDeltaTime * k_max_power);
 	}
@@ -229,3 +253,3 @@
 
-	m_fAlcohol		+= m_fV_Alcohol*m_fDeltaTime;
+	m_fAlcohol += v_alcohol * m_fDeltaTime;
 	clamp			(m_fAlcohol,			0.0f,		1.0f);
@@ -316,2 +346,23 @@
 
+float CActorCondition::GetBoosterValue(LPCSTR name, bool type)
+{
+	for (u8 i = 0; i < eBoostMaxCount; i++)
+	{
+		if (0 == xr_strcmp(ef_boosters_section_names[i], name))
+		{
+			BOOSTER_MAP::iterator it = m_booster_influences.find((EBoostParams)i);
+			if (it != m_booster_influences.end())
+			{
+				if (type)
+				{
+					return (it->second.fBoostTime);
+				}
+				return (it->second.fBoostValue);
+			}
+		}
+	}
+
+	return 0.f;
+}
+
 void CActorCondition::AffectDamage_InjuriousMaterialAndMonstersInfluence()
@@ -433,5 +485,7 @@
 {
+	float v_satiety_power = IsSleeping() ? m_fV_SatietyPowerSleep : m_fV_SatietyPower;
+	
  	if (!IsGameTypeSingle()) 
 	{
-		m_fDeltaPower += m_fV_SatietyPower * m_fDeltaTime;
+		m_fDeltaPower += v_satiety_power * m_fDeltaTime;
  		return;
@@ -439,5 +493,10 @@
 
+	m_fSatiety += m_fSatietyChange;
+	clamp(m_fSatiety, 0.0f, 1.0f);
+	m_fSatietyChange = 0.0f;
+
 	if(m_fSatiety>0)
 	{
-		m_fSatiety -= m_fV_Satiety*m_fDeltaTime;
+		float v_satiety = IsSleeping() ? m_fV_SatietySleep : m_fV_Satiety;
+		m_fSatiety -= v_satiety * m_fDeltaTime;
 		clamp(m_fSatiety, 0.0f, 1.0f);
@@ -445,7 +504,10 @@
 		
-	float satiety_health_koef = (m_fSatiety-m_fSatietyCritical)/(m_fSatiety>=m_fSatietyCritical?1-m_fSatietyCritical:m_fSatietyCritical);
+	float satiety_health_koef = (m_fSatiety - m_fSatietyCritical) / (m_fSatiety >= m_fSatietyCritical
+		                                                                 ? 1 - m_fSatietyCritical
+		                                                                 : m_fSatietyCritical);
 	if(CanBeHarmed() && !psActorFlags.test(AF_GODMODE_RT) )
 	{
-		m_fDeltaHealth += m_fV_SatietyHealth*satiety_health_koef*m_fDeltaTime;
-		m_fDeltaPower += m_fV_SatietyPower*m_fSatiety*m_fDeltaTime;
+		float v_satiety_health = IsSleeping() ? m_fV_SatietyHealthSleep : m_fV_SatietyHealth;
+		m_fDeltaHealth += v_satiety_health * satiety_health_koef * m_fDeltaTime;
+		m_fDeltaPower += v_satiety_power * m_fSatiety * m_fDeltaTime;
 	}
@@ -472,2 +535,3 @@
 	m_fPower			-=	HitPowerEffect(power);
+	clamp(m_fPower, 0.f, 1.f);
 }
@@ -480,2 +544,3 @@
 	m_fPower			-=	HitPowerEffect(power);
+	clamp(m_fPower, 0.f, 1.f);
 }
@@ -487,2 +552,3 @@
 	m_fPower			-= power;
+	clamp(m_fPower, 0.f, 1.f);
 }
@@ -532,2 +598,9 @@
 }
+
+bool CActorCondition::IsSleeping() const
+{
+	return object().HasInfo("actor_is_sleeping");
+}
+
+
 extern bool g_bShowHudInfo;
@@ -597,2 +670,7 @@
 
+CEntityCondition::SConditionChangeV& CActorCondition::change_v()
+{
+	return IsSleeping() ? m_change_v_sleep : m_change_v;
+}
+
 void CActorCondition::ChangeAlcohol	(float value)
@@ -601,6 +679,6 @@
 }
+
 void CActorCondition::ChangeSatiety(float value)
 {
-	m_fSatiety += value;
-	clamp		(m_fSatiety, 0.0f, 1.0f);
+	m_fSatietyChange += value;
 }
@@ -664,2 +778,3 @@
 	m_change_v.m_fV_HealthRestore += value;
+	m_change_v_sleep.m_fV_HealthRestore += value;
 }
@@ -668,2 +784,3 @@
 	m_fV_SatietyPower += value;
+	m_fV_SatietyPowerSleep += value;
 }
@@ -672,2 +790,3 @@
 	m_change_v.m_fV_Radiation += value;
+	m_change_v_sleep.m_fV_Radiation += value;
 }
@@ -676,2 +796,3 @@
 	m_change_v.m_fV_WoundIncarnation += value;
+	m_change_v_sleep.m_fV_WoundIncarnation += value;
 }
@@ -677,6 +798,8 @@
 }
+
 void CActorCondition::BoostMaxWeight(const float value)
 {
-	m_object->inventory().SetMaxWeight(object().inventory().GetMaxWeight()+value);
-	m_MaxWalkWeight += value;
+	//m_object->inventory().SetMaxWeight(object().inventory().GetMaxWeight() + value);
+	//m_MaxWalkWeight += value;
+	m_CarryWeightBoost += value;
 }
@@ -897,3 +1044,9 @@
 		if(it!=m_booster_influences.end())
+		{
+			if (B.fBoostValue * B.fBoostTime < (*it).second.fBoostValue * (*it).second.fBoostTime)
+			{
+				return true;
+			}
 			DisableBoostParameters((*it).second);
+		}
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ActorCondition.h xray-monolith/src/xrGame/ActorCondition.h
--- coc-1.4-xray-64/src/xrGame/ActorCondition.h	2023-10-20 20:54:50.563337900 +0100
+++ xray-monolith/src/xrGame/ActorCondition.h	2023-10-20 20:54:32.548036700 +0100
@@ -7,2 +7,4 @@
 #include "actor_defs.h"
+#include "script_export_space.h"
+#include "Wound.h"
 
@@ -39,2 +46,3 @@
 	virtual void		reinit						();
+	virtual SConditionChangeV& change_v();
 
@@ -43,2 +51,3 @@
 			void		UpdateBoosters				();
+	float GetBoosterValue(LPCSTR name, bool type);
 
@@ -49,19 +58,19 @@
 	void 				DisableBoostParameters		(const SBooster& B);
-	IC void				BoostMaxWeight				(const float value);
-	IC void				BoostHpRestore				(const float value);
-	IC void				BoostPowerRestore			(const float value);
-	IC void				BoostRadiationRestore		(const float value);
-	IC void				BoostBleedingRestore		(const float value);
-	IC void				BoostBurnImmunity			(const float value);
-	IC void				BoostShockImmunity			(const float value);
-	IC void				BoostRadiationImmunity		(const float value);
-	IC void				BoostTelepaticImmunity		(const float value);
-	IC void				BoostChemicalBurnImmunity	(const float value);
-	IC void				BoostExplImmunity			(const float value);
-	IC void				BoostStrikeImmunity			(const float value);
-	IC void				BoostFireWoundImmunity		(const float value);
-	IC void				BoostWoundImmunity			(const float value);
-	IC void				BoostRadiationProtection	(const float value);
-	IC void				BoostTelepaticProtection	(const float value);
-	IC void				BoostChemicalBurnProtection	(const float value);
+	void BoostMaxWeight(const float value);
+	void BoostHpRestore(const float value);
+	void BoostPowerRestore(const float value);
+	void BoostRadiationRestore(const float value);
+	void BoostBleedingRestore(const float value);
+	void BoostBurnImmunity(const float value);
+	void BoostShockImmunity(const float value);
+	void BoostRadiationImmunity(const float value);
+	void BoostTelepaticImmunity(const float value);
+	void BoostChemicalBurnImmunity(const float value);
+	void BoostExplImmunity(const float value);
+	void BoostStrikeImmunity(const float value);
+	void BoostFireWoundImmunity(const float value);
+	void BoostWoundImmunity(const float value);
+	void BoostRadiationProtection(const float value);
+	void BoostTelepaticProtection(const float value);
+	void BoostChemicalBurnProtection(const float value);
 	BOOSTER_MAP			GetCurBoosterInfluences		() {return m_booster_influences;};
@@ -73,5 +82,5 @@
 	virtual bool		IsCantSprint				() const;
+	bool IsSleeping() const;
 
 			void		PowerHit					(float power, bool apply_outfit);
-			float		GetPower					() const { return m_fPower; }
 
@@ -81,2 +90,7 @@
 	IC		float		MaxWalkWeight				() const	{ return m_MaxWalkWeight; }
+	IC void SetMaxWalkWeight(float mww) { m_MaxWalkWeight = mww; }
+	IC float GetCarryWeightBoost() const { return m_CarryWeightBoost; }
+
+	float GetPsyBar() { return m_fPsyBar; }
+	void SetPsyBar(float psybar) { m_fPsyBar = psybar; }
 			
@@ -84,4 +98,5 @@
 			float	xr_stdcall	GetPsy				()	{return 1.0f-GetPsyHealth();}
-			float				GetSatiety			()  {return m_fSatiety;}
-	IC		float				GetSatietyPower		() const {return m_fV_SatietyPower*m_fSatiety;};
+	virtual float GetSatiety() { return m_fSatiety; }
+	virtual void SetSatiety(float satiety) { m_fSatiety = satiety; }
+	IC float GetSatietyPower() const { return IsSleeping() ? m_fV_SatietyPowerSleep * m_fSatiety : m_fV_SatietyPower * m_fSatiety; };
 
@@ -102,5 +118,5 @@
 //	IC		float const&	Satiety					()	{ return m_fSatiety; }
-	IC		float const&	V_Satiety				()	{ return m_fV_Satiety; }
-	IC		float const&	V_SatietyPower			()	{ return m_fV_SatietyPower; }
-	IC		float const&	V_SatietyHealth			()	{ return m_fV_SatietyHealth; }
+	IC float const& V_Satiety() { return IsSleeping() ? m_fV_SatietySleep : m_fV_Satiety; }
+	IC float const& V_SatietyPower() { return IsSleeping() ? m_fV_SatietyPowerSleep : m_fV_SatietyPower; }
+	IC float const& V_SatietyHealth() { return IsSleeping() ? m_fV_SatietyHealthSleep : m_fV_SatietyHealth; }
 	IC		float const&	SatietyCritical			()	{ return m_fSatietyCritical; }
@@ -120,10 +136,19 @@
 protected:
+	SConditionChangeV m_change_v_sleep;
+	
 	SMedicineInfluenceValues						m_curr_medicine_influence;
+	float m_fPsyBar;
+
 	float m_fAlcohol;
 	float m_fV_Alcohol;
+	float m_fV_AlcoholSleep;
 //--
 	float m_fSatiety;
+	float m_fSatietyChange;
 	float m_fV_Satiety;
+	float m_fV_SatietySleep;
 	float m_fV_SatietyPower;
+	float m_fV_SatietyPowerSleep;
 	float m_fV_SatietyHealth;
+	float m_fV_SatietyHealthSleep;
 	float m_fSatietyCritical;
@@ -131,2 +156,3 @@
 	float m_fPowerLeakSpeed;
+	float m_fPowerLeakSpeedSleep;
 
@@ -142,5 +168,5 @@
 	
-public:
 	float	m_MaxWalkWeight;
-protected:
+	float m_CarryWeightBoost;
+
 	float	m_zone_max_power[ALife::infl_max_count];
@@ -172,2 +198,4 @@
 	ref_sound m_use_sound;
+	
+	DECLARE_SCRIPT_REGISTER_FUNCTION
 };
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ActorEffector.cpp xray-monolith/src/xrGame/ActorEffector.cpp
--- coc-1.4-xray-64/src/xrGame/ActorEffector.cpp	2023-10-20 20:54:50.563337900 +0100
+++ xray-monolith/src/xrGame/ActorEffector.cpp	2023-10-20 20:54:32.548036700 +0100
@@ -157,2 +165,3 @@
 	m_fov					= -1.0f;
+	m_power = 1.f;
 }
@@ -182,6 +191,15 @@
 
-	const Fmatrix& m			= m_objectAnimator->XFORM();
+	Fmatrix m = m_objectAnimator->XFORM();
 	m_objectAnimator->Update	(Device.fTimeDelta);
 
-	if(!m_bAbsolutePositioning){
+	if (m_power != 1.f)
+	{
+		m.mul(m_power);
+		m.m[0][0] = 1.f;
+		m.m[1][1] = 1.f;
+		m.m[2][2] = 1.f;
+	}
+
+	if (!m_bAbsolutePositioning)
+	{
 		Fmatrix Mdef;
@@ -192,9 +210,9 @@
 		Mdef.c						= info.p;
-//		Msg("fr[%d] %2.3f,%2.3f,%2.3f", Device.dwFrame,m.c.x,m.c.y,m.c.z);
-		Fmatrix mr;
-		mr.mul						(Mdef,m);
-		info.d						= mr.k;
-		info.n						= mr.j;
-		info.p						= mr.c;
-	}else{
+		m.mulA_43(Mdef);
+		info.d = m.k;
+		info.n = m.j;
+		info.p = m.c;
+	}
+	else
+	{
 		info.d						= m.k;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ActorEffector.h xray-monolith/src/xrGame/ActorEffector.h
--- coc-1.4-xray-64/src/xrGame/ActorEffector.h	2023-10-20 20:54:50.564327400 +0100
+++ xray-monolith/src/xrGame/ActorEffector.h	2023-10-20 20:54:32.549038000 +0100
@@ -62,2 +73,3 @@
 	float				m_fov;
+	float m_power;
 
@@ -68,2 +80,4 @@
 			void		SetCyclic				(bool b)				{m_bCyclic=b;}
+	void SetPower(float p) { m_power = p; }
+	float GetPower() { return m_power; }
 	virtual	BOOL		Valid					();
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ActorHelmet.cpp xray-monolith/src/xrGame/ActorHelmet.cpp
--- coc-1.4-xray-64/src/xrGame/ActorHelmet.cpp	2023-10-20 20:54:50.565327100 +0100
+++ xray-monolith/src/xrGame/ActorHelmet.cpp	2023-10-20 20:54:32.549038000 +0100
@@ -57,3 +57,3 @@
 	m_fPowerLoss					= READ_IF_EXISTS(pSettings, r_float, section, "power_loss",    1.0f );
-	clamp							( m_fPowerLoss, 0.0f, 1.0f );
+	clamp(m_fPowerLoss, EPS, 1.0f);
 
@@ -113,5 +113,4 @@
 		{
-			CTorch* pTorch = smart_cast<CTorch*>(pActor->inventory().ItemFromSlot(TORCH_SLOT));
-			if(pTorch && pTorch->GetNightVisionStatus())
-				pTorch->SwitchNightVision(true, false);
+			if (pActor->GetNightVisionStatus())
+				pActor->SwitchNightVision(true, false);
 		}
@@ -128,5 +127,3 @@
 		{
-			CTorch* pTorch = smart_cast<CTorch*>(pActor->inventory().ItemFromSlot(TORCH_SLOT));
-			if(pTorch)
-				pTorch->SwitchNightVision(false);
+			pActor->SwitchNightVision(false);
 		}
@@ -137,2 +134,3 @@
 {
+	if (IsUsingCondition() == false) return;
 	hit_power *= GetHitImmunity(hit_type);
@@ -214,4 +222,12 @@
 
+float CHelmet::get_HitFracActor() const
+{
+	return m_boneProtection->m_fHitFracActor;
+}
+
 float CHelmet::HitThroughArmor(float hit_power, s16 element, float ap, bool& add_wound, ALife::EHitType hit_type)
 {
+	if (strstr(Core.Params, "-dbgbullet"))
+		Msg("CHelmet::HitThroughArmor hit_type=%d | unmodified hit_power=%f", (u32)hit_type, hit_power);
+
 	float NewHitPower = hit_power;
@@ -220,3 +236,3 @@
 		float ba = GetBoneArmor(element);
-		if(ba<0.0f)
+		if (ba <= 0.0f)
 			return NewHitPower;
@@ -224,23 +240,23 @@
 		float BoneArmor = ba*GetCondition();
-		if(/*!fis_zero(ba, EPS) && */(ap > BoneArmor))
+		if (ap <= BoneArmor)
 		{
-			//ïóëÿ ïðîáèëà áðîíü
-			if(!IsGameTypeSingle())
-			{
-				float hit_fraction = (ap - BoneArmor) / ap;
-				if(hit_fraction < m_boneProtection->m_fHitFracActor)
-					hit_fraction = m_boneProtection->m_fHitFracActor;
-
-				NewHitPower *= hit_fraction;
-				NewHitPower *= m_boneProtection->getBoneProtection(element);
+			//ïóëÿ ÍÅ ïðîáèëà áðîíü
+			NewHitPower *= m_boneProtection->m_fHitFracActor;
+			//add_wound = false; 	//ðàíû íåò
+			if (strstr(Core.Params, "-dbgbullet"))
+				Msg("CHelmet::HitThroughArmor AP(%f) <= bone_armor(%f) [HitFracActor=%f] modified hit_power=%f", ap,
+				    BoneArmor, m_boneProtection->m_fHitFracActor, NewHitPower);
 			}
 
-			VERIFY(NewHitPower>=0.0f);
-		}
 		else
 		{
-			//ïóëÿ ÍÅ ïðîáèëà áðîíü
-			NewHitPower *= m_boneProtection->m_fHitFracActor;
-			add_wound = false; 	//ðàíû íåò
+			float d_hit_power = (ap - BoneArmor) / (ap * m_boneProtection->APScale);
+			clamp(d_hit_power, m_boneProtection->m_fHitFracActor, 1.0f);
+
+			NewHitPower *= d_hit_power;
 		}
+
+		if (strstr(Core.Params, "-dbgbullet"))
+			Msg("CHelmet::HitThroughArmor AP(%f) > bone_armor(%f) [HitFracActor=%f] modified hit_power=%f", ap,
+			    BoneArmor, m_boneProtection->m_fHitFracActor, NewHitPower);
 	}
@@ -261,3 +277,11 @@
 			NewHitPower = 0.f;
+
+		if (strstr(Core.Params, "-dbgbullet"))
+			Msg("CHelmet::HitThroughArmor hit_type=%d | After HitTypeProtection(%f) hit_power=%f", (u32)hit_type,
+			    protect * one, NewHitPower);
 	}
+
+	if (strstr(Core.Params, "-dbgbullet"))
+		Msg("CHelmet::HitThroughArmor hit_type=%d | After HitFractionActor hit_power=%f", (u32)hit_type, NewHitPower);
+
 	//óâåëè÷èòü èçíîøåííîñòü øëåìà
@@ -265,2 +289,5 @@
 
+	if (strstr(Core.Params, "-dbgbullet"))
+		Msg("CCustomOutfit::HitThroughArmor hit_type=%d | After immunities hit_power=%f", (u32)hit_type, NewHitPower);
+
 	return NewHitPower;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ActorHelmet.h xray-monolith/src/xrGame/ActorHelmet.h
--- coc-1.4-xray-64/src/xrGame/ActorHelmet.h	2023-10-20 20:54:50.565327100 +0100
+++ xray-monolith/src/xrGame/ActorHelmet.h	2023-10-20 20:54:32.550035700 +0100
@@ -33,2 +34,7 @@
 
+protected:
+	HitImmunity::HitTypeSVec m_HitTypeProtection;
+	SBoneProtections* m_boneProtection;
+	
+public:
 	float					m_fPowerLoss;
@@ -42,7 +48,5 @@
 
+	float get_HitFracActor() const;
 	void					ReloadBonesProtection	();
 	void					AddBonesProtection		(LPCSTR bones_section);
-protected:
-	HitImmunity::HitTypeSVec	m_HitTypeProtection;
-	SBoneProtections*		m_boneProtection;	
 
@@ -50,2 +54,8 @@
 	virtual bool			install_upgrade_impl	( LPCSTR section, bool test );
+	
+	DECLARE_SCRIPT_REGISTER_FUNCTION
 };
+
+add_to_type_list(CHelmet)
+#undef script_type_list
+#define script_type_list save_type_list(CHelmet)
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ActorInput.cpp xray-monolith/src/xrGame/ActorInput.cpp
--- coc-1.4-xray-64/src/xrGame/ActorInput.cpp	2023-10-20 20:54:50.566338200 +0100
+++ xray-monolith/src/xrGame/ActorInput.cpp	2023-10-20 20:54:32.550035700 +0100
@@ -13,3 +13,2 @@
 #include "PHDestroyable.h"
-#include "Car.h"
 #include "UIGameSP.h"
@@ -35,2 +34,5 @@
 #include "Weapon.h"
+#include "Flashlight.h"
+#include "../xrPhysics/IElevatorState.h"
+#include "holder_custom.h"
 
@@ -53,5 +55,12 @@
 
-			u16 slot = inventory().GetActiveSlot();
-			if(inventory().ActiveItem() && (slot==INV_SLOT_3 || slot==INV_SLOT_2) )
-				mstate_wishful &=~mcSprint;
+			// Tronex: export to allow/prevent weapon fire if returned false
+			luabind::functor<bool> funct;
+			if (ai().script_engine().functor("_G.CActor_Fire", funct))
+			{
+				if (!funct())
+				{
+					return;
+				}
+			}
+
 			//-----------------------------
@@ -92,7 +104,29 @@
 			mstate_wishful |= mcJump;
-		}break;
+		}
+		break;
 	case kSPRINT_TOGGLE:	
 		{
+			if (psActorFlags.test(AF_SPRINT_TOGGLE))
+			{
+				if (psActorFlags.test(AF_WALK_TOGGLE)) mstate_wishful &= ~mcAccel;
+				if (psActorFlags.test(AF_CROUCH_TOGGLE)) mstate_wishful &= ~mcCrouch;
 			mstate_wishful ^= mcSprint;
-		}break;
+			}
+		}
+		break;
+	case kFREELOOK:
+	{
+		if (psActorFlags.test(AF_FREELOOK_TOGGLE))
+		{
+			if (cam_freelook == eflDisabled && CanUseFreelook())
+			{
+				cam_SetFreelook();
+			}
+			else if (cam_freelook == eflEnabled)
+			{
+				cam_UnsetFreelook();
+			}
+		}
+	}
+	break;
 	case kCROUCH:	
@@ -101,9 +135,37 @@
 			mstate_wishful ^= mcCrouch;
-		}break;
-	case kCAM_1:	cam_Set			(eacFirstEye);				break;
-	case kCAM_2:	cam_Set			(eacLookAt);				break;
-	case kCAM_3:	cam_Set			(eacFreeLook);				break;
+		}
+		break;
+	case kACCEL:
+		{
+			if (psActorFlags.test(AF_WALK_TOGGLE))
+				mstate_wishful ^= mcAccel;
+		}
+		break;
+	case kL_LOOKOUT:
+		{
+			if (psActorFlags.test(AF_LOOKOUT_TOGGLE))
+			{
+				mstate_wishful &= ~mcRLookout;
+				mstate_wishful ^= mcLLookout;
+			}
+		}
+		break;
+	case kR_LOOKOUT:
+		{
+			if (psActorFlags.test(AF_LOOKOUT_TOGGLE))
+			{
+				mstate_wishful &= ~mcLLookout;
+				mstate_wishful ^= mcRLookout;
+			}
+		}
+		break;
+	case kCAM_1: cam_Set(eacFirstEye);
+		break;
+	case kCAM_2: cam_Set(eacLookAt);
+		break;
+	case kCAM_3: cam_Set(eacFreeLook);
+		break;
 	case kNIGHT_VISION:
 		{
-			SwitchNightVision();
+			//SwitchNightVision(); //Rezy: now it's controlled via LUA scripts for timing and animations
 			break;
@@ -112,3 +174,3 @@
 		{
-			SwitchTorch();
+			//SwitchTorch(); //Tronex: now it's controlled via LUA scripts for timing and animations
 			break;
@@ -118,10 +180,11 @@
 		{
-			PIItem det_active					= inventory().ItemFromSlot(DETECTOR_SLOT);
-			if(det_active)
+			PIItem dev_active = inventory().ItemFromSlot(DETECTOR_SLOT);
+			if (dev_active)
 			{
-				CCustomDetector* det			= smart_cast<CCustomDetector*>(det_active);
-				det->ToggleDetector				(g_player_hud->attached_item(0)!=NULL);
-				return;
+				CCustomDevice* dev = smart_cast<CCustomDevice*>(dev_active);
+				if (dev)
+					dev->ToggleDevice(g_player_hud->attached_item(0) != NULL);
 			}
-		}break;
+		}
+		break;
 /*
@@ -171,3 +236,7 @@
 
-				if(itm)
+				luabind::functor<bool> funct;
+				if (itm && ai().script_engine().functor("_G.CInventory__eat", funct))
+				{
+					CGameObject* GO = itm->cast_game_object();
+					if (GO && funct(GO->lua_game_object()))
 				{
@@ -186,6 +256,8 @@
 					
-					CurrentGameUI()->GetActorMenu().m_pQuickSlot->ReloadReferences(this);
+						//CurrentGameUI()->GetActorMenu().m_pQuickSlot->ReloadReferences(this);
 				}
 			}
-		}break;
+			}
+		}
+		break;
 	}
@@ -193,2 +265,6 @@
 
+// demonized: switch to disable mouse wheel weapon change
+BOOL mouseWheelChangeWeapon = TRUE;
+// mbehm: switch to allow inverting mouse wheel zoom direction
+BOOL mouseWheelInvertZoom = TRUE;
 void CActor::IR_OnMouseWheel(int direction)
@@ -201,5 +277,9 @@
 
+	if (mouseWheelInvertZoom) {
 	if(inventory().Action( (direction>0)? (u16)kWPN_ZOOM_DEC:(u16)kWPN_ZOOM_INC , CMD_START)) return;
+	} else {
+		if (inventory().Action((direction > 0) ? (u16)kWPN_ZOOM_INC : (u16)kWPN_ZOOM_DEC, CMD_START)) return;
+	}
 
-
+	if (mouseWheelChangeWeapon) {
 	if (direction>0)
@@ -209,2 +289,3 @@
 }
+}
 
@@ -220,2 +301,5 @@
 	{
+		if (cmd == kUSE && !psActorFlags.test(AF_MULTI_ITEM_PICKUP))
+			m_bPickupMode = false;
+
 		if(m_holder)
@@ -266,17 +352,32 @@
 	case kDOWN: 
-		cam_Active()->Move( (cmd==kUP) ? kDOWN : kUP, 0, LookFactor);									break;
+		if(cam_freelook != eflEnabling && cam_freelook != eflDisabling) cam_Active()->Move((cmd == kUP) ? kDOWN : kUP, 0, LookFactor);
+		break;
 	case kCAM_ZOOM_IN: 
 	case kCAM_ZOOM_OUT: 
-		cam_Active()->Move(cmd);												break;
+		cam_Active()->Move(cmd);
+		break;
 	case kLEFT:
 	case kRIGHT:
-		if (eacFreeLook!=cam_active) cam_Active()->Move(cmd, 0, LookFactor);	break;
-
-	case kACCEL:	mstate_wishful |= mcAccel;									break;
-	case kL_STRAFE:	mstate_wishful |= mcLStrafe;								break;
-	case kR_STRAFE:	mstate_wishful |= mcRStrafe;								break;
-	case kL_LOOKOUT:mstate_wishful |= mcLLookout;								break;
-	case kR_LOOKOUT:mstate_wishful |= mcRLookout;								break;
-	case kFWD:		mstate_wishful |= mcFwd;									break;
-	case kBACK:		mstate_wishful |= mcBack;									break;
+		if (eacFreeLook != cam_active && cam_freelook != eflEnabling && cam_freelook != eflDisabling) cam_Active()->Move(cmd, 0, LookFactor);
+		break;
+	case kL_STRAFE: mstate_wishful |= mcLStrafe;
+		break;
+	case kR_STRAFE: mstate_wishful |= mcRStrafe;
+		break;
+	case kL_LOOKOUT:
+		{
+			if (!psActorFlags.test(AF_LOOKOUT_TOGGLE) && cam_freelook == eflDisabled)
+				mstate_wishful |= mcLLookout;
+		}
+		break;
+	case kR_LOOKOUT:
+		{
+			if (!psActorFlags.test(AF_LOOKOUT_TOGGLE) && cam_freelook == eflDisabled)
+				mstate_wishful |= mcRLookout;
+		}
+		break;
+	case kFWD: mstate_wishful |= mcFwd;
+		break;
+	case kBACK: mstate_wishful |= mcBack;
+		break;
 	case kCROUCH:
@@ -285,4 +386,31 @@
 					mstate_wishful |= mcCrouch;
-
-		}break;
+		}
+		break;
+	case kACCEL:
+		{
+			if (!psActorFlags.test(AF_WALK_TOGGLE))
+				mstate_wishful |= mcAccel;
+		}
+	break;
+	case kFREELOOK:
+	{
+		if (!psActorFlags.test(AF_FREELOOK_TOGGLE))
+		{
+			if (cam_freelook == eflDisabled && CanUseFreelook())
+			{
+				cam_SetFreelook();
+			}
+		}
+	}
+	break;
+	case kSPRINT_TOGGLE:
+		{
+			if (!psActorFlags.test(AF_SPRINT_TOGGLE))
+			{
+				if (psActorFlags.test(AF_WALK_TOGGLE)) mstate_wishful &= ~mcAccel;
+				if (psActorFlags.test(AF_CROUCH_TOGGLE)) mstate_wishful &= ~mcCrouch;
+				mstate_wishful |= mcSprint;
+			}
+		}
+		break;
 	}
@@ -311,2 +438,5 @@
 
+	if (cam_freelook == eflEnabling || cam_freelook == eflDisabling)
+		return;
+
 	float LookFactor = GetLookFactor();
@@ -314,4 +444,5 @@
 	CCameraBase* C	= cameras	[cam_active];
-	float scale		= (C->f_fov/g_fov)*psMouseSens * psMouseSensScale/50.f  / LookFactor;
-	if (dx){
+    float scale = (C->f_fov / g_fov) * (psMouseSens * sens_multiple) * psMouseSensScale / 50.f / LookFactor;
+	if (dx)
+	{
 		float d = float(dx)*scale;
@@ -325,16 +458,11 @@
 #include "HudItem.h"
+
 bool CActor::use_Holder				(CHolderCustom* holder)
 {
+	if (m_holder)
+	{
+		bool b = use_HolderEx(0, false);
 
-	if(m_holder){
-		bool b = false;
-		CGameObject* holderGO			= smart_cast<CGameObject*>(m_holder);
-		
-		if(smart_cast<CCar*>(holderGO))
-			b = use_Vehicle(0);
-		else
-			if (holderGO->CLS_ID==CLSID_OBJECT_W_STATMGUN || holderGO->CLS_ID==CLSID_OBJECT_HOLDER_ENT)
-				b = use_HolderEx(0,false);
-
-		if(inventory().ActiveItem()){
+		if (inventory().ActiveItem())
+		{
 			CHudItem* hi = smart_cast<CHudItem*>(inventory().ActiveItem());
@@ -344,15 +472,14 @@
 		return b;
-	}else{
-		bool b = false;
-		CGameObject* holderGO			= smart_cast<CGameObject*>(holder);
-		if(smart_cast<CCar*>(holder))
-			b = use_Vehicle(holder);
-
-		if (holderGO->CLS_ID==CLSID_OBJECT_W_STATMGUN || holderGO->CLS_ID==CLSID_OBJECT_HOLDER_ENT)
-			b = use_HolderEx(holder,false);
+	}
+	else
+	{
+		bool b = use_HolderEx(holder, false);
 		
-		if(b){//used succesfully
+		if (b)
+		{
+			//used succesfully
 			// switch off torch...
 			CAttachableItem *I = CAttachmentOwner::attachedItem(CLSID_DEVICE_TORCH);
-			if (I){
+			if (I)
+			{
 				CTorch* torch = smart_cast<CTorch*>(I);
@@ -383,2 +511,5 @@
 				
+	if (!psActorFlags.test(AF_MULTI_ITEM_PICKUP))
+		m_bPickupMode = true;
+
 	if(character_physics_support()->movement()->PHCapture())
@@ -419,2 +549,6 @@
 			bool b_allow = !!pSettings->line_exist("ph_capture_visuals",object->cNameVisual());
+			luabind::functor<bool> funct;
+			if (ai().script_engine().functor("_G.CActor__OnBeforePHCapture", funct))
+				b_allow = funct(object->lua_game_object(), b_allow);
+
 			if(b_allow && !character_physics_support()->movement()->PHCapture())
@@ -470,6 +601,5 @@
 		}
-
 	}
 }
-
+extern BOOL firstPersonDeath;
 BOOL CActor::HUDview				( )const 
@@ -477,3 +607,3 @@
 	return IsFocused() && (cam_active==eacFirstEye)&&
-		((!m_holder) || (m_holder && m_holder->allowWeapon() && m_holder->HUDView() ) ); 
+		((!m_holder) || (m_holder && m_holder->allowWeapon() && m_holder->HUDView())) && (firstPersonDeath ? g_Alive() : true);
 }
@@ -486,2 +616,3 @@
 		ARTEFACT_SLOT	,		// 10
+	PDA_SLOT
 };
@@ -516,2 +647,6 @@
 			}
+			else if (SlotsToCheck[i] == PDA_SLOT)
+			{
+				IR_OnKeyboardPress(kACTIVE_JOBS);
+			}
 			else
@@ -551,2 +686,6 @@
 			}
+			else if (SlotsToCheck[i] == PDA_SLOT)
+			{
+				IR_OnKeyboardPress(kACTIVE_JOBS);
+			}
 			else
@@ -558,2 +697,4 @@
 
+extern float g_AimLookFactor;
+
 float	CActor::GetLookFactor()
@@ -563,13 +704,9 @@
 
+	if (m_bZoomAimingMode)
+		return (1.f / g_AimLookFactor);
 	
-	float factor	= 1.f;
-
-	PIItem pItem	= inventory().ActiveItem();
+	if (cam_freelook != eflDisabled)
+		return 1.5f;
 
-	if (pItem)
-		factor *= pItem->GetControlInertionFactor();
-
-	VERIFY(!fis_zero(factor));
-
-	return factor;
+	return 1.f;
 }
@@ -592,28 +729,3 @@
 {
-	CWeapon* wpn1 = NULL;
-	CWeapon* wpn2 = NULL;
-	if(inventory().ItemFromSlot(INV_SLOT_2))
-		wpn1 = smart_cast<CWeapon*>(inventory().ItemFromSlot(INV_SLOT_2));
-
-	if(inventory().ItemFromSlot(INV_SLOT_3))
-		wpn2 = smart_cast<CWeapon*>(inventory().ItemFromSlot(INV_SLOT_3));
-
-	xr_vector<CAttachableItem*> const& all = CAttachmentOwner::attached_objects();
-	xr_vector<CAttachableItem*>::const_iterator it = all.begin();
-	xr_vector<CAttachableItem*>::const_iterator it_e = all.end();
-	for ( ; it != it_e; ++it )
-	{
-		CTorch* torch = smart_cast<CTorch*>(*it);
-		if ( torch )
-		{	
-			if(wpn1 && wpn1->IsZoomed())
-				return;
-
-			if(wpn2 && wpn2->IsZoomed())
-				return;
-
-			torch->SwitchNightVision();
-			return;
-		}
-	}
+	SwitchNightVision(!m_bNightVisionOn);
 }
@@ -622,14 +734,5 @@
 { 
-	xr_vector<CAttachableItem*> const& all = CAttachmentOwner::attached_objects();
-	xr_vector<CAttachableItem*>::const_iterator it = all.begin();
-	xr_vector<CAttachableItem*>::const_iterator it_e = all.end();
-	for ( ; it != it_e; ++it )
-	{
-		CTorch* torch = smart_cast<CTorch*>(*it);
-		if ( torch )
-		{		
-			torch->Switch();
-			return;
-		}
-	}
+	CTorch* pTorch = smart_cast<CTorch*>(inventory().ItemFromSlot(TORCH_SLOT));
+	if (pTorch)
+		pTorch->Switch();
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/AdvancedDetector.cpp xray-monolith/src/xrGame/AdvancedDetector.cpp
--- coc-1.4-xray-64/src/xrGame/AdvancedDetector.cpp	2023-10-20 20:54:50.569340400 +0100
+++ xray-monolith/src/xrGame/AdvancedDetector.cpp	2023-10-20 20:54:32.554036500 +0100
@@ -18,3 +19,3 @@
 {
-	R_ASSERT			(NULL==m_ui);
+	R_ASSERT(nullptr==m_ui);
 	m_ui				= xr_new<CUIArtefactDetectorAdv>();
@@ -28,2 +29,8 @@
 
+void CAdvancedDetector::ResetUI()
+{
+	if (m_ui)
+		ui().SetValue(0.0f, Fvector().set(0, 0, 0));
+}
+
 void CAdvancedDetector::UpdateAf()
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/AdvancedDetector.h xray-monolith/src/xrGame/AdvancedDetector.h
--- coc-1.4-xray-64/src/xrGame/AdvancedDetector.h	2023-10-20 20:54:50.569340400 +0100
+++ xray-monolith/src/xrGame/AdvancedDetector.h	2023-10-20 20:54:32.554036500 +0100
@@ -15,2 +15,3 @@
 	virtual void 	CreateUI					();
+	virtual void ResetUI();
 	CUIArtefactDetectorAdv& ui					();
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/ai_monsters_anims.h xray-monolith/src/xrGame/ai/ai_monsters_anims.h
--- coc-1.4-xray-64/src/xrGame/ai/ai_monsters_anims.h	2023-10-20 20:54:50.774327300 +0100
+++ xray-monolith/src/xrGame/ai/ai_monsters_anims.h	2023-10-20 20:54:32.721035600 +0100
@@ -30,3 +33,4 @@
 		string256		S;
-		for (int j=0; caBaseNames[j]; ++j);
+		int j = 0;
+		for (; caBaseNames[j]; ++j);
 		A.resize		(j);
@@ -52,3 +58,4 @@
 		string256	S;
-		for (int j=0; caBaseNames[j]; ++j);
+		int j = 0;
+		for (; caBaseNames[j]; ++j);
 		A.resize	(j);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/crow/ai_crow.cpp xray-monolith/src/xrGame/ai/crow/ai_crow.cpp
--- coc-1.4-xray-64/src/xrGame/ai/crow/ai_crow.cpp	2023-10-20 20:54:50.775326700 +0100
+++ xray-monolith/src/xrGame/ai/crow/ai_crow.cpp	2023-10-20 20:54:32.722035100 +0100
@@ -108,2 +112,4 @@
 	bPlayDeathIdle		= false;
+	o_workload_frame = 0;
+	o_workload_rframe = 0;
 }
@@ -132,4 +139,5 @@
 	fIdleSoundTime				= fIdleSoundDelta+fIdleSoundDelta*Random.randF(-.5f,.5f);
+#ifdef DEBUG
 	VERIFY2( valid_pos( Position() ), dbg_valide_pos_string(Position(),this,"CAI_Crow::Load( LPCSTR section )") );
-
+#endif
 }
@@ -139,2 +147,4 @@
 	BOOL R		= inherited::net_Spawn	(DC);
+	if (!R) return FALSE;
+
 	setVisible	(TRUE);
@@ -150,5 +161,25 @@
 
+	renderable.visual->_ignore_optimization = true;
+
+	o_workload_frame = 0;
+	o_workload_rframe = 0;
+
+	if (GetfHealth() > 0)
+	{
+		st_current = eFlyIdle;
+		st_target = eFlyIdle;
 	// disable UpdateCL, enable only on HIT
 	processing_deactivate		();
+	}
+	else
+	{
+		st_current = eDeathFall;
+		st_target = eDeathDead;
+		// Crow is already dead, need to enable physics
+		processing_activate();
+		CreateSkeleton();
+	}
+#ifdef DEBUG
 	VERIFY2( valid_pos( Position() ), dbg_valide_pos_string(Position(),this,"CAI_Crow::net_Spawn") );
+#endif
 	return		R;
@@ -235,3 +275,5 @@
 	Position().mad	(vOldPosition,vDirection,fSpeed*fdt);
+#ifdef DEBUG
 	VERIFY2( valid_pos( Position() ), dbg_valide_pos_string(Position(),this,"state_Flying		(float fdt)") );
+#endif
 }
@@ -256,3 +300,5 @@
 	}
+#ifdef DEBUG
 	VERIFY2( valid_pos( Position() ), dbg_valide_pos_string(Position(),this,"CAI_Crow::state_DeathFall()") );
+#endif
 }
@@ -287,4 +335,7 @@
 	inherited::UpdateCL		();
+#ifdef DEBUG
 	VERIFY2( valid_pos( Position() ), dbg_valide_pos_string(Position(),this," CAI_Crow::UpdateCL		()") );
-	if (m_pPhysicsShell)	{
+#endif
+	if (m_pPhysicsShell)
+	{
 		m_pPhysicsShell->Update		();
@@ -345,3 +411,5 @@
 	else					UpdateWorkload			(fDT);
+#ifdef DEBUG
 	VERIFY2( valid_pos( Position() ), dbg_valide_pos_string(Position(),this," CAI_Crow::shedule_Update		(u32 DT)") );
+#endif
 }
@@ -400,3 +469,5 @@
 	XFORM().setHPB		(yaw,pitch,bank);
+#ifdef DEBUG
 	VERIFY2				( valid_pos( Position() ), dbg_valide_pos_string(Position(),this," CAI_Crow::net_Import	(NET_Packet& P)") );
+#endif
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/monsters/basemonster/base_monster.cpp xray-monolith/src/xrGame/ai/monsters/basemonster/base_monster.cpp
--- coc-1.4-xray-64/src/xrGame/ai/monsters/basemonster/base_monster.cpp	2023-10-20 20:54:50.783326400 +0100
+++ xray-monolith/src/xrGame/ai/monsters/basemonster/base_monster.cpp	2023-10-20 20:54:32.731035500 +0100
@@ -45,2 +45,6 @@
 
+#include "script_hit.h"
+#include "../../xrServerEntities/script_engine.h"
+#include "script_game_object.h"
+
 // Lain: added 
@@ -463,2 +469,14 @@
 	}
+
+	CScriptHit tLuaHit(pHDS);
+
+	luabind::functor<bool>	funct;
+	if (ai().script_engine().functor("_G.CBaseMonster__BeforeHitCallback", funct))
+	{
+		if (!funct(this->lua_game_object(), &tLuaHit, pHDS->boneID))
+			return;
+	}
+
+	pHDS->ApplyScriptHit(&tLuaHit);
+
 	inherited::Hit(pHDS);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/monsters/basemonster/base_monster_script.cpp xray-monolith/src/xrGame/ai/monsters/basemonster/base_monster_script.cpp
--- coc-1.4-xray-64/src/xrGame/ai/monsters/basemonster/base_monster_script.cpp	2023-10-20 20:54:50.786326600 +0100
+++ xray-monolith/src/xrGame/ai/monsters/basemonster/base_monster_script.cpp	2023-10-20 20:54:32.734035500 +0100
@@ -191,3 +204,7 @@
 						=	smart_cast<CSE_ALifeMonsterAbstract*>( ai().alife().objects().object(ID()) );
+
 			VERIFY								(i_am);
+			if (!i_am || i_am->m_group_id == (ALife::_OBJECT_ID)(-1))
+				break;
+
 			CSE_ALifeOnlineOfflineGroup& group	
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/monsters/bloodsucker/bloodsucker.cpp xray-monolith/src/xrGame/ai/monsters/bloodsucker/bloodsucker.cpp
--- coc-1.4-xray-64/src/xrGame/ai/monsters/bloodsucker/bloodsucker.cpp	2023-10-20 20:54:50.788326500 +0100
+++ xray-monolith/src/xrGame/ai/monsters/bloodsucker/bloodsucker.cpp	2023-10-20 20:54:32.735036100 +0100
@@ -456,2 +507,17 @@
 
+//--DSR-- HeatVision_start
+float CAI_Bloodsucker::GetTransparency() 
+{
+	if (m_visibility_state == no_visibility) 
+	{
+		return 1.0f;
+	}
+	else
+	{
+		return 0.0f;
+	}
+
+}
+//--DSR-- HeatVision_end
+
 void   CAI_Bloodsucker::set_visibility_state (visibility_t new_state)
@@ -491,2 +557,8 @@
 	}
+	//--DSR-- HeatVision_start
+	/*else if (m_visibility_state == no_visibility)
+	{
+		start_invisible_predator();
+	}*/
+	//--DSR-- HeatVision_end
 	else
@@ -802,8 +879,16 @@
 
+
+extern int ps_r2_heatvision;
 void   CAI_Bloodsucker::renderable_Render ()
 {
-	if ( m_visibility_state != no_visibility )
-	{
+	//--DSR-- HeatVision_start
+	
+	//if (m_visibility_state != no_visibility)
+	//{
+	//	inherited::renderable_Render();  
+	//}
+
+	if (m_visibility_state != no_visibility || ps_r2_heatvision > 0)
 		inherited::renderable_Render();
-	}
+	//--DSR-- HeatVision_end
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/monsters/bloodsucker/bloodsucker.h xray-monolith/src/xrGame/ai/monsters/bloodsucker/bloodsucker.h
--- coc-1.4-xray-64/src/xrGame/ai/monsters/bloodsucker/bloodsucker.h	2023-10-20 20:54:50.788326500 +0100
+++ xray-monolith/src/xrGame/ai/monsters/bloodsucker/bloodsucker.h	2023-10-20 20:54:32.736035600 +0100
@@ -212,2 +217,5 @@
 public:
+
+	virtual float GetTransparency(); //--DSR-- HeatVision
+
 	float			get_full_visibility_radius ();
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/monsters/burer/burer.cpp xray-monolith/src/xrGame/ai/monsters/burer/burer.cpp
--- coc-1.4-xray-64/src/xrGame/ai/monsters/burer/burer.cpp	2023-10-20 20:54:50.798326600 +0100
+++ xray-monolith/src/xrGame/ai/monsters/burer/burer.cpp	2023-10-20 20:54:32.746036100 +0100
@@ -26,2 +26,3 @@
 #include "../control_direction_base.h"
+#include "../../script_game_object.h"
 
@@ -245,3 +258,3 @@
 
-	bool const do_weapon_drop		=	Actor()->conditions().GetPower() < stamina_hit*m_weapon_drop_stamina_k;
+	bool do_weapon_drop = Actor()->conditions().GetPower() < stamina_hit * m_weapon_drop_stamina_k;
 
@@ -251,2 +264,9 @@
 	{
+		luabind::functor<bool> funct;
+		if (ai().script_engine().functor("_G.CBurer_BeforeWeaponDropCallback", funct))
+			do_weapon_drop = funct(this->lua_game_object(), active_weapon->lua_game_object());
+	}
+
+	if (do_weapon_drop)
+	{
 		Fvector dir					=	Actor()->Direction();
@@ -364,2 +390,5 @@
 		
+		CInventoryItem* itm = smart_cast<CInventoryItem*>(obj);
+		if (itm && itm->IsQuestItem()) continue;
+
 		Fvector dir;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/monsters/burer/burer_state_attack_gravi_inline.h xray-monolith/src/xrGame/ai/monsters/burer/burer_state_attack_gravi_inline.h
--- coc-1.4-xray-64/src/xrGame/ai/monsters/burer/burer_state_attack_gravi_inline.h	2023-10-20 20:54:50.801326500 +0100
+++ xray-monolith/src/xrGame/ai/monsters/burer/burer_state_attack_gravi_inline.h	2023-10-20 20:54:32.749036100 +0100
@@ -140,2 +140,6 @@
 	object->sound().play				(CBurer::eMonsterSoundGraviAttack);
+
+	// Interactive Grass FX
+	extern Fvector4 ps_ssfx_grass_interactive;
+	g_pGamePersistent->GrassBendersAddExplosion(object->ID(), from_pos, object->Direction(), 1.33f, 3.0f, ps_ssfx_grass_interactive.w, 13.0f);
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/monsters/burer/burer_state_attack_tele_inline.h xray-monolith/src/xrGame/ai/monsters/burer/burer_state_attack_tele_inline.h
--- coc-1.4-xray-64/src/xrGame/ai/monsters/burer/burer_state_attack_tele_inline.h	2023-10-20 20:54:50.804329000 +0100
+++ xray-monolith/src/xrGame/ai/monsters/burer/burer_state_attack_tele_inline.h	2023-10-20 20:54:32.751035900 +0100
@@ -203,2 +204,3 @@
 		CGrenade			*grenade		=	smart_cast<CGrenade *>(tpObjects[i]);
+		CInventoryItem* itm = smart_cast<CInventoryItem*>(tpObjects[i]);
 		
@@ -214,3 +216,5 @@
 			object->CTelekinesis::is_active_object(obj) || 
-			!obj->m_pPhysicsShell->get_ApplyByGravity()) continue;
+			!obj->m_pPhysicsShell->get_ApplyByGravity() ||
+			(itm && itm->IsQuestItem()))
+			continue;
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/monsters/cat/cat.cpp xray-monolith/src/xrGame/ai/monsters/cat/cat.cpp
--- coc-1.4-xray-64/src/xrGame/ai/monsters/cat/cat.cpp	2023-10-20 20:54:50.807327300 +0100
+++ xray-monolith/src/xrGame/ai/monsters/cat/cat.cpp	2023-10-20 20:54:32.753035800 +0100
@@ -12,2 +12,4 @@
 	StateMan = xr_new<CStateManagerCat>		(this);
+	com_man().add_ability(ControlCom::eControlJump);
+	//com_man().add_ability(ControlCom::eControlRotationJump);
 }
@@ -92,16 +94,5 @@
 
-	MotionID			def1, def2, def3;
-	IKinematicsAnimated	*pSkel = smart_cast<IKinematicsAnimated*>(Visual());
-
-	def1 = pSkel->ID_Cycle_Safe("jump_attack_0");	VERIFY(def1);
-	def2 = pSkel->ID_Cycle_Safe("jump_attack_1");	VERIFY(def2);
-	def3 = pSkel->ID_Cycle_Safe("jump_attack_2");	VERIFY(def3);
-
-	//CJumpingAbility::reinit(def1, def2, def3);
-}
-
-void CCat::try_to_jump()
-{
-	CObject *target = const_cast<CEntityAlive *>(EnemyMan.get_enemy());
-	if (!target || !EnemyMan.see_enemy_now()) return;
+	com_man().load_jump_data(0, "run_jamp_0", "run_jamp_1", "run_jamp_2", MonsterMovement::eVelocityParameterRunNormal,
+	                         MonsterMovement::eVelocityParameterRunNormal, 0);
+	//com_man().add_rotation_jump_data(0,0,"run_turn_180_r_0", "run_turn_180_r_1", deg(179));
 }
@@ -153,3 +144,3 @@
 {
-	SAAParam &params	= anim().AA_GetParams("jump_attack_2");
+	SAAParam& params = anim().AA_GetParams("run_jamp_1");
 	HitEntity			(pEntity, params.hit_power, params.impulse, params.impulse_dir);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/monsters/cat/cat.h xray-monolith/src/xrGame/ai/monsters/cat/cat.h
--- coc-1.4-xray-64/src/xrGame/ai/monsters/cat/cat.h	2023-10-20 20:54:50.808326700 +0100
+++ xray-monolith/src/xrGame/ai/monsters/cat/cat.h	2023-10-20 20:54:32.753035800 +0100
@@ -17,4 +18,2 @@
 
-			void	try_to_jump			();
-
 	virtual	void	HitEntityInJump		(const CEntity *pEntity);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/monsters/chimera/chimera_attack_state_inline.h xray-monolith/src/xrGame/ai/monsters/chimera/chimera_attack_state_inline.h
--- coc-1.4-xray-64/src/xrGame/ai/monsters/chimera/chimera_attack_state_inline.h	2023-10-20 20:54:50.812326500 +0100
+++ xray-monolith/src/xrGame/ai/monsters/chimera/chimera_attack_state_inline.h	2023-10-20 20:54:32.755035800 +0100
@@ -189,4 +189,5 @@
 
-		for (			u32	index			=	0; 
-							index			<	move_scan_points; 
+		u32 index = 0;
+
+		for (; index < move_scan_points;
 						  ++index	)
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/monsters/control_animation_base.h xray-monolith/src/xrGame/ai/monsters/control_animation_base.h
--- coc-1.4-xray-64/src/xrGame/ai/monsters/control_animation_base.h	2023-10-20 20:54:50.823326900 +0100
+++ xray-monolith/src/xrGame/ai/monsters/control_animation_base.h	2023-10-20 20:54:32.762035800 +0100
@@ -224,2 +238,3 @@
 	void					set_override_animation (EMotionAnim anim=eAnimUndefined, u32 index=-1);
+	void set_override_animation_script(EMotionAnim anim = eAnimUndefined, u32 index = -1);
 	void					set_override_animation (pcstr name);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/monsters/control_animation_base_accel.cpp xray-monolith/src/xrGame/ai/monsters/control_animation_base_accel.cpp
--- coc-1.4-xray-64/src/xrGame/ai/monsters/control_animation_base_accel.cpp	2023-10-20 20:54:50.823326900 +0100
+++ xray-monolith/src/xrGame/ai/monsters/control_animation_base_accel.cpp	2023-10-20 20:54:32.762035800 +0100
@@ -131,5 +138,8 @@
 	if (!accel_active(eAV_Braking))										return (braking_mode = false);
+	if (m_man->path_builder().detail().path()[m_man->path_builder().detail().curr_travel_point_index()].velocity == MonsterMovement::eVelocityParameterStand)
+		return (braking_mode = false);
 
 	float acceleration = accel_get(eAV_Braking);
-	float braking_dist	= (nominal_speed * ((braking_mode) ? nominal_speed : m_man->movement().velocity_current())) / (2 * acceleration);
+	float braking_dist = (nominal_speed * ((braking_mode) ? nominal_speed : m_man->movement().velocity_current())) / (2
+		* acceleration);
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/monsters/control_animation_base_update.cpp xray-monolith/src/xrGame/ai/monsters/control_animation_base_update.cpp
--- coc-1.4-xray-64/src/xrGame/ai/monsters/control_animation_base_update.cpp	2023-10-20 20:54:50.824327200 +0100
+++ xray-monolith/src/xrGame/ai/monsters/control_animation_base_update.cpp	2023-10-20 20:54:32.763035500 +0100
@@ -138,9 +144,23 @@
 {
-	if ( m_override_animation == anim )
+	if (m_override_animation == anim) return;
+	if (!m_anim_storage[anim]) return;
+
+	m_override_animation = anim;
+	m_override_animation_index = index;
+}
+
+void CControlAnimationBase::set_override_animation_script(EMotionAnim anim, u32 index)
+{
+	if (m_override_animation == anim) return;
+
+	if (!m_anim_storage[anim])
+	{
+		Msg("![CControlAnimationBase] wrong animation id.");
 		return;
+	}
 
-	if ( anim != eAnimUndefined )
+	if (m_anim_storage[anim]->count < index)
 	{
-		VERIFY2						(m_override_animation == eAnimUndefined, 
-									"animation already overriden, call clear_override_animation");
+		Msg("![CControlAnimationBase] wrong animation index.");
+		return;
 	}
@@ -175,3 +195,3 @@
 	
-	NODEFAULT;
+	Msg("![CControlAnimationBase] override animation %s not found.", name);
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/monsters/control_jump.cpp xray-monolith/src/xrGame/ai/monsters/control_jump.cpp
--- coc-1.4-xray-64/src/xrGame/ai/monsters/control_jump.cpp	2023-10-20 20:54:50.828327200 +0100
+++ xray-monolith/src/xrGame/ai/monsters/control_jump.cpp	2023-10-20 20:54:32.766035700 +0100
@@ -474,5 +502,8 @@
 
-			ctrl_data->set_speed	(m_man->animation().current_blend()->timeTotal/ m_man->animation().current_blend()->speed / m_jump_time);
-
-		} else 
+			CBlend* current_blend = m_man->animation().current_blend();
+			ctrl_data->set_speed(
+				(current_blend ? current_blend->timeTotal / current_blend->speed : 1.0f) /
+				m_jump_time);
+		}
+		else
 			ctrl_data->set_speed	(-1.f);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/monsters/control_run_attack.cpp xray-monolith/src/xrGame/ai/monsters/control_run_attack.cpp
--- coc-1.4-xray-64/src/xrGame/ai/monsters/control_run_attack.cpp	2023-10-20 20:54:50.843327300 +0100
+++ xray-monolith/src/xrGame/ai/monsters/control_run_attack.cpp	2023-10-20 20:54:32.773034800 +0100
@@ -94,3 +97,3 @@
 			// animation time
-			float					anim_time = blend->timeTotal / blend->speed;
+			float anim_time = blend ? blend->timeTotal / blend->speed : 0.0f;
 			
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/monsters/controller/controller.cpp xray-monolith/src/xrGame/ai/monsters/controller/controller.cpp
--- coc-1.4-xray-64/src/xrGame/ai/monsters/controller/controller.cpp	2023-10-20 20:54:50.849326900 +0100
+++ xray-monolith/src/xrGame/ai/monsters/controller/controller.cpp	2023-10-20 20:54:32.776035900 +0100
@@ -41,3 +41,3 @@
 #include "../monster_cover_manager.h"
-#include "controller_psy_aura.h"
+//#include "controller_psy_aura.h"
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/monsters/monster_enemy_memory.cpp xray-monolith/src/xrGame/ai/monsters/monster_enemy_memory.cpp
--- coc-1.4-xray-64/src/xrGame/ai/monsters/monster_enemy_memory.cpp	2023-10-20 20:54:50.883326400 +0100
+++ xray-monolith/src/xrGame/ai/monsters/monster_enemy_memory.cpp	2023-10-20 20:54:32.807036500 +0100
@@ -63,3 +63,4 @@
 
-	if ( monster->SoundMemory.IsRememberSound() )
+	if (monster->SoundMemory.IsRememberSound() && g_actor
+		&& g_actor->memory().visual().visible_now(monster))
 	{
@@ -72,4 +73,4 @@
 			{
-				float const xz_dist	=	monster->Position().distance_to_xz(g_actor->Position());
-				float const y_dist	=	_abs(monster->Position().y - g_actor->Position().y);
+				float const xz_dist = monster->Position().distance_to_xz(enemy->Position());
+				float const y_dist = _abs(monster->Position().y - enemy->Position().y);
 
@@ -77,4 +78,3 @@
 					 y_dist < 10 &&
-					 xz_dist < monster->get_feel_enemy_who_made_sound_max_distance() &&
-					 g_actor->memory().visual().visible_now(monster)	)
+					xz_dist < monster->get_feel_enemy_who_made_sound_max_distance())
 				{
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/monsters/poltergeist/poltergeist.cpp xray-monolith/src/xrGame/ai/monsters/poltergeist/poltergeist.cpp
--- coc-1.4-xray-64/src/xrGame/ai/monsters/poltergeist/poltergeist.cpp	2023-10-20 20:54:50.889326700 +0100
+++ xray-monolith/src/xrGame/ai/monsters/poltergeist/poltergeist.cpp	2023-10-20 20:54:32.813034800 +0100
@@ -363,2 +382,3 @@
 	inherited::net_Destroy();
+	CTelekinesis::deactivate();
 	Energy::disable();
@@ -370,17 +390,22 @@
 {
-// 	if (m_tele) {
-// 		if (state_invisible) {
-// 			setVisible(true);
-// 
-// 			if (PPhysicsShell()) {
-// 				Fmatrix M;
-// 				M.set							(XFORM());
-// 				M.translate_over				(m_current_position);
-// 				PPhysicsShell()->SetTransform	(M);
-// 			} else 
-// 				Position() = m_current_position;
-// 		}
-// 	}
+	if (m_tele)
+	{
+		if (state_invisible)
+		{
+			setVisible(true);
+
+			if (PPhysicsShell())
+			{
+				Fmatrix M;
+				M.set(XFORM());
+				M.translate_over(m_current_position);
+				PPhysicsShell()->SetTransform(M, mh_unspecified);
+			}
+			else
+				Position() = m_current_position;
+		}
+	}
 
 	inherited::Die				(who);
+	CTelekinesis::deactivate();
 	Energy::disable				();
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/monsters/poltergeist/poltergeist_ability.cpp xray-monolith/src/xrGame/ai/monsters/poltergeist/poltergeist_ability.cpp
--- coc-1.4-xray-64/src/xrGame/ai/monsters/poltergeist/poltergeist_ability.cpp	2023-10-20 20:54:50.889326700 +0100
+++ xray-monolith/src/xrGame/ai/monsters/poltergeist/poltergeist_ability.cpp	2023-10-20 20:54:32.813034800 +0100
@@ -6,2 +6,3 @@
 #include "../../../level_debug.h"
+#include "inventory_item.h"
 
@@ -117,3 +122,5 @@
 	CPhysicsShellHolder  *obj = smart_cast<CPhysicsShellHolder *>(m_nearest[index]);
+	CInventoryItem* itm = smart_cast<CInventoryItem*>(obj);
 	if (!obj || !obj->m_pPhysicsShell) return;
+	if (itm && itm->IsQuestItem()) return;
 
@@ -146,4 +156,9 @@
 				// Èãðàòü çâóê
-				if (!mtl_pair->CollideSounds.empty()) {
-					CLONE_MTL_SOUND(m_strange_sound, mtl_pair, CollideSounds);
+				if (!mtl_pair->CollideSounds.empty())
+				{
+#ifdef DEBUG
+					CLONE_MTL_SOUND_CHECK(m_strange_sound, mtl_pair, CollideSounds);
+#endif
+					CLONE_MTL_SOUND_DO(m_strange_sound, mtl_pair, CollideSounds);
+
 					Fvector pos;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/monsters/poltergeist/poltergeist_movement.cpp xray-monolith/src/xrGame/ai/monsters/poltergeist/poltergeist_movement.cpp
--- coc-1.4-xray-64/src/xrGame/ai/monsters/poltergeist/poltergeist_movement.cpp	2023-10-20 20:54:50.890326400 +0100
+++ xray-monolith/src/xrGame/ai/monsters/poltergeist/poltergeist_movement.cpp	2023-10-20 20:54:32.814035700 +0100
@@ -5,5 +5,7 @@
 
-void CPoltergeisMovementManager::move_along_path(CPHMovementControl *movement_control, Fvector &dest_position, float time_delta)
+void CPoltergeisMovementManager::move_along_path(CPHMovementControl* movement_control, Fvector& dest_position,
+                                                 float time_delta)
+{
+	if (!m_monster->is_hidden())
 {
-	if (!m_monster->is_hidden()) {
 		inherited::move_along_path(movement_control, dest_position, time_delta);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/monsters/poltergeist/poltergeist_telekinesis.cpp xray-monolith/src/xrGame/ai/monsters/poltergeist/poltergeist_telekinesis.cpp
--- coc-1.4-xray-64/src/xrGame/ai/monsters/poltergeist/poltergeist_telekinesis.cpp	2023-10-20 20:54:50.892326800 +0100
+++ xray-monolith/src/xrGame/ai/monsters/poltergeist/poltergeist_telekinesis.cpp	2023-10-20 20:54:32.817035800 +0100
@@ -6,2 +6,4 @@
 #include "../../../../xrPhysics/icolisiondamageinfo.h"
+#include "inventory_item.h"
+
 CPolterTele::CPolterTele(CPoltergeist *polter) : inherited (polter),m_pmt_object_collision_damage(0.5f)
@@ -49,2 +52,5 @@
 
+	if (!m_object->g_Alive() || m_object->get_actor_ignore())
+		return;
+
 	Fvector const actor_pos				=	Actor()->Position();
@@ -58,8 +64,7 @@
 
-	if ( m_object->get_actor_ignore() )
-		return;
-
-	switch (m_state) {
+	switch (m_state)
+	{
 	case eStartRaiseObjects:	
-		if (m_time + m_time_next < time()) {
+		if (m_time + m_time_next < time())
+		{
 			if (!tele_raise_objects())
@@ -181,5 +196,7 @@
 
-	for (u32 i=0;i<m_nearest.size();i++) {
+	for (u32 i = 0; i < m_nearest.size(); i++)
+	{
 		CPhysicsShellHolder *obj			= smart_cast<CPhysicsShellHolder *>(m_nearest[i]);
 		CCustomMonster		*custom_monster	= smart_cast<CCustomMonster *>(m_nearest[i]);
+		CInventoryItem* itm = smart_cast<CInventoryItem*>(m_nearest[i]);
 		if (!obj || 
@@ -193,3 +210,5 @@
 			m_object->CTelekinesis::is_active_object(obj) || 
-			!obj->m_pPhysicsShell->get_ApplyByGravity()) continue;
+			!obj->m_pPhysicsShell->get_ApplyByGravity() ||
+			(itm && itm->IsQuestItem()))
+			continue;
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/monsters/pseudodog/psy_dog.cpp xray-monolith/src/xrGame/ai/monsters/pseudodog/psy_dog.cpp
--- coc-1.4-xray-64/src/xrGame/ai/monsters/pseudodog/psy_dog.cpp	2023-10-20 20:54:50.895326800 +0100
+++ xray-monolith/src/xrGame/ai/monsters/pseudodog/psy_dog.cpp	2023-10-20 20:54:32.819035500 +0100
@@ -161,2 +167,3 @@
 {
+	m_aura->on_death();
 	delete_all_phantoms	();
@@ -315,5 +331,7 @@
 	CObject	*obj = Level().Objects.net_Find(m_parent_id);
-	if (obj) {
+	if (obj)
+	{
 		CPsyDog *dog = smart_cast<CPsyDog *>(obj);
 		VERIFY(dog);
+		if (!dog) return;
 		
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/monsters/pseudogigant/pseudo_gigant.cpp xray-monolith/src/xrGame/ai/monsters/pseudogigant/pseudo_gigant.cpp
--- coc-1.4-xray-64/src/xrGame/ai/monsters/pseudogigant/pseudo_gigant.cpp	2023-10-20 20:54:50.898326700 +0100
+++ xray-monolith/src/xrGame/ai/monsters/pseudogigant/pseudo_gigant.cpp	2023-10-20 20:54:32.823036800 +0100
@@ -17,2 +17,10 @@
 #include "../control_path_builder_base.h"
+#include "inventory_item.h"
+
+#include "script_hit.h"
+#include "pch_script.h"
+#include "../../script_game_object.h"
+
+// demonized: Flag for damaging NPCs and other objects by the stomp attack
+BOOL pseudogiantCanDamageObjects = 1;
 
@@ -238,5 +267,21 @@
 {
-	if (type == ControlCom::eControlThreaten) {
+	if (type == ControlCom::eControlThreaten)
+	{
 		m_sound_start_threaten.play_at_pos(this,get_head_position(this));
 		m_time_next_threaten = time() + Random.randI(m_threaten_delay_min,m_threaten_delay_max);
+
+		// callback for start animation, will be triggered by everyone in radius
+		m_nearest.clear_not_free();
+		Level().ObjectSpace.GetNearest(m_nearest, Position(), 15.f, NULL);
+		for (u32 i = 0; i < m_nearest.size(); i++)
+		{
+			CPhysicsShellHolder* obj = smart_cast<CPhysicsShellHolder*>(m_nearest[i]);
+			if (obj && obj->ID() != 0 && obj->ID() != ID()) {
+				luabind::functor<void> funct;
+				if (ai().script_engine().functor("_G.CPseudoGigant__OnStartStompAnimation", funct))
+				{
+					funct(obj->lua_game_object(), this->lua_game_object());
+				}
+			}
+		}
 	}
@@ -249,5 +294,57 @@
 	Level().ObjectSpace.GetNearest	(m_nearest,Position(), 15.f, NULL); 
-	for (u32 i=0;i<m_nearest.size();i++) {
+	for (u32 i = 0; i < m_nearest.size(); i++)
+	{
 		CPhysicsShellHolder  *obj = smart_cast<CPhysicsShellHolder *>(m_nearest[i]);
-		if (!obj || !obj->m_pPhysicsShell) continue;
+		CInventoryItem* itm = smart_cast<CInventoryItem*>(m_nearest[i]);
+
+		if (pseudogiantCanDamageObjects && obj && obj->ID() != 0 && obj->ID() != ID()) {
+			float dist_to_enemy = obj->Position().distance_to(Position());
+			float hit_value;
+			hit_value = m_kick_damage - m_kick_damage * dist_to_enemy / m_threaten_dist_max;
+			clamp(hit_value, 0.f, 1.f);
+
+			SHit HS;
+
+			HS.GenHeader(GE_HIT, obj->ID()); 
+			HS.whoID = ID(); 
+			HS.who = this;
+			HS.weaponID = ID(); 
+			HS.dir = Fvector().set(0.f, 1.f, 0.f); 
+			HS.power = hit_value; 
+			HS.boneID = smart_cast<IKinematics*>(obj->Visual())->LL_GetBoneRoot();
+			HS.p_in_bone_space = Fvector().set(0.f, 0.f, 0.f);
+
+			HS.impulse = obj->cast_entity_alive() && obj->cast_entity_alive()->g_Alive() ? 80 * 80 : 0; // 0 impulse for not alive objects, they will receive the impulse later
+			//HS.impulse = 80 * obj->character_physics_support()->movement()->GetMass();
+
+			HS.hit_type = ALife::eHitTypeStrike;
+
+			bool doHit = true;
+			luabind::functor<bool> funct;
+			CScriptHit tLuaHit(&HS);
+			if (ai().script_engine().functor("_G.CPseudoGigant__BeforeHitCallback", funct))
+			{
+				doHit = funct(obj->lua_game_object(), this->lua_game_object(), &tLuaHit, HS.boneID);
+				if (doHit) {
+					HS.ApplyScriptHit(&tLuaHit);
+				}
+			}
+
+			if (doHit) {
+				//Msg("hit entity %d, name %s, damage %f", obj->ID(), obj->Name(), hit_value);
+				obj->Hit(&HS);
+
+				luabind::functor<void> hitFunct;
+				if (ai().script_engine().functor("_G.CPseudoGigant__HitCallback", hitFunct))
+				{
+					hitFunct(obj->lua_game_object(), this->lua_game_object(), &tLuaHit, HS.boneID);
+				}
+
+				//NET_Packet l_P;
+				//HS.Write_Packet(l_P);
+				//u_EventSend(l_P);
+			}						
+		}
+
+		if (!obj || !obj->m_pPhysicsShell || (itm && itm->IsQuestItem())) continue;
 
@@ -268,2 +365,6 @@
 
+	// Interactive Grass FX
+	extern Fvector4 ps_ssfx_grass_interactive;
+	g_pGamePersistent->GrassBendersAddExplosion(ID(), pos, Fvector().set(0, -99, 0), 1.33f, 5.0f, ps_ssfx_grass_interactive.w, 20);
+
 	// èãðàòü ïàðòèêëû
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/monsters/state.h xray-monolith/src/xrGame/ai/monsters/state.h
--- coc-1.4-xray-64/src/xrGame/ai/monsters/state.h	2023-10-20 20:54:50.909327000 +0100
+++ xray-monolith/src/xrGame/ai/monsters/state.h	2023-10-20 20:54:32.834035600 +0100
@@ -74,8 +82,17 @@
 template<typename _Object>
-class CStateMove : public CState<_Object> {
+class CStateMove : public CState<_Object>
+{
+protected:
 	typedef CState<_Object> inherited;
 public:
-						CStateMove	(_Object *obj, void *data = 0) : inherited(obj,data){}
-	virtual 			~CStateMove	(){}
-	virtual void initialize() {
+	CStateMove(_Object* obj, void* data = 0) : inherited(obj, data)
+	{
+	}
+
+	virtual ~CStateMove()
+	{
+	}
+
+	virtual void initialize()
+	{
 		inherited::initialize();
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/monsters/states/state_move_to_restrictor_inline.h xray-monolith/src/xrGame/ai/monsters/states/state_move_to_restrictor_inline.h
--- coc-1.4-xray-64/src/xrGame/ai/monsters/states/state_move_to_restrictor_inline.h	2023-10-20 20:54:50.940326600 +0100
+++ xray-monolith/src/xrGame/ai/monsters/states/state_move_to_restrictor_inline.h	2023-10-20 20:54:32.865035800 +0100
@@ -16,2 +16,3 @@
 	u32		node = object->control().path_builder().restrictions().accessible_nearest(object->Position(), position);
+	if (node != (u32)-1 && object->control().path_builder().restrictions().accessible(node))
 	object->path().set_target_point	(ai().level_graph().vertex_position(node), node);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/stalker/ai_stalker.cpp xray-monolith/src/xrGame/ai/stalker/ai_stalker.cpp
--- coc-1.4-xray-64/src/xrGame/ai/stalker/ai_stalker.cpp	2023-10-20 20:54:50.949326700 +0100
+++ xray-monolith/src/xrGame/ai/stalker/ai_stalker.cpp	2023-10-20 20:54:32.875037200 +0100
@@ -943,2 +1087,5 @@
 {
+	// Optimization update
+//	if (Device.dwFrame % 2) return;
+
 	START_PROFILE("stalker")
@@ -1396,17 +1552,25 @@
 	CInifile* ini = pKinematics->LL_UserData();
-	if (ini)
-	{
-		if (imm_sect || ini->section_exist("immunities"))
-		{
-			imm_sect = imm_sect ? imm_sect : ini->r_string("immunities", "immunities_sect");
-			conditions().LoadImmunities(imm_sect, pSettings);
+	conditions().LoadImmunities(
+		(ini && ini->section_exist("immunities") && ini->line_exist("immunities", "immunities_sect"))
+			? ini->r_string("immunities", "immunities_sect")
+			: (imm_sect ? imm_sect : "stalker_immunities"), pSettings);
+
+	m_boneHitProtection->reload(
+		(ini && ini->section_exist("bone_protection") && ini->line_exist("bone_protection", "bones_protection_sect"))
+			? ini->r_string("bone_protection", "bones_protection_sect")
+			: (bone_sect ? bone_sect : "stalker_damage"), pKinematics);
 		}
 
-		if (bone_sect || ini->line_exist("bone_protection", "bones_protection_sect"))
+void CAI_Stalker::ChangeVisual(shared_str NewVisual)
 		{
-			//m_boneHitProtection = xr_new<SBoneProtections>();
-			bone_sect = ini->r_string("bone_protection", "bones_protection_sect");
-			m_boneHitProtection->reload(bone_sect, pKinematics);
-		}
-	}
+	if (!NewVisual.size()) return;
+	if (cNameVisual().size())
+	{
+		if (cNameVisual() == NewVisual) return;
 }
\ No newline at end of file
+
+	cNameVisual_set(NewVisual);
+
+	Visual()->dcast_PKinematics()->CalculateBones_Invalidate();
+	Visual()->dcast_PKinematics()->CalculateBones(TRUE);
+};
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/stalker/ai_stalker.h xray-monolith/src/xrGame/ai/stalker/ai_stalker.h
--- coc-1.4-xray-64/src/xrGame/ai/stalker/ai_stalker.h	2023-10-20 20:54:50.950326700 +0100
+++ xray-monolith/src/xrGame/ai/stalker/ai_stalker.h	2023-10-20 20:54:32.875037200 +0100
@@ -155,2 +159,6 @@
 
+	// demonized: add enabling pathfinding and damage by anomalies flags
+	bool m_enable_anomalies_pathfinding = false;
+	bool m_enable_anomalies_damage = false;
+
 public:
@@ -215,2 +223,5 @@
 	virtual float						Radius								() const;
+
+	virtual void ChangeVisual(shared_str NewVisual);
+
 #ifdef DEBUG
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/stalker/ai_stalker_debug.cpp xray-monolith/src/xrGame/ai/stalker/ai_stalker_debug.cpp
--- coc-1.4-xray-64/src/xrGame/ai/stalker/ai_stalker_debug.cpp	2023-10-20 20:54:50.951326700 +0100
+++ xray-monolith/src/xrGame/ai/stalker/ai_stalker_debug.cpp	2023-10-20 20:54:32.876036000 +0100
@@ -136,3 +136,3 @@
 	{
-		pHudItem->OnStateSwitch(pHudItem->GetState());
+		pHudItem->OnStateSwitch(pHudItem->GetState(), pHudItem->GetState());
 	}
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/stalker/ai_stalker_events.cpp xray-monolith/src/xrGame/ai/stalker/ai_stalker_events.cpp
--- coc-1.4-xray-64/src/xrGame/ai/stalker/ai_stalker_events.cpp	2023-10-20 20:54:50.951326700 +0100
+++ xray-monolith/src/xrGame/ai/stalker/ai_stalker_events.cpp	2023-10-20 20:54:32.876036000 +0100
@@ -17,2 +17,3 @@
 #include "../../characterphysicssupport.h"
+#include "CustomZone.h"
 
@@ -138,2 +142,3 @@
 
+extern BOOL g_ai_die_in_anomaly;
 void CAI_Stalker::feel_touch_new				(CObject* O)
@@ -145,2 +150,10 @@
 
+	// demonized: add g_ai_die_in_anomaly == 0 check
+	if (!(g_ai_die_in_anomaly || m_enable_anomalies_pathfinding)) {
+		CCustomZone* sr = smart_cast<CCustomZone*>(O);
+		if (sr) {
+			return;
+		}
+	}
+
 	// Now, test for game specific logical objects to minimize traffic
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/stalker/ai_stalker_feel.cpp xray-monolith/src/xrGame/ai/stalker/ai_stalker_feel.cpp
--- coc-1.4-xray-64/src/xrGame/ai/stalker/ai_stalker_feel.cpp	2023-10-20 20:54:50.951326700 +0100
+++ xray-monolith/src/xrGame/ai/stalker/ai_stalker_feel.cpp	2023-10-20 20:54:32.877038000 +0100
@@ -16,2 +16,3 @@
 #include "../../stalker_animation_manager.h"
+#include "CustomZone.h"
 
@@ -58,2 +59,3 @@
 
+extern BOOL g_ai_die_in_anomaly;
 bool CAI_Stalker::feel_touch_contact	(CObject *O)
@@ -73,2 +75,11 @@
 
+	// demonized: add g_ai_die_in_anomaly == 0 and m_enable_anomalies_pathfinding check
+	// when 0 - disable pathfinding around anomaly
+	if (!(g_ai_die_in_anomaly || m_enable_anomalies_pathfinding)) {
+		CCustomZone* sr = smart_cast<CCustomZone*>(O);
+		if (sr && (sr->spatial.type & STYPE_VISIBLEFORAI)) {
+			return false;
+		}
+	}
+
 	return							(game_object->feel_touch_on_contact(this));
@@ -83,2 +94,11 @@
 
+	// demonized: add g_ai_die_in_anomaly == 0 and m_enable_anomalies_damage check
+	// when 0 - prevent any damage from anomalies
+	if (!(g_ai_die_in_anomaly || m_enable_anomalies_damage)) {
+		CCustomZone* sr = smart_cast<CCustomZone*>(O);
+		if (sr) {
+			return false;
+		}
+	}
+
 	return		(inherited::feel_touch_on_contact(O));
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/stalker/ai_stalker_fire.cpp xray-monolith/src/xrGame/ai/stalker/ai_stalker_fire.cpp
--- coc-1.4-xray-64/src/xrGame/ai/stalker/ai_stalker_fire.cpp	2023-10-20 20:54:50.952326800 +0100
+++ xray-monolith/src/xrGame/ai/stalker/ai_stalker_fire.cpp	2023-10-20 20:54:32.877038000 +0100
@@ -54,2 +54,4 @@
 #include "../../trajectories.h"
+#include "script_hit.h"
+#include "../../xrServerEntities/script_engine.h"
 
@@ -68,2 +70,5 @@
 
+float g_dispersion_base = 1.0f;
+float g_dispersion_factor = 1.0f;
+
 float CAI_Stalker::GetWeaponAccuracy	() const
@@ -75,26 +80,56 @@
 
-	if (!movement().path_completed()) {
+	if (!movement().path_completed())
+	{
 		if (movement().movement_type() == eMovementTypeWalk)
+		{
 			if (movement().body_state() == eBodyStateStand)
-				return		(base*m_disp_walk_stand);
-			else
-				return		(base*m_disp_walk_crouch);
+			{
+				return base * (m_disp_walk_stand * g_dispersion_factor + g_dispersion_base);
+			}
 		else
-			if (movement().movement_type() == eMovementTypeRun)
+			{
+				return base * (m_disp_walk_crouch * g_dispersion_factor + g_dispersion_base);
+			}
+		}
+		else if (movement().movement_type() == eMovementTypeRun)
+		{
 				if (movement().body_state() == eBodyStateStand)
-					return	(base*m_disp_run_stand);
+			{
+				return base * (m_disp_run_stand * g_dispersion_factor + g_dispersion_base);
+			}
 				else
-					return	(base*m_disp_run_crouch);
+			{
+				return base * (m_disp_run_crouch * g_dispersion_factor + g_dispersion_base);
+			}
+		}
 	}
 	
+	CWeapon* W = smart_cast<CWeapon*>(inventory().ActiveItem());
+	bool hasScope = W && W->IsScopeAttached();
+	
 	if (movement().body_state() == eBodyStateStand)
-		if (zoom_state())
-			return			(base*m_disp_stand_stand);
+	{
+		if (zoom_state() && hasScope)
+		{
+			return base * (m_disp_stand_stand_zoom * g_dispersion_factor + g_dispersion_base);
+		}
 		else
-			return			(base*m_disp_stand_stand_zoom);
+		{
+			return base * (m_disp_stand_stand * g_dispersion_factor + g_dispersion_base);
+		}
+	}
+	else if (movement().body_state() == eBodyStateCrouch)
+	{
+		if (zoom_state() && hasScope)
+		{
+			return base * (m_disp_stand_crouch_zoom * g_dispersion_factor + g_dispersion_base);
+		}
 	else
-		if (zoom_state())
-			return			(base*m_disp_stand_crouch);
+		{
+			return base * (m_disp_stand_crouch * g_dispersion_factor + g_dispersion_base);
+		}
+	}
 		else
-			return			(base*m_disp_stand_crouch_zoom);
+		return base * (m_disp_run_stand * g_dispersion_factor + g_dispersion_base); // fallback to worst aim if state could not determined, this should never happen (tm)
+
 }
@@ -228,2 +273,6 @@
 
+	if (strstr(Core.Params, "-dbgbullet"))
+		Msg("CAI_Stalker::Hit hit_type=%d | hit_power(%f)*m_fRankImmunity(%f) = %f", (u32)HDS.hit_type, HDS.power,
+		    m_fRankImmunity, hit_power);
+
 	if(m_boneHitProtection && HDS.hit_type == ALife::eHitTypeFireWound)
@@ -236,5 +285,4 @@
 			{
-				float d_hit_power = (ap - BoneArmor) / ap;
-				if(d_hit_power < m_boneHitProtection->m_fHitFracNpc)
-					d_hit_power = m_boneHitProtection->m_fHitFracNpc;
+				float d_hit_power = (ap - BoneArmor) / (ap * m_boneHitProtection->APScale);
+				clamp(d_hit_power, m_boneHitProtection->m_fHitFracNpc, 1.0f);
 
@@ -242,2 +290,6 @@
 				VERIFY(hit_power>=0.0f);
+
+				if (strstr(Core.Params, "-dbgbullet"))
+					Msg("CAI_Stalker::Hit AP(%f) > BoneArmor(%f) [HitFracNpc=%f] modified hit_power=%f", ap, BoneArmor,
+					    m_boneHitProtection->m_fHitFracNpc, hit_power);
 			}
@@ -246,3 +298,7 @@
 				hit_power *= m_boneHitProtection->m_fHitFracNpc;
-				HDS.add_wound = false;
+				//HDS.add_wound = false;
+
+				if (strstr(Core.Params, "-dbgbullet"))
+					Msg("CAI_Stalker::Hit AP(%f) > BoneArmor(%f) [HitFracNpc=%f] modified hit_power=%f", ap, BoneArmor,
+					    m_boneHitProtection->m_fHitFracNpc, hit_power);
 			}
@@ -329,2 +392,13 @@
 	{
+		CScriptHit tLuaHit(&HDS);
+
+		luabind::functor<bool>	funct;
+		if (ai().script_engine().functor("_G.CAI_Stalker__BeforeHitCallback", funct))
+		{
+			if (!funct(this->lua_game_object(), &tLuaHit, HDS.boneID))
+				return;
+		}
+
+		HDS.ApplyScriptHit(&tLuaHit);
+
 		float const damage_factor	= invulnerable() ? 0.f : 100.f;
@@ -380,5 +454,4 @@
 {
-
 	luabind::functor<CScriptGameObject*> funct;
-	if (ai().script_engine().functor("ai_stalker.update_best_weapon", funct))
+	if (ai().script_engine().functor("_g.update_best_weapon", funct))
 	{
@@ -1079,3 +1185,3 @@
 	
-	m_throw_velocity.mul(::Random.randF(.99f,1.01f));
+	m_throw_velocity.mul(::Random.randF(.75f, 1.25f));
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai/trader/trader_animation.cpp xray-monolith/src/xrGame/ai/trader/trader_animation.cpp
--- coc-1.4-xray-64/src/xrGame/ai/trader/trader_animation.cpp	2023-10-20 20:54:50.955326800 +0100
+++ xray-monolith/src/xrGame/ai/trader/trader_animation.cpp	2023-10-20 20:54:32.880035700 +0100
@@ -1,2 +1,2 @@
-#include "pch_script.h"
+ï»¿#include "pch_script.h"
 #include "trader_animation.h"
@@ -53,3 +54,3 @@
 
-	// íàçíà÷èòü àíèìàöèþ ãîëîâû
+	// Ð½Ð°Ð·Ð½Ð°ÑÐ¸ÑÑ Ð°Ð½Ð¸Ð¼Ð°ÑÐ¸Ñ Ð³Ð¾Ð»Ð¾Ð²Ñ
 	IKinematicsAnimated	*kinematics_animated	= smart_cast<IKinematicsAnimated*>(m_trader->Visual());
@@ -70,3 +71,3 @@
 	m_sound->create		(sound,st_Effect,SOUND_TYPE_WORLD);
-	m_sound->play		(NULL, sm_2D);
+	m_sound->play(m_trader);
 }
@@ -89,3 +90,8 @@
 {
-	if (m_sound && !m_sound->_feedback()) {
+	if (m_sound)
+	{
+		if (m_sound->_feedback())
+			m_sound->set_position(m_trader->Position());
+		else
+		{
 		m_trader->callback	(GameObject::eTraderSoundEnd)();
@@ -93,5 +99,6 @@
 	}
+	}
 
-	
-	if (!m_motion_global) {
+	if (!m_motion_global)
+	{
 		m_trader->callback(GameObject::eTraderGlobalAnimationRequest)();
@@ -100,5 +107,7 @@
 
-	// íàçíà÷èòü àíèìàöèþ ãîëîâû
-	if (!m_motion_head) {
-		if (m_sound && m_sound->_feedback()) {
+	// Ã­Ã Ã§Ã­Ã Ã·Ã¨Ã²Ã¼ Ã Ã­Ã¨Ã¬Ã Ã¶Ã¨Ã¾ Ã£Ã®Ã«Ã®Ã¢Ã»
+	if (!m_motion_head)
+	{
+		if (m_sound && m_sound->_feedback())
+		{
 			m_trader->callback(GameObject::eTraderHeadAnimationRequest)();
@@ -117,3 +126,3 @@
 	m_sound->create			(phrase,st_Effect,SOUND_TYPE_WORLD);
-	m_sound->play			(NULL, sm_2D);
+	m_sound->play(m_trader);
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai_object_location.h xray-monolith/src/xrGame/ai_object_location.h
--- coc-1.4-xray-64/src/xrGame/ai_object_location.h	2023-10-20 20:54:50.958326700 +0100
+++ xray-monolith/src/xrGame/ai_object_location.h	2023-10-20 20:54:32.883035300 +0100
@@ -31,3 +33,3 @@
 	IC	void				game_vertex			(CVertex const *game_vertex);
-	IC	void				game_vertex			(_GRAPH_ID const &game_vertex_id);
+	void game_vertex(_GRAPH_ID const& game_vertex_id);
 	IC	const CVertex		*game_vertex		() const;
@@ -35,4 +37,4 @@
 	IC	void				level_vertex		(CLevelVertex const *level_vertex);
-	IC	void				level_vertex		(u32 const &level_vertex_id);
-	IC	const CLevelVertex	*level_vertex		() const;
+	void level_vertex(u32 const& level_vertex_id);
+	const CLevelVertex* level_vertex() const;
 	IC	const u32			level_vertex_id		() const;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai_object_location_impl.h xray-monolith/src/xrGame/ai_object_location_impl.h
--- coc-1.4-xray-64/src/xrGame/ai_object_location_impl.h	2023-10-20 20:54:50.958326700 +0100
+++ xray-monolith/src/xrGame/ai_object_location_impl.h	2023-10-20 20:54:32.883035300 +0100
@@ -34,3 +34,3 @@
 
-IC	void CAI_ObjectLocation::game_vertex						(_GRAPH_ID const &game_vertex_id)
+void CAI_ObjectLocation::game_vertex(_GRAPH_ID const& game_vertex_id)
 {
@@ -52,3 +52,3 @@
 
-IC	void CAI_ObjectLocation::level_vertex						(u32 const &level_vertex_id)
+void CAI_ObjectLocation::level_vertex(u32 const& level_vertex_id)
 {
@@ -58,3 +58,3 @@
 
-IC	const CLevelGraph::CVertex *CAI_ObjectLocation::level_vertex() const
+const CLevelGraph::CVertex* CAI_ObjectLocation::level_vertex() const
 {
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/AI_PhraseDialogManager.cpp xray-monolith/src/xrGame/AI_PhraseDialogManager.cpp
--- coc-1.4-xray-64/src/xrGame/AI_PhraseDialogManager.cpp	2023-10-20 20:54:50.559329200 +0100
+++ xray-monolith/src/xrGame/AI_PhraseDialogManager.cpp	2023-10-20 20:54:32.543037500 +0100
@@ -61,3 +63,3 @@
 
-		for(i=0; i<phrase_dialog->PhraseList().size(); i++)
+		for (u32 i = 0; i < phrase_dialog->PhraseList().size(); i++)
 		{
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ai_space.cpp xray-monolith/src/xrGame/ai_space.cpp
--- coc-1.4-xray-64/src/xrGame/ai_space.cpp	2023-10-20 20:54:50.960326800 +0100
+++ xray-monolith/src/xrGame/ai_space.cpp	2023-10-20 20:54:32.885036500 +0100
@@ -25,3 +25,3 @@
 
-ENGINE_API	bool g_dedicated_server;
+extern ENGINE_API bool g_dedicated_server;
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/alife_dynamic_object.cpp xray-monolith/src/xrGame/alife_dynamic_object.cpp
--- coc-1.4-xray-64/src/xrGame/alife_dynamic_object.cpp	2023-10-20 20:54:50.968326700 +0100
+++ xray-monolith/src/xrGame/alife_dynamic_object.cpp	2023-10-20 20:54:32.893035900 +0100
@@ -89,3 +91,7 @@
 {
-	if (!ai().level_graph().valid_vertex_position(o_Position) || ai().level_graph().inside(ai().level_graph().vertex(m_tNodeID),o_Position))
+	if (!ai().level_graph().valid_vertex_id(m_tNodeID)) return false;
+
+	if (!ai().level_graph().valid_vertex_position(o_Position) || ai().level_graph().inside(
+		ai().level_graph().vertex(m_tNodeID),
+		o_Position))
 		return					(true);
@@ -221,5 +239,12 @@
 
-	for (u32 i=0, n=saved_children.size(); i<n; ++i) {
-		CSE_ALifeDynamicObject	*child = smart_cast<CSE_ALifeDynamicObject*>(ai().alife().objects().object(saved_children[i],true));
-		R_ASSERT				(child);
+	for (u32 i = 0, n = saved_children.size(); i < n; ++i)
+	{
+		CSE_ALifeDynamicObject* child = smart_cast<CSE_ALifeDynamicObject*>(
+			ai().alife().objects().object(saved_children[i], true));
+		// R_ASSERT(child);
+		if (!child)
+		{
+			Msg("[DO] can't switch child [%d] offline, it's null", saved_children[i]);
+			continue;
+		}
 		child->m_bOnline		= false;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/alife_group_abstract.cpp xray-monolith/src/xrGame/alife_group_abstract.cpp
--- coc-1.4-xray-64/src/xrGame/alife_group_abstract.cpp	2023-10-20 20:54:50.969326900 +0100
+++ xray-monolith/src/xrGame/alife_group_abstract.cpp	2023-10-20 20:54:32.894035900 +0100
@@ -134,5 +140,8 @@
 	// iterating on group members
-	for (u32 i=0, N = (u32)m_tpMembers.size(); i<N; ++i) {
+	u32 i = 0, N = (u32)m_tpMembers.size();
+	for (; i < N; ++i)
+	{
 		// casting group member to the abstract monster to get access to the Health property
-		CSE_ALifeMonsterAbstract		*tpGroupMember = smart_cast<CSE_ALifeMonsterAbstract*>(ai().alife().objects().object(m_tpMembers[i]));
+		CSE_ALifeMonsterAbstract* tpGroupMember = smart_cast<CSE_ALifeMonsterAbstract*>(
+			ai().alife().objects().object(m_tpMembers[i]));
 		if (!tpGroupMember)
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/alife_monster_detail_path_manager.cpp xray-monolith/src/xrGame/alife_monster_detail_path_manager.cpp
--- coc-1.4-xray-64/src/xrGame/alife_monster_detail_path_manager.cpp	2023-10-20 20:54:50.975326800 +0100
+++ xray-monolith/src/xrGame/alife_monster_detail_path_manager.cpp	2023-10-20 20:54:32.900035800 +0100
@@ -55,2 +63,6 @@
 {
+	if (&task == NULL)
+	{
+		return;
+	}
 	target							(task.game_vertex_id(),task.level_vertex_id(),task.position());
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/alife_monster_movement_manager_script.cpp xray-monolith/src/xrGame/alife_monster_movement_manager_script.cpp
--- coc-1.4-xray-64/src/xrGame/alife_monster_movement_manager_script.cpp	2023-10-20 20:54:50.977327500 +0100
+++ xray-monolith/src/xrGame/alife_monster_movement_manager_script.cpp	2023-10-20 20:54:32.902035700 +0100
@@ -12,2 +12,3 @@
 #include "alife_monster_patrol_path_manager.h"
+#include "movement_manager_space.h"
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/alife_monster_patrol_path_manager_script.cpp xray-monolith/src/xrGame/alife_monster_patrol_path_manager_script.cpp
--- coc-1.4-xray-64/src/xrGame/alife_monster_patrol_path_manager_script.cpp	2023-10-20 20:54:50.978326500 +0100
+++ xray-monolith/src/xrGame/alife_monster_patrol_path_manager_script.cpp	2023-10-20 20:54:32.903036700 +0100
@@ -10,2 +10,3 @@
 #include "alife_monster_patrol_path_manager.h"
+#include "patrol_path_manager_space.h"
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/alife_object_registry.cpp xray-monolith/src/xrGame/alife_object_registry.cpp
--- coc-1.4-xray-64/src/xrGame/alife_object_registry.cpp	2023-10-20 20:54:50.979326600 +0100
+++ xray-monolith/src/xrGame/alife_object_registry.cpp	2023-10-20 20:54:32.904039100 +0100
@@ -112,3 +114,9 @@
 	CSE_Abstract			*tpSE_Abstract = F_entity_Create	(s_name);
-	R_ASSERT2				(tpSE_Abstract,"Can't create entity.");
+	if (!tpSE_Abstract)
+	{
+		Msg("! Can't create entity '%s'", s_name);
+		tNetPacket.B.count = file_stream.r_u16();
+		file_stream.advance(tNetPacket.B.count);
+		return nullptr;
+	}
 	CSE_ALifeDynamicObject	*tpALifeDynamicObject = smart_cast<CSE_ALifeDynamicObject*>(tpSE_Abstract);
@@ -135,12 +143,12 @@
 	u32							count = file_stream.r_u32();
-	CSE_ALifeDynamicObject		**objects = (CSE_ALifeDynamicObject**)_alloca(count*sizeof(CSE_ALifeDynamicObject*));
+	for (u32 I = 0; I < count; ++I)
+	{
+		CSE_ALifeDynamicObject* tpSE_Abstract = get_object(file_stream);
+		if (!tpSE_Abstract)
+			continue;
 
-	CSE_ALifeDynamicObject		**I = objects;
-	CSE_ALifeDynamicObject		**E = objects + count;
-	for ( ; I != E; ++I) {
-		*I						= get_object(file_stream);
-		add						(*I);
+		add(tpSE_Abstract);
 	}
 
-	Msg							("* %d objects are successfully loaded",count);
+	Msg("* %d objects are successfully loaded", m_objects.size());
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/alife_simulator_script.cpp xray-monolith/src/xrGame/alife_simulator_script.cpp
--- coc-1.4-xray-64/src/xrGame/alife_simulator_script.cpp	2023-10-20 20:54:50.988326900 +0100
+++ xray-monolith/src/xrGame/alife_simulator_script.cpp	2023-10-20 20:54:32.913035700 +0100
@@ -306,2 +313,8 @@
 {
+	const GameGraph::LEVEL_MAP& levels = ai().game_graph().header().levels();
+	GameGraph::LEVEL_MAP::const_iterator I = levels.find((GameGraph::_LEVEL_ID)level_id);
+	if (I == levels.end())
+	{
+		return NULL;
+	}
 	LPCSTR								result = *ai().game_graph().header().level((GameGraph::_LEVEL_ID)level_id).name();
@@ -341,4 +354,27 @@
 
+void AlifeGiveInfo(const CALifeSimulator *alife, const ALife::_OBJECT_ID &id, LPCSTR info_id)
+{
+	KNOWN_INFO_VECTOR *known_info = alife->registry(info_portions).object(id, true);
+	if (!known_info)
+		return;
+
+	if (std::find_if(known_info->begin(), known_info->end(), CFindByIDPred(info_id)) == known_info->end())
+	{
+		known_info->push_back(info_id);
+	}
+
+	return;
+}
+
+void AlifeRemoveInfo(const CALifeSimulator *alife, const ALife::_OBJECT_ID &id, LPCSTR info_id)
+{
+	KNOWN_INFO_VECTOR	*known_info = alife->registry(info_portions).object(id, true);
+	if (!known_info)
+		return;
+	known_info->erase(std::find_if(known_info->begin(), known_info->end(), CFindByIDPred(info_id)),known_info->end());
+}
+
 //Alundaio: teleport object
-void teleport_object(CALifeSimulator *alife, ALife::_OBJECT_ID id, GameGraph::_GRAPH_ID game_vertex_id, u32 level_vertex_id, const Fvector &position)
+void teleport_object(CALifeSimulator* alife, ALife::_OBJECT_ID id, GameGraph::_GRAPH_ID game_vertex_id,
+                     u32 level_vertex_id, const Fvector& position)
 {
@@ -378,3 +414,14 @@
 
-CSE_Abstract* try_to_clone_object(CALifeSimulator *self, CSE_Abstract *object, LPCSTR section, const Fvector &position, u32 level_vertex_id, GameGraph::_GRAPH_ID game_vertex_id, ALife::_OBJECT_ID id_parent, bool bRegister = true)
+// demonized: iterate alife objects
+void CALifeSimulator__iterate_objects(const CALifeSimulator* self, luabind::functor<bool> functor)
+{
+	const CALifeObjectRegistry &objects = self->objects();
+	for (const auto& se_obj : objects.objects()) {
+		if (functor(se_obj.second)) break;
+	}
+}
+
+CSE_Abstract* try_to_clone_object(CALifeSimulator* self, CSE_Abstract* object, LPCSTR section, const Fvector& position,
+                                  u32 level_vertex_id, GameGraph::_GRAPH_ID game_vertex_id, ALife::_OBJECT_ID id_parent,
+                                  bool bRegister = true)
 {
@@ -413,2 +461,14 @@
 }
+
+const CALifeObjectRegistry::OBJECT_REGISTRY& alife_objects(const CALifeSimulator *self)
+{
+	VERIFY(self);
+	return self->objects().objects();
+}
+
+xr_vector<u16>& get_children(const CALifeSimulator *self, CSE_Abstract *object)
+{
+	VERIFY(self);
+	return object->children;
+}
 //-Alundaio
@@ -427,2 +487,3 @@
 			.def("object",					(CSE_ALifeDynamicObject *(*) (const CALifeSimulator *,ALife::_OBJECT_ID, bool))(alife_object))
+// FIX LATER:		.def("objects", &alife_objects, return_stl_pair_iterator)
 			.def("story_object",			(CSE_ALifeDynamicObject *(*) (const CALifeSimulator *,ALife::_STORY_ID))(alife_story_object))
@@ -449,4 +510,7 @@
 			.def("dont_has_info",			&dont_has_info)
+		.def("give_info", &AlifeGiveInfo)
+		.def("disable_info", &AlifeRemoveInfo)
 			.def("switch_distance",			&CALifeSimulator::switch_distance)
-			.def("set_switch_distance",			&CALifeSimulator::set_switch_distance) //Alundaio: renamed to set_switch_distance from switch_distance
+		.def("set_switch_distance", &CALifeSimulator::set_switch_distance)
+		//Alundaio: renamed to set_switch_distance from switch_distance
 			//Alundaio: extend alife simulator exports
@@ -458,4 +522,8 @@
 			.def("set_process_time", &set_process_time)
+		.def("get_children", &get_children, return_stl_iterator)
 			//Alundaio: END
 	
+		// demonized: iterate alife objects
+		.def("iterate_objects", &CALifeSimulator__iterate_objects)
+
 		,def("alife",						&alife)
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/alife_smart_terrain_task.cpp xray-monolith/src/xrGame/alife_smart_terrain_task.cpp
--- coc-1.4-xray-64/src/xrGame/alife_smart_terrain_task.cpp	2023-10-20 20:54:50.989328000 +0100
+++ xray-monolith/src/xrGame/alife_smart_terrain_task.cpp	2023-10-20 20:54:32.914035600 +0100
@@ -32,7 +32,12 @@
 {
-	if (m_game_vertex_id == GameGraph::_GRAPH_ID(-1))	{
-		VERIFY3					(ai().game_graph().valid_vertex_id(patrol_point().game_vertex_id()),*m_patrol_path_name,*m_patrol_point->name());
+	if (m_game_vertex_id == GameGraph::_GRAPH_ID(-1))
+	{
+#ifdef DEBUG
+		VERIFY3(ai().game_graph().valid_vertex_id(patrol_point().game_vertex_id()), *m_patrol_path_name,
+		        *m_patrol_point->name());
+#endif
 		return					(patrol_point().game_vertex_id());
 	}
-	else {
+	else
+	{
 		VERIFY(ai().game_graph().valid_vertex_id(m_game_vertex_id));
@@ -44,9 +49,14 @@
 {
-	if (m_level_vertex_id == u32(-1))	{
-		VERIFY3					(ai().game_graph().valid_vertex_id(patrol_point().game_vertex_id()),*m_patrol_path_name,*m_patrol_point->name());
+	if (m_level_vertex_id == u32(-1))
+	{
+#ifdef DEBUG
+		VERIFY3(ai().game_graph().valid_vertex_id(patrol_point().game_vertex_id()), *m_patrol_path_name,
+		        *m_patrol_point->name());
+#endif
 		return					(patrol_point().level_vertex_id());
 	}
-	else {
-
-		VERIFY2(ai().game_graph().valid_vertex_id(m_game_vertex_id), make_string("Vertex [%d] is not valid!!!", m_game_vertex_id));
+	else
+	{
+		VERIFY2(ai().game_graph().valid_vertex_id(m_game_vertex_id),
+		        make_string("Vertex [%d] is not valid!!!", m_game_vertex_id));
 		return m_level_vertex_id;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/alife_storage_manager.cpp xray-monolith/src/xrGame/alife_storage_manager.cpp
--- coc-1.4-xray-64/src/xrGame/alife_storage_manager.cpp	2023-10-20 20:54:50.993331600 +0100
+++ xray-monolith/src/xrGame/alife_storage_manager.cpp	2023-10-20 20:54:32.917035600 +0100
@@ -31,3 +31,3 @@
 
-XRCORE_API string_path g_bug_report_file;
+extern XRCORE_API string_path g_bug_report_file;
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/alife_switch_manager.cpp xray-monolith/src/xrGame/alife_switch_manager.cpp
--- coc-1.4-xray-64/src/xrGame/alife_switch_manager.cpp	2023-10-20 20:54:50.995326700 +0100
+++ xray-monolith/src/xrGame/alife_switch_manager.cpp	2023-10-20 20:54:32.920037900 +0100
@@ -183,3 +186,3 @@
 	}
-
+#ifdef DEBUG
 	VERIFY2						(
@@ -192,5 +195,6 @@
 		Level().Objects.dump_all_objects(),
-		make_string("frame [%d] time [%d] object [%s] with id [%d] is offline, but is on the level",Device.dwFrame,Device.dwTimeGlobal,I->name_replace(),I->ID)
+			make_string("frame [%d] time [%d] object [%s] with id [%d] is offline, but is on the level",Device.dwFrame,
+				Device.dwTimeGlobal,I->name_replace(),I->ID)
 	);
-
+#endif
 	I->try_switch_online		();
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/alife_trader_abstract.cpp xray-monolith/src/xrGame/alife_trader_abstract.cpp
--- coc-1.4-xray-64/src/xrGame/alife_trader_abstract.cpp	2023-10-20 20:54:50.998328900 +0100
+++ xray-monolith/src/xrGame/alife_trader_abstract.cpp	2023-10-20 20:54:32.923035700 +0100
@@ -222,7 +229,15 @@
 
-void add_offline_impl						(CSE_ALifeDynamicObject *object, const xr_vector<ALife::_OBJECT_ID> &saved_children, const bool &update_registries)
+void add_offline_impl(CSE_ALifeDynamicObject* object, const xr_vector<ALife::_OBJECT_ID>& saved_children,
+                      const bool& update_registries)
+{
+	for (u32 i = 0, n = saved_children.size(); i < n; ++i)
 {
-	for (u32 i=0, n=saved_children.size(); i<n; ++i) {
-		CSE_ALifeDynamicObject	*child = smart_cast<CSE_ALifeDynamicObject*>(ai().alife().objects().object(saved_children[i],true));
-		R_ASSERT				(child);
+		CSE_ALifeDynamicObject* child = smart_cast<CSE_ALifeDynamicObject*>(
+			ai().alife().objects().object(saved_children[i], true));
+		// R_ASSERT(child);
+		if (!child)
+		{
+			Msg("[TR] can't switch child [%d] offline, it's null", saved_children[i]);
+			continue;
+		}
 		child->m_bOnline		= false;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/animation_script_callback.cpp xray-monolith/src/xrGame/animation_script_callback.cpp
--- coc-1.4-xray-64/src/xrGame/animation_script_callback.cpp	2023-10-20 20:54:51.000326400 +0100
+++ xray-monolith/src/xrGame/animation_script_callback.cpp	2023-10-20 20:54:32.925035700 +0100
@@ -28,5 +29,5 @@
 {
-
 	MotionID	m	=	sa->LL_MotionID		( *anim )			;
-	R_ASSERT( m.valid( ) );
+	if(!m.valid( ))
+		return NULL;
 	if(sa->LL_GetMotionDef	( m )->StopAtEnd())
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/antirad.h xray-monolith/src/xrGame/antirad.h
--- coc-1.4-xray-64/src/xrGame/antirad.h	2023-10-20 20:54:51.002326800 +0100
+++ xray-monolith/src/xrGame/antirad.h	2023-10-20 20:54:32.927036100 +0100
@@ -9,2 +9,3 @@
 #include "eatable_item_object.h"
+#include "script_export_space.h"
 
@@ -15,2 +16,8 @@
 	virtual		 ~CAntirad			();
+
+	DECLARE_SCRIPT_REGISTER_FUNCTION
 };
+
+add_to_type_list(CAntirad)
+#undef script_type_list
+#define script_type_list save_type_list(CAntirad)
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Artefact.cpp xray-monolith/src/xrGame/Artefact.cpp
--- coc-1.4-xray-64/src/xrGame/Artefact.cpp	2023-10-20 20:54:50.571326700 +0100
+++ xray-monolith/src/xrGame/Artefact.cpp	2023-10-20 20:54:32.555038100 +0100
@@ -22,2 +22,3 @@
 #include "patrol_path_storage.h"
+#include "player_hud.h"
 
@@ -253,3 +257,4 @@
 	m_pTrailLight				= ::Render->light_create();
-	bool const b_light_shadow	= !!pSettings->r_bool(cNameSect(), "idle_light_shadow");
+	bool const b_light_shadow = !!READ_IF_EXISTS(pSettings, r_bool, cNameSect(), "idle_light_shadow", false);
+	bool const b_light_volumetric = !!READ_IF_EXISTS(pSettings, r_bool, cNameSect(), "idle_light_volumetric", false);
 
@@ -257,2 +262,15 @@
 
+	if (b_light_volumetric)
+	{
+		float const f_light_volumetric_quality = READ_IF_EXISTS(pSettings, r_float, cNameSect(), "idle_light_volumetric_quality", .5f);
+		float const f_light_volumetric_power = READ_IF_EXISTS(pSettings, r_float, cNameSect(), "idle_light_volumetric_power", .5f);
+		float const f_light_volumetric_range = READ_IF_EXISTS(pSettings, r_float, cNameSect(), "idle_light_volumetric_range", .5f);
+
+		m_pTrailLight->set_shadow(true);
+		m_pTrailLight->set_volumetric(true);
+		m_pTrailLight->set_volumetric_quality(f_light_volumetric_quality);
+		m_pTrailLight->set_volumetric_intensity(f_light_volumetric_power);
+		m_pTrailLight->set_volumetric_distance(f_light_volumetric_range);
+	}
+
 	m_pTrailLight->set_color	(m_TrailLightColor); 
@@ -401,18 +426,27 @@
 
-void CArtefact::OnStateSwitch(u32 S)
+void CArtefact::OnStateSwitch(u32 S, u32 oldState)
+{
+	inherited::OnStateSwitch(S, oldState);
+
+	switch (S)
 {
-	inherited::OnStateSwitch	(S);
-	switch(S){
 	case eShowing:
 		{
-			PlayHUDMotion("anm_show", FALSE, this, S);
-		}break;
+			if (ParentIsActor()) g_player_hud->attach_item(this);
+			PlayHUDMotion("anm_show", FALSE, this, S, 1.f, 0.f, false);
+		}
+		break;
 	case eHiding:
 		{
-			PlayHUDMotion("anm_hide", FALSE, this, S);
-		}break;
+			if (oldState != eHiding)
+			{
+				PlayHUDMotion("anm_hide", TRUE, this, S);
+			}
+		}
+		break;
 	case eActivating:
 		{
-			PlayHUDMotion("anm_activate", FALSE, this, S);
-		}break;
+			PlayHUDMotion("anm_activate", TRUE, this, S);
+		}
+		break;
 	case eIdle:
@@ -426,3 +461,3 @@
 {
-	PlayHUDMotion("anm_idle", FALSE, NULL, eIdle);
+	PlayHUDMotion("anm_idle", TRUE, NULL, eIdle);
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Artefact.h xray-monolith/src/xrGame/Artefact.h
--- coc-1.4-xray-64/src/xrGame/Artefact.h	2023-10-20 20:54:50.571326700 +0100
+++ xray-monolith/src/xrGame/Artefact.h	2023-10-20 20:54:32.555038100 +0100
@@ -46,2 +46,3 @@
 				float	GetBleedingPower						()					{return m_fBleedingRestoreSpeed;} 
+	float GetImmunity(ALife::EHitType hit_type) { return m_ArtefactHitImmunities.GetHitImmunity(hit_type); }
           
@@ -52,5 +53,8 @@
 				void	SetBleedingPower						(float value)					{m_fBleedingRestoreSpeed = value;}                                  
+	void SetImmunity(ALife::EHitType hit_type, float val) { m_ArtefactHitImmunities.SetHitImmunity(hit_type, val); }
 
 protected:
-	virtual void					UpdateCLChild					()		{};
+	virtual void UpdateCLChild()
+	{
+	};
 	virtual void					CreateArtefactActivation			();
@@ -68,3 +72,2 @@
 	bool							m_bLightsEnabled;
-	float							m_additional_weight;
 
@@ -84,3 +87,8 @@
 	virtual void					PhDataUpdate					(float step);
-	virtual void					PhTune							(float step)	{};
+
+	virtual void PhTune(float step)
+	{
+	};
+
+	float m_additional_weight;
 
@@ -110,3 +120,3 @@
 	virtual bool					Action				(u16 cmd, u32 flags);
-	virtual void					OnStateSwitch		(u32 S);
+	virtual void OnStateSwitch(u32 S, u32 oldState);
 	virtual void					OnAnimationEnd		(u32 state);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/artefact_script.cpp xray-monolith/src/xrGame/artefact_script.cpp
--- coc-1.4-xray-64/src/xrGame/artefact_script.cpp	2023-10-20 20:54:51.003326800 +0100
+++ xray-monolith/src/xrGame/artefact_script.cpp	2023-10-20 20:54:32.928035700 +0100
@@ -26,2 +26,12 @@
 		.def(						constructor<>() )
+		.def("ActivateArtefact", &CArtefact::ActivateArtefact)
+		.def("CanBeActivated", &CArtefact::CanBeActivated)
+		.def("AdditionalInventoryWeight", &CArtefact::AdditionalInventoryWeight)
+		.def_readwrite("m_bCanSpawnZone", &CArtefact::m_bCanSpawnZone)
+		.def_readwrite("m_fHealthRestoreSpeed", &CArtefact::m_fHealthRestoreSpeed)
+		.def_readwrite("m_fRadiationRestoreSpeed", &CArtefact::m_fRadiationRestoreSpeed)
+		.def_readwrite("m_fSatietyRestoreSpeed", &CArtefact::m_fSatietyRestoreSpeed)
+		.def_readwrite("m_fPowerRestoreSpeed", &CArtefact::m_fPowerRestoreSpeed)
+		.def_readwrite("m_fBleedingRestoreSpeed", &CArtefact::m_fBleedingRestoreSpeed)
+		.def_readwrite("m_additional_weight", &CArtefact::m_additional_weight)
 		.def("FollowByPath",		&CArtefact::FollowByPath)
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/atlas_submit_queue.cpp xray-monolith/src/xrGame/atlas_submit_queue.cpp
--- coc-1.4-xray-64/src/xrGame/atlas_submit_queue.cpp	2023-10-20 20:54:51.005328900 +0100
+++ xray-monolith/src/xrGame/atlas_submit_queue.cpp	2023-10-20 20:54:32.929036100 +0100
@@ -21,14 +21,14 @@
 {
-	gamespy_gp::login_manager* tmp_lmngr		= MainMenu()->GetLoginMngr();
-	VERIFY(tmp_lmngr);
-	gamespy_gp::profile const * tmp_curr_prof	= tmp_lmngr->get_current_profile();
-	if (!tmp_curr_prof || !tmp_curr_prof->online())
-	{
-		Msg("! ATLAS submit can be only in online profile mode");
-		return;
-	}
-	submit_task	tmp_task;
-	tmp_task.m_data_type = submit_task::edt_submit_all;
-	m_reward_tasks.push_back(tmp_task);
-	update();
+	//gamespy_gp::login_manager* tmp_lmngr		= MainMenu()->GetLoginMngr();
+	//VERIFY(tmp_lmngr);
+	//gamespy_gp::profile const * tmp_curr_prof	= tmp_lmngr->get_current_profile();
+	//if (!tmp_curr_prof || !tmp_curr_prof->online())
+	//{
+	//	Msg("! ATLAS submit can be only in online profile mode");
+	//	return;
+	//}
+	//submit_task	tmp_task;
+	//tmp_task.m_data_type = submit_task::edt_submit_all;
+	//m_reward_tasks.push_back(tmp_task);
+	//update();
 }
@@ -37,26 +37,26 @@
 {
-	using namespace gamespy_profile;
-	gamespy_gp::login_manager* tmp_lmngr		= MainMenu()->GetLoginMngr();
-	VERIFY(tmp_lmngr);
-	gamespy_gp::profile const * tmp_curr_prof	= tmp_lmngr->get_current_profile();
-	if (!tmp_curr_prof->online())
-	{
-		Msg("! ATLAS submit can be only in online profile mode");
-		return;
-	}
-	m_stats_submitter->quick_reward_with_award(award_id, tmp_curr_prof);
-
-	profile_store*	tmp_store	= MainMenu()->GetProfileStore();
-	R_ASSERT(tmp_store);
-	all_awards_t const & tmp_all_awards = tmp_store->get_awards();
-	all_awards_t::const_iterator tmp_iter = tmp_all_awards.find(award_id);
-	R_ASSERT(tmp_iter != tmp_all_awards.end());
-
-	submit_task	tmp_task;
-	tmp_task.m_data_type		= submit_task::edt_award_id;
-	tmp_task.m_award_id			= award_id;
-	tmp_task.m_awards_count		= tmp_iter->second.m_count;	//+1 was on quick_reward_with_award
-	m_reward_tasks.push_back	(tmp_task);
-	
-	update();
+	//using namespace gamespy_profile;
+	//gamespy_gp::login_manager* tmp_lmngr		= MainMenu()->GetLoginMngr();
+	//VERIFY(tmp_lmngr);
+	//gamespy_gp::profile const * tmp_curr_prof	= tmp_lmngr->get_current_profile();
+	//if (!tmp_curr_prof->online())
+	//{
+	//	Msg("! ATLAS submit can be only in online profile mode");
+	//	return;
+	//}
+	//m_stats_submitter->quick_reward_with_award(award_id, tmp_curr_prof);
+
+	//profile_store*	tmp_store	= MainMenu()->GetProfileStore();
+	//R_ASSERT(tmp_store);
+	//all_awards_t const & tmp_all_awards = tmp_store->get_awards();
+	//all_awards_t::const_iterator tmp_iter = tmp_all_awards.find(award_id);
+	//R_ASSERT(tmp_iter != tmp_all_awards.end());
+
+	//submit_task	tmp_task;
+	//tmp_task.m_data_type		= submit_task::edt_award_id;
+	//tmp_task.m_award_id			= award_id;
+	//tmp_task.m_awards_count		= tmp_iter->second.m_count;	//+1 was on quick_reward_with_award
+	//m_reward_tasks.push_back	(tmp_task);
+	//
+	//update();
 }
@@ -65,16 +65,16 @@
 {
-	gamespy_gp::login_manager* tmp_lmngr		= MainMenu()->GetLoginMngr();
-	VERIFY(tmp_lmngr);
-	gamespy_gp::profile const * tmp_curr_prof	= tmp_lmngr->get_current_profile();
-	if (!tmp_curr_prof->online())
-	{
-		Msg("! ATLAS submit can be only in online profile mode");
-		return;
-	}
-
-	submit_task	tmp_task;
-	tmp_task.m_data_type				= submit_task::edt_best_scores_ptr;
-	m_reward_tasks.push_back(tmp_task);
-	m_stats_submitter->quick_set_best_scores(&m_best_results_to_submit, tmp_curr_prof);
-	update();
+	//gamespy_gp::login_manager* tmp_lmngr		= MainMenu()->GetLoginMngr();
+	//VERIFY(tmp_lmngr);
+	//gamespy_gp::profile const * tmp_curr_prof	= tmp_lmngr->get_current_profile();
+	//if (!tmp_curr_prof->online())
+	//{
+	//	Msg("! ATLAS submit can be only in online profile mode");
+	//	return;
+	//}
+
+	//submit_task	tmp_task;
+	//tmp_task.m_data_type				= submit_task::edt_best_scores_ptr;
+	//m_reward_tasks.push_back(tmp_task);
+	//m_stats_submitter->quick_set_best_scores(&m_best_results_to_submit, tmp_curr_prof);
+	//update();
 }
@@ -86,26 +86,26 @@
 	
-	gamespy_gp::login_manager* tmp_lmngr		= MainMenu()->GetLoginMngr();
-	VERIFY(tmp_lmngr);
-	gamespy_gp::profile const * tmp_curr_prof	= tmp_lmngr->get_current_profile();
-	VERIFY(tmp_curr_prof);
-	VERIFY2(tmp_curr_prof->online(), "ATLAS submit can be only in online profile mode");
-	
-	if (m_reward_tasks.front().m_data_type == submit_task::edt_award_id)
-	{
-		do_atlas_reward(
-			tmp_curr_prof,
-			m_reward_tasks.front().m_award_id,
-			m_reward_tasks.front().m_awards_count
-		);
-	} else if (m_reward_tasks.front().m_data_type == submit_task::edt_best_scores_ptr)
-	{
-		do_atlas_best_results(tmp_curr_prof, &m_best_results_to_submit);
-	} else if (m_reward_tasks.front().m_data_type == submit_task::edt_submit_all)
-	{
-		do_atlas_submit_all(tmp_curr_prof);
-	} else
-	{
-		NODEFAULT;
-	}
-	m_reward_tasks.pop_front();
+	//gamespy_gp::login_manager* tmp_lmngr		= MainMenu()->GetLoginMngr();
+	//VERIFY(tmp_lmngr);
+	//gamespy_gp::profile const * tmp_curr_prof	= tmp_lmngr->get_current_profile();
+	//VERIFY(tmp_curr_prof);
+	//VERIFY2(tmp_curr_prof->online(), "ATLAS submit can be only in online profile mode");
+	//
+	//if (m_reward_tasks.front().m_data_type == submit_task::edt_award_id)
+	//{
+	//	do_atlas_reward(
+	//		tmp_curr_prof,
+	//		m_reward_tasks.front().m_award_id,
+	//		m_reward_tasks.front().m_awards_count
+	//	);
+	//} else if (m_reward_tasks.front().m_data_type == submit_task::edt_best_scores_ptr)
+	//{
+	//	do_atlas_best_results(tmp_curr_prof, &m_best_results_to_submit);
+	//} else if (m_reward_tasks.front().m_data_type == submit_task::edt_submit_all)
+	//{
+	//	do_atlas_submit_all(tmp_curr_prof);
+	//} else
+	//{
+	//	NODEFAULT;
+	//}
+	//m_reward_tasks.pop_front();
 }
@@ -140,12 +140,12 @@
 
-	gamespy_profile::profile_store* tmp_store	= MainMenu()->GetProfileStore();
-	VERIFY(tmp_store);
-	
-	m_atlas_in_process = true;
-	m_stats_submitter->submit_all(
-		&tmp_store->get_awards(),
-		&tmp_store->get_best_scores(),
-		profile,
-		m_atlas_submitted
-	);
+	//gamespy_profile::profile_store* tmp_store	= MainMenu()->GetProfileStore();
+	//VERIFY(tmp_store);
+	//
+	//m_atlas_in_process = true;
+	//m_stats_submitter->submit_all(
+	//	&tmp_store->get_awards(),
+	//	&tmp_store->get_best_scores(),
+	//	profile,
+	//	m_atlas_submitted
+	//);
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/attachable_item.cpp xray-monolith/src/xrGame/attachable_item.cpp
--- coc-1.4-xray-64/src/xrGame/attachable_item.cpp	2023-10-20 20:54:51.005328900 +0100
+++ xray-monolith/src/xrGame/attachable_item.cpp	2023-10-20 20:54:32.930035900 +0100
@@ -20,3 +20,3 @@
 
-IC	CPhysicsShellHolder &CAttachableItem::object	() const
+CPhysicsShellHolder& CAttachableItem::object() const
 {
@@ -120,5 +124,8 @@
 }
+
 void CAttachableItem::afterAttach		()
 {
+#ifdef DEBUG
 	VERIFY							(m_valid);
+#endif
 	object().processing_activate	();
@@ -128,3 +135,5 @@
 {
+#ifdef DEBUG
 	VERIFY							(m_valid);
+#endif
 	object().processing_deactivate	();
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/attachable_item.h xray-monolith/src/xrGame/attachable_item.h
--- coc-1.4-xray-64/src/xrGame/attachable_item.h	2023-10-20 20:54:51.006326700 +0100
+++ xray-monolith/src/xrGame/attachable_item.h	2023-10-20 20:54:32.930035900 +0100
@@ -39,3 +40,3 @@
 	IC		CInventoryItem		&item					() const;
-	IC		CPhysicsShellHolder	&object					() const;
+	CPhysicsShellHolder& object() const;
 	IC		shared_str			bone_name				() const;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/attachable_item_inline.h xray-monolith/src/xrGame/attachable_item_inline.h
--- coc-1.4-xray-64/src/xrGame/attachable_item_inline.h	2023-10-20 20:54:51.006326700 +0100
+++ xray-monolith/src/xrGame/attachable_item_inline.h	2023-10-20 20:54:32.930035900 +0100
@@ -24,3 +24,5 @@
 {
+#ifdef DEBUG
 	VERIFY				(m_valid);
+#endif
 	return				(m_bone_name);
@@ -30,3 +32,5 @@
 {
+#ifdef DEBUG
 	VERIFY				(m_valid);
+#endif
 	return				(m_offset);
@@ -36,3 +40,5 @@
 {
+#ifdef DEBUG
 	VERIFY				(m_valid);
+#endif
 	return				(m_bone_id);
@@ -42,3 +48,5 @@
 {
+#ifdef DEBUG
 	VERIFY				(m_valid);
+#endif
 	m_bone_id			= bone_id;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/awards_store.cpp xray-monolith/src/xrGame/awards_store.cpp
--- coc-1.4-xray-64/src/xrGame/awards_store.cpp	2023-10-20 20:54:51.008326400 +0100
+++ xray-monolith/src/xrGame/awards_store.cpp	2023-10-20 20:54:32.933036100 +0100
@@ -2,4 +2,2 @@
 #include "awards_store.h"
-#include "GameSpy/GameSpy_Full.h"
-#include "GameSpy/GAmeSpy_SAKE.h"
 
@@ -7,14 +5,12 @@
 {
-
-
 awards_store::awards_store(CGameSpy_Full* fullgs_obj)
 {
-	VERIFY(fullgs_obj && fullgs_obj->GetGameSpySAKE());
-	m_fullgs_obj		= fullgs_obj;
-	m_sake_obj			= fullgs_obj->GetGameSpySAKE();
+		//VERIFY(fullgs_obj && fullgs_obj->GetGameSpySAKE());
+		//m_fullgs_obj		= fullgs_obj;
+		//m_sake_obj			= fullgs_obj->GetGameSpySAKE();
 	
 	init_field_names	();
-	m_get_records_input.mTableId	= profile_table_name;
-	m_get_records_input.mFieldNames = m_field_names_store;
-	m_get_records_input.mNumFields	= fields_count;
+		//m_get_records_input.mTableId	= profile_table_name;
+		//m_get_records_input.mFieldNames = m_field_names_store;
+		//m_get_records_input.mNumFields	= fields_count;
 }
@@ -59,14 +55,14 @@
 		
-	SAKERequest reqres = m_sake_obj->GetMyRecords(
-		&m_get_records_input,
-		&awards_store::get_my_awards_cb,
-		this
-	);
-	
-	if (!reqres)
-	{
-		SAKEStartRequestResult tmp_result	= m_sake_obj->GetRequestResult();
-		m_award_operation_cb				(false, CGameSpy_SAKE::TryToTranslate(tmp_result).c_str());
-		m_award_operation_cb.clear			();
-	}
+		//SAKERequest reqres = m_sake_obj->GetMyRecords(
+		//	&m_get_records_input,
+		//	&awards_store::get_my_awards_cb,
+		//	this
+		//);
+		//
+		//if (!reqres)
+		//{
+		//	SAKEStartRequestResult tmp_result	= m_sake_obj->GetRequestResult();
+		//	m_award_operation_cb				(false, CGameSpy_SAKE::TryToTranslate(tmp_result).c_str());
+		//	m_award_operation_cb.clear			();
+		//}
 }
@@ -129,12 +126,12 @@
 {
-	enum_awards_t awid			= get_award_by_stat_name(award_params[ap_award_id].mName);
-	VERIFY(awid != at_awards_count);
+		//enum_awards_t awid			= get_award_by_stat_name(award_params[ap_award_id].mName);
+		//VERIFY(awid != at_awards_count);
 
-	int rdate_statid_real		= get_award_reward_date_stat(awid);
-	int rdate_statid_from_table = ATLAS_GET_STAT(award_params[ap_award_rdate].mName);
-	VERIFY(rdate_statid_real == rdate_statid_from_table);
-
-	u16	awards_count			= award_params[ap_award_id].mValue.mShort;
-	u32 award_rdate				= award_params[ap_award_rdate].mValue.mInt;
-	m_awards_result.insert		(std::make_pair(awid, award_data(awards_count, award_rdate)));
+		//int rdate_statid_real		= get_award_reward_date_stat(awid);
+		//int rdate_statid_from_table = ATLAS_GET_STAT(award_params[ap_award_rdate].mName);
+		//VERIFY(rdate_statid_real == rdate_statid_from_table);
+
+		//u16	awards_count			= award_params[ap_award_id].mValue.mShort;
+		//u32 award_rdate				= award_params[ap_award_rdate].mValue.mInt;
+		//m_awards_result.insert		(std::make_pair(awid, award_data(awards_count, award_rdate)));
 }
@@ -143,40 +140,38 @@
 {
-	VERIFY(tmp_out->mNumRecords <= 1);					//one raw
-	if (tmp_out->mNumRecords == 0)
-		return;
-
-	for (int i = 0; i < out_fields_count; ++i)
-	{
-		if (get_award_by_stat_name(tmp_out->mRecords[0][i].mName) != at_awards_count)
-		{
-			process_award(&tmp_out->mRecords[0][i]);
-		}
-	}
-}
-
-void __cdecl awards_store::get_my_awards_cb(SAKE sake,
-											SAKERequest request,
-											SAKERequestResult result,
-											void * inputData,
-											void * outputData,
-											void * userData)
-{
-	awards_store* my_inst					= static_cast<awards_store*>(userData);
-	VERIFY(my_inst && my_inst->m_award_operation_cb);
-	if (result != SAKERequestResult_SUCCESS)
-	{
-		my_inst->m_award_operation_cb		(false, CGameSpy_SAKE::TryToTranslate(result).c_str());
-	} else
-	{
-		SAKEGetMyRecordsOutput*	tmp_out		= static_cast<SAKEGetMyRecordsOutput*>(
-			outputData
-		);
-		VERIFY(tmp_out);
-		my_inst->process_aw_out_response	(tmp_out, fields_count);
-		my_inst->m_award_operation_cb		(true, "");
-	}
-	my_inst->m_award_operation_cb.clear		();
-}
-
-
+		//VERIFY(tmp_out->mNumRecords <= 1);					//one raw
+		//if (tmp_out->mNumRecords == 0)
+		//	return;
+
+		//for (int i = 0; i < out_fields_count; ++i)
+		//{
+		//	if (get_award_by_stat_name(tmp_out->mRecords[0][i].mName) != at_awards_count)
+		//	{
+		//		process_award(&tmp_out->mRecords[0][i]);
+		//	}
+		//}
+	}
+
+	//void __cdecl awards_store::get_my_awards_cb(SAKE sake,
+	//											SAKERequest request,
+	//											SAKERequestResult result,
+	//											void * inputData,
+	//											void * outputData,
+	//											void * userData)
+	//{
+	//	awards_store* my_inst					= static_cast<awards_store*>(userData);
+	//	VERIFY(my_inst && my_inst->m_award_operation_cb);
+	//	if (result != SAKERequestResult_SUCCESS)
+	//	{
+	//		my_inst->m_award_operation_cb		(false, CGameSpy_SAKE::TryToTranslate(result).c_str());
+	//	} else
+	//	{
+	//		SAKEGetMyRecordsOutput*	tmp_out		= static_cast<SAKEGetMyRecordsOutput*>(
+	//			outputData
+	//		);
+	//		VERIFY(tmp_out);
+	//		my_inst->process_aw_out_response	(tmp_out, fields_count);
+	//		my_inst->m_award_operation_cb		(true, "");
+	//	}
+	//	my_inst->m_award_operation_cb.clear		();
+	//}
 }//namespace gamespy_profile
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/awards_store.h xray-monolith/src/xrGame/awards_store.h
--- coc-1.4-xray-64/src/xrGame/awards_store.h	2023-10-20 20:54:51.008326400 +0100
+++ xray-monolith/src/xrGame/awards_store.h	2023-10-20 20:54:32.933036100 +0100
@@ -6,3 +6,2 @@
 #include "profile_data_types.h"
-#include "../xrGameSpy/GameSpy/sake/sake.h"
 #include "gsc_dsigned_ltx.h"
@@ -12,2 +11,8 @@
 
+/**/
+struct SAKEGetMyRecordsOutput; // HACK, FAKE STRUCT TO PRETEND GAMESPY EXISTS
+struct SAKEField; // HACK, FAKE STRUCT TO PRETEND GAMESPY EXISTS
+/**/
+
+
 namespace gamespy_profile
@@ -42,3 +46,3 @@
 	award_fields_names_t	m_field_names_store;
-	SAKEGetMyRecordsInput	m_get_records_input;
+		//SAKEGetMyRecordsInput	m_get_records_input;
 	void					init_field_names();
@@ -48,8 +52,8 @@
 
-	static void __cdecl	get_my_awards_cb				(SAKE sake,
-														 SAKERequest request,
-														 SAKERequestResult result,
-														 void * inputData,
-														 void * outputData,
-														 void * userData);
+		//static void __cdecl	get_my_awards_cb				(SAKE sake,
+		//													 SAKERequest request,
+		//													 SAKERequestResult result,
+		//													 void * inputData,
+		//													 void * outputData,
+		//													 void * userData);
 }; //class award_system
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/best_scores_store.cpp xray-monolith/src/xrGame/best_scores_store.cpp
--- coc-1.4-xray-64/src/xrGame/best_scores_store.cpp	2023-10-20 20:54:51.011326400 +0100
+++ xray-monolith/src/xrGame/best_scores_store.cpp	2023-10-20 20:54:32.935036400 +0100
@@ -2,4 +2,2 @@
 #include "best_scores_store.h"
-#include "GameSpy/GameSpy_Full.h"
-#include "GameSpy/GAmeSpy_SAKE.h"
 
@@ -7,9 +5,7 @@
 {
-
-
 best_scores_store::best_scores_store(CGameSpy_Full* fullgs_obj)
 {
-	VERIFY(fullgs_obj && fullgs_obj->GetGameSpySAKE());
-	m_fullgs_obj		= fullgs_obj;
-	m_sake_obj			= fullgs_obj->GetGameSpySAKE();
+		//VERIFY(fullgs_obj && fullgs_obj->GetGameSpySAKE());
+		//m_fullgs_obj		= fullgs_obj;
+		//m_sake_obj			= fullgs_obj->GetGameSpySAKE();
 
@@ -17,5 +13,5 @@
 	
-	m_get_records_input.mTableId	= profile_table_name;
-	m_get_records_input.mFieldNames	= m_field_names_store;
-	m_get_records_input.mNumFields	= fields_count;
+		//m_get_records_input.mTableId	= profile_table_name;
+		//m_get_records_input.mFieldNames	= m_field_names_store;
+		//m_get_records_input.mNumFields	= fields_count;
 }
@@ -57,14 +53,14 @@
 
-	SAKERequest reqres = m_sake_obj->GetMyRecords(
-		&m_get_records_input,
-		&best_scores_store::get_my_player_scores_cb,
-		this
-	);
-	
-	if (!reqres)
-	{
-		SAKEStartRequestResult tmp_result	= m_sake_obj->GetRequestResult();
-		m_scores_operation_cb				(false, CGameSpy_SAKE::TryToTranslate(tmp_result).c_str());
-		m_scores_operation_cb.clear			();
-	}
+		//SAKERequest reqres = m_sake_obj->GetMyRecords(
+		//	&m_get_records_input,
+		//	&best_scores_store::get_my_player_scores_cb,
+		//	this
+		//);
+		//
+		//if (!reqres)
+		//{
+		//	SAKEStartRequestResult tmp_result	= m_sake_obj->GetRequestResult();
+		//	m_scores_operation_cb				(false, CGameSpy_SAKE::TryToTranslate(tmp_result).c_str());
+		//	m_scores_operation_cb.clear			();
+		//}
 }
@@ -126,55 +122,54 @@
 
-void __cdecl best_scores_store::get_my_player_scores_cb(SAKE sake,
-														SAKERequest request,
-														SAKERequestResult result,
-														void * inputData,
-														void * outputData,
-														void * userData)
-{
-	best_scores_store* my_inst				= static_cast<best_scores_store*>(userData);
-	VERIFY(my_inst && my_inst->m_scores_operation_cb);
-	if (result != SAKERequestResult_SUCCESS)
-	{
-		my_inst->m_scores_operation_cb		(false, CGameSpy_SAKE::TryToTranslate(result).c_str());
-	} else
-	{
-		SAKEGetMyRecordsOutput*	tmp_out		= static_cast<SAKEGetMyRecordsOutput*>(
-			outputData
-		);
-		VERIFY(tmp_out);
-		my_inst->process_scores_out_response(tmp_out, fields_count);
-		my_inst->m_scores_operation_cb		(true, "mp_load_best_scores_complete");
-	}
-	my_inst->m_scores_operation_cb.clear	();
-}
-
-void best_scores_store::process_scores_out_response(SAKEGetMyRecordsOutput* tmp_out, int const out_fields_count)
-{
-	VERIFY(tmp_out->mNumRecords <= 1);					//one raw
-	if (tmp_out->mNumRecords == 0)
-	{
-		for (int i = 0; i < bst_score_types_count; ++i)
-		{
-			m_result_scores.insert(
-				std::make_pair(
-					static_cast<gamespy_profile::enum_best_score_type>(i),
-					0
-				)
-			);
-		}
-		return;
-	}
-	
-	for (int i = 0; i < out_fields_count; ++i)
-	{
-		enum_best_score_type bst	= get_best_score_type_by_sname(
-			tmp_out->mRecords[0][i].mName
-		);
-		if (bst == bst_score_types_count)
-			continue;
-		s32 bs_value				= tmp_out->mRecords[0][i].mValue.mInt;	//one raw
-		m_result_scores.insert		(std::make_pair(bst, bs_value));
-	};
-}
-
+	//void __cdecl best_scores_store::get_my_player_scores_cb(SAKE sake,
+	//														SAKERequest request,
+	//														SAKERequestResult result,
+	//														void * inputData,
+	//														void * outputData,
+	//														void * userData)
+	//{
+	//	best_scores_store* my_inst				= static_cast<best_scores_store*>(userData);
+	//	VERIFY(my_inst && my_inst->m_scores_operation_cb);
+	//	if (result != SAKERequestResult_SUCCESS)
+	//	{
+	//		my_inst->m_scores_operation_cb		(false, CGameSpy_SAKE::TryToTranslate(result).c_str());
+	//	} else
+	//	{
+	//		SAKEGetMyRecordsOutput*	tmp_out		= static_cast<SAKEGetMyRecordsOutput*>(
+	//			outputData
+	//		);
+	//		VERIFY(tmp_out);
+	//		my_inst->process_scores_out_response(tmp_out, fields_count);
+	//		my_inst->m_scores_operation_cb		(true, "mp_load_best_scores_complete");
+	//	}
+	//	my_inst->m_scores_operation_cb.clear	();
+	//}
+
+	//void best_scores_store::process_scores_out_response(SAKEGetMyRecordsOutput* tmp_out, int const out_fields_count)
+	//{
+	//	VERIFY(tmp_out->mNumRecords <= 1);					//one raw
+	//	if (tmp_out->mNumRecords == 0)
+	//	{
+	//		for (int i = 0; i < bst_score_types_count; ++i)
+	//		{
+	//			m_result_scores.insert(
+	//				std::make_pair(
+	//					static_cast<gamespy_profile::enum_best_score_type>(i),
+	//					0
+	//				)
+	//			);
+	//		}
+	//		return;
+	//	}
+	//	
+	//	for (int i = 0; i < out_fields_count; ++i)
+	//	{
+	//		enum_best_score_type bst	= get_best_score_type_by_sname(
+	//			tmp_out->mRecords[0][i].mName
+	//		);
+	//		if (bst == bst_score_types_count)
+	//			continue;
+	//		s32 bs_value				= tmp_out->mRecords[0][i].mValue.mInt;	//one raw
+	//		m_result_scores.insert		(std::make_pair(bst, bs_value));
+	//	};
+	//}
 } //namespace gamespy_profile
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/best_scores_store.h xray-monolith/src/xrGame/best_scores_store.h
--- coc-1.4-xray-64/src/xrGame/best_scores_store.h	2023-10-20 20:54:51.011326400 +0100
+++ xray-monolith/src/xrGame/best_scores_store.h	2023-10-20 20:54:32.935036400 +0100
@@ -5,3 +5,2 @@
 #include "../xrServerEntities/associative_vector.h"
-#include "../xrGameSpy/GameSpy/sake/sake.h"
 #include "profile_data_types.h"
@@ -34,3 +32,3 @@
 	best_fields_names_t const &	get_field_names				() const { return m_field_names_store; }
-	void						process_scores_out_response	(SAKEGetMyRecordsOutput* tmp_out, int const out_fields_count);
+		//void						process_scores_out_response	(SAKEGetMyRecordsOutput* tmp_out, int const out_fields_count);
 private:
@@ -44,11 +42,11 @@
 	best_fields_names_t		m_field_names_store;
-	SAKEGetMyRecordsInput	m_get_records_input;
+		//SAKEGetMyRecordsInput	m_get_records_input;
 	void					init_field_names();
 
-	static void __cdecl get_my_player_scores_cb			(SAKE sake,
-														 SAKERequest request,
-														 SAKERequestResult result,
-														 void * inputData,
-														 void * outputData,
-														 void * userData);
+		//static void __cdecl get_my_player_scores_cb			(SAKE sake,
+		//													 SAKERequest request,
+		//													 SAKERequestResult result,
+		//													 void * inputData,
+		//													 void * outputData,
+		//													 void * userData);
 }; //best_scores_store
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Bolt.cpp xray-monolith/src/xrGame/Bolt.cpp
--- coc-1.4-xray-64/src/xrGame/Bolt.cpp	2023-10-20 20:54:50.574338000 +0100
+++ xray-monolith/src/xrGame/Bolt.cpp	2023-10-20 20:54:32.557037300 +0100
@@ -5,2 +5,5 @@
 #include "xr_level_controller.h"
+// Tronex
+#include "inventory.h"
+#include "actor.h"
 
@@ -27,2 +29,15 @@
 	if(!l_pBolt)				return;
+
+	luabind::functor<bool> funct;
+	if (m_pInventory && smart_cast<CInventoryOwner*>(H_Parent()) &&
+		ai().script_engine().functor("_G.CBolt__State", funct))
+	{
+		CActor* pActor = smart_cast<CActor*>(m_pInventory->GetOwner());
+		if (pActor)
+		{
+			if (!funct(pActor->ID()))
+				l_pBolt->SetCanTake(FALSE);
+		}
+	}
+	
 	l_pBolt->set_destroy_time	(u32(m_dwDestroyTimeMax/phTimefactor));
@@ -30,2 +45,5 @@
 	spawn_fake_missile			();
+
+	//DestroyObject();
+	m_thrown = true;
 }
@@ -34,3 +52,3 @@
 {
-	return false;
+	return CanTake();
 }
@@ -76 +95,83 @@
 }
\ No newline at end of file
+
+// Tronex: for limited bolts
+void CBolt::PutNextToSlot()
+{
+	if (OnClient()) return;
+
+	VERIFY(!getDestroy());
+	//Ð²ÑÐºÐ¸Ð½ÑÑÑ Ð³ÑÐ°Ð½Ð°ÑÑ Ð¸Ð· Ð¸Ð½Ð²ÐµÐ½ÑÐ°ÑÑ
+	NET_Packet P;
+	if (m_pInventory)
+	{
+		m_pInventory->Ruck(this);
+
+		this->u_EventGen(P, GEG_PLAYER_ITEM2RUCK, this->H_Parent()->ID());
+		P.w_u16(this->ID());
+		this->u_EventSend(P);
+	}
+	else
+		Msg("! PutNextToSlot : m_pInventory = NULL [%d][%d]", ID(), Device.dwFrame);
+
+	if (smart_cast<CInventoryOwner*>(H_Parent()) && m_pInventory)
+	{
+		CBolt* pNext = smart_cast<CBolt*>(m_pInventory->Same(this, true));
+		if (!pNext) pNext = smart_cast<CBolt*>(m_pInventory->SameSlot(BOLT_SLOT, this, true));
+
+		VERIFY(pNext != this);
+
+		if (pNext && m_pInventory->Slot(pNext->BaseSlot(), pNext))
+		{
+			pNext->u_EventGen(P, GEG_PLAYER_ITEM2SLOT, pNext->H_Parent()->ID());
+			P.w_u16(pNext->ID());
+			P.w_u16(pNext->BaseSlot());
+			pNext->u_EventSend(P);
+			m_pInventory->SetActiveSlot(pNext->BaseSlot());
+		}
+		else
+		{
+			CActor* pActor = smart_cast<CActor*>(m_pInventory->GetOwner());
+
+			if (pActor)
+				pActor->OnPrevWeaponSlot();
+		}
+
+		m_thrown = false;
+	}
+}
+
+void CBolt::State(u32 state, u32 old_state)
+{
+	switch (state)
+	{
+	case eThrowEnd:
+		{
+			if (m_thrown)
+			{
+				if (m_pPhysicsShell)
+					m_pPhysicsShell->Deactivate();
+				xr_delete(m_pPhysicsShell);
+				//m_dwDestroyTime			= 0xffffffff;
+
+				luabind::functor<bool> funct;
+				if (m_pInventory && smart_cast<CInventoryOwner*>(H_Parent()) && 
+					ai().script_engine().functor("_G.CBolt__State", funct))
+				{
+					CActor* pActor = smart_cast<CActor*>(m_pInventory->GetOwner());
+					if (pActor && funct(pActor->ID()))
+					{
+						PutNextToSlot();
+						if (Local())
+							DestroyObject();
+					}
+					else
+						m_thrown = false;
+				}
+				else
+					m_thrown = false;
+			};
+		}
+		break;
+	};
+	inherited::State(state, old_state);
+}
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Bolt.h xray-monolith/src/xrGame/Bolt.h
--- coc-1.4-xray-64/src/xrGame/Bolt.h	2023-10-20 20:54:50.574338000 +0100
+++ xray-monolith/src/xrGame/Bolt.h	2023-10-20 20:54:32.558036700 +0100
@@ -23,4 +24,10 @@
 
+	void PutNextToSlot();
+	virtual void State(u32 state, u32 old_state);
+
 	virtual BOOL UsedAI_Locations	() {return FALSE;}
 	virtual IDamageSource*	cast_IDamageSource			()	{return this;}
+
+private:
+	bool m_thrown;
 };
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/BoneProtections.cpp xray-monolith/src/xrGame/BoneProtections.cpp
--- coc-1.4-xray-64/src/xrGame/BoneProtections.cpp	2023-10-20 20:54:50.575326700 +0100
+++ xray-monolith/src/xrGame/BoneProtections.cpp	2023-10-20 20:54:32.558036700 +0100
@@ -39,2 +39,3 @@
 	m_fHitFracNpc				= READ_IF_EXISTS(pSettings, r_float, bone_sect, "hit_fraction_npc",	0.1f);
+	APScale = READ_IF_EXISTS(pSettings, r_float, bone_sect, "ap_scale", 1.0f);
 
@@ -47,9 +48,8 @@
 	{
-		string256			buffer;
-
-		BoneProtection	BP;
+		if (strstr(i->first.c_str(), "hit_fraction"))
+			continue;
+		if (!xr_strcmp(i->first.c_str(), "ap_scale"))
+			continue;
 
-		BP.koeff			= (float)atof( _GetItem( i->second.c_str(), 0, buffer) );
-		BP.armor			= (float)atof( _GetItem( i->second.c_str(), 1, buffer) );
-		BP.BonePassBullet	= (BOOL) (atof( _GetItem(i->second.c_str(), 2, buffer) )>0.5f); //Alundaio change atoi to atof
+		string256 buffer;
 		
@@ -57,3 +57,5 @@
 		{
-			m_default = BP;
+			m_default.koeff = (float)atof(_GetItem(i->second.c_str(), 0, buffer));
+			m_default.armor = (float)atof(_GetItem(i->second.c_str(), 1, buffer));
+			m_default.BonePassBullet = (BOOL)(atof(_GetItem(i->second.c_str(), 2, buffer)) > 0.5f);
 		}
@@ -61,6 +63,9 @@
 		{
-			if (!xr_strcmp(i->first.c_str(), "hit_fraction")) continue;
-
-			s16	bone_id				= kinematics->LL_BoneID(i->first);
-			R_ASSERT2				(BI_NONE != bone_id, i->first.c_str());			
+			u16 bone_id = kinematics->LL_BoneID(i->first);
+			if (bone_id != BI_NONE)
+			{
+				BoneProtection BP;
+				BP.koeff = (float)atof(_GetItem(i->second.c_str(), 0, buffer));
+				BP.armor = (float)atof(_GetItem(i->second.c_str(), 1, buffer));
+				BP.BonePassBullet = (BOOL)(atof(_GetItem(i->second.c_str(), 2, buffer)) > 0.5f);
 			m_bones_koeff.insert	(mk_pair(bone_id,BP));
@@ -69,2 +74,3 @@
 }
+}
 
@@ -77,2 +83,3 @@
 	m_fHitFracNpc += READ_IF_EXISTS(pSettings, r_float, bone_sect.c_str(), "hit_fraction_npc", 0.0f);
+	APScale += READ_IF_EXISTS(pSettings, r_float, bone_sect.c_str(), "ap_scale", 0.0f);
 
@@ -81,3 +88,5 @@
 	{
-		if(!xr_strcmp(i->first.c_str(), "hit_fraction")) 
+		if (strstr(i->first.c_str(), "hit_fraction"))
+			continue;
+		if (!xr_strcmp(i->first.c_str(), "ap_scale"))
 			continue;
@@ -87,5 +96,4 @@
 		{
-			BoneProtection&	BP	= m_default;
-			BP.koeff			+= (float)atof( _GetItem( i->second.c_str(), 0, buffer) );
-			BP.armor			+= (float)atof( _GetItem( i->second.c_str(), 1, buffer) );
+			m_default.koeff += (float)atof(_GetItem(i->second.c_str(), 0, buffer));
+			m_default.armor += (float)atof(_GetItem(i->second.c_str(), 1, buffer));
 		}
@@ -93,4 +101,5 @@
 		{
-			s16	bone_id			= kinematics->LL_BoneID(i->first);
-			R_ASSERT2			(BI_NONE != bone_id, i->first.c_str());			
+			u16 bone_id = kinematics->LL_BoneID(i->first);
+			if (bone_id != BI_NONE)
+			{
 			BoneProtection&	BP	= m_bones_koeff[bone_id];
@@ -101 +110,2 @@
 }
+}
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/BoneProtections.h xray-monolith/src/xrGame/BoneProtections.h
--- coc-1.4-xray-64/src/xrGame/BoneProtections.h	2023-10-20 20:54:50.575326700 +0100
+++ xray-monolith/src/xrGame/BoneProtections.h	2023-10-20 20:54:32.558036700 +0100
@@ -10,7 +12,11 @@
 	};
+
 	float				m_fHitFracNpc;
 	float				m_fHitFracActor;
+	float APScale;
 	typedef xr_map<s16,BoneProtection>		storage_type;
 	typedef storage_type::iterator	storage_it;
-    SBoneProtections() {
+
+	SBoneProtections()
+	{
         m_default.koeff = 1.0f;
@@ -20,2 +26,3 @@
         m_fHitFracNpc = 0.1f;
+		APScale = 1.0f;
     }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/BottleItem.h xray-monolith/src/xrGame/BottleItem.h
--- coc-1.4-xray-64/src/xrGame/BottleItem.h	2023-10-20 20:54:50.575326700 +0100
+++ xray-monolith/src/xrGame/BottleItem.h	2023-10-20 20:54:32.559038100 +0100
@@ -9,3 +9,3 @@
 #include "fooditem.h"
-
+#include "script_export_space.h"
 
@@ -34,2 +34,8 @@
 	ref_sound sndBreaking;
+
+	DECLARE_SCRIPT_REGISTER_FUNCTION
 };
\ No newline at end of file
+
+add_to_type_list(CBottleItem)
+#undef script_type_list
+#define script_type_list save_type_list(CBottleItem)
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/BreakableObject.cpp xray-monolith/src/xrGame/BreakableObject.cpp
--- coc-1.4-xray-64/src/xrGame/BreakableObject.cpp	2023-10-20 20:54:50.576326500 +0100
+++ xray-monolith/src/xrGame/BreakableObject.cpp	2023-10-20 20:54:32.560036000 +0100
@@ -44,4 +44,4 @@
 	R_ASSERT				(obj);
-	inherited::net_Spawn	(DC);
-	VERIFY(!collidable.model);
+	BOOL res = inherited::net_Spawn(DC);
+	xr_delete(collidable.model);
 	collidable.model = xr_new<CCF_Skeleton>(this);
@@ -59,3 +59,3 @@
 //	shedule_unregister		();
-	return					(TRUE);
+	return (res);
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/CameraFirstEye.h xray-monolith/src/xrGame/CameraFirstEye.h
--- coc-1.4-xray-64/src/xrGame/CameraFirstEye.h	2023-10-20 20:54:50.578339400 +0100
+++ xray-monolith/src/xrGame/CameraFirstEye.h	2023-10-20 20:54:32.561039900 +0100
@@ -23,3 +23,13 @@
 	virtual float	GetWorldPitch	( )	{ return pitch; };
-			void	LookAtPoint		(Fvector p){lookat_point=p;lookat_active=true;}
+
+	void LookAtPoint(Fvector p)
+	{
+		lookat_point = p;
+		lookat_active = true;
+	}
+
+	void StopLookAtPoint()
+	{
+		lookat_active = false;
+	}
 };
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/cameralook.cpp xray-monolith/src/xrGame/cameralook.cpp
--- coc-1.4-xray-64/src/xrGame/cameralook.cpp	2023-10-20 20:54:51.014327500 +0100
+++ xray-monolith/src/xrGame/cameralook.cpp	2023-10-20 20:54:32.938036100 +0100
@@ -127,5 +137,7 @@
 		}
-	}else
+	}
+	else
+	{
+		if (!pInput->iGetAsyncKeyState(cam_dik))
 	{
-		if( !pInput->iGetAsyncKeyState(cam_dik) ){
 			m_locked_enemy	= NULL;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/CaptureBoneCallback.h xray-monolith/src/xrGame/CaptureBoneCallback.h
--- coc-1.4-xray-64/src/xrGame/CaptureBoneCallback.h	2023-10-20 20:54:50.578339400 +0100
+++ xray-monolith/src/xrGame/CaptureBoneCallback.h	2023-10-20 20:54:32.562036300 +0100
@@ -1,2 +1,2 @@
-#pragma once;
+#pragma once
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Car.cpp xray-monolith/src/xrGame/Car.cpp
--- coc-1.4-xray-64/src/xrGame/Car.cpp	2023-10-20 20:54:50.579338100 +0100
+++ xray-monolith/src/xrGame/Car.cpp	2023-10-20 20:54:32.562036300 +0100
@@ -126,3 +130,5 @@
 {
+#ifdef DEBUG
 	VERIFY2(fsimilar(DET(B->mTransform),1.f,DET_CHECK_EPS),"Bones receive returns 0 matrix");
+#endif
 	CCar*	C			= static_cast<CCar*>(B->callback_param());
@@ -157,19 +163,32 @@
 #endif
-	CSE_Abstract					*e = (CSE_Abstract*)(DC);
-	CSE_ALifeCar					*co=smart_cast<CSE_ALifeCar*>(e);
-	BOOL							R = inherited::net_Spawn(DC);
 
-	PKinematics(Visual())->CalculateBones_Invalidate();
-	PKinematics(Visual())->CalculateBones(TRUE);
+	if (!inherited::net_Spawn(DC))
+		return (FALSE);
+
+	CSE_Abstract *e = (CSE_Abstract*)(DC);
+	CSE_ALifeCar *car = smart_cast<CSE_ALifeCar*>(e);
 
 	CPHSkeleton::Spawn(e);
+	
+	IKinematics* K = smart_cast<IKinematics*>(Visual());
+	IKinematicsAnimated	*A = smart_cast<IKinematicsAnimated*>(Visual());
+	if (A) {
+		if (car->startup_animation.size())
+			A->PlayCycle(*car->startup_animation);
+		K->CalculateBones(TRUE);
+	}
+
 	setEnabled						(TRUE);
 	setVisible						(TRUE);
-	PKinematics(Visual())->CalculateBones_Invalidate();
-	PKinematics(Visual())->CalculateBones(TRUE);
+
 	m_fSaveMaxRPM					= m_max_rpm;
-	SetfHealth						(co->health);
+	SetfHealth(car->health);
 
-	if(!g_Alive())					b_exploded=true;
-	else							b_exploded=false;
+	if (!g_Alive())
+		b_exploded = true;
+	else
+	{
+		b_exploded = false;
+		processing_activate();
+	}
 									
@@ -190,4 +208,3 @@
 
-	return							(CScriptEntity::net_Spawn(DC) && R);
-	
+	return (CScriptEntity::net_Spawn(DC));
 }
@@ -216,2 +234,4 @@
 	CPHUpdateObject::Activate       ();
+
+	m_pPhysicsShell->applyImpulse(Fvector().set(0.f, -1.f, 0.f), 0.1f);
 }
@@ -233,8 +251,2 @@
 	CExplosive::net_Destroy();
-	if(m_pPhysicsShell)
-	{
-		m_pPhysicsShell->Deactivate();
-		m_pPhysicsShell->ZeroCallbacks();
-		xr_delete(m_pPhysicsShell);
-	}
 	CHolderCustom::detach_Actor();
@@ -254,2 +266,8 @@
 	CPHCollisionDamageReceiver::Clear();
+	if (m_pPhysicsShell)
+	{
+		m_pPhysicsShell->Deactivate();
+		m_pPhysicsShell->ZeroCallbacks();
+		xr_delete(m_pPhysicsShell);
+	}
 	b_breaks=false;
@@ -413,2 +428,3 @@
 		OwnerActor()->Cameras().UpdateFromCamera(Camera());
+		if (eacFirstEye == active_camera->tag && !Level().Cameras().GetCamEffector(cefDemo))
 		OwnerActor()->Cameras().ApplyDevice(VIEWPORT_NEAR);
@@ -445,10 +460,8 @@
 {
+	if (m_pPhysicsShell)
+	{
 	m_pPhysicsShell->InterpolateGlobalTransform(&XFORM());
-
-	Fvector lin_vel;
-	m_pPhysicsShell->get_LinearVel(lin_vel);
-	// Sound
-	Fvector		C,V;
-	Center		(C);
-	V.set		(lin_vel);
+		IKinematics* K = smart_cast<IKinematics*>(Visual());
+		K->CalculateBones();
+	}
 
@@ -1726,5 +1739,5 @@
 			//moved to DropItem
-		}break;
 	}
-
+		break;
+	}
 }
@@ -1807,5 +1819,3 @@
 	{
-		if(!m_doors.empty())m_doors.begin()->second.GetExitPosition(m_exit_position);
-		else m_exit_position.set(Position());
-		A->detach_Vehicle();
+		A->use_HolderEx(0, false);
 		if(A->g_Alive()<=0.f)A->character_physics_support()->movement()->DestroyCharacter();
@@ -2119 +2144,7 @@
 /*************************************************** added by Ray Twitty (aka Shadows) END ***************************************************/
+Fvector CCar::ExitPosition()
+{
+	if (!m_doors.empty())m_doors.begin()->second.GetExitPosition(m_exit_position);
+	else m_exit_position.set(Position());
+	return m_exit_position;
+}
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Car.h xray-monolith/src/xrGame/Car.h
--- coc-1.4-xray-64/src/xrGame/Car.h	2023-10-20 20:54:50.579338100 +0100
+++ xray-monolith/src/xrGame/Car.h	2023-10-20 20:54:32.563035800 +0100
@@ -549,3 +587,3 @@
 	virtual bool			HUDView						() const;
-	virtual Fvector			ExitPosition				(){return m_exit_position;}
+	virtual Fvector ExitPosition();
 	virtual Fvector			ExitVelocity				();
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/CarCameras.cpp xray-monolith/src/xrGame/CarCameras.cpp
--- coc-1.4-xray-64/src/xrGame/CarCameras.cpp	2023-10-20 20:54:50.580326700 +0100
+++ xray-monolith/src/xrGame/CarCameras.cpp	2023-10-20 20:54:32.563035800 +0100
@@ -24,3 +24,5 @@
 {
+#ifdef DEBUG
 	VERIFY(!physics_world()->Processing());
+#endif
 	Fvector							P,Da;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/CarInput.cpp xray-monolith/src/xrGame/CarInput.cpp
--- coc-1.4-xray-64/src/xrGame/CarInput.cpp	2023-10-20 20:54:50.581327400 +0100
+++ xray-monolith/src/xrGame/CarInput.cpp	2023-10-20 20:54:32.565036600 +0100
@@ -18,2 +18,3 @@
 #include "CarWeapon.h"
+#include "HUDManager.h"
 
@@ -33,2 +36,12 @@
 	}
+	if (m_car_weapon && m_car_weapon->IsActive())
+	{
+		Fvector pos = active_camera->Position();
+		Fvector cam_dir = active_camera->Direction();
+
+		collide::rq_result& RQ = HUD().GetCurrentRayQuery();
+
+		pos.mad(cam_dir, RQ.range>3.f ? RQ.range : 30.f);
+		SetParam(CCarWeapon::eWpnDesiredPos, pos);
+	};
 }
@@ -125,15 +147,34 @@
 	{
-	case kCAM_1:	OnCameraChange(ectFirst);	break;
-	case kCAM_2:	OnCameraChange(ectChase);	break;
-	case kCAM_3:	OnCameraChange(ectFree);	break;
-	case kACCEL:	TransmissionUp();			break;
-	case kCROUCH:	TransmissionDown();			break;
-	case kFWD:		PressForward();				break;
-	case kBACK:		PressBack();				break;
-	case kR_STRAFE:	PressRight();				if (OwnerActor()) OwnerActor()->steer_Vehicle(1);	break;
-	case kL_STRAFE:	PressLeft();				if (OwnerActor()) OwnerActor()->steer_Vehicle(-1);break;
-	case kJUMP:		PressBreaks();				break;
-	case kDETECTOR:	SwitchEngine();				break;
-	case kTORCH:	m_lights.SwitchHeadLights();break;
+	case kCAM_1: OnCameraChange(ectFirst);
+		break;
+	case kCAM_2: OnCameraChange(ectChase);
+		break;
+	case kCAM_3: OnCameraChange(ectFree);
+		break;
+	case kACCEL: TransmissionUp();
+		break;
+	case kCROUCH: TransmissionDown();
+		break;
+	case kFWD: PressForward();
+		break;
+	case kBACK: PressBack();
+		break;
+	case kR_STRAFE: PressRight();
+		if (OwnerActor()) OwnerActor()->steer_Vehicle(1);
+		break;
+	case kL_STRAFE: PressLeft();
+		if (OwnerActor()) OwnerActor()->steer_Vehicle(-1);
+		break;
+	case kJUMP: PressBreaks();
+		break;
+	case kDETECTOR: SwitchEngine();
+		break;
+	case kWPN_FUNC:
+		if (HasWeapon())			
+			m_car_weapon->Action(CCarWeapon::eWpnActivate, !m_car_weapon->IsActive()); break;
+		break;
+	case kTORCH: m_lights.SwitchHeadLights();
+		break;
 	case kUSE:									break;
+	case kWPN_FIRE: if (HasWeapon()) m_car_weapon->Action(CCarWeapon::eWpnFire, 1); break;
 	};
@@ -148,7 +188,16 @@
 	case kACCEL:break;
-	case kFWD:		ReleaseForward();			break;
-	case kBACK:		ReleaseBack();				break;
-	case kL_STRAFE:	ReleaseLeft();				if (OwnerActor()) OwnerActor()->steer_Vehicle(0);	break;
-	case kR_STRAFE:	ReleaseRight();				if (OwnerActor()) OwnerActor()->steer_Vehicle(0);	break;
-	case kJUMP:		ReleaseBreaks();			break;
+	case kFWD: ReleaseForward();
+		break;
+	case kBACK: ReleaseBack();
+		break;
+	case kL_STRAFE: ReleaseLeft();
+		if (OwnerActor()) OwnerActor()->steer_Vehicle(0);
+		break;
+	case kR_STRAFE: ReleaseRight();
+		if (OwnerActor()) OwnerActor()->steer_Vehicle(0);
+		break;
+	case kJUMP: ReleaseBreaks();
+		break;
+	case kWPN_FIRE: if (HasWeapon()) m_car_weapon->Action(CCarWeapon::eWpnFire, 0);
+		break;
 	};
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/CarWeapon.cpp xray-monolith/src/xrGame/CarWeapon.cpp
--- coc-1.4-xray-64/src/xrGame/CarWeapon.cpp	2023-10-20 20:54:50.583326700 +0100
+++ xray-monolith/src/xrGame/CarWeapon.cpp	2023-10-20 20:54:32.566036400 +0100
@@ -4,3 +4,2 @@
 #include "PhysicsShellHolder.h"
-//#include "../Include/xrRender/Kinematics.h"
 #include "../Include/xrRender/Kinematics.h"
@@ -11,2 +10,3 @@
 #include "game_object_space.h"
+#include "holder_custom.h"
 
@@ -227,4 +238,4 @@
 {
-	FireBullet				(	m_fire_pos, m_fire_dir, fireDispersionBase, *m_Ammo, 
-								m_object->ID(), m_object->ID(), SendHitAllowed(m_object), ::Random.randI(0,30));
+	CHolderCustom* holder = smart_cast<CHolderCustom*>(m_object);
+	FireBullet(m_fire_pos, m_fire_dir, fireDispersionBase, *m_Ammo, holder->Engaged() ? 0 : m_object->ID(), m_object->ID(), SendHitAllowed(m_object), ::Random.randI(0, 30));
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/CarWheels.cpp xray-monolith/src/xrGame/CarWheels.cpp
--- coc-1.4-xray-64/src/xrGame/CarWheels.cpp	2023-10-20 20:54:50.584328400 +0100
+++ xray-monolith/src/xrGame/CarWheels.cpp	2023-10-20 20:54:32.567036700 +0100
@@ -205,3 +220,3 @@
 	gear_factor=pwheel->radius/pwheel->car->m_ref_radius;
-	CBoneData& bone_data= smart_cast<IKinematics*>(pwheel->car->Visual())->LL_GetData(u16(pwheel->bone_id));
+	/*CBoneData& bone_data = smart_cast<IKinematics*>(pwheel->car->Visual())->LL_GetData(u16(pwheel->bone_id));
 	switch(bone_data.IK_data.type)
@@ -216,3 +231,4 @@
 	pos_fvd=pos_fvd>0.f ? -1.f : 1.f;
-
+	*/
+	pos_fvd = -1.f;
 }
@@ -245,3 +265,3 @@
 	(bone_map.find(pwheel->bone_id))->second.joint->GetLimits(lo_limit,hi_limit,0);
-	CBoneData& bone_data= pKinematics->LL_GetData(u16(pwheel->bone_id));
+	/*CBoneData& bone_data = pKinematics->LL_GetData(u16(pwheel->bone_id));
 	switch(bone_data.IK_data.type)
@@ -256,2 +277,4 @@
 	pos_right=pos_right>0.f ? -1.f : 1.f;
+	*/
+	pos_right = -1.f;
 	float steering_torque=pKinematics->LL_UserData()->r_float("car_definition","steering_torque");
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/character_community.cpp xray-monolith/src/xrGame/character_community.cpp
--- coc-1.4-xray-64/src/xrGame/character_community.cpp	2023-10-20 20:54:51.016326300 +0100
+++ xray-monolith/src/xrGame/character_community.cpp	2023-10-20 20:54:32.939035900 +0100
@@ -67,2 +67,5 @@
 	
+	if (from == NO_COMMUNITY_INDEX || to == NO_COMMUNITY_INDEX)
+		return 0;
+
 	return m_relation_table.table()[from][to];
@@ -76,2 +80,5 @@
 
+	if (from == NO_COMMUNITY_INDEX || to == NO_COMMUNITY_INDEX)
+		return;
+
 	m_relation_table.table()[from][to] = goodwill;
@@ -82,2 +89,6 @@
 	VERIFY(comm >= 0 && comm <(int)m_sympathy_table.table().size());
+
+	if (comm == NO_COMMUNITY_INDEX)
+		return 0;
+
 	return m_sympathy_table.table()[comm][0];
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/character_community.h xray-monolith/src/xrGame/character_community.h
--- coc-1.4-xray-64/src/xrGame/character_community.h	2023-10-20 20:54:51.016326300 +0100
+++ xray-monolith/src/xrGame/character_community.h	2023-10-20 20:54:32.940036100 +0100
@@ -58,2 +59,9 @@
 	static void					DeleteIdToIndexData	();
+
+	static void Reset()
+	{
+		m_relation_table.clear();
+		m_sympathy_table.clear();
+	}
+
 private:
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/character_rank.h xray-monolith/src/xrGame/character_rank.h
--- coc-1.4-xray-64/src/xrGame/character_rank.h	2023-10-20 20:54:51.018326600 +0100
+++ xray-monolith/src/xrGame/character_rank.h	2023-10-20 20:54:32.941035700 +0100
@@ -59,2 +64,8 @@
 
+	static void Reset()
+	{
+		m_relation_table.clear();
+		m_rank_kill_table.clear();
+	}
+
 private:
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/character_reputation.h xray-monolith/src/xrGame/character_reputation.h
--- coc-1.4-xray-64/src/xrGame/character_reputation.h	2023-10-20 20:54:51.018326600 +0100
+++ xray-monolith/src/xrGame/character_reputation.h	2023-10-20 20:54:32.942035600 +0100
@@ -56,2 +61,3 @@
 
+	static void Reset() { m_relation_table.clear(); }
 private:
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/CharacterPhysicsSupport.cpp xray-monolith/src/xrGame/CharacterPhysicsSupport.cpp
--- coc-1.4-xray-64/src/xrGame/CharacterPhysicsSupport.cpp	2023-10-20 20:54:50.584328400 +0100
+++ xray-monolith/src/xrGame/CharacterPhysicsSupport.cpp	2023-10-20 20:54:32.568037300 +0100
@@ -54,2 +52,5 @@
 
+#define IK_CALC_DIST 100.f
+#define IK_ALWAYS_CALC_DIST 20.f
+
 //void  NodynamicsCollide( bool& do_colide, bool bo1, dContact& c, SGameMtl * /*material_1*/, SGameMtl * /*material_2*/ )
@@ -647,2 +650,14 @@
 	{
+		CFrustum& view_frust = ::Render->ViewBase;
+		vis_data& vis = m_EntityAlife.Visual()->getVisData();
+		Fvector p;
+
+		m_EntityAlife.XFORM().transform_tiny(p, vis.sphere.P);
+
+		float dist = Device.vCameraPosition.distance_to(p);
+
+		if (dist < IK_CALC_DIST)
+		{
+			if (view_frust.testSphere_dirty(p, vis.sphere.R) || dist < IK_ALWAYS_CALC_DIST)
+			{
 		update_interactive_anims();
@@ -650,2 +665,4 @@
 	}
+		}
+	}
 
@@ -1148,5 +1168,4 @@
 
-
 	if(!DoCharacterShellCollide())
-		m_pPhysicsShell->DisableCharacterCollision();
+		m_pPhysicsShell->SetDeadBody();
 
@@ -1171,7 +1190,3 @@
 		m_pPhysicsShell->SetPrefereExactIntegration	();//use exact integration for ragdolls in single
-        //AVO: turn on collision with dead bodies (thanks malandrinus)
-#ifndef DEAD_BODY_COLLISION
-			m_pPhysicsShell->SetRemoveCharacterCollLADisable();
-#endif
-        //-AVO
+		m_pPhysicsShell->SetDeadBody();
 	}
@@ -1431,3 +1443,3 @@
 
-void		CCharacterPhysicsSupport::in_Die( )
+void CCharacterPhysicsSupport::in_Die(bool hit)
 {
@@ -1441,2 +1453,4 @@
 	}
+
+	if (hit)
 	in_Hit( m_sv_hit, true );
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/CharacterPhysicsSupport.h xray-monolith/src/xrGame/CharacterPhysicsSupport.h
--- coc-1.4-xray-64/src/xrGame/CharacterPhysicsSupport.h	2023-10-20 20:54:50.584328400 +0100
+++ xray-monolith/src/xrGame/CharacterPhysicsSupport.h	2023-10-20 20:54:32.568037300 +0100
@@ -142,3 +154,3 @@
 		void							in_ChangeVisual					( );
-		void							in_Die							( );
+	void in_Die(bool hit = true);
 		void							on_create_anim_mov_ctrl			( );
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/configs_dumper.cpp xray-monolith/src/xrGame/configs_dumper.cpp
--- coc-1.4-xray-64/src/xrGame/configs_dumper.cpp	2023-10-20 20:54:51.023327800 +0100
+++ xray-monolith/src/xrGame/configs_dumper.cpp	2023-10-20 20:54:32.946035700 +0100
@@ -129,5 +130,8 @@
 		}
-	} else
+		}
+		else
+		{
+			while (m_ltx_configs.dump_one(m_dump_result))
 	{
-		while (m_ltx_configs.dump_one(m_dump_result)) {};
+			};
 	}
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/console_commands.cpp xray-monolith/src/xrGame/console_commands.cpp
--- coc-1.4-xray-64/src/xrGame/console_commands.cpp	2023-10-20 20:54:51.024327600 +0100
+++ xray-monolith/src/xrGame/console_commands.cpp	2023-10-20 20:54:32.947035500 +0100
@@ -1 +1,2 @@
+#include <unordered_set>
 #include "pch_script.h"
@@ -43,3 +44,3 @@
 //#include "../xrEngine/resourcemanager.h"
-#include "../xrEngine/doug_lea_memory_allocator.h"
+//#include "../xrEngine/doug_lea_memory_allocator.h"
 #include "cameralook.h"
@@ -48,7 +49,6 @@
 
-#include "GameSpy/GameSpy_Full.h"
-#include "GameSpy/GameSpy_Patching.h"
-
 #include "ai_debug_variables.h"
 #include "../xrphysics/console_vars.h"
+
+#include "..\xrCore\LocatorAPI.h"
 #ifdef DEBUG
@@ -60,2 +60,8 @@
 
+
+#include "..\..\xrEngine\x_ray.h"
+
+#include "NewZoomFlag.h"
+float n_zoom_step_count = 3.0f;
+
 string_path		g_last_saved_game;
@@ -74,3 +80,3 @@
 ENGINE_API
-extern	float	psHUD_FOV;
+extern float psHUD_FOV_def;
 extern	float	psSqueezeVelocity;
@@ -78,2 +84,4 @@
 
+float g_end_modif = 0.f;
+
 extern	int		x_m_x;
@@ -92,3 +100,5 @@
 extern	float	g_fTimeFactor;
-extern	BOOL	b_toggle_weapon_aim;
+extern float f_weapon_deterioration;
+extern float f_power_loss_bias;
+extern float f_power_loss_factor;
 //extern  BOOL	g_old_style_ui_hud;
@@ -101,3 +111,4 @@
 float			g_aim_predict_time = 0.40f;
-int				g_keypress_on_start = 1;
+float g_head_bob_factor = 1.00f;
+float streff;
 
@@ -105,4 +116,28 @@
 
+//demonized: new console vars
+extern BOOL firstPersonDeath;
+extern BOOL pseudogiantCanDamageObjects;
+extern BOOL use_english_text_for_missing_translations;
+namespace crash_saving {
+	extern BOOL enabled;
+	extern int saveCountMax;
+}
+extern BOOL pda_map_zoom_in_to_mouse;
+extern BOOL pda_map_zoom_out_to_mouse;
+extern BOOL mouseWheelChangeWeapon;
+extern BOOL mouseWheelInvertZoom;
+extern BOOL monsterStuckFix;
+
 ENGINE_API extern float	g_console_sensitive;
 
+u32 g_dead_body_collision = 1;
+
+xr_token dead_body_collision_tokens[] =
+{
+	{ "full", 2 },
+	{ "actor_only", 1 },
+	{ "off", 0 },
+	{ 0, 0 }
+};
+
 void register_mp_console_commands();
@@ -146,3 +185,3 @@
 //#	ifndef USE_MEMORY_MONITOR
-#		define SEVERAL_ALLOCATORS
+//#		define SEVERAL_ALLOCATORS
 //#	endif // USE_MEMORY_MONITOR
@@ -155,3 +194,3 @@
 typedef void(*full_memory_stats_callback_type) ();
-XRCORE_API full_memory_stats_callback_type g_full_memory_stats_callback;
+extern XRCORE_API full_memory_stats_callback_type g_full_memory_stats_callback;
 
@@ -159,2 +198,3 @@
 {
+	Msg("* [x-ray]: Full Memory Stats");
 	Memory.mem_compact();
@@ -412,2 +478,3 @@
 //-----------------------------------------------------------------------
+std::unordered_set<CDemoRecord*> pDemoRecords;
 class CCC_DemoRecord : public IConsole_Command
@@ -433,3 +503,51 @@
 
-		g_pGameLevel->Cameras().AddCamEffector(xr_new<CDemoRecord>(fn));
+		auto pDemoRecord = xr_new<CDemoRecord>(fn, &pDemoRecords);
+		g_pGameLevel->Cameras().AddCamEffector(pDemoRecord);
+	}
+};
+
+class CCC_DemoRecordBlockedInput : public IConsole_Command
+{
+public:
+
+	CCC_DemoRecordBlockedInput(LPCSTR N) : IConsole_Command(N)
+	{
+	};
+
+	virtual void Execute(LPCSTR args)
+	{
+#ifndef	DEBUG
+		//if (GameID() != eGameIDSingle)
+		//{
+		//	Msg("For this game type Demo Record is disabled.");
+		//	return;
+		//};
+#endif
+		Console->Hide();
+
+		LPSTR fn_;
+		STRCONCAT(fn_, args, ".xrdemo");
+		string_path fn;
+		FS.update_path(fn, "$game_saves$", fn_);
+
+		auto pDemoRecord = xr_new<CDemoRecord>(fn, &pDemoRecords, TRUE);
+		g_pGameLevel->Cameras().AddCamEffector(pDemoRecord);
+	}
+};
+
+class CCC_DemoRecordStop : public IConsole_Command
+{
+public:
+
+	CCC_DemoRecordStop(LPCSTR N) : IConsole_Command(N)
+	{
+		bEmptyArgsHandled = true;
+	};
+
+	virtual void Execute(LPCSTR args)
+	{
+		for (auto pDemoRecord : pDemoRecords) {
+			pDemoRecord->StopDemo();
+		}
+		pDemoRecords.clear();
 	}
@@ -458,4 +581,34 @@
 };
+
 Fvector CCC_DemoRecordSetPos::p = { 0, 0, 0 };
 
+class CCC_DemoRecordSetDir : public CCC_Vector3
+{
+	static Fvector d;
+public:
+
+	CCC_DemoRecordSetDir(LPCSTR N) : CCC_Vector3(N, &d, Fvector().set(-FLT_MAX, -FLT_MAX, -FLT_MAX),
+		Fvector().set(FLT_MAX, FLT_MAX, FLT_MAX))
+	{
+	};
+
+	virtual void Execute(LPCSTR args)
+	{
+#ifndef	DEBUG
+		//if (GameID() != eGameIDSingle)
+		//{
+		//	Msg("For this game type Demo Record is disabled.");
+		//	return;
+		//};
+#endif
+		CDemoRecord::GetGlobalDirection(d);
+		CCC_Vector3::Execute(args);
+		CDemoRecord::SetGlobalDirection(d);
+	}
+
+	virtual void Save(IWriter* F) { ; }
+};
+
+Fvector CCC_DemoRecordSetDir::d = { 0, 0, 0 };
+
 class CCC_DemoPlay : public IConsole_Command
@@ -499,2 +653,53 @@
 
+// First Person Death
+extern float offsetH;
+extern float offsetP;
+extern float offsetB;
+extern float offsetX;
+extern float offsetY;
+extern float offsetZ;
+extern float viewportNearOffset;
+extern int firstPersonDeathPositionSmoothing;
+extern int firstPersonDeathDirectionSmoothing;
+
+class CCC_FPDDirectionOffset : public CCC_Vector3
+{
+	static Fvector d;
+public:
+
+	CCC_FPDDirectionOffset(LPCSTR N) : CCC_Vector3(N, &d, Fvector().set(-FLT_MAX, -FLT_MAX, -FLT_MAX),
+		Fvector().set(FLT_MAX, FLT_MAX, FLT_MAX))
+	{
+	};
+
+	virtual void Execute(LPCSTR args)
+	{
+		CCC_Vector3::Execute(args);
+		offsetH = d.x;
+		offsetP = d.y;
+		offsetB = d.z;
+	}
+};
+Fvector CCC_FPDDirectionOffset::d = { 0, 0, 0 };
+
+class CCC_FPDPositionOffset : public CCC_Vector3
+{
+	static Fvector d;
+public:
+
+	CCC_FPDPositionOffset(LPCSTR N) : CCC_Vector3(N, &d, Fvector().set(-FLT_MAX, -FLT_MAX, -FLT_MAX),
+		Fvector().set(FLT_MAX, FLT_MAX, FLT_MAX))
+	{
+	};
+
+	virtual void Execute(LPCSTR args)
+	{
+		CCC_Vector3::Execute(args);
+		offsetX = d.x;
+		offsetY = d.y;
+		offsetZ = d.z;
+	}
+};
+Fvector CCC_FPDPositionOffset::d = { 0, 0, 0 };
+
 // helper functions --------------------------------------------
@@ -1403,2 +1634,4 @@
 		Device.time_factor(time_factor);
+		if (!strstr(Core.Params, "-sound_constant_speed"))
+			psSpeedOfSound = time_factor;
 	}
@@ -1445,2 +1680,5 @@
 
+		if (Device.Paused() && bWhatToDo == TRUE)
+			Device.Pause(FALSE, TRUE, TRUE, "li_pause_key");
+
 		MainMenu()->Activate(bWhatToDo);
@@ -1449,5 +1687,30 @@
 
+class CCC_DiscordStatus : public CCC_Mask
+{
+public:
+	CCC_DiscordStatus(LPCSTR N, Flags32* V, u32 M) :
+		CCC_Mask(N, V, M){};
+
+	virtual void Execute(LPCSTR args)
+	{
+		if (EQ(args, "on") || EQ(args, "1"))
+		{
+			value->set(mask, TRUE);
+			discord_gameinfo.ex_update = true;
+		}
+		else if (EQ(args, "off") || EQ(args, "0"))
+		{
+			value->set(mask, FALSE);
+			clearDiscordPresence();
+		}
+		else InvalidSyntax();
+	}
+};
+
 struct CCC_StartTimeSingle : public IConsole_Command
 {
-	CCC_StartTimeSingle(LPCSTR N) : IConsole_Command(N) {};
+	CCC_StartTimeSingle(LPCSTR N) : IConsole_Command(N)
+	{
+	};
+
 	virtual void	Execute(LPCSTR args)
@@ -1819,3 +2086,3 @@
 
-		MainMenu()->GetGS()->GetGameSpyPatching()->CheckForPatch(InformOfNoPatch);
+		//MainMenu()->GetGS()->GetGameSpyPatching()->CheckForPatch(InformOfNoPatch);
 	}
@@ -1881,4 +2149,4 @@
 {
-	// options
-	g_OptConCom.Init();
+	//Not needed for a singleplayer-only mod
+	//g_OptConCom.Init();
 
@@ -1889,3 +2157,18 @@
 	// game
+
+	psActorFlags.set(AF_CROUCH_TOGGLE, FALSE);
+	psActorFlags.set(AF_WALK_TOGGLE, FALSE);
+	psActorFlags.set(AF_SPRINT_TOGGLE, TRUE);
+	psActorFlags.set(AF_LOOKOUT_TOGGLE, FALSE);
+	psActorFlags.set(AF_FREELOOK_TOGGLE, FALSE);
+	psActorFlags.set(AF_SIMPLE_PDA, TRUE);
+	psActorFlags.set(AF_3D_PDA, TRUE);
+
 	CMD3(CCC_Mask, "g_crouch_toggle", &psActorFlags, AF_CROUCH_TOGGLE);
+	CMD3(CCC_Mask, "g_walk_toggle", &psActorFlags, AF_WALK_TOGGLE);
+	CMD3(CCC_Mask, "g_sprint_toggle", &psActorFlags, AF_SPRINT_TOGGLE);
+	CMD3(CCC_Mask, "g_lookout_toggle", &psActorFlags, AF_LOOKOUT_TOGGLE);
+	CMD3(CCC_Mask, "g_freelook_toggle", &psActorFlags, AF_FREELOOK_TOGGLE);
+	CMD3(CCC_Mask, "g_3d_pda", &psActorFlags, AF_3D_PDA);
+	CMD3(CCC_Mask, "g_simple_pda", &psActorFlags, AF_SIMPLE_PDA);
 	CMD1(CCC_GameDifficulty, "g_game_difficulty");
@@ -1930,3 +2213,3 @@
 	//#ifdef DEBUG
-	CMD4(CCC_Float, "hud_fov", &psHUD_FOV, 0.1f, 1.0f);
+	CMD4(CCC_Float, "hud_fov", &psHUD_FOV_def, 0.1f, 1.0f);
 	CMD4(CCC_Float, "fov", &g_fov, 5.0f, 180.0f);
@@ -1938,3 +2221,6 @@
 	CMD1(CCC_DemoRecord, "demo_record");
+	CMD1(CCC_DemoRecordBlockedInput, "demo_record_blocked_input");
+	CMD1(CCC_DemoRecordStop, "demo_record_stop");
 	CMD1(CCC_DemoRecordSetPos, "demo_set_cam_position");
+	CMD1(CCC_DemoRecordSetDir, "demo_set_cam_direction");
 	//#endif // #ifndef MASTER_GOLD
@@ -2083,5 +2369,7 @@
 		CMD1(CCC_ScriptCommand, "run_string");
-		CMD1(CCC_TimeFactor, "time_factor");
 		//CMD3(CCC_Mask, "g_no_clip", &psActorFlags, AF_NO_CLIP);
 		CMD1(CCC_PHGravity, "ph_gravity");
+		CMD3(CCC_Mask, "log_missing_ini", &FS.m_Flags, FS.flPrintLTX);
+		CMD3(CCC_Mask, "g_firepos", &psActorFlags, AF_FIREPOS);
+		CMD4(CCC_Float, "g_end_modif", &g_end_modif, 0.f, 10.f);
 	}
@@ -2091,2 +2379,3 @@
 
+	CMD1(CCC_TimeFactor, "time_factor");
 	CMD3(CCC_Mask, "g_use_tracers", &psActorFlags, AF_USE_TRACERS);
@@ -2094,2 +2383,3 @@
 	CMD3(CCC_Mask, "g_dynamic_music", &psActorFlags, AF_DYNAMIC_MUSIC);
+	psActorFlags.set(AF_IMPORTANT_SAVE, TRUE);
 	CMD3(CCC_Mask, "g_important_save", &psActorFlags, AF_IMPORTANT_SAVE);
@@ -2239,4 +2529,2 @@
 #ifdef DEBUG
-	CMD4(CCC_Integer, "string_table_error_msg", &CStringTable::m_bWriteErrorsToLog, 0, 1);
-
 	CMD1(CCC_DumpInfos, "dump_infos");
@@ -2247,2 +2535,4 @@
 #endif
+	// demonized: string_table_error_msg cvar to display missing translations
+	CMD4(CCC_Integer, "string_table_error_msg", &CStringTable::m_bWriteErrorsToLog, 0, 1);
 
@@ -2290,3 +2580,9 @@
 	CMD4(CCC_Float, "con_sensitive", &g_console_sensitive, 0.01f, 1.0f);
-	CMD4(CCC_Integer, "wpn_aim_toggle", &b_toggle_weapon_aim, 0, 1);
+
+	psActorFlags.set(AF_AIM_TOGGLE, FALSE);
+	CMD3(CCC_Mask, "wpn_aim_toggle", &psActorFlags, AF_AIM_TOGGLE);
+	CMD4(CCC_Float, "wpn_degradation", &f_weapon_deterioration, 0.1f, 2.0f);
+	CMD4(CCC_Float, "power_loss_bias", &f_power_loss_bias, 0.0f, 1.0f);
+	CMD4(CCC_Float, "power_loss_factor", &f_power_loss_factor, 0.1f, 3.0f);
+
 	//	CMD4(CCC_Integer,	"hud_old_style",			&g_old_style_ui_hud, 0, 1);
@@ -2304,4 +2600,10 @@
 
+	CMD4(CCC_Integer, "pseudogiant_can_damage_objects_on_stomp", &pseudogiantCanDamageObjects, 0, 1);
+
 	CMD4(CCC_Float, "ai_aim_predict_time", &g_aim_predict_time, 0.f, 10.f);
 
+	CMD4(CCC_Float, "head_bob_factor", &g_head_bob_factor, 0.f, 2.f);
+
+	CMD3(CCC_Mask, "weapon_sway", &psDeviceFlags2, rsAimSway);
+
 #ifdef DEBUG
@@ -2343,4 +2645,61 @@
 
-	CMD4(CCC_Integer, "keypress_on_start", &g_keypress_on_start, 0, 1);
-	register_mp_console_commands();
+	psDeviceFlags2.set(rsKeypress, TRUE);
+	CMD3(CCC_Mask, "keypress_on_start", &psDeviceFlags2, rsKeypress);
+
+	//Discord
+	psDeviceFlags2.set(rsDiscord, TRUE);
+	CMD3(CCC_DiscordStatus, "discord_status", &psDeviceFlags2, rsDiscord);
+	CMD4(CCC_Float, "discord_update_rate", &discord_update_rate, .5f, 5.f);
+
+	psActorFlags.set(rsCODPickup, TRUE);
+	CMD3(CCC_Mask, "cl_cod_pickup_mode", &psDeviceFlags2, rsCODPickup);
+	psActorFlags.set(AF_MULTI_ITEM_PICKUP, TRUE);
+	CMD3(CCC_Mask, "g_multi_item_pickup", &psActorFlags, AF_MULTI_ITEM_PICKUP);
+
+	CMD3(CCC_Token, "g_dead_body_collision", &g_dead_body_collision, dead_body_collision_tokens);
+	CMD3(CCC_Mask, "g_feel_grenade", &psDeviceFlags2, rsFeelGrenade);
+	CMD3(CCC_Mask, "g_always_active", &psDeviceFlags2, rsAlwaysActive);
+
+	// demonized: use_english_text_for_missing_translations
+	CMD4(CCC_Integer, "use_english_text_for_missing_translations", &use_english_text_for_missing_translations, 0, 1);
+
+	//First Person Death
+	CMD4(CCC_Integer, "first_person_death", &firstPersonDeath, 0, 1);
+	CMD1(CCC_FPDDirectionOffset, "first_person_death_direction_offset");
+	CMD1(CCC_FPDPositionOffset, "first_person_death_position_offset");
+	CMD4(CCC_Integer, "first_person_death_position_smoothing", &firstPersonDeathPositionSmoothing, 1, 30);
+	CMD4(CCC_Integer, "first_person_death_direction_smoothing", &firstPersonDeathDirectionSmoothing, 1, 60);
+	CMD4(CCC_Float, "first_person_death_near_plane_offset", &viewportNearOffset, -0.1, 0.5);
+
+	// PDA commands
+	CMD4(CCC_Integer, "pda_map_zoom_in_to_mouse", &pda_map_zoom_in_to_mouse, 0, 1);
+	CMD4(CCC_Integer, "pda_map_zoom_out_to_mouse", &pda_map_zoom_out_to_mouse, 0, 1);
+
+	// Mouse Wheel
+	CMD4(CCC_Integer, "mouse_wheel_change_weapon", &mouseWheelChangeWeapon, 0, 1);
+	CMD4(CCC_Integer, "mouse_wheel_invert_zoom", &mouseWheelInvertZoom, 0, 1);
+
+	//Toggle crash saving
+	CMD4(CCC_Integer, "crash_save", &crash_saving::enabled, 0, 1);
+	CMD4(CCC_Integer, "crash_save_count", &crash_saving::saveCountMax, 0, 20);
+
+	// Monster Stuck Fix
+	CMD4(CCC_Integer, "monster_stuck_fix", &monsterStuckFix, 0, 1);
+
+	if (strstr(Core.Params, "-dbgdev"))
+		CMD4(CCC_Float, "g_streff", &streff, -10.f, 10.f);
+	//No need for server commands in a singleplayer-only mod
+	//register_mp_console_commands();
+    
+    zoomFlags.set(NEW_ZOOM, FALSE);
+    zoomFlags.set(SDS_ZOOM, TRUE);
+    zoomFlags.set(SDS_SPEED, TRUE);
+    zoomFlags.set(SDS, TRUE);
+
+    CMD3(CCC_Mask, "new_zoom_enable", &zoomFlags, NEW_ZOOM);
+    CMD3(CCC_Mask, "sds_zoom_enable", &zoomFlags, SDS_ZOOM);
+    CMD3(CCC_Mask, "sds_speed_enable", &zoomFlags, SDS_SPEED);
+    CMD3(CCC_Mask, "sds_enable", &zoomFlags, SDS);
+
+    CMD4(CCC_Float, "zoom_step_count", &n_zoom_step_count, 1.0f, 10.0f);
 }
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/console_commands_mp.cpp xray-monolith/src/xrGame/console_commands_mp.cpp
--- coc-1.4-xray-64/src/xrGame/console_commands_mp.cpp	2023-10-20 20:54:51.025326800 +0100
+++ xray-monolith/src/xrGame/console_commands_mp.cpp	2023-10-20 20:54:32.948035700 +0100
@@ -19,6 +19,4 @@
 #include "string_table.h"
-#include "../xrGameSpy/xrGameSpy_MainDefs.h"
 #include "DemoPlay_Control.h"
 #include "account_manager_console.h"
-#include "gamespy/GameSpy_GP.h"
 
@@ -36,3 +34,2 @@
 extern	float	g_fTimeFactor;
-extern	BOOL	g_b_COD_PickUpMode		;
 extern	int		g_iWeaponRemove			;
@@ -116,6 +113,7 @@
 void XRNETSERVER_API DumpNetCompressorStats	(bool brief);
-BOOL XRNETSERVER_API g_net_compressor_enabled;
-BOOL XRNETSERVER_API g_net_compressor_gather_stats;
+extern BOOL XRNETSERVER_API g_net_compressor_enabled;
+extern BOOL XRNETSERVER_API g_net_compressor_gather_stats;
 
-class CCC_Restart : public IConsole_Command {
+class CCC_Restart : public IConsole_Command
+{
 public:
@@ -1720,9 +1865,16 @@
 
-class CCC_AuthCheck : public CCC_Integer {
+class CCC_AuthCheck : public CCC_Integer
+{
 public:
-					CCC_AuthCheck	(LPCSTR N, int* V, int _min=0, int _max=999) :CCC_Integer(N,V,_min,_max){};
-	  virtual void	Save			(IWriter *F)	{};
+	CCC_AuthCheck(LPCSTR N, int* V, int _min = 0, int _max = 999) : CCC_Integer(N, V, _min, _max)
+	{
 };
 
-class CCC_ReturnToBase: public IConsole_Command {
+	virtual void Save(IWriter* F)
+	{
+	};
+};
+
+class CCC_ReturnToBase : public IConsole_Command
+{
 public:
@@ -1843,7 +2010,7 @@
 				Level().Send(P,net_flags(TRUE,TRUE));
-			}else
-				Msg("2 args(user pass) needed");
 		}
 		else
-		if(strstr(arguments,"logout")==arguments)
+				Msg("2 args(user pass) needed");
+		}
+		else if (strstr(arguments, "logout") == arguments)
 		{
@@ -2051,3 +2240,2 @@
 
-	CMD4(CCC_Integer,		"cl_cod_pickup_mode",	&g_b_COD_PickUpMode,	0, 1)	;
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/cover_manager.cpp xray-monolith/src/xrGame/cover_manager.cpp
--- coc-1.4-xray-64/src/xrGame/cover_manager.cpp	2023-10-20 20:54:51.027326000 +0100
+++ xray-monolith/src/xrGame/cover_manager.cpp	2023-10-20 20:54:32.951037100 +0100
@@ -91,5 +92,8 @@
 	CLevelGraph const		&graph = ai().level_graph();
-	for (u32 i=0, n = ai().level_graph().header().vertex_count(); i<n; ++i) {
+	u32 n = ai().level_graph().header().vertex_count();
+	for (u32 i = 0; i < n; ++i)
+	{
 		CLevelGraph::CVertex const &vertex = *graph.vertex(i);
-		if (vertex.high_cover(0) + vertex.high_cover(1) + vertex.high_cover(2) + vertex.high_cover(3)) {
+		if (vertex.high_cover(0) + vertex.high_cover(1) + vertex.high_cover(2) + vertex.high_cover(3))
+		{
 			m_temp[i]		= edge_vertex(i);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/cta_game_artefact.cpp xray-monolith/src/xrGame/cta_game_artefact.cpp
--- coc-1.4-xray-64/src/xrGame/cta_game_artefact.cpp	2023-10-20 20:54:51.029327500 +0100
+++ xray-monolith/src/xrGame/cta_game_artefact.cpp	2023-10-20 20:54:32.952035800 +0100
@@ -59,5 +62,5 @@
 
-void CtaGameArtefact::OnStateSwitch(u32 S)
+void CtaGameArtefact::OnStateSwitch(u32 S, u32 oldState)
 {
-	inherited::OnStateSwitch(S);
+	inherited::OnStateSwitch(S, oldState);
 	/*// just temporary (before we get huds for artefact activation)
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/cta_game_artefact.h xray-monolith/src/xrGame/cta_game_artefact.h
--- coc-1.4-xray-64/src/xrGame/cta_game_artefact.h	2023-10-20 20:54:51.030326900 +0100
+++ xray-monolith/src/xrGame/cta_game_artefact.h	2023-10-20 20:54:32.953037900 +0100
@@ -23,3 +24,3 @@
 	virtual		bool	Action						(s32 cmd, u32 flags);
-	virtual		void	OnStateSwitch				(u32 S);
+	virtual void OnStateSwitch(u32 S, u32 oldState);
 	virtual		void	OnAnimationEnd				(u32 state);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/CustomDetector.cpp xray-monolith/src/xrGame/CustomDetector.cpp
--- coc-1.4-xray-64/src/xrGame/CustomDetector.cpp	2023-10-20 20:54:50.586338200 +0100
+++ xray-monolith/src/xrGame/CustomDetector.cpp	2023-10-20 20:54:32.569035700 +0100
@@ -1,2 +1,2 @@
-#include "stdafx.h"
+ï»¿#include "stdafx.h"
 #include "customdetector.h"
@@ -27,168 +27,3 @@
 
-bool CCustomDetector::CheckCompatibilityInt(CHudItem* itm, u16* slot_to_activate)
-{
-	if(itm==NULL)
-		return true;
-
-	CInventoryItem& iitm			= itm->item();
-	u32 slot						= iitm.BaseSlot();
-	bool bres = (slot==INV_SLOT_2 || slot==KNIFE_SLOT || slot==BOLT_SLOT);
-	if(!bres && slot_to_activate)
-	{
-		*slot_to_activate	= NO_ACTIVE_SLOT;
-		if(m_pInventory->ItemFromSlot(BOLT_SLOT))
-			*slot_to_activate = BOLT_SLOT;
-
-		if(m_pInventory->ItemFromSlot(KNIFE_SLOT))
-			*slot_to_activate = KNIFE_SLOT;
-
-		if(m_pInventory->ItemFromSlot(INV_SLOT_3) && m_pInventory->ItemFromSlot(INV_SLOT_3)->BaseSlot()!=INV_SLOT_3)
-			*slot_to_activate = INV_SLOT_3;
-
-		if(m_pInventory->ItemFromSlot(INV_SLOT_2) && m_pInventory->ItemFromSlot(INV_SLOT_2)->BaseSlot()!=INV_SLOT_3)
-			*slot_to_activate = INV_SLOT_2;
-
-		if(*slot_to_activate != NO_ACTIVE_SLOT)
-			bres = true;
-	}
-
-	if(itm->GetState()!=CHUDState::eShowing)
-		bres = bres && !itm->IsPending();
-
-	if(bres)
-	{
-		CWeapon* W = smart_cast<CWeapon*>(itm);
-		if(W)
-			bres =	bres								&& 
-					(W->GetState()!=CHUDState::eBore)	&& 
-					(W->GetState()!=CWeapon::eReload) && 
-					(W->GetState()!=CWeapon::eSwitch) && 
-					!W->IsZoomed();
-	}
-	return bres;
-}
-
-bool  CCustomDetector::CheckCompatibility(CHudItem* itm)
-{
-	if(!inherited::CheckCompatibility(itm) )	
-		return false;
-
-	if(!CheckCompatibilityInt(itm, NULL))
-	{
-		HideDetector	(true);
-		return			false;
-	}
-	return true;
-}
-
-void CCustomDetector::HideDetector(bool bFastMode)
-{
-	if(GetState()==eIdle)
-		ToggleDetector(bFastMode);
-}
-
-void CCustomDetector::ShowDetector(bool bFastMode)
-{
-	if(GetState()==eHidden)
-		ToggleDetector(bFastMode);
-}
-
-void CCustomDetector::ToggleDetector(bool bFastMode)
-{
-	m_bNeedActivation		= false;
-	m_bFastAnimMode			= bFastMode;
-
-	if(GetState()==eHidden)
-	{
-		PIItem iitem = m_pInventory->ActiveItem();
-		CHudItem* itm = (iitem)?iitem->cast_hud_item():NULL;
-		u16 slot_to_activate = NO_ACTIVE_SLOT;
-
-		if(CheckCompatibilityInt(itm, &slot_to_activate))
-		{
-			if(slot_to_activate!=NO_ACTIVE_SLOT)
-			{
-				m_pInventory->Activate(slot_to_activate);
-				m_bNeedActivation		= true;
-			}else
-			{
-				SwitchState				(eShowing);
-				TurnDetectorInternal	(true);
-			}
-		}
-	}else
-	if(GetState()==eIdle)
-		SwitchState					(eHiding);
-
-}
-
-void CCustomDetector::OnStateSwitch(u32 S)
-{
-	inherited::OnStateSwitch(S);
-
-	switch(S)
-	{
-	case eShowing:
-		{
-			g_player_hud->attach_item	(this);
-			m_sounds.PlaySound			("sndShow", Fvector().set(0,0,0), this, true, false);
-			PlayHUDMotion				(m_bFastAnimMode?"anm_show_fast":"anm_show", FALSE/*TRUE*/, this, GetState());
-			SetPending					(TRUE);
-		}break;
-	case eHiding:
-		{
-			m_sounds.PlaySound			("sndHide", Fvector().set(0,0,0), this, true, false);
-			PlayHUDMotion				(m_bFastAnimMode?"anm_hide_fast":"anm_hide", FALSE/*TRUE*/, this, GetState());
-			SetPending					(TRUE);
-		}break;
-	case eIdle:
-		{
-			PlayAnimIdle				();
-			SetPending					(FALSE);
-		}break;
-}
-}
-
-void CCustomDetector::OnAnimationEnd(u32 state)
-{
-	inherited::OnAnimationEnd	(state);
-	switch(state)
-	{
-	case eShowing:
-		{
-			SwitchState					(eIdle);
-			if (IsUsingCondition() && m_fDecayRate > 0.f)
-			{
-				this->SetCondition(-m_fDecayRate);
-			}
-		} break;
-	case eHiding:
-		{
-			SwitchState					(eHidden);
-			TurnDetectorInternal		(false);
-			g_player_hud->detach_item	(this);
-		} break;
-	}
-}
-
-void CCustomDetector::UpdateXForm()
-{
-	CInventoryItem::UpdateXForm();
-}
-
-void CCustomDetector::OnActiveItem()
-{
-	return;
-}
-
-void CCustomDetector::OnHiddenItem()
-{
-}
-
-CCustomDetector::CCustomDetector() 
-{
-	m_ui				= NULL;
-	m_bFastAnimMode		= false;
-	m_bNeedActivation	= false;
-}
+CCustomDetector::CCustomDetector(){}
 
@@ -197,10 +32,2 @@
 	m_artefacts.destroy		();
-	TurnDetectorInternal	(false);
-	xr_delete				(m_ui);
-}
-
-BOOL CCustomDetector::net_Spawn(CSE_Abstract* DC) 
-{
-	TurnDetectorInternal(false);
-	return		(inherited::net_Spawn(DC));
 }
@@ -213,7 +40,3 @@
 	m_fAfVisRadius			= pSettings->r_float(section,"af_vis_radius");
-	m_fDecayRate = READ_IF_EXISTS(pSettings, r_float, section, "decay_rate", 0.f); //Alundaio
 	m_artefacts.load		(section, "af");
-
-	m_sounds.LoadSound( section, "snd_draw", "sndShow");
-	m_sounds.LoadSound( section, "snd_holster", "sndHide");
 }
@@ -225,5 +47,4 @@
 	
-	if( !IsWorking() )			return;
-
-	Position().set(H_Parent()->Position());
+	if (!IsWorking())
+		return;
 
@@ -232,5 +53,2 @@
 
-	if (IsUsingCondition() && GetCondition() <= 0.01f)
-		return;
-
 	m_artefacts.feel_touch_update(P,m_fAfDetectRadius);
@@ -238,68 +56,7 @@
 
-
-bool CCustomDetector::IsWorking()
-{
-	return m_bWorking && H_Parent() && H_Parent()==Level().CurrentViewEntity();
-}
-
-void CCustomDetector::UpfateWork()
+void CCustomDetector::UpdateWork()
 {
 	UpdateAf				();
-	m_ui->update			();
-}
-
-void CCustomDetector::UpdateVisibility()
-{
-	//check visibility
-	attachable_hud_item* i0		= g_player_hud->attached_item(0);
-	if(i0 && HudItemData())
-	{
-		bool bClimb			= ( (Actor()->MovingState()&mcClimb) != 0 );
-		if(bClimb)
-		{
-			HideDetector		(true);
-			m_bNeedActivation	= true;
-		}else
-		{
-			CWeapon* wpn			= smart_cast<CWeapon*>(i0->m_parent_hud_item);
-			if(wpn)
-			{
-				u32 state			= wpn->GetState();
-				if(wpn->IsZoomed() || state==CWeapon::eReload || state==CWeapon::eSwitch)
-				{
-					HideDetector		(true);
-					m_bNeedActivation	= true;
-				}
-			}
-		}
-	}else
-	if(m_bNeedActivation)
-	{
-		attachable_hud_item* i0		= g_player_hud->attached_item(0);
-		bool bClimb					= ( (Actor()->MovingState()&mcClimb) != 0 );
-		if(!bClimb)
-		{
-			CHudItem* huditem		= (i0)?i0->m_parent_hud_item : NULL;
-			bool bChecked			= !huditem || CheckCompatibilityInt(huditem, 0);
 			
-			if(	bChecked )
-				ShowDetector		(true);
-		}
-	}
-}
-
-void CCustomDetector::UpdateCL() 
-{
-	inherited::UpdateCL();
-
-	if(H_Parent()!=Level().CurrentEntity() )			return;
-
-	UpdateVisibility		();
-	if( !IsWorking() )		return;
-	UpfateWork				();
-}
-
-void CCustomDetector::OnH_A_Chield() 
-{
-	inherited::OnH_A_Chield		();
+	inherited::UpdateWork();
 }
@@ -313,41 +70,3 @@
 
-
-void CCustomDetector::OnMoveToRuck(const SInvItemPlace& prev)
-{
-	inherited::OnMoveToRuck	(prev);
-	if(prev.type==eItemPlaceSlot)
-	{
-		SwitchState					(eHidden);
-		g_player_hud->detach_item	(this);
-	}
-	TurnDetectorInternal			(false);
-	StopCurrentAnimWithoutCallback	();
-}
-
-void CCustomDetector::OnMoveToSlot(const SInvItemPlace& prev)
-{
-	inherited::OnMoveToSlot	(prev);
-}
-
-void CCustomDetector::TurnDetectorInternal(bool b)
-{
-	m_bWorking				= b;
-	if(b && m_ui==NULL)
-	{
-		CreateUI			();
-	}else
-	{
-//.		xr_delete			(m_ui);
-	}
-
-	UpdateNightVisionMode	(b);
-}
-
-
-
 #include "game_base_space.h"
-void CCustomDetector::UpdateNightVisionMode(bool b_on)
-{
-}
-
 bool CAfList::feel_touch_contact	(CObject* O)
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/CustomDetector.h xray-monolith/src/xrGame/CustomDetector.h
--- coc-1.4-xray-64/src/xrGame/CustomDetector.h	2023-10-20 20:54:50.586338200 +0100
+++ xray-monolith/src/xrGame/CustomDetector.h	2023-10-20 20:54:32.569035700 +0100
@@ -1,3 +1,3 @@
 #pragma once
-#include "inventory_item_object.h"
+#include "customdevice.h"
 #include "../xrEngine/feel_touch.h"
@@ -111,12 +120,5 @@
 
-class CUIArtefactDetectorBase;
-
-class CCustomDetector :		public CHudItemObject
+class CCustomDetector : public CCustomDevice
 {
-	typedef	CHudItemObject	inherited;
-protected:
-	CUIArtefactDetectorBase*			m_ui;
-	bool			m_bFastAnimMode;
-	bool			m_bNeedActivation;
-
+	typedef CCustomDevice inherited;
 public:
@@ -125,6 +127,4 @@
 
-	virtual BOOL 	net_Spawn			(CSE_Abstract* DC);
 	virtual void 	Load				(LPCSTR section);
 
-	virtual void 	OnH_A_Chield		();
 	virtual void 	OnH_B_Independent	(bool just_before_destroy);
@@ -132,21 +132,4 @@
 	virtual void 	shedule_Update		(u32 dt);
-	virtual void 	UpdateCL			();
-
 
-			bool 	IsWorking			();
-
-	virtual void 	OnMoveToSlot		(const SInvItemPlace& prev);
-	virtual void 	OnMoveToRuck		(const SInvItemPlace& prev);
-
-	virtual void	OnActiveItem		();
-	virtual void	OnHiddenItem		();
-	virtual void	OnStateSwitch		(u32 S);
-	virtual void	OnAnimationEnd		(u32 state);
-	virtual	void	UpdateXForm			();
-
-	void			ToggleDetector		(bool bFastMode);
-	void			HideDetector		(bool bFastMode);
-	void			ShowDetector		(bool bFastMode);
 	float			m_fAfDetectRadius;
-	virtual bool	CheckCompatibility	(CHudItem* itm);
 
@@ -154,14 +137,7 @@
 protected:
-			bool	CheckCompatibilityInt		(CHudItem* itm, u16* slot_to_activate);
-			void 	TurnDetectorInternal		(bool b);
-	void 			UpdateNightVisionMode		(bool b_off);
-	void			UpdateVisibility			();
-	virtual void	UpfateWork					();
+	virtual void UpdateWork();
 	virtual void 	UpdateAf					()				{};
-	virtual void 	CreateUI					()				{};
+	virtual void ResetUI(){};
 
-	bool			m_bWorking;
 	float			m_fAfVisRadius;
-	float			m_fDecayRate; //Alundaio
-
 	CAfList			m_artefacts;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/CustomMonster.cpp xray-monolith/src/xrGame/CustomMonster.cpp
--- coc-1.4-xray-64/src/xrGame/CustomMonster.cpp	2023-10-20 20:54:50.587326600 +0100
+++ xray-monolith/src/xrGame/CustomMonster.cpp	2023-10-20 20:54:32.571036600 +0100
@@ -742,6 +767,11 @@
 			movement().set_level_dest_vertex		(ai_location().level_vertex_id());
-		else {
+		else
+		{
 			Fvector									dest_position;
 			u32										level_vertex_id;
-			level_vertex_id							= movement().restrictions().accessible_nearest(ai().level_graph().vertex_position(ai_location().level_vertex_id()),dest_position);
+			level_vertex_id = movement().restrictions().accessible_nearest(
+				ai().level_graph().vertex_position(ai_location().level_vertex_id()),
+				dest_position);
+			if (level_vertex_id != (u32)-1 && movement().restrictions().accessible(level_vertex_id))
+			{
 			movement().set_level_dest_vertex		(level_vertex_id);
@@ -750,2 +780,3 @@
 	}
+	}
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/CustomOutfit.cpp xray-monolith/src/xrGame/CustomOutfit.cpp
--- coc-1.4-xray-64/src/xrGame/CustomOutfit.cpp	2023-10-20 20:54:50.588340400 +0100
+++ xray-monolith/src/xrGame/CustomOutfit.cpp	2023-10-20 20:54:32.572036100 +0100
@@ -98,3 +98,3 @@
 	m_fPowerLoss			= READ_IF_EXISTS(pSettings, r_float, section, "power_loss",    1.0f );
-	clamp					( m_fPowerLoss, 0.0f, 1.0f );
+	clamp(m_fPowerLoss, EPS, 1.0f);
 
@@ -112,3 +112,4 @@
 	m_artefact_count 		= READ_IF_EXISTS( pSettings, r_u32, section, "artefact_count", 0 );
-	clamp( m_artefact_count, (u32)0, (u32)5 );
+	//clamp(m_artefact_count, (u32)0, (u32)5);
+	m_artefact_count = _max(m_artefact_count, (u32)0);
 
@@ -116,2 +117,3 @@
 	bIsHelmetAvaliable		= !!READ_IF_EXISTS(pSettings, r_bool, section, "helmet_avaliable", true);
+	bIsBackpackAvaliable = !!READ_IF_EXISTS(pSettings, r_bool, section, "backpack_avaliable", true);
 
@@ -156,2 +158,5 @@
 {
+	if (strstr(Core.Params, "-dbgbullet"))
+		Msg("CCustomOutfit::HitThroughArmor hit_type=%d | unmodified hit_power=%f", (u32)hit_type, hit_power);
+
 	float NewHitPower = hit_power;
@@ -160,3 +165,3 @@
 		float ba = GetBoneArmor(element);
-		if(ba<0.0f)
+		if (ba <= 0.0f)
 			return NewHitPower;
@@ -164,22 +169,23 @@
 		float BoneArmor = ba*GetCondition();
-		if(/*!fis_zero(ba, EPS) && */(ap > BoneArmor))
-		{
-			//ïóëÿ ïðîáèëà áðîíü
-			if(!IsGameTypeSingle())
+		if (ap <= BoneArmor)
 			{
-				float hit_fraction = (ap - BoneArmor) / ap;
-				if(hit_fraction < m_boneProtection->m_fHitFracActor)
-					hit_fraction = m_boneProtection->m_fHitFracActor;
+			//ïóëÿ ÍÅ ïðîáèëà áðîíü
+			NewHitPower *= m_boneProtection->m_fHitFracActor;
+			//add_wound = false; 	//ðàíû íåò
 
-				NewHitPower *= hit_fraction;
-				NewHitPower *= m_boneProtection->getBoneProtection(element);
+			if (strstr(Core.Params, "-dbgbullet"))
+				Msg("CCustomOutfit::HitThroughArmor AP(%f) <= bone_armor(%f) [HitFracActor=%f] modified hit_power=%f",
+				    ap, BoneArmor, m_boneProtection->m_fHitFracActor, NewHitPower);
 			}
 
-			VERIFY(NewHitPower>=0.0f);
-		}
 		else
 		{
-			//ïóëÿ ÍÅ ïðîáèëà áðîíü
-			NewHitPower *= m_boneProtection->m_fHitFracActor;
-			add_wound = false; 	//ðàíû íåò
+			float d_hit_power = (ap - BoneArmor) / (ap * m_boneProtection->APScale);
+			clamp(d_hit_power, m_boneProtection->m_fHitFracActor, 1.0f);
+
+			NewHitPower *= d_hit_power;
+
+			if (strstr(Core.Params, "-dbgbullet"))
+				Msg("CCustomOutfit::HitThroughArmor AP(%f) > bone_armor(%f) [HitFracActor=%f] modified hit_power=%f",
+				    ap, BoneArmor, m_boneProtection->m_fHitFracActor, NewHitPower);
 		}
@@ -201,2 +207,6 @@
 			NewHitPower = 0.f;
+
+		if (strstr(Core.Params, "-dbgbullet"))
+			Msg("CCustomOutfit::HitThroughArmor hit_type=%d | After HitTypeProtection(%f) hit_power=%f", (u32)hit_type,
+			    protect * one, NewHitPower);
 	}
@@ -205,2 +215,5 @@
 
+	if (strstr(Core.Params, "-dbgbullet"))
+		Msg("CCustomOutfit::HitThroughArmor hit_type=%d | After Immunities hit_power=%f", (u32)hit_type, NewHitPower);
+
 	return NewHitPower;
@@ -224,5 +238,4 @@
 			{
-				CTorch* pTorch = smart_cast<CTorch*>(pActor->inventory().ItemFromSlot(TORCH_SLOT));
-				if(pTorch && pTorch->GetNightVisionStatus())
-					pTorch->SwitchNightVision(true, false);
+				if (pActor->GetNightVisionStatus())
+					pActor->SwitchNightVision(true, false);
 			}
@@ -231,2 +244,6 @@
 				pActor->inventory().Ruck(pHelmet, false);
+
+			PIItem pBackpack = pActor->inventory().ItemFromSlot(BACKPACK_SLOT);
+			if (pBackpack && !bIsBackpackAvaliable)
+				pActor->inventory().Ruck(pBackpack, false);
 		}
@@ -290,5 +307,4 @@
 			ApplySkinModel(pActor, false, false);
-			CTorch* pTorch = smart_cast<CTorch*>(pActor->inventory().ItemFromSlot(TORCH_SLOT));
-			if(pTorch && !bIsHelmetAvaliable)
-				pTorch->SwitchNightVision(false);
+			if (!bIsHelmetAvaliable)
+				pActor->SwitchNightVision(false);
 		}
@@ -350,3 +366,4 @@
 	result |= process_if_exists( section, "artefact_count", &CInifile::r_u32, m_artefact_count, test );
-	clamp( m_artefact_count, (u32)0, (u32)5 );
+	//clamp(m_artefact_count, (u32)0, (u32)5);
+	m_artefact_count = _max(m_artefact_count, (u32)0);
 
@@ -364 +381,6 @@
 }
+
+float CCustomOutfit::get_HitFracActor() const
+{
+	return m_boneProtection->m_fHitFracActor;
+}
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/CustomOutfit.h xray-monolith/src/xrGame/CustomOutfit.h
--- coc-1.4-xray-64/src/xrGame/CustomOutfit.h	2023-10-20 20:54:50.589326800 +0100
+++ xray-monolith/src/xrGame/CustomOutfit.h	2023-10-20 20:54:32.572036100 +0100
@@ -56,2 +57,3 @@
 	bool					bIsHelmetAvaliable;
+	bool bIsBackpackAvaliable;
 
@@ -59,2 +61,3 @@
 	virtual	BOOL			BonePassBullet			(int boneID);
+	float get_HitFracActor() const;
 	const shared_str&		GetFullIconName			() const	{ return m_full_icon_name; }
@@ -71,2 +74,8 @@
 	virtual bool			install_upgrade_impl( LPCSTR section, bool test );
+
+	DECLARE_SCRIPT_REGISTER_FUNCTION
 };
+
+add_to_type_list(CCustomOutfit)
+#undef script_type_list
+#define script_type_list save_type_list(CCustomOutfit)
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/CustomZone.cpp xray-monolith/src/xrGame/CustomZone.cpp
--- coc-1.4-xray-64/src/xrGame/CustomZone.cpp	2023-10-20 20:54:50.590326600 +0100
+++ xray-monolith/src/xrGame/CustomZone.cpp	2023-10-20 20:54:32.574037000 +0100
@@ -19,5 +19,8 @@
 #include "GamePersistent.h"
+#include "../../script_game_object.h"
 
 #define WIND_RADIUS (4*Radius())	//ðàññòîÿíèå äî àêòåðà, êîãäà ïîÿâëÿåòñÿ âåòåð 
-#define FASTMODE_DISTANCE (50.f)	//distance to camera from sphere, when zone switches to fast update sequence
+#define FASTMODE_DISTANCE (100.f)	//distance to camera from sphere, when zone switches to fast update sequence
+
+extern Fvector4 ps_ssfx_int_grass_params_1;
 
@@ -36,2 +39,3 @@
 	m_pIdleLAnim				= NULL;
+	m_pBlowLAnim = NULL;
 	
@@ -59,2 +63,3 @@
 {	
+	g_pGamePersistent->GrassBendersRemoveByIndex(grassbender_id);
 	m_idle_sound.destroy		();
@@ -96,2 +101,55 @@
 	
+	// -- Interactive Grass - IDLE
+	if (pSettings->line_exist(section, "bend_grass_idle_anim"))
+		m_BendGrass_idle_anim = pSettings->r_s8(section, "bend_grass_idle_anim");
+	else
+		m_BendGrass_idle_anim = -1;
+
+	if (pSettings->line_exist(section, "bend_grass_idle_str"))
+		m_BendGrass_idle_str = pSettings->r_float(section, "bend_grass_idle_str");
+	else
+		m_BendGrass_idle_str = 1.0f;
+
+	if (pSettings->line_exist(section, "bend_grass_idle_radius"))
+		m_BendGrass_idle_radius = pSettings->r_float(section, "bend_grass_idle_radius");
+	else
+		m_BendGrass_idle_radius = 1.0f;
+
+	if (pSettings->line_exist(section, "bend_grass_idle_speed"))
+		m_BendGrass_idle_speed = pSettings->r_float(section, "bend_grass_idle_speed");
+	else
+		m_BendGrass_idle_speed = 1.0f;
+
+	// -- Interactive Grass - ACTIVE
+	if (pSettings->line_exist(section, "bend_grass_whenactive_anim"))
+		m_BendGrass_whenactive_anim = pSettings->r_s8(section, "bend_grass_whenactive_anim");
+	else
+		m_BendGrass_whenactive_anim = -1;
+
+	if (pSettings->line_exist(section, "bend_grass_whenactive_speed"))
+		m_BendGrass_whenactive_speed = pSettings->r_float(section, "bend_grass_whenactive_speed");
+	else
+		m_BendGrass_whenactive_speed = -1;
+
+	if (pSettings->line_exist(section, "bend_grass_whenactive_str"))
+		m_BendGrass_whenactive_str = pSettings->r_float(section, "bend_grass_whenactive_str");
+	else
+		m_BendGrass_whenactive_str = -1;
+
+	// -- Interactive Grass - BLOWOUT
+	if (pSettings->line_exist(section, "bend_grass_blowout_duration"))
+		m_BendGrass_Blowout_time = pSettings->r_u32(section, "bend_grass_blowout_duration");
+	else
+		m_BendGrass_Blowout_time = -1;
+
+	if (pSettings->line_exist(section, "bend_grass_blowout"))
+		m_BendGrass_Blowout = pSettings->r_bool(section, "bend_grass_blowout");
+
+	if (pSettings->line_exist(section, "bend_grass_blowout_speed"))
+		m_BendGrass_Blowout_speed = pSettings->r_float(section, "bend_grass_blowout_speed");
+
+	if (pSettings->line_exist(section, "bend_grass_blowout_radius"))
+		m_BendGrass_Blowout_radius = pSettings->r_float(section, "bend_grass_blowout_radius");
+	// --
+
 	if(pSettings->line_exist(section,"idle_sound")) 
@@ -258,3 +325,5 @@
 		m_fLightTimeLeft		= 0;
-
+		LPCSTR light_anim = (READ_IF_EXISTS(pSettings, r_string, section, "blowout_light_anim", (0)));
+		if (light_anim)
+			m_pBlowLAnim = LALib.FindItem(light_anim);
 		m_fLightHeight		= pSettings->r_float(section,"light_height");
@@ -270,3 +339,8 @@
 		m_fIdleLightHeight		= pSettings->r_float(section,"idle_light_height");
+
 		m_zone_flags.set(eIdleLightVolumetric,pSettings->r_bool (section, "idle_light_volumetric") );
+		volumetric_distance = READ_IF_EXISTS(pSettings, r_float, section, "idle_light_volumetric_distance", .5f);
+		volumetric_intensity = READ_IF_EXISTS(pSettings, r_float, section, "idle_light_volumetric_intensity", .5f);
+		volumetric_quality = READ_IF_EXISTS(pSettings, r_float, section, "idle_light_volumetric_quality", .5f);
+
 		m_zone_flags.set(eIdleLightShadow,pSettings->r_bool (section, "idle_light_shadow") );
@@ -322,4 +396,7 @@
 		{
-			//m_pIdleLight->set_type				(IRender_Light::SPOT);
+			m_pIdleLight->set_type(IRender_Light::POINT);
 			m_pIdleLight->set_volumetric		(true);
+			m_pIdleLight->set_volumetric_distance(volumetric_distance);
+			m_pIdleLight->set_volumetric_intensity(volumetric_intensity);
+			m_pIdleLight->set_volumetric_quality(volumetric_quality);
 		}
@@ -463,3 +545,3 @@
 	{
-		Fvector P			= Device.vCameraPosition;
+		Fvector P = Level().CurrentControlEntity()->Position();
 		P.y					-= 0.9f;
@@ -529,2 +612,10 @@
 
+			// Ignore object override script callback
+			if (pEntityAlive)
+			{
+				luabind::functor<bool> funct;
+				if (ai().script_engine().functor("_G.CCustomZone_BeforeActivateCallback", funct))
+					info.zone_ignore = !funct(this->lua_game_object(), pObject->lua_game_object());
+			}
+
 			//åñëè åñòü õîòÿ áû îäèí íå äèñàáëåíûé îáúåêò, òî
@@ -541,5 +632,4 @@
 		// check "fast-mode" border
-		float	cam_distance	= Device.vCameraPosition.distance_to(P)-s.R;
-		
-		if (cam_distance>FASTMODE_DISTANCE && !m_zone_flags.test(eAlwaysFastmode) )	
+		float act_distance = Level().CurrentControlEntity()->Position().distance_to(P) - s.R;
+		if (act_distance > FASTMODE_DISTANCE && !m_zone_flags.test(eAlwaysFastmode))
 			o_switch_2_slow	();
@@ -551,2 +641,26 @@
 
+		if (act_distance < ps_ssfx_int_grass_params_1.w)
+			GrassZoneUpdate();
+		else
+		{
+			// Out of range, fadeOut if a grassbender_id is assigned
+			if (grassbender_id)
+			{
+				IGame_Persistent::grass_data& GData = g_pGamePersistent->grass_shader_data;
+
+				// If the ID doesn't match... Just remove the grassbender_id.
+				if (GData.id[grassbender_id] == ID())
+				{
+					GData.str_target[grassbender_id] += g_pGamePersistent->GrassBenderToValue(GData.str_target[grassbender_id], 0.0f, 4.0f, false);
+
+					// Remove ( Don't worry, GrassBenderToValue() it's going to get the == 0 )
+					if (GData.str_target[grassbender_id] == 0)
+						g_pGamePersistent->GrassBendersRemoveByIndex(grassbender_id);
+				}
+				else
+				{
+					grassbender_id = NULL;
+				}
+			}
+		}
 	};
@@ -659,4 +773,14 @@
 
+void CCustomZone::ChangeIdleParticles(LPCSTR name, bool bIdleLight)
+{
+	StopIdleParticles(true);
+	m_sIdleParticles = name;
+	PlayIdleParticles(bIdleLight);
+}
+
 void CCustomZone::PlayIdleParticles(bool bIdleLight)
 {
+	if (!m_zone_flags.test(eFastMode)) return;
+
+	if (!m_idle_sound._feedback())
 	m_idle_sound.play_at_pos(0, Position(), true);
@@ -695,2 +819,3 @@
 {
+	if (!m_zone_flags.test(eFastMode)) return;
 	if(m_pIdleLight)
@@ -712,2 +838,3 @@
 {
+	if (!m_zone_flags.test(eFastMode)) return;
 	if(!m_pIdleLight || !m_pIdleLight->get_active())
@@ -736,2 +863,3 @@
 	if(!m_sBlowoutParticles) return;
+	if (!m_zone_flags.test(eFastMode)) return;
 
@@ -741,2 +869,4 @@
 	pParticles->Play(false);
+
+	m_fBlowoutTimeLeft = (float)Device.dwTimeGlobal + m_BendGrass_Blowout_time;
 }
@@ -745,2 +875,3 @@
 {
+	if (!m_zone_flags.test(eFastMode)) return;
 	m_hit_sound.play_at_pos(0, pObject->Position());
@@ -771,4 +904,6 @@
 #include "bolt.h"
+
 void CCustomZone::PlayEntranceParticles(CGameObject* pObject)
 {
+	if (!m_zone_flags.test(eFastMode)) return;
 	m_entrance_sound.play_at_pos		(0, pObject->Position());
@@ -829,3 +964,3 @@
 {
-
+	if (!m_zone_flags.test(eFastMode)) return;
 	CCF_Shape* Sh		= (CCF_Shape*)CFORM();
@@ -889,2 +1023,3 @@
 {
+	if (!m_zone_flags.test(eFastMode)) return;
 	m_entrance_sound.play_at_pos(0, pos);
@@ -973,2 +1108,3 @@
 {
+	if (!m_zone_flags.test(eFastMode)) return;
 	if(!m_pLight || m_fLightTime<=0.f) return;
@@ -995,2 +1130,3 @@
 {
+	if (!m_zone_flags.test(eFastMode)) return;
 	if(m_fLightTimeLeft > (float)Device.dwTimeGlobal)
@@ -1005,6 +1141,16 @@
 		float r			= m_fLightRange*scale;
+
+		if (m_pBlowLAnim)
+		{
+			int frame = 0;
+			u32 clr = m_pBlowLAnim->CalculateBGR(Device.fTimeGlobal, frame);
+			Fcolor fclr;
+			fclr.set((float)color_get_B(clr) / 255.f, (float)color_get_G(clr) / 255.f, (float)color_get_R(clr) / 255.f,
+			         1.f);
+			m_pLight->set_color(fclr);
+		}
+		else
+			m_pLight->set_color(m_LightColor.r * scale, m_LightColor.g * scale, m_LightColor.b * scale);
+
 		VERIFY(_valid(r));
-		m_pLight->set_color(m_LightColor.r*scale, 
-							m_LightColor.g*scale, 
-							m_LightColor.b*scale);
 		m_pLight->set_range(r);
@@ -1040,2 +1186,3 @@
 {
+	if (!m_zone_flags.test(eFastMode)) return;
 	if(m_dwBlowoutParticlesTime>=(u32)m_iPreviousStateTime && 
@@ -1063,2 +1210,5 @@
 		AffectObjects();
+		
+		if (m_BendGrass_Blowout)
+			g_pGamePersistent->GrassBendersAddExplosion(ID(), Position(), Fvector().set(0, -99, 0), 1.33f, m_BendGrass_Blowout_speed, 1.0f, m_BendGrass_Blowout_radius);
 	}
@@ -1096,3 +1246,17 @@
 			m_pIdleLight->set_position(Position());
+
+		if (grassbender_id)
+		{
+			// Check ID, just in case...
+			if (g_pGamePersistent->grass_shader_data.id[grassbender_id] == ID())
+				g_pGamePersistent->grass_shader_data.pos[grassbender_id] = Position();
+		}
+	}
      }
+
+void CCustomZone::MoveScript(Fvector pos)
+{
+	XFORM().translate_over(pos);
+
+	OnMove();
 }
@@ -1311,2 +1477,3 @@
 {
+	if (!m_zone_flags.test(eFastMode)) return;
 	if(m_sAccumParticles.size())
@@ -1325,2 +1492,3 @@
 {
+	if (!m_zone_flags.test(eFastMode)) return;
 	if(m_sAwakingParticles.size())
@@ -1491,2 +1659,3 @@
 	StartIdleLight();
+	PlayIdleParticles(true);
 	processing_activate			();
@@ -1502,2 +1671,3 @@
 	}
+	StopIdleParticles(true);
 	processing_deactivate		();
@@ -1522 +1692,59 @@
 }
\ No newline at end of file
+
+void CCustomZone::GrassZoneUpdate()
+{
+	if (m_BendGrass_idle_anim == -1 && m_BendGrass_whenactive_anim == -1)
+		return;
+
+	IGame_Persistent::grass_data& GData = g_pGamePersistent->grass_shader_data;
+	bool IsActive;
+	s8 targetAnim = -1;
+
+	// If m_BendGrass_Blowout_time is not set, use m_eZoneState to detect activation
+	if (m_BendGrass_Blowout_time <= -1)
+		IsActive = m_eZoneState != eZoneStateIdle;
+	else
+		IsActive = m_fBlowoutTimeLeft > (float)Device.dwTimeGlobal;
+
+	// Target animation depending if Zone is active
+	if (IsActive)
+		targetAnim = (m_BendGrass_whenactive_anim > -1) ? m_BendGrass_whenactive_anim : m_BendGrass_idle_anim;
+	else
+		targetAnim = m_BendGrass_idle_anim;
+
+	// Update grass bender if the animation is > -1
+	if (targetAnim > 0 || (grassbender_id > 0 && GData.anim[grassbender_id] > 0))
+		g_pGamePersistent->GrassBendersUpdate(ID(), grassbender_id, grassbender_frame, Position(), m_BendGrass_idle_radius, 0.0f, false);
+	else
+		g_pGamePersistent->GrassBendersRemoveByIndex(grassbender_id);
+
+	// Return if grassbender_id doesn't exist
+	if (grassbender_id <= 0)
+		return;
+
+	// Animation transition, diminish intensity to 0 and change.
+	if (GData.anim[grassbender_id] != targetAnim)
+	{
+		GData.str_target[grassbender_id] += g_pGamePersistent->GrassBenderToValue(GData.str_target[grassbender_id], 0.0f, 7.5f, false);
+
+		if (GData.str_target[grassbender_id] <= 0.05f)
+			GData.anim[grassbender_id] = targetAnim;
+
+		return;
+	}
+
+	// Apply settings when needed
+	if (IsActive)
+	{
+		if (m_BendGrass_whenactive_speed >= 0)
+			GData.speed[grassbender_id] += g_pGamePersistent->GrassBenderToValue(GData.speed[grassbender_id], m_BendGrass_whenactive_speed, 10.0f, true);
+
+		if (m_BendGrass_whenactive_str >= 0)
+			GData.str_target[grassbender_id] += g_pGamePersistent->GrassBenderToValue(GData.str_target[grassbender_id], m_BendGrass_whenactive_str, 10.0f, true);
+	}
+	else
+	{
+		GData.speed[grassbender_id] += g_pGamePersistent->GrassBenderToValue(GData.speed[grassbender_id], m_BendGrass_idle_speed, 10.0f, true);
+		GData.str_target[grassbender_id] += g_pGamePersistent->GrassBenderToValue(GData.str_target[grassbender_id], m_BendGrass_idle_str, 10.0f, true);
+	}
+}
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/CustomZone.h xray-monolith/src/xrGame/CustomZone.h
--- coc-1.4-xray-64/src/xrGame/CustomZone.h	2023-10-20 20:54:50.590326600 +0100
+++ xray-monolith/src/xrGame/CustomZone.h	2023-10-20 20:54:32.574037000 +0100
@@ -4,2 +4,3 @@
 #include "../xrEngine/feel_touch.h"
+#include "script_export_space.h"
 
@@ -71,2 +76,5 @@
 
+	float GetEffectiveRadius() { return m_fEffectiveRadius; }
+	void SetEffectiveRadius(float p) { m_fEffectiveRadius = p; }
+
 	//âû÷èñëåíèå ñèëû õèòà â çàâèñèìîñòè îò ðàññòîÿíèÿ äî öåíòðà çîíû
@@ -142,2 +157,28 @@
 
+	float volumetric_distance;
+	float volumetric_intensity;
+	float volumetric_quality;
+
+	// Interactive grass Settings
+	float m_fBlowoutTimeLeft;
+
+	s8 m_BendGrass_idle_anim;
+	float m_BendGrass_idle_radius;
+	float m_BendGrass_idle_speed;
+	float m_BendGrass_idle_str;
+
+	s8 m_BendGrass_whenactive_anim;
+	float m_BendGrass_whenactive_speed;
+	float m_BendGrass_whenactive_str;
+
+	bool m_BendGrass_Blowout;
+	s32 m_BendGrass_Blowout_time;
+	float m_BendGrass_Blowout_speed;
+	float m_BendGrass_Blowout_radius;
+
+	u8 grassbender_id;
+	u32 grassbender_frame;
+
+	void GrassZoneUpdate();
+
 	//ìàññèâ ñ âðåìåíàìè, ñêîëüêî êàæäîå ñîñòîÿíèå äîëæíî 
@@ -168,2 +211,4 @@
 				void		ZoneDisable					();
+	void ChangeIdleParticles(LPCSTR name, bool bIdleLight);
+	void MoveScript(Fvector pos);
 	EZoneState				ZoneState					() {return m_eZoneState;}
@@ -249,2 +296,3 @@
 	CLAItem*				m_pIdleLAnim;
+	CLAItem* m_pBlowLAnim;
 
@@ -327,2 +375,7 @@
 
+	DECLARE_SCRIPT_REGISTER_FUNCTION
 };
+
+add_to_type_list(CCustomZone)
+#undef script_type_list
+#define script_type_list save_type_list(CCustomZone)
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/data_storage_binary_heap_inline.h xray-monolith/src/xrGame/data_storage_binary_heap_inline.h
--- coc-1.4-xray-64/src/xrGame/data_storage_binary_heap_inline.h	2023-10-20 20:54:51.038326900 +0100
+++ xray-monolith/src/xrGame/data_storage_binary_heap_inline.h	2023-10-20 20:54:32.960035100 +0100
@@ -70,3 +72,4 @@
 	VERIFY					(!is_opened_empty());
-	for (CGraphVertex **i = m_heap_head; *i != &vertex; ++i);
+	CGraphVertex** i = m_heap_head;
+	for (; *i != &vertex; ++i);
 	std::push_heap			(m_heap_head,i + 1,CGraphNodePredicate());
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/death_anims.cpp xray-monolith/src/xrGame/death_anims.cpp
--- coc-1.4-xray-64/src/xrGame/death_anims.cpp	2023-10-20 20:54:51.042327000 +0100
+++ xray-monolith/src/xrGame/death_anims.cpp	2023-10-20 20:54:32.964035900 +0100
@@ -22,2 +21,3 @@
 
+	R_ASSERT(xr_strlen(s) < sizeof(string1024)); // loop var 'n'
 	const u16 nb =( u16 )_GetItemCount( s );
@@ -25,3 +25,3 @@
 	{
-		string64 n;
+		string1024 n;
 		_GetItem( s, i, n );
@@ -89,3 +89,3 @@
 		}
-		R_ASSERT( xr_strlen( line ) < 1023 );
+		R_ASSERT(xr_strlen( line ) < sizeof(string1024)); // loop var 'sdir_anim'
 		const int num = _GetItemCount( line, '/' );
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/death_anims_predicates.cpp xray-monolith/src/xrGame/death_anims_predicates.cpp
--- coc-1.4-xray-64/src/xrGame/death_anims_predicates.cpp	2023-10-20 20:54:51.043326800 +0100
+++ xray-monolith/src/xrGame/death_anims_predicates.cpp	2023-10-20 20:54:32.964035900 +0100
@@ -8,2 +8,3 @@
 #include	"weaponshotgun.h"
+#include	"WeaponAutomaticShotgun.h"
 #include	"explosive.h"
@@ -180,4 +180,7 @@
 		CWeaponShotgun* s = smart_cast< CWeaponShotgun* >( static_cast<CGameObject*>(O) );
+		if (!s) {
+			CWeaponAutomaticShotgun* s = smart_cast<CWeaponAutomaticShotgun*>(static_cast<CGameObject*>(O));
 		if(!s)
 			return false;
+		}		
 		Fvector p;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/debug_renderer.cpp xray-monolith/src/xrGame/debug_renderer.cpp
--- coc-1.4-xray-64/src/xrGame/debug_renderer.cpp	2023-10-20 20:54:51.044326800 +0100
+++ xray-monolith/src/xrGame/debug_renderer.cpp	2023-10-20 20:54:32.965035700 +0100
@@ -9,11 +9,10 @@
 #include "stdafx.h"
-#ifdef DEBUG
 #	include "debug_renderer.h"
 
-void CDebugRenderer::add_lines		(Fvector const *vertices, u32 const &vertex_count, u16 const *pairs, u32 const &pair_count, u32 const &color)
+void CDebugRenderer::add_lines		(Fvector const *vertices, u32 const &vertex_count, u16 const *pairs, u32 const &pair_count, u32 const &color, bool bHud)
 {
-	DRender->add_lines				(vertices, vertex_count, pairs, pair_count, color);
+	DRender->add_lines				(vertices, vertex_count, pairs, pair_count, color, bHud);
 }
 
-void CDebugRenderer::draw_obb		(const Fmatrix &matrix, const u32 &color)
+void CDebugRenderer::draw_obb		(const Fmatrix &matrix, const u32 &color, bool bHud)
 {
@@ -33,6 +32,6 @@
 
-	add_lines						(aabb, sizeof(aabb)/sizeof(Fvector), &aabb_id[0], sizeof(aabb_id)/(2*sizeof(u16)), color);
+	add_lines						(aabb, sizeof(aabb)/sizeof(Fvector), &aabb_id[0], sizeof(aabb_id)/(2*sizeof(u16)), color, bHud);
 }
 
-void CDebugRenderer::draw_obb		(const Fmatrix &matrix, const Fvector &half_size, const u32 &color)
+void CDebugRenderer::draw_obb		(const Fmatrix &matrix, const Fvector &half_size, const u32 &color, bool bHud)
 {
@@ -43,6 +42,6 @@
 
-	draw_obb						(mL2W_Transform,color);
+	draw_obb						(mL2W_Transform,color,bHud);
 }
 
-void CDebugRenderer::draw_ellipse	(const Fmatrix &matrix, const u32 &color)
+void CDebugRenderer::draw_ellipse	(const Fmatrix &matrix, const u32 &color, bool bHud)
 {
@@ -137,4 +136,3 @@
 
-	add_lines						((Fvector*)&vertices[0], sizeof(vertices)/sizeof(Fvector), &pairs[0], sizeof(pairs)/(2*sizeof(u16)), color);
+	add_lines						((Fvector*)&vertices[0], sizeof(vertices)/sizeof(Fvector), &pairs[0], sizeof(pairs)/(2*sizeof(u16)), color, bHud);
 }
-#endif // DEBUG
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/debug_renderer.h xray-monolith/src/xrGame/debug_renderer.h
--- coc-1.4-xray-64/src/xrGame/debug_renderer.h	2023-10-20 20:54:51.044326800 +0100
+++ xray-monolith/src/xrGame/debug_renderer.h	2023-10-20 20:54:32.966035700 +0100
@@ -9,5 +9,2 @@
 #pragma once
-
-#ifdef DEBUG
-
 #include "../Include/xrRender/DebugRender.h"
@@ -16,3 +13,3 @@
 private:
-			void	add_lines		(Fvector const *vertices, u32 const &vertex_count, u16 const *pairs, u32 const &pair_count, u32 const &color);
+			void	add_lines		(Fvector const *vertices, u32 const &vertex_count, u16 const *pairs, u32 const &pair_count, u32 const &color, bool bHud);
 public:
@@ -21,7 +18,7 @@
 public:
-	IC		void	draw_line		(const Fmatrix &matrix, const Fvector &vertex0, const Fvector &vertex1, const u32 &color);
-	IC		void	draw_aabb		(const Fvector &center, const float &half_radius_x, const float &half_radius_y, const float &half_radius_z, const u32 &color);
-			void	draw_obb		(const Fmatrix &matrix, const u32 &color);
-			void	draw_obb		(const Fmatrix &matrix, const Fvector &half_size, const u32 &color);
-			void	draw_ellipse	(const Fmatrix &matrix, const u32 &color);
+	IC		void	draw_line		(const Fmatrix &matrix, const Fvector &vertex0, const Fvector &vertex1, const u32 &color, bool bHud);
+	IC		void	draw_aabb		(const Fvector &center, const float &half_radius_x, const float &half_radius_y, const float &half_radius_z, const u32 &color, bool bHud);
+			void	draw_obb		(const Fmatrix &matrix, const u32 &color, bool bHud);
+			void	draw_obb		(const Fmatrix &matrix, const Fvector &half_size, const u32 &color, bool bHud);
+			void	draw_ellipse	(const Fmatrix &matrix, const u32 &color, bool bHud);
 };
@@ -29,3 +26 @@
 #include "debug_renderer_inline.h"
-
-#endif // DEBUG
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/debug_renderer_inline.h xray-monolith/src/xrGame/debug_renderer_inline.h
--- coc-1.4-xray-64/src/xrGame/debug_renderer_inline.h	2023-10-20 20:54:51.044326800 +0100
+++ xray-monolith/src/xrGame/debug_renderer_inline.h	2023-10-20 20:54:32.966035700 +0100
@@ -15,3 +15,4 @@
 
-IC	void CDebugRenderer::draw_line	(const Fmatrix &matrix, const Fvector &vertex0, const Fvector &vertex1, const u32 &color)
+IC void CDebugRenderer::draw_line(const Fmatrix& matrix, const Fvector& vertex0, const Fvector& vertex1,
+                                  const u32& color, bool bHud)
 {
@@ -19,6 +20,8 @@
 	u16					indices[2] = { 0, 1};
-	add_lines			(&vertices[0], sizeof(vertices)/sizeof(Fvector), &indices[0], sizeof(indices)/(2*sizeof(u16)), color);
+	add_lines(&vertices[0], sizeof(vertices) / sizeof(Fvector), &indices[0], sizeof(indices) / (2 * sizeof(u16)),
+	          color, bHud);
 }
 
-IC	void CDebugRenderer::draw_aabb	(const Fvector &center, const float &half_radius_x, const float &half_radius_y, const float &half_radius_z, const u32 &color)
+IC void CDebugRenderer::draw_aabb(const Fvector& center, const float& half_radius_x, const float& half_radius_y,
+                                  const float& half_radius_z, const u32& color, bool bHud)
 {
@@ -30,3 +33,3 @@
 
-	draw_obb			(matrix,half_radius,color);	
+	draw_obb(matrix, half_radius, color, bHud);
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/DestroyablePhysicsObject.cpp xray-monolith/src/xrGame/DestroyablePhysicsObject.cpp
--- coc-1.4-xray-64/src/xrGame/DestroyablePhysicsObject.cpp	2023-10-20 20:54:50.595326700 +0100
+++ xray-monolith/src/xrGame/DestroyablePhysicsObject.cpp	2023-10-20 20:54:32.579035800 +0100
@@ -53,2 +55,4 @@
 	BOOL res=inherited::net_Spawn(DC);
+	if (!res) return FALSE;
+
 	IKinematics		*K=smart_cast<IKinematics*>(Visual());
@@ -97,5 +103,8 @@
 }
+
 void CDestroyablePhysicsObject::Destroy()
 {
+#ifdef DEBUG
 	VERIFY(!physics_world()->Processing());
+#endif
 	const CGameObject *who_object = smart_cast<const CGameObject*>(FatalHit().initiator());
@@ -119,7 +130,10 @@
 		{
-			do {
+			do
+			{
 				hdir.random_dir();
-			} while(fsimilar(_abs(m.j.dotproduct(hdir)),1.f,EPS_L));
 		}
-		m.i.crossproduct(m.j,hdir);m.i.normalize();
+			while (fsimilar(_abs(m.j.dotproduct(hdir)), 1.f, EPS_L));
+		}
+		m.i.crossproduct(m.j, hdir);
+		m.i.normalize();
 		m.k.crossproduct(m.i,m.j);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/detail_path_manager_smooth.cpp xray-monolith/src/xrGame/detail_path_manager_smooth.cpp
--- coc-1.4-xray-64/src/xrGame/detail_path_manager_smooth.cpp	2023-10-20 20:54:51.047326700 +0100
+++ xray-monolith/src/xrGame/detail_path_manager_smooth.cpp	2023-10-20 20:54:32.969035800 +0100
@@ -772,8 +841,13 @@
 
-	for (int i=1, n=(int)m_key_points.size() - 1; i < n; ++i) {
-		STravelPoint		key_point0 = compute_better_key_point(m_key_points[i-1],m_key_points[i],m_key_points[i+1],false);
-		STravelPoint		key_point1 = compute_better_key_point(m_key_points[i+1],m_key_points[i],m_key_points[i-1],true);
+	for (int i = 1, n = (int)m_key_points.size() - 1; i < n; ++i)
+	{
+		STravelPoint key_point0 = compute_better_key_point(m_key_points[i - 1], m_key_points[i], m_key_points[i + 1],
+		                                                   false);
+		STravelPoint key_point1 = compute_better_key_point(m_key_points[i + 1], m_key_points[i], m_key_points[i - 1],
+		                                                   true);
+		{
+			u32 vertex_id = ai().level_graph().check_position_in_direction(
+				m_key_points[i - 1].vertex_id, m_key_points[i - 1].position, key_point0.position);
+			if (!ai().level_graph().valid_vertex_id(vertex_id))
 		{
-			u32				vertex_id = ai().level_graph().check_position_in_direction(m_key_points[i-1].vertex_id,m_key_points[i-1].position,key_point0.position);
-			if (!ai().level_graph().valid_vertex_id(vertex_id)) {
 				vertex_id	= vertex_id;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/eatable_item.cpp xray-monolith/src/xrGame/eatable_item.cpp
--- coc-1.4-xray-64/src/xrGame/eatable_item.cpp	2023-10-20 20:54:51.052326700 +0100
+++ xray-monolith/src/xrGame/eatable_item.cpp	2023-10-20 20:54:32.974036700 +0100
@@ -55,3 +55,3 @@
 		if (m_iMaxUses > 0)
-			SetCondition((float)(m_iRemainingUses / m_iMaxUses));
+			SetCondition(1);
 		else
@@ -83,3 +83,3 @@
 		if (m_iMaxUses > 0)
-			SetCondition((float)(m_iRemainingUses / m_iMaxUses));
+			SetCondition(1);
 		else
@@ -166,3 +168,3 @@
 		if (m_iMaxUses > 0)
-			SetCondition((float)(m_iRemainingUses / m_iMaxUses));
+			SetCondition(1);
 		else
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/eatable_item.h xray-monolith/src/xrGame/eatable_item.h
--- coc-1.4-xray-64/src/xrGame/eatable_item.h	2023-10-20 20:54:51.052326700 +0100
+++ xray-monolith/src/xrGame/eatable_item.h	2023-10-20 20:54:32.974036700 +0100
@@ -8,2 +8,3 @@
 #include "inventory_item.h"
+#include "script_export_space.h"
 
@@ -48,2 +50,8 @@
 		virtual float Weight() const;
+
+	DECLARE_SCRIPT_REGISTER_FUNCTION
 };
\ No newline at end of file
+
+add_to_type_list(CEatableItem)
+#undef script_type_list
+#define script_type_list save_type_list(CEatableItem)
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/eatable_item_object.cpp xray-monolith/src/xrGame/eatable_item_object.cpp
--- coc-1.4-xray-64/src/xrGame/eatable_item_object.cpp	2023-10-20 20:54:51.053326400 +0100
+++ xray-monolith/src/xrGame/eatable_item_object.cpp	2023-10-20 20:54:32.975038200 +0100
@@ -103,3 +103,3 @@
 	BOOL								res = CPhysicItem::net_Spawn(DC);
-	CEatableItem::net_Spawn			(DC);
+	res &= CEatableItem::net_Spawn(DC);
 	return								(res);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/eatable_item_object.h xray-monolith/src/xrGame/eatable_item_object.h
--- coc-1.4-xray-64/src/xrGame/eatable_item_object.h	2023-10-20 20:54:51.053326400 +0100
+++ xray-monolith/src/xrGame/eatable_item_object.h	2023-10-20 20:54:32.975038200 +0100
@@ -29,2 +29,3 @@
 	virtual CMissile			*cast_missile				()	{return 0;}
+	virtual CFlashlight* cast_flashlight() { return 0; }
 	virtual CHudItem			*cast_hud_item				()	{return 0;}
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/edge_path_inline.h xray-monolith/src/xrGame/edge_path_inline.h
--- coc-1.4-xray-64/src/xrGame/edge_path_inline.h	2023-10-20 20:54:51.054326700 +0100
+++ xray-monolith/src/xrGame/edge_path_inline.h	2023-10-20 20:54:32.976036700 +0100
@@ -45,3 +45,4 @@
 	CGraphVertex			*t1 = best, *t2 = best->back();
-	for (u32 i=1; t2; t1 = t2, t2 = t2->back(), ++i) ;
+	u32 i = 1;
+	for (; t2; t1 = t2, t2 = t2->back(), ++i);
 	u32						n = (u32)path.size(); 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ef_pattern.cpp xray-monolith/src/xrGame/ef_pattern.cpp
--- coc-1.4-xray-64/src/xrGame/ef_pattern.cpp	2023-10-20 20:54:51.054326700 +0100
+++ xray-monolith/src/xrGame/ef_pattern.cpp	2023-10-20 20:54:32.977035900 +0100
@@ -86,3 +89,4 @@
 	m_dwParameterCount = 0;
-	for ( i=0; i<m_dwPatternCount; ++i) {
+	for (u32 i = 0; i < m_dwPatternCount; ++i)
+	{
 		if (i)
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ef_pattern.h xray-monolith/src/xrGame/ef_pattern.h
--- coc-1.4-xray-64/src/xrGame/ef_pattern.h	2023-10-20 20:54:51.055326900 +0100
+++ xray-monolith/src/xrGame/ef_pattern.h	2023-10-20 20:54:32.977035900 +0100
@@ -40,4 +44,6 @@
 		SPattern &tPattern = m_tpPatterns[iPatternIndex];
-		for (u32 i=1, dwIndex = dwpTest[tPattern.dwaVariableIndexes[0]]; i<(int)tPattern.dwCardinality; ++i)
-			dwIndex = dwIndex*m_dwaAtomicFeatureRange[tPattern.dwaVariableIndexes[i]] + dwpTest[tPattern.dwaVariableIndexes[i]];
+		u32 dwIndex = dwpTest[tPattern.dwaVariableIndexes[0]];
+		for (u32 i = 1; i < (int)tPattern.dwCardinality; ++i)
+			dwIndex = dwIndex * m_dwaAtomicFeatureRange[tPattern.dwaVariableIndexes[i]] + dwpTest[tPattern.
+				dwaVariableIndexes[i]];
 		return(dwIndex + m_dwaPatternIndexes[iPatternIndex]);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/EffectorBobbing.cpp xray-monolith/src/xrGame/EffectorBobbing.cpp
--- coc-1.4-xray-64/src/xrGame/EffectorBobbing.cpp	2023-10-20 20:54:50.597328100 +0100
+++ xray-monolith/src/xrGame/EffectorBobbing.cpp	2023-10-20 20:54:32.581035400 +0100
@@ -48,3 +48,3 @@
 
-
+extern float g_head_bob_factor;
 BOOL CEffectorBobbing::ProcessCam(SCamEffectorInfo& info)
@@ -89,4 +93,4 @@
 	
-		float _sinA	= _abs(_sin(ST)*A)*fReminderFactor;
-		float _cosA	= _cos(ST)*A*fReminderFactor;
+		float _sinA = _abs(_sin(ST) * A) * fReminderFactor * g_head_bob_factor;
+		float _cosA = _cos(ST) * A * fReminderFactor * g_head_bob_factor;
 
@@ -111 +115,61 @@
 }
+
+// demonized: First Person Death (Cam Effector, can be used in scripts any time to set custom position and direction)
+CFPCamEffector::CFPCamEffector() : CEffectorCam(eCEUser, INT_MAX) {
+	m_Camera.identity();
+	m_Camera.setHPB(0, 0, 0);
+	m_HPB.set(0, 0, 0);
+	m_Position.set(0, 0, 0);
+	m_customSmoothing = 0;
+	hudEnabled = false;
+}
+
+// EMA smoothing for changing values, frame independent
+int firstPersonDeathPositionSmoothing = 6;
+int firstPersonDeathDirectionSmoothing = 12;
+
+void CFPCamEffector::ema(Fvector &current, Fvector &target, unsigned int steps) {
+	float smoothing_alpha = 2.0 / (steps + 1);
+	float delta = Device.dwTimeDelta;
+
+	if (fis_zero(current.x) && fis_zero(current.y) && fis_zero(current.z)) {
+		current.x = target.x;
+		current.y = target.y;
+		current.z = target.z;
+		return;
+	}
+
+	current.x = current.x + min(1.f, smoothing_alpha * (delta / steps)) * (target.x - current.x);
+	current.y = current.y + min(1.f, smoothing_alpha * (delta / steps)) * (target.y - current.y);
+	current.z = current.z + min(1.f, smoothing_alpha * (delta / steps)) * (target.z - current.z);
+}
+
+BOOL CFPCamEffector::ProcessCam(SCamEffectorInfo& info)
+{
+	// Set target camera
+	Fmatrix temp;
+	temp.identity().setHPB(m_HPB.x, m_HPB.y, m_HPB.z).translate_over(m_Position);
+
+	// Smooth out transition between current camera and target
+	if (m_customSmoothing) {
+		if (m_customSmoothing > 1) {
+			ema(m_Camera.j, temp.j, m_customSmoothing);
+			ema(m_Camera.k, temp.k, m_customSmoothing);
+			ema(m_Camera.c, temp.c, m_customSmoothing);
+		} else {
+			m_Camera.j = temp.j;
+			m_Camera.k = temp.k;
+			m_Camera.c = temp.c;
+		}
+	} else {
+		ema(m_Camera.j, temp.j, firstPersonDeathDirectionSmoothing);
+		ema(m_Camera.k, temp.k, firstPersonDeathDirectionSmoothing);
+		ema(m_Camera.c, temp.c, firstPersonDeathPositionSmoothing);
+	}
+
+	// update camera
+	info.n.set(m_Camera.j);
+	info.d.set(m_Camera.k);
+	info.p.set(m_Camera.c);
+	return TRUE;
+}
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/EffectorBobbing.h xray-monolith/src/xrGame/EffectorBobbing.h
--- coc-1.4-xray-64/src/xrGame/EffectorBobbing.h	2023-10-20 20:54:50.597328100 +0100
+++ xray-monolith/src/xrGame/EffectorBobbing.h	2023-10-20 20:54:32.581035400 +0100
@@ -35 +35,18 @@
 #endif //_EFFECTOR_BOBBING_H
+
+// demonized: First Person Death Cam Effector
+class CFPCamEffector : public CEffectorCam
+{
+public:
+	Fvector m_Position;
+	Fvector m_HPB;
+	Fmatrix m_Camera;
+	bool hudEnabled = false;
+	unsigned int m_customSmoothing; // 0 - use FPDeath smoothing params, no custom smoothing
+	virtual void ema(Fvector& current, Fvector& target, unsigned int steps);
+	
+public:
+	CFPCamEffector();
+	virtual BOOL ProcessCam(SCamEffectorInfo& info);
+
+};
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/EffectorShot.cpp xray-monolith/src/xrGame/EffectorShot.cpp
--- coc-1.4-xray-64/src/xrGame/EffectorShot.cpp	2023-10-20 20:54:50.598326700 +0100
+++ xray-monolith/src/xrGame/EffectorShot.cpp	2023-10-20 20:54:32.582035500 +0100
@@ -23,2 +23,7 @@
 
+void CWeaponShotEffector::UpdateCameraRecoil(const CameraRecoil& cam_recoil)
+{
+	m_cam_recoil.Clone(cam_recoil);
+}
+
 void CWeaponShotEffector::Reset()
@@ -35,2 +40,3 @@
 	m_LastSeed		= 0;
+	m_shot_numer = 0;
 	m_single_shot	= false;
@@ -47,3 +53,3 @@
 	{
-		m_shot_numer = 0;
+		// m_shot_numer = 0; // it's now done in Reset()
 		Reset();
@@ -52,4 +58,14 @@
 
-	float angle	= m_cam_recoil.Dispersion    * weapon->cur_silencer_koef.cam_dispersion;
-	angle      += m_cam_recoil.DispersionInc * weapon->cur_silencer_koef.cam_disper_inc * (float)m_shot_numer;
+	CCartridge* ammo = !weapon->m_magazine.empty() ? &weapon->m_magazine.back() : (0);
+	float k_cam_disp = ammo ? ammo->param_s.k_cam_dispersion : 1.0f;
+	float angle = m_cam_recoil.Dispersion
+		* weapon->cur_silencer_koef.cam_dispersion
+		* weapon->cur_scope_koef.cam_dispersion
+		* weapon->cur_launcher_koef.cam_dispersion
+		* k_cam_disp;
+	angle += m_cam_recoil.DispersionInc
+		* weapon->cur_silencer_koef.cam_disper_inc
+		* weapon->cur_scope_koef.cam_disper_inc
+		* weapon->cur_launcher_koef.cam_disper_inc
+		* (float)m_shot_numer;
 	Shot2( angle );
@@ -186,2 +202,3 @@
 	m_pActor		= NULL;
+	m_WeaponID = (u16)-1;
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/EffectorShot.h xray-monolith/src/xrGame/EffectorShot.h
--- coc-1.4-xray-64/src/xrGame/EffectorShot.h	2023-10-20 20:54:50.598326700 +0100
+++ xray-monolith/src/xrGame/EffectorShot.h	2023-10-20 20:54:32.582035500 +0100
@@ -41,5 +41,9 @@
 				CWeaponShotEffector	();
-	virtual		~CWeaponShotEffector(){};
+
+	virtual ~CWeaponShotEffector()
+	{
+	};
 
 		void	Initialize			(const CameraRecoil& cam_recoil);
+	void UpdateCameraRecoil(const CameraRecoil& cam_recoil);
 		void	Reset				();
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/EliteDetector.cpp xray-monolith/src/xrGame/EliteDetector.cpp
--- coc-1.4-xray-64/src/xrGame/EliteDetector.cpp	2023-10-20 20:54:50.601326500 +0100
+++ xray-monolith/src/xrGame/EliteDetector.cpp	2023-10-20 20:54:32.585036900 +0100
@@ -22,3 +22,3 @@
 {
-	R_ASSERT(NULL==m_ui);
+	R_ASSERT(nullptr==m_ui);
 	m_ui				= xr_new<CUIArtefactDetectorElite>();
@@ -32,2 +32,7 @@
 
+void CEliteDetector::ResetUI()
+{
+	if (m_ui) ui().Clear();
+}
+
 void CEliteDetector::UpdateAf()
@@ -59,7 +64,2 @@
 
-bool  CEliteDetector::render_item_3d_ui_query()
-{
-	return IsWorking();
-}
-
 void CEliteDetector::render_item_3d_ui()
@@ -67,3 +67,2 @@
 	R_ASSERT(HudItemData());
-	inherited::render_item_3d_ui();
 	ui().Draw			();
@@ -69,4 +68,5 @@
 	ui().Draw			();
+
 	//	Restore cull mode
-	UIRender->CacheSetCullMode	(IUIRender::cmCCW);
+	inherited::render_item_3d_ui();
 }
@@ -149,8 +148,3 @@
 
-	IUIRender::ePointType bk	= UI().m_currentPointType;
-
-	UI().m_currentPointType	= IUIRender::pttLIT;
-
 	UIRender->CacheSetXformWorld(LM);
-	UIRender->CacheSetCullMode	(IUIRender::cmNONE);
 
@@ -199,3 +190,3 @@
 
-	UI().m_currentPointType		= bk;
+	UI().ScreenFrustumLIT().Clear();
 }
@@ -205,3 +196,6 @@
 	Fmatrix	trans					= m_parent->HudItemData()->m_item_transform;
-	u16 bid							= m_parent->HudItemData()->m_model->LL_BoneID("cover");
+
+	// Lucy: custom boneid for ui
+	u16 bid = m_parent->HudItemData()->m_model->LL_BoneID(READ_IF_EXISTS(pSettings, r_string, *m_parent->HudItemData()->m_sect_name, "detector_ui_bone", "cover"));
+
 	Fmatrix cover_bone				= m_parent->HudItemData()->m_model->LL_GetTransform(bid);
@@ -246,3 +240,3 @@
 
-void CScientificDetector::UpfateWork()
+void CScientificDetector::UpdateWork()
 {
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/EliteDetector.h xray-monolith/src/xrGame/EliteDetector.h
--- coc-1.4-xray-64/src/xrGame/EliteDetector.h	2023-10-20 20:54:50.602327300 +0100
+++ xray-monolith/src/xrGame/EliteDetector.h	2023-10-20 20:54:32.585036900 +0100
@@ -13,3 +13,2 @@
 	virtual void	render_item_3d_ui			();
-	virtual bool	render_item_3d_ui_query		();
 	virtual LPCSTR	ui_xml_tag					() const {return "elite";}
@@ -18,2 +17,3 @@
 	virtual void 	CreateUI					();
+	virtual void ResetUI();
 	CUIArtefactDetectorElite& ui				();
@@ -34,3 +33,3 @@
 protected:
-	virtual void	UpfateWork					();
+	virtual void UpdateWork();
 	CZoneList		m_zones;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/encyclopedia_article.cpp xray-monolith/src/xrGame/encyclopedia_article.cpp
--- coc-1.4-xray-64/src/xrGame/encyclopedia_article.cpp	2023-10-20 20:54:51.057326400 +0100
+++ xray-monolith/src/xrGame/encyclopedia_article.cpp	2023-10-20 20:54:32.979036200 +0100
@@ -77,2 +77,8 @@
 	{
+		if (pSettings->line_exist(ltx, "icons_texture"))
+		{
+			LPCSTR icons_texture = pSettings->r_string(ltx, "icons_texture");
+			data()->image.SetShader(InventoryUtilities::GetCustomIconTextureShader(icons_texture));
+		}
+		else
 		data()->image.SetShader(InventoryUtilities::GetEquipmentIconsShader());
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/enemy_manager.cpp xray-monolith/src/xrGame/enemy_manager.cpp
--- coc-1.4-xray-64/src/xrGame/enemy_manager.cpp	2023-10-20 20:54:51.058326600 +0100
+++ xray-monolith/src/xrGame/enemy_manager.cpp	2023-10-20 20:54:32.980036200 +0100
@@ -23,2 +23,3 @@
 #include "actor.h"
+#include "actor_memory.h"
 #include "ai/stalker/ai_stalker.h"
@@ -92,3 +93,3 @@
 
-	bool					actor = (!!smart_cast<CActor const*>(object));
+	const CActor* actor = smart_cast<const CActor*>(object);
 	if (actor)
@@ -121,12 +124,12 @@
 	// if object is actor and he/she sees us
-//	if (actor) {
-//		if (smart_cast<const CActor*>(object)->memory().visual().visible_now(m_object))
-//			penalty			-= 900.f;
-//	}
-//	else {
-//		// if object is npc and it sees us
-//		const CCustomMonster	*monster = smart_cast<const CCustomMonster*>(object);
-//		if (monster && monster->memory().visual().visible_now(m_object))
-//			penalty			-= 300.f;
-//	}
+	if (actor) {
+		if (actor->memory().visual().visible_now(m_object))
+			penalty -= 900.f;
+	}
+	else {
+		// if object is npc and it sees us
+		const CCustomMonster	*monster = smart_cast<const CCustomMonster*>(object);
+		if (monster && monster->memory().visual().visible_now(m_object))
+			penalty -= 300.f;
+	}
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Entity.cpp xray-monolith/src/xrGame/Entity.cpp
--- coc-1.4-xray-64/src/xrGame/Entity.cpp	2023-10-20 20:54:50.602327300 +0100
+++ xray-monolith/src/xrGame/Entity.cpp	2023-10-20 20:54:32.585036900 +0100
@@ -165,9 +165,17 @@
 
-        R_ASSERT2(!((E->get_killer_id() != ALife::_OBJECT_ID(-1)) && g_Alive()), make_string("server entity [%s][%d] has an killer [%d] and not dead",
-            E->name_replace(), E->ID, E->get_killer_id()).c_str());
+		//R_ASSERT2(!((E->get_killer_id() != ALife::_OBJECT_ID(-1)) && g_Alive()),
+		//          make_string("server entity [%s][%d] has an killer [%d] and not dead",
+		//	          E->name_replace(), E->ID, E->get_killer_id()).c_str());
 
         m_killer_id = E->get_killer_id();
-        if (m_killer_id == ID())
+
+		if ((m_killer_id != ALife::_OBJECT_ID(-1)) && g_Alive())
+		{
+			Msg("!server entity [%s][%d] has a killer [%d] and is not dead", E->name_replace(), E->ID, E->get_killer_id());
             m_killer_id = ALife::_OBJECT_ID(-1);
     }
+		
+		//if (m_killer_id == ID())
+		//	m_killer_id = ALife::_OBJECT_ID(-1);
+	}
     else
@@ -213,3 +223,3 @@
         m_level_death_time = Device.dwTimeGlobal;
-        m_game_death_time = E->m_game_death_time;;
+		m_game_death_time = E->m_game_death_time;
     }
@@ -256,3 +266,3 @@
     {
-		Actor()->use_HolderEx(NULL,true);
+		Actor()->use_HolderEx(NULL, false);
         Actor()->callback(GameObject::eActorBeforeDeath)(whoID);
@@ -389 +403,22 @@
 }
+
+//--DSR-- HeatVision_start
+u32 clampU(u32 x, u32 a, u32 b) {
+	if (x < a) return a;
+	else if (x > b) return b;
+	return x;
+}
+
+float CEntity::GetHotness() {
+	if (AlreadyDie() || !g_Alive())
+		return 1.0f - (float)clampU(Device.dwTimeGlobal - m_level_death_time, 0, 20000) / 20000.0f;
+	return 1.0f;
+}
+
+void CEntity::OnChangeVisual()
+{
+	inherited::OnChangeVisual();
+	if (renderable.visual != 0)
+		renderable.visual->MarkAsHot(true);
+}
+//--DSR-- HeatVision_end
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Entity.h xray-monolith/src/xrGame/Entity.h
--- coc-1.4-xray-64/src/xrGame/Entity.h	2023-10-20 20:54:50.602327300 +0100
+++ xray-monolith/src/xrGame/Entity.h	2023-10-20 20:54:32.586035800 +0100
@@ -74,6 +79,14 @@
 //	virtual float			g_Health			()const	{ return GetfHealth();}
-/*	virtual*/ IC float			GetMaxHealth		()const	{ return m_entity_condition->max_health();	}
-/*	virtual*/ IC void			SetMaxHealth		(float v)	{ m_entity_condition->max_health()=v;}
+	/*	virtual*/
+	IC float GetMaxHealth() const { return m_entity_condition->max_health(); }
+	/*	virtual*/
+	IC void SetMaxHealth(float v) { m_entity_condition->max_health() = v; }
+
+	//--DSR-- HeatVision_start
+	virtual float GetHotness();
+	virtual void  OnChangeVisual();
+	//--DSR-- HeatVision_end
 
-	/*virtual*/ IC BOOL		g_Alive				()const	{ return GetfHealth()>0; }
+	/*virtual*/
+	IC BOOL g_Alive() const { return GetfHealth() > 0; }
 	virtual BOOL			g_State				(SEntityState&) const	{return FALSE;}
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/entity_alive.cpp xray-monolith/src/xrGame/entity_alive.cpp
--- coc-1.4-xray-64/src/xrGame/entity_alive.cpp	2023-10-20 20:54:51.059326700 +0100
+++ xray-monolith/src/xrGame/entity_alive.cpp	2023-10-20 20:54:32.981036500 +0100
@@ -1,2 +1,2 @@
-#include "pch_script.h"
+ï»¿#include "pch_script.h"
 #include "entity_alive.h"
@@ -26,3 +26,3 @@
 
-//îòìåòêè êðîâè íà ñòåíàõ 
+//Ð¾ÑÐ¼ÐµÑÐºÐ¸ ÐºÑÐ¾Ð²Ð¸ Ð½Ð° ÑÑÐµÐ½Ð°Ñ 
 FactoryPtr<IWallMarkArray>* CEntityAlive::m_pBloodMarksVector = NULL;
@@ -33,3 +33,3 @@
 
-//êàïàíèå êðîâè
+//ÐºÐ°Ð¿Ð°Ð½Ð¸Ðµ ÐºÑÐ¾Ð²Ð¸
 FactoryPtr<IWallMarkArray>* CEntityAlive::m_pBloodDropsVector = NULL;
@@ -40,8 +40,8 @@
 
-//ìèíèìàëüíûé ðàçìåð îæåãà, ïîñëå êîòîðîãî ãîðÿò ïàðòèêëû
-//ìèíèìàëüíîå âðåìÿ ãîðåíèÿ
+//Ð¼Ð¸Ð½Ð¸Ð¼Ð°Ð»ÑÐ½ÑÐ¹ ÑÐ°Ð·Ð¼ÐµÑ Ð¾Ð¶ÐµÐ³Ð°, Ð¿Ð¾ÑÐ»Ðµ ÐºÐ¾ÑÐ¾ÑÐ¾Ð³Ð¾ Ð³Ð¾ÑÑÑ Ð¿Ð°ÑÑÐ¸ÐºÐ»Ñ
+//Ð¼Ð¸Ð½Ð¸Ð¼Ð°Ð»ÑÐ½Ð¾Ðµ Ð²ÑÐµÐ¼Ñ Ð³Ð¾ÑÐµÐ½Ð¸Ñ
 u32	  CEntityAlive::m_dwMinBurnTime = 10000;
-//ðàçìåð ðàíû, ÷òîá çàïóñòèòü ïàðòèêëû
+//ÑÐ°Ð·Ð¼ÐµÑ ÑÐ°Ð½Ñ, ÑÑÐ¾Ð± Ð·Ð°Ð¿ÑÑÑÐ¸ÑÑ Ð¿Ð°ÑÑÐ¸ÐºÐ»Ñ
 float CEntityAlive::m_fStartBurnWoundSize = 0.3f;
-//ðàçìåð ðàíû, ÷òîá îñòàíîâèòü ïàðòèêëû
+//ÑÐ°Ð·Ð¼ÐµÑ ÑÐ°Ð½Ñ, ÑÑÐ¾Ð± Ð¾ÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Ð¿Ð°ÑÑÐ¸ÐºÐ»Ñ
 float CEntityAlive::m_fStopBurnWoundSize = 0.1f;
@@ -98,3 +97,3 @@
 
-	//áèîëîã. âèä ê òîðîìó ïðèíàäëåæèò ìîíñòð èëè ïåðñîíàæ
+	//Ð±Ð¸Ð¾Ð»Ð¾Ð³. Ð²Ð¸Ð´ Ðº ÑÐ¾ÑÐ¾Ð¼Ñ Ð¿ÑÐ¸Ð½Ð°Ð´Ð»ÐµÐ¶Ð¸Ñ Ð¼Ð¾Ð½ÑÑÑ Ð¸Ð»Ð¸ Ð¿ÐµÑÑÐ¾Ð½Ð°Ð¶
 	monster_community->set	(pSettings->r_string(section, "species"));
@@ -109,3 +108,3 @@
 	
-	//êðîâàâûå îòìåòêè íà ñòåíàõ
+	//ÐºÑÐ¾Ð²Ð°Ð²ÑÐµ Ð¾ÑÐ¼ÐµÑÐºÐ¸ Ð½Ð° ÑÑÐµÐ½Ð°Ñ
 	string256	tmp;
@@ -125,4 +124,3 @@
 
-
-	//êàïëè êðîâè ñ îòêðûòûõ ðàí
+	//ÐºÐ°Ð¿Ð»Ð¸ ÐºÑÐ¾Ð²Ð¸ Ñ Ð¾ÑÐºÑÑÑÑÑ ÑÐ°Ð½
 	wallmarks_name = pSettings->r_string(section, "blood_drops");
@@ -216,13 +217,14 @@
 	conditions().UpdateCondition		();
-	//Îáíîâëåíèå ïàðòèêëîâ îãíÿ
+	//ÐÐ±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ Ð¿Ð°ÑÑÐ¸ÐºÐ»Ð¾Ð² Ð¾Ð³Ð½Ñ
 	UpdateFireParticles	();
-	//êàïëè êðîâè
+	//ÐºÐ°Ð¿Ð»Ð¸ ÐºÑÐ¾Ð²Ð¸
 	UpdateBloodDrops	();
-	//îáíîâèòü ðàíû
+	//Ð¾Ð±Ð½Ð¾Ð²Ð¸ÑÑ ÑÐ°Ð½Ñ
 	conditions().UpdateWounds		();
 
-	//óáèòü ñóùíîñòü
+	//ÑÐ±Ð¸ÑÑ ÑÑÑÐ½Ð¾ÑÑÑ
 	if(Local() && !g_Alive() && !AlreadyDie())
 	{
-		if(conditions().GetWhoHitLastTime()) {
+		if (conditions().GetWhoHitLastTime())
+		{
 //			Msg			("%6d : KillEntity from CEntityAlive (using who hit last time) for object %s",Device.dwTimeGlobal,*cName());
@@ -239,3 +242,3 @@
 {
-	//óñòàíîâèòü êîìàíäó â ñîîòâåòñòâèè ñ community
+	//ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ Ð² ÑÐ¾Ð¾ÑÐ²ÐµÑÑÑÐ²Ð¸Ð¸ Ñ community
 /*	if(monster_community->team() != 255)
@@ -244,16 +247,16 @@
 	conditions().reinit			();
-	inherited::net_Spawn		(DC);
+	BOOL res = inherited::net_Spawn(DC);
 
-	m_BloodWounds.clear			();
-	m_ParticleWounds.clear		();
-
-	//äîáàâèòü êðîâü è îãîíü íà ïàðòèêëû, åñëè íóæíî
-	for(WOUND_VECTOR::const_iterator it = conditions().wounds().begin(); conditions().wounds().end() != it; ++it)
+	//Ð´Ð¾Ð±Ð°Ð²Ð¸ÑÑ ÐºÑÐ¾Ð²Ñ Ð¸ Ð¾Ð³Ð¾Ð½Ñ Ð½Ð° Ð¿Ð°ÑÑÐ¸ÐºÐ»Ñ, ÐµÑÐ»Ð¸ Ð½ÑÐ¶Ð½Ð¾
+	CEntityCondition::WOUND_VECTOR::const_iterator it = conditions().wounds().begin();
+	CEntityCondition::WOUND_VECTOR::const_iterator it_e = conditions().wounds().end();
+	for (; it != it_e; ++it)
 	{
 		CWound					*pWound = *it;
+		if (pWound->GetDestroy())
+			continue;
 		StartFireParticles		(pWound);
-		StartBloodDrops			(pWound);
 	}
 
-	return						(TRUE);
+	return (res);
 }
@@ -278,16 +281,16 @@
 	//-------------------------------------------------------------------
-	CDamageManager::HitScale(HDS.boneID, conditions().hit_bone_scale(), conditions().wound_bone_scale(),pHDS->aim_bullet);
+	CDamageManager::HitScale(HDS.boneID, conditions().hit_bone_scale(), conditions().wound_bone_scale(),
+	                         pHDS->aim_bullet);
 
-	//èçìåíèòü ñîñòîÿíèå, ïåðåä òåì êàê ðîäèòåëüñêèé êëàññ îáðàáîòàåò õèò
+	//Ã¨Ã§Ã¬Ã¥Ã­Ã¨Ã²Ã¼ Ã±Ã®Ã±Ã²Ã®Ã¿Ã­Ã¨Ã¥, Ã¯Ã¥Ã°Ã¥Ã¤ Ã²Ã¥Ã¬ ÃªÃ Ãª Ã°Ã®Ã¤Ã¨Ã²Ã¥Ã«Ã¼Ã±ÃªÃ¨Ã© ÃªÃ«Ã Ã±Ã± Ã®Ã¡Ã°Ã Ã¡Ã®Ã²Ã Ã¥Ã² ÃµÃ¨Ã²
 	CWound* pWound = conditions().ConditionHit(&HDS);
-
-	if(pWound){
+	if (pWound && !pWound->GetDestroy())
+	{
 		if(ALife::eHitTypeBurn == HDS.hit_type || ALife::eHitTypeLightBurn == HDS.hit_type)
 			StartFireParticles(pWound);
-		else if(ALife::eHitTypeWound == HDS.hit_type || ALife::eHitTypeFireWound == HDS.hit_type)
-			StartBloodDrops(pWound);
 	}
 
-	if (HDS.hit_type != ALife::eHitTypeTelepatic){
-		//äîáàâèòü êðîâü íà ñòåíû
+	if (HDS.hit_type != ALife::eHitTypeTelepatic && HDS.hit_type != ALife::eHitTypeRadiation && HDS.hit_type != ALife::eHitTypeBurn && HDS.hit_type != ALife::eHitTypeLightBurn && HDS.hit_type != ALife::eHitTypeChemicalBurn)
+	{
+		//Ã¤Ã®Ã¡Ã Ã¢Ã¨Ã²Ã¼ ÃªÃ°Ã®Ã¢Ã¼ Ã­Ã  Ã±Ã²Ã¥Ã­Ã»
 		if (!use_simplified_visual())
@@ -339,3 +344,3 @@
 
-//âûâçûâàåò ïðè ïîäñ÷åòå õèòà
+//Ð²ÑÐ²Ð·ÑÐ²Ð°ÐµÑ Ð¿ÑÐ¸ Ð¿Ð¾Ð´ÑÑÐµÑÐµ ÑÐ¸ÑÐ°
 float CEntityAlive::CalcCondition(float /**hit/**/)
@@ -369,5 +377,6 @@
 }
+
 //////////////////////////////////////////////////////////////////////
 
-//äîáàâëåíèå êðîâàâûõ îòìåòîê íà ñòåíàõ, ïîñëå ïîëó÷åíèÿ õèòà
+//Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ ÐºÑÐ¾Ð²Ð°Ð²ÑÑ Ð¾ÑÐ¼ÐµÑÐ¾Ðº Ð½Ð° ÑÑÐµÐ½Ð°Ñ, Ð¿Ð¾ÑÐ»Ðµ Ð¿Ð¾Ð»ÑÑÐµÐ½Ð¸Ñ ÑÐ¸ÑÐ°
 void CEntityAlive::BloodyWallmarks (float P, const Fvector &dir, s16 element, 
@@ -378,3 +387,3 @@
 
-	//âû÷èñëèòü êîîðäèíàòû ïîïàäàíèÿ
+	//Ð²ÑÑÐ¸ÑÐ»Ð¸ÑÑ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ñ
 	IKinematics* V = smart_cast<IKinematics*>(Visual());
@@ -421,3 +429,3 @@
 
-	//åñëè êðîâü äîëåòåëà äî ñòàòè÷åñêîãî îáúåêòà
+	//ÐµÑÐ»Ð¸ ÐºÑÐ¾Ð²Ñ Ð´Ð¾Ð»ÐµÑÐµÐ»Ð° Ð´Ð¾ ÑÑÐ°ÑÐ¸ÑÐµÑÐºÐ¾Ð³Ð¾ Ð¾Ð±ÑÐµÐºÑÐ°
 	if(reach_wall)
@@ -429,6 +437,6 @@
 		{
-			//âû÷èñëèòü íîðìàëü ê ïîðàæåííîé ïîâåðõíîñòè
+			//Ð²ÑÑÐ¸ÑÐ»Ð¸ÑÑ Ð½Ð¾ÑÐ¼Ð°Ð»Ñ Ðº Ð¿Ð¾ÑÐ°Ð¶ÐµÐ½Ð½Ð¾Ð¹ Ð¿Ð¾Ð²ÐµÑÑÐ½Ð¾ÑÑÐ¸
 			Fvector*	pVerts	= Level().ObjectSpace.GetStaticVerts();
 
-			//âû÷èñëèòü òî÷êó ïîïàäàíèÿ
+			//Ð²ÑÑÐ¸ÑÐ»Ð¸ÑÑ ÑÐ¾ÑÐºÑ Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ñ
 			Fvector end_point;
@@ -441,3 +449,3 @@
 			{
-				//äîáàâèòü îòìåòêó íà ìàòåðèàëå
+				//Ð´Ð¾Ð±Ð°Ð²Ð¸ÑÑ Ð¾ÑÐ¼ÐµÑÐºÑ Ð½Ð° Ð¼Ð°ÑÐµÑÐ¸Ð°Ð»Ðµ
 				//::Render->add_StaticWallmark(wallmarkShader, end_point, wallmark_size, pTri, pVerts);
@@ -455,9 +462,2 @@
 	{
-		if(std::find(m_ParticleWounds.begin(),
-			m_ParticleWounds.end(),
-			pWound) == m_ParticleWounds.end())
-		{
-			m_ParticleWounds.push_back(pWound);
-		}
-
 		IKinematics* V = smart_cast<IKinematics*>(Visual());
@@ -490,23 +490,22 @@
 {
-	if(m_ParticleWounds.empty()) return;
-	
-//	WOUND_VECTOR_IT last_it;
+	CEntityCondition::WOUND_VECTOR const& wounds = conditions().wounds();
+	CEntityCondition::WOUND_VECTOR::const_iterator it = wounds.begin();
+	CEntityCondition::WOUND_VECTOR::const_iterator it_e = wounds.end();
 
-	for(WOUND_VECTOR_IT it = m_ParticleWounds.begin(); 
-					  it != m_ParticleWounds.end();)
+	for (; it != it_e; ++it)
 	{
 		CWound* pWound = *it;
+		if (pWound->GetDestroy())
+			continue;
+
+		if (!pWound->GetParticleName() || pWound->GetParticleBoneNum() == BI_NONE)
+			continue;
+
 		float burn_size = pWound->TypeSize(ALife::eHitTypeBurn);
 
-		if(pWound->GetDestroy() || 
-			(burn_size>0 && (burn_size<m_fStopBurnWoundSize || !g_Alive())))
+		if ((burn_size > 0 && (burn_size < m_fStopBurnWoundSize || !g_Alive())))
 		{
-			CParticlesPlayer::AutoStopParticles(pWound->GetParticleName(),
-												pWound->GetParticleBoneNum(),
-												u32(float(m_dwMinBurnTime)*::Random.randF(0.5f,1.5f))
-												);
-			it = m_ParticleWounds.erase(it);
-			continue;
+			CParticlesPlayer::AutoStopParticles(pWound->GetParticleName(), pWound->GetParticleBoneNum(),
+			                                    u32(float(m_dwMinBurnTime) * ::Random.randF(0.5f, 1.5f)));
 		}
-		it++;
 	}
@@ -534,15 +540,2 @@
 
-void CEntityAlive::StartBloodDrops			(CWound* pWound)
-{
-	if(pWound->BloodSize()>m_fStartBloodWoundSize)
-	{
-		if(std::find(m_BloodWounds.begin(), m_BloodWounds.end(),
-			  pWound) == m_BloodWounds.end())
-		{
-			m_BloodWounds.push_back(pWound);
-			pWound->m_fDropTime = 0.f;
-		}
-	}
-}
-
 void CEntityAlive::UpdateBloodDrops()
@@ -552,23 +545,21 @@
 
-	if(m_BloodWounds.empty()) return;
-
 	if(!g_Alive())
-	{
-		m_BloodWounds.clear();
 		return;
-	}
 
-//	WOUND_VECTOR_IT last_it;
+	CEntityCondition::WOUND_VECTOR const& wounds = conditions().wounds();
+	CEntityCondition::WOUND_VECTOR::const_iterator it = wounds.begin();
+	CEntityCondition::WOUND_VECTOR::const_iterator it_e = wounds.end();
 
-	for(WOUND_VECTOR_IT it = m_BloodWounds.begin(); 
-		it != m_BloodWounds.end();)
+	for (; it != it_e; ++it)
 	{
 		CWound* pWound = *it;
-		float blood_size = pWound->BloodSize();
+		if (pWound->GetDestroy())
+			continue;
 
-		if(pWound->GetDestroy() || blood_size < m_fStopBloodWoundSize)
-		{
-			it =  m_BloodWounds.erase(it);
+		if (pWound->GetBoneNum() == BI_NONE)
+			continue;
+
+		float blood_size = pWound->BloodSize();
+		if (blood_size < m_fStopBloodWoundSize)
 			continue;
-		}
 
@@ -578,6 +569,5 @@
 			size_k = size_k<1.f?size_k:1.f;
-			pWound->m_fDropTime = Device.fTimeGlobal + (m_fBloodDropTimeMax - (m_fBloodDropTimeMax-m_fBloodDropTimeMin)*size_k)*Random.randF(0.8f, 1.2f);
+			pWound->m_fDropTime = Device.fTimeGlobal + (m_fBloodDropTimeMax - (m_fBloodDropTimeMax - m_fBloodDropTimeMin
+			) * size_k) * Random.randF(0.8f, 1.2f);
 			VERIFY(m_pBloodDropsVector);
-			if(pWound->GetBoneNum() != BI_NONE)
-			{
 				Fvector pos;
@@ -588,9 +578,6 @@
 				pos.add(pos_distort);
-				PlaceBloodWallmark(Fvector().set(0.f, -1.f, 0.f),
-								pos, m_fBloodMarkDistance, 
-								m_fBloodDropSize, &**m_pBloodDropsVector);
+			PlaceBloodWallmark(Fvector().set(0.f, -1.f, 0.f), pos, m_fBloodMarkDistance, m_fBloodDropSize,
+			                   &**m_pBloodDropsVector);
 			}
 		}
-		it++;
-	}
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/entity_alive.h xray-monolith/src/xrGame/entity_alive.h
--- coc-1.4-xray-64/src/xrGame/entity_alive.h	2023-10-20 20:54:51.059326700 +0100
+++ xray-monolith/src/xrGame/entity_alive.h	2023-10-20 20:54:32.982036000 +0100
@@ -96,6 +98,2 @@
 protected:
-	DEFINE_VECTOR				(CWound*, WOUND_VECTOR, WOUND_VECTOR_IT);
-	WOUND_VECTOR				m_ParticleWounds;
-
-
 	virtual void				StartFireParticles(CWound* pWound);
@@ -117,3 +115,2 @@
 
-	void						ClearBloodWounds		() {m_BloodWounds.clear();};
 protected:
@@ -134,4 +131,2 @@
 	
-	DEFINE_VECTOR				(CWound*, WOUND_VECTOR, WOUND_VECTOR_IT);
-	WOUND_VECTOR				m_BloodWounds;
 	//ðàçìåð ðàíû, ÷òîá íà÷àëà êàïàòü êðîâü
@@ -143,3 +138,2 @@
 	//îáíîâëåíèå ðàí, è ðèñîâàíèå îòìåòîê îò êàïàþùåé êðîâè
-	virtual void				StartBloodDrops			(CWound* pWound);
 	virtual void				UpdateBloodDrops		();
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/EntityCondition.cpp xray-monolith/src/xrGame/EntityCondition.cpp
--- coc-1.4-xray-64/src/xrGame/EntityCondition.cpp	2023-10-20 20:54:50.603338100 +0100
+++ xray-monolith/src/xrGame/EntityCondition.cpp	2023-10-20 20:54:32.586035800 +0100
@@ -13,2 +13,7 @@
 #include "ActorHelmet.h"
+#include "ActorBackpack.h"
+
+// demonized: add lua callback before hit but after calculations
+#include "script_hit.h"
+#include "script_game_object.h"
 
@@ -22,2 +27,5 @@
 
+float f_power_loss_bias = 0.25f;
+float f_power_loss_factor = 0.5f;
+
 CEntityConditionSimple::CEntityConditionSimple()
@@ -124,2 +133,3 @@
 	m_fInvulnerableTimeDelta= READ_IF_EXISTS(pSettings,r_float,section,"invulnerable_time",0.0f)/1000.f;
+	m_fBleedSpeedK = READ_IF_EXISTS(pSettings, r_float, section, "bleed_speed_k", 1.f);
 }
@@ -163,3 +173,7 @@
 	ClearWounds				();
+}
 
+CEntityCondition::SConditionChangeV& CEntityCondition::change_v()
+{
+	return m_change_v;
 }
@@ -203,3 +218,3 @@
 		(*it)->Incarnation			(percent, m_fMinWoundSize);
-		if(0 == (*it)->TotalSize	())
+		if (fis_zero((*it)->TotalSize()))
 			(*it)->SetDestroy		(true);
@@ -361,7 +377,15 @@
 	CCustomOutfit* pOutfit			= pInvOwner->GetOutfit();
-	if(!pOutfit)					return power_loss*0.5f;
+	CHelmet* pHelmet = (CHelmet*)pInvOwner->inventory().ItemFromSlot(HELMET_SLOT);
+	CBackpack* pBackpack = (CBackpack*)pInvOwner->inventory().ItemFromSlot(BACKPACK_SLOT);
 
-	float new_power_loss			= power_loss*pOutfit->m_fPowerLoss;
+	float power_loss_factor = 0.0f;
+	power_loss_factor += pOutfit ? pOutfit->m_fPowerLoss : EPS;
+	power_loss_factor += pHelmet ? pHelmet->m_fPowerLoss : EPS;
+	power_loss_factor += pBackpack ? pBackpack->m_fPowerLoss : EPS;
+	power_loss_factor /= 3.0f;
+	power_loss_factor *= f_power_loss_factor;
+	power_loss_factor += f_power_loss_bias;
+	clamp(power_loss_factor, 0.0f, 1.0f);
 
-	return							new_power_loss;
+	return power_loss * power_loss_factor;
 }
@@ -401,2 +425,20 @@
 
+// demonized: add lua callback before hit but after calculations
+// pHDS and hit_power will be changed after execution
+static inline void applyBeforeHitAfterCalcsCallback(CEntityAlive* target, const luabind::functor<void>& funct, SHit* pHDS, float& hit_power, const float hit_part = 1)
+{
+	CScriptHit tLuaHit(pHDS);
+	tLuaHit.m_fPower = hit_power;
+	if (hit_part > 0)
+		tLuaHit.m_fPower *= hit_part;
+
+	funct(&tLuaHit, target->lua_game_object(), pHDS->boneID);
+
+	if (hit_part > 0)
+		tLuaHit.m_fPower /= hit_part;
+
+	pHDS->ApplyScriptHit(&tLuaHit);
+	hit_power = tLuaHit.m_fPower;
+}
+
 CWound* CEntityCondition::ConditionHit(SHit* pHDS)
@@ -415,2 +457,7 @@
 
+	// demonized: add lua callback before hit but after calculations
+	// don't call if there is no target
+	luabind::functor<void> funct;
+	bool has_func = ai().script_engine().functor("_G.CBeforeHitAfterCalcs", funct);
+
 	switch(pHDS->hit_type)
@@ -422,2 +469,9 @@
 		hit_power *= GetHitImmunity(pHDS->hit_type)-m_fBoostTelepaticImmunity;
+
+		// demonized: add lua callback before hit but after calculations
+		if (has_func)
+		{
+			applyBeforeHitAfterCalcsCallback(m_object, funct, pHDS, hit_power, m_fHealthHitPart);
+		}
+
 		ChangePsyHealth(-hit_power);
@@ -431,2 +485,9 @@
 		hit_power *= GetHitImmunity(ALife::eHitTypeBurn)-m_fBoostBurnImmunity;
+
+		// demonized: add lua callback before hit but after calculations
+		if (has_func)
+		{
+			applyBeforeHitAfterCalcsCallback(m_object, funct, pHDS, hit_power, m_fHealthHitPart * m_fHitBoneScale);
+		}
+
 		m_fHealthLost = hit_power*m_fHealthHitPart*m_fHitBoneScale;
@@ -442,2 +503,9 @@
 		hit_power *= GetHitImmunity(pHDS->hit_type)-m_fBoostChemicalBurnImmunity;
+
+		// demonized: add lua callback before hit but after calculations
+		if (has_func)
+		{
+			applyBeforeHitAfterCalcsCallback(m_object, funct, pHDS, hit_power, m_fHealthHitPart);
+		}
+
 		m_fHealthLost = hit_power*m_fHealthHitPart;
@@ -449,2 +517,9 @@
 		hit_power		*= GetHitImmunity(pHDS->hit_type)-m_fBoostShockImmunity;
+
+		// demonized: add lua callback before hit but after calculations
+		if (has_func)
+		{
+			applyBeforeHitAfterCalcsCallback(m_object, funct, pHDS, hit_power, m_fHealthHitPart);
+		}
+
 		m_fHealthLost	=  hit_power*m_fHealthHitPart;
@@ -459,2 +534,9 @@
 		hit_power			*= GetHitImmunity(pHDS->hit_type)-m_fBoostRadiationImmunity;
+
+		// demonized: add lua callback before hit but after calculations
+		if (has_func)
+		{
+			applyBeforeHitAfterCalcsCallback(m_object, funct, pHDS, hit_power, 1);
+		}
+
 		m_fDeltaRadiation	+= hit_power;
@@ -465,2 +547,9 @@
 		hit_power *= GetHitImmunity(pHDS->hit_type)-m_fBoostExplImmunity;
+
+		// demonized: add lua callback before hit but after calculations
+		if (has_func)
+		{
+			applyBeforeHitAfterCalcsCallback(m_object, funct, pHDS, hit_power, m_fHealthHitPart);
+		}
+
 		m_fHealthLost = hit_power*m_fHealthHitPart;
@@ -472,2 +561,9 @@
 		hit_power *= GetHitImmunity(pHDS->hit_type)-m_fBoostStrikeImmunity;
+
+		// demonized: add lua callback before hit but after calculations
+		if (has_func)
+		{
+			applyBeforeHitAfterCalcsCallback(m_object, funct, pHDS, hit_power, m_fHealthHitPart);
+		}
+
 		m_fHealthLost = hit_power*m_fHealthHitPart;
@@ -479,2 +575,9 @@
 		hit_power *= GetHitImmunity(pHDS->hit_type)-m_fBoostFireWoundImmunity;
+
+		// demonized: add lua callback before hit but after calculations
+		if (has_func)
+		{
+			applyBeforeHitAfterCalcsCallback(m_object, funct, pHDS, hit_power, m_fHealthHitPart * m_fHitBoneScale);
+		}
+
 		m_fHealthLost = hit_power*m_fHealthHitPart*m_fHitBoneScale;
@@ -485,2 +588,9 @@
 		hit_power *= GetHitImmunity(pHDS->hit_type)-m_fBoostWoundImmunity;
+
+		// demonized: add lua callback before hit but after calculations
+		if (has_func)
+		{
+			applyBeforeHitAfterCalcsCallback(m_object, funct, pHDS, hit_power, m_fHealthHitPart * m_fHitBoneScale);
+		}
+
 		m_fHealthLost = hit_power*m_fHealthHitPart*m_fHitBoneScale;
@@ -512,3 +626,3 @@
 {
-	float bleeding_speed		=0;
+	float bleeding_speed = 0.f;
 
@@ -516,5 +630,5 @@
 		bleeding_speed			+= (*it)->TotalSize();
-	
-	
-	return (m_WoundVector.empty() ? 0.f : bleeding_speed / m_WoundVector.size());
+	bleeding_speed *= m_fBleedSpeedK;
+	clamp(bleeding_speed, 0.0f, 10.f);
+	return bleeding_speed;
 }
@@ -524,9 +638,9 @@
 {
-	float bleeding_speed		= BleedingSpeed() * m_fDeltaTime * m_change_v.m_fV_Bleeding;
+	float bleeding_speed = BleedingSpeed() * m_fDeltaTime * change_v().m_fV_Bleeding;
 	m_bIsBleeding				= fis_zero(bleeding_speed)?false:true;
 	m_fDeltaHealth				-= CanBeHarmed() ? bleeding_speed : 0;
-	m_fDeltaHealth				+= m_fDeltaTime * m_change_v.m_fV_HealthRestore;
+	m_fDeltaHealth += m_fDeltaTime * change_v().m_fV_HealthRestore;
 	
 	VERIFY						(_valid(m_fDeltaHealth));
-	ChangeBleeding				(m_change_v.m_fV_WoundIncarnation * m_fDeltaTime);
+	ChangeBleeding(change_v().m_fV_WoundIncarnation * m_fDeltaTime);
 }
@@ -539,3 +653,3 @@
 {
-	m_fDeltaPsyHealth += m_change_v.m_fV_PsyHealth*m_fDeltaTime;
+	m_fDeltaPsyHealth += change_v().m_fV_PsyHealth * m_fDeltaTime;
 }
@@ -546,6 +660,6 @@
 	{
-		m_fDeltaRadiation -= m_change_v.m_fV_Radiation*
+		m_fDeltaRadiation -= change_v().m_fV_Radiation *
 							m_fDeltaTime;
 
-		m_fDeltaHealth -= CanBeHarmed() ? m_change_v.m_fV_RadiationHealth*m_fRadiation*m_fDeltaTime : 0.0f;
+		m_fDeltaHealth -= CanBeHarmed() ? change_v().m_fV_RadiationHealth * m_fRadiation * m_fDeltaTime : 0.0f;
 	}
@@ -557,3 +671,3 @@
 	{
-		m_fDeltaEntityMorale += m_change_v.m_fV_EntityMorale*m_fDeltaTime;
+		m_fDeltaEntityMorale += change_v().m_fV_EntityMorale * m_fDeltaTime;
 	}
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/EntityCondition.h xray-monolith/src/xrGame/EntityCondition.h
--- coc-1.4-xray-64/src/xrGame/EntityCondition.h	2023-10-20 20:54:50.603338100 +0100
+++ xray-monolith/src/xrGame/EntityCondition.h	2023-10-20 20:54:32.587035900 +0100
@@ -109,7 +119,12 @@
 	IC float				GetPower				() const			{return m_fPower;}	
+	IC void SetPower(float power) { m_fPower = power; }
 	IC float				GetRadiation			() const			{return m_fRadiation;}
+	IC void SetRadiation(float radiation) { m_fRadiation = radiation; }
 	IC float				GetPsyHealth			() const			{return m_fPsyHealth;}
-	IC float				GetSatiety				() const			{return 1.0f;}	
+	IC void SetPsyHealth(float psyHealth) { m_fPsyHealth = psyHealth; }
+	virtual float GetSatiety() const { return 1.0f; }
+	virtual void SetSatiety(float satiety) {}
 
 	IC float 				GetEntityMorale			() const			{return m_fEntityMorale;}
+	IC void SetEntityMorale(float morale) { m_fEntityMorale = morale; }
 
@@ -178,4 +202,6 @@
 	//è ñêîðîñòü ïîòåðè êðîâè èç ðàíû
+public:
 	DEFINE_VECTOR(CWound*, WOUND_VECTOR, WOUND_VECTOR_IT);
 	WOUND_VECTOR			m_WoundVector;
+protected:
 	//î÷èñòêà ìàññèâà ðàí
@@ -188,2 +214,3 @@
 	float m_fEntityMorale;			//ìîðàëü
+	float m_fBleedSpeedK;
 
@@ -274,4 +301,3 @@
 	IC float&						wound_bone_scale	()			{return		(m_fWoundBoneScale);	}
-	IC SConditionChangeV&			change_v			()			{return		(m_change_v);			}
-
+	virtual SConditionChangeV& change_v();
 };
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Explosive.cpp xray-monolith/src/xrGame/Explosive.cpp
--- coc-1.4-xray-64/src/xrGame/Explosive.cpp	2023-10-20 20:54:50.604326900 +0100
+++ xray-monolith/src/xrGame/Explosive.cpp	2023-10-20 20:54:32.588036400 +0100
@@ -86,10 +87,3 @@
 
-CExplosive::~CExplosive(void) 
-{
-#ifdef LAYERED_SND_SHOOT
-
-#else
-	sndExplode.destroy		();
-#endif
-}
+CExplosive::~CExplosive(void){}
 
@@ -129,9 +123,3 @@
 
-	//Alundaio: LAYERED_SND_SHOOT
-#ifdef LAYERED_SND_SHOOT
 	m_layered_sounds.LoadSound(ini,section, "snd_explode", "sndExplode", false, m_eSoundExplode);
-#else
-	LPCSTR	snd_name		= ini->r_string(section,"snd_explode");
-	sndExplode.create		(snd_name, st_Effect,m_eSoundExplode);
-#endif
 
@@ -342,2 +343,7 @@
 #endif
+	
+	// Interactive Grass FX
+	extern Fvector4 ps_ssfx_int_grass_params_2;
+	g_pGamePersistent->GrassBendersAddExplosion(cast_game_object()->ID(), pos, Fvector().set(0, -99, 0), 1.33f, ps_ssfx_int_grass_params_2.y, ps_ssfx_int_grass_params_2.x, m_fBlastRadius * 2.0f);
+	
 //	Msg("---------CExplosive Explode [%d] frame[%d]",cast_game_object()->ID(), Device.dwFrame);
@@ -345,7 +351,4 @@
 	//èãðàåì çâóê âçðûâà
-#ifdef LAYERED_SND_SHOOT
+
 	m_layered_sounds.PlaySound("sndExplode", pos, smart_cast<CObject*>(this), false, false, (u8)-1);
-#else
-	Sound->play_at_pos(sndExplode, 0, pos, false);
-#endif
 	
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Explosive.h xray-monolith/src/xrGame/Explosive.h
--- coc-1.4-xray-64/src/xrGame/Explosive.h	2023-10-20 20:54:50.604326900 +0100
+++ xray-monolith/src/xrGame/Explosive.h	2023-10-20 20:54:32.588036400 +0100
@@ -67,3 +72,3 @@
 protected:
-			bool				IsSoundPlaying			(){return !!sndExplode._feedback();}
+	bool IsSoundPlaying() { return !!m_layered_sounds.FindSoundItem("sndExplode", true)->playing(); }
 			bool				IsExploded				(){return !!m_explosion_flags.test(flExploded);}
@@ -81,8 +87,3 @@
 protected:
-
-	//Alundaio: LAYERED_SND_SHOOT
-#ifdef LAYERED_SND_SHOOT
 	HUD_SOUND_COLLECTION_LAYERED m_layered_sounds;
-#endif
-	//-Alundaio
 
@@ -145,3 +149,2 @@
 	//çâóêè
-	ref_sound					sndExplode;
 	ESoundTypes					m_eSoundExplode;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ExplosiveItem.cpp xray-monolith/src/xrGame/ExplosiveItem.cpp
--- coc-1.4-xray-64/src/xrGame/ExplosiveItem.cpp	2023-10-20 20:54:50.605327100 +0100
+++ xray-monolith/src/xrGame/ExplosiveItem.cpp	2023-10-20 20:54:32.588036400 +0100
@@ -49,4 +51,4 @@
 	if(!CDelayedActionFuse::isActive() &&
-		CDelayedActionFuse::CheckCondition(GetCondition() &&
-		pHDS->who)/*&&CExplosive::Initiator()==u16(-1)*/)
+		CDelayedActionFuse::CheckCondition(GetCondition()) &&
+			pHDS->who/*&&CExplosive::Initiator()==u16(-1)*/)
 	{
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/F1.cpp xray-monolith/src/xrGame/F1.cpp
--- coc-1.4-xray-64/src/xrGame/F1.cpp	2023-10-20 20:54:50.607338100 +0100
+++ xray-monolith/src/xrGame/F1.cpp	2023-10-20 20:54:32.590035700 +0100
@@ -26,2 +28,4 @@
 			//new 14.10.08 peacemaker
+		//Alun: Moved to other files
+		/*
 		class_<CWeaponAmmo,CGameObject>("CWeaponAmmo")
@@ -38,2 +42,3 @@
 			.def(constructor<>()),
+		*/
 		class_<CExplosiveItem,CGameObject>("CExplosiveItem")
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/first_bullet_controller.h xray-monolith/src/xrGame/first_bullet_controller.h
--- coc-1.4-xray-64/src/xrGame/first_bullet_controller.h	2023-10-20 20:54:51.065326700 +0100
+++ xray-monolith/src/xrGame/first_bullet_controller.h	2023-10-20 20:54:32.987035300 +0100
@@ -16,2 +16,3 @@
 	inline	float	get_fire_dispertion	() const {return m_fire_dispertion;};
+	inline void set_fire_dispertion(float val) { m_fire_dispertion = val; };
 			void	make_shot			();
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/flare.cpp xray-monolith/src/xrGame/flare.cpp
--- coc-1.4-xray-64/src/xrGame/flare.cpp	2023-10-20 20:54:51.065326700 +0100
+++ xray-monolith/src/xrGame/flare.cpp	2023-10-20 20:54:32.987035300 +0100
@@ -13,6 +13,6 @@
 {
-	inherited::net_Spawn	(DC);
+	BOOL res = inherited::net_Spawn(DC);
 	SwitchState				(eFlareHidden);
 	m_pFlareParticles		= NULL;
-	return					TRUE;
+	return res;
 }
@@ -43,5 +44,5 @@
 
-void CFlare::OnStateSwitch(u32 S)
+void CFlare::OnStateSwitch(u32 S, u32 oldState)
 {
-	inherited::OnStateSwitch(S);
+	inherited::OnStateSwitch(S, oldState);
 
@@ -52,10 +53,15 @@
 			g_player_hud->attach_item	(this);
-			PlayHUDMotion				("anm_show", TRUE, this, GetState());
+			PlayHUDMotion("anm_show", FALSE, this, GetState(), 1.f, 0.f, false);
 			SetPending					(TRUE);
-		}break;
+		}
+		break;
 	case eFlareHiding:
 		{
+			if (oldState != eFlareHiding)
+			{
 			PlayHUDMotion				("anm_hide", TRUE, this, GetState());
 			SetPending					(TRUE);
-		}break;
+			}
+		}
+		break;
 	case eFlareIdle:
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/flare.h xray-monolith/src/xrGame/flare.h
--- coc-1.4-xray-64/src/xrGame/flare.h	2023-10-20 20:54:51.066326800 +0100
+++ xray-monolith/src/xrGame/flare.h	2023-10-20 20:54:32.988036500 +0100
@@ -27,3 +28,3 @@
 
-	virtual void				OnStateSwitch					(u32 S);
+	virtual void OnStateSwitch(u32 S, u32 oldState);
 	virtual void				OnAnimationEnd					(u32 state);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/FoodItem.h xray-monolith/src/xrGame/FoodItem.h
--- coc-1.4-xray-64/src/xrGame/FoodItem.h	2023-10-20 20:54:50.608326600 +0100
+++ xray-monolith/src/xrGame/FoodItem.h	2023-10-20 20:54:32.592035000 +0100
@@ -3,2 +3,3 @@
 #include "eatable_item_object.h"
+#include "script_export_space.h"
 
@@ -10,2 +11,7 @@
 
+	DECLARE_SCRIPT_REGISTER_FUNCTION
 };
+
+add_to_type_list(CFoodItem)
+#undef script_type_list
+#define script_type_list save_type_list(CFoodItem)
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/fs_registrator_script.cpp xray-monolith/src/xrGame/fs_registrator_script.cpp
--- coc-1.4-xray-64/src/xrGame/fs_registrator_script.cpp	2023-10-20 20:54:51.066326800 +0100
+++ xray-monolith/src/xrGame/fs_registrator_script.cpp	2023-10-20 20:54:32.988036500 +0100
@@ -27,11 +28,25 @@
 }
+
 //-Alundaio
 
-class FS_file_list{
+void rescan_pathes_script(CLocatorAPI* fs)
+{
+	fs->rescan_pathes();
+}
+
+class FS_file_list
+{
 	xr_vector<LPSTR>*	m_p;
 public :
-				FS_file_list	(xr_vector<LPSTR>* p):m_p(p)	{ }
+	FS_file_list(xr_vector<LPSTR>* p): m_p(p)
+	{
+	}
+
 	u32			Size			()								{ return m_p->size();}
 	LPCSTR		GetAt			(u32 idx)						{ return m_p->at(idx);}
-	void		Free			()								{ FS.file_list_close(m_p);};
+
+	void Free()
+	{
+		FS.file_list_close(m_p);
+	};
 };
@@ -224,2 +259,4 @@
 			
+		.def("rescan_pathes", &rescan_pathes_script)
+
 			.def("file_delete",							(void	(CLocatorAPI::*)(LPCSTR,LPCSTR)) (&CLocatorAPI::file_delete))
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/game_base.cpp xray-monolith/src/xrGame/game_base.cpp
--- coc-1.4-xray-64/src/xrGame/game_base.cpp	2023-10-20 20:54:51.067326700 +0100
+++ xray-monolith/src/xrGame/game_base.cpp	2023-10-20 20:54:32.989038700 +0100
@@ -8,6 +8,6 @@
 u64		g_qwStartGameTime		= 12*60*60*1000;
-float	g_fTimeFactor			= pSettings->r_float("alife","time_factor");
+float g_fTimeFactor = 10.0f;
 u64		g_qwEStartGameTime		= 12*60*60*1000;
 
-ENGINE_API	bool g_dedicated_server;
+extern ENGINE_API bool g_dedicated_server;
 EGameIDs ParseStringToGameType(LPCSTR str);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/game_cl_base_weapon_usage_statistic.cpp xray-monolith/src/xrGame/game_cl_base_weapon_usage_statistic.cpp
--- coc-1.4-xray-64/src/xrGame/game_cl_base_weapon_usage_statistic.cpp	2023-10-20 20:54:51.070326700 +0100
+++ xray-monolith/src/xrGame/game_cl_base_weapon_usage_statistic.cpp	2023-10-20 20:54:32.992036500 +0100
@@ -171,3 +182,3 @@
 	size_t name_index = static_cast<size_t>(id);
-	if (name_index > m_data.size())
+	if (name_index >= m_data.size())
 		return shared_str();
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/game_cl_base_weapon_usage_statistic_save.cpp xray-monolith/src/xrGame/game_cl_base_weapon_usage_statistic_save.cpp
--- coc-1.4-xray-64/src/xrGame/game_cl_base_weapon_usage_statistic_save.cpp	2023-10-20 20:54:51.071326600 +0100
+++ xray-monolith/src/xrGame/game_cl_base_weapon_usage_statistic_save.cpp	2023-10-20 20:54:32.992036500 +0100
@@ -257,3 +260,3 @@
 	fwrite(&NumHits, 4, 1, pFile);
-	for (i=0; i<m_Hits.size(); i++)
+	for (u32 i = 0; i < m_Hits.size(); i++)
 	{
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/game_cl_mp.cpp xray-monolith/src/xrGame/game_cl_mp.cpp
--- coc-1.4-xray-64/src/xrGame/game_cl_mp.cpp	2023-10-20 20:54:51.075326900 +0100
+++ xray-monolith/src/xrGame/game_cl_mp.cpp	2023-10-20 20:54:32.997036800 +0100
@@ -32,3 +32,2 @@
 #include "RegistryFuncs.h"
-#include "../xrGameSpy/xrGameSpy_MainDefs.h"
 #include "screenshot_server.h"
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/game_graph_inline.h xray-monolith/src/xrGame/game_graph_inline.h
--- coc-1.4-xray-64/src/xrGame/game_graph_inline.h	2023-10-20 20:54:51.081326500 +0100
+++ xray-monolith/src/xrGame/game_graph_inline.h	2023-10-20 20:54:33.001035900 +0100
@@ -152,3 +155,6 @@
 	LEVEL_MAP::const_iterator	I = levels().find(id);
-	R_ASSERT2					(I != levels().end(),make_string("there is no specified level in the game graph : %d",id));
+	if (I == levels().end())
+	{
+		R_ASSERT2(false, make_string("there is no specified level in the game graph : %d", id));
+	}
 	return						((*I).second);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/game_object_space.h xray-monolith/src/xrGame/game_object_space.h
--- coc-1.4-xray-64/src/xrGame/game_object_space.h	2023-10-20 20:54:51.083326600 +0100
+++ xray-monolith/src/xrGame/game_object_space.h	2023-10-20 20:54:33.003036400 +0100
@@ -79,2 +79,3 @@
 		eOnWeaponJammed,
+		eOnWeaponFired,
 		eOnWeaponMagazineEmpty,
@@ -91,4 +92,8 @@
 #endif
+		eOnFootStep,
         //-AVO
 
+		eOnWeaponLowered,
+		eOnWeaponRaised,
+
         eDummy = u32(-1),
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/game_sv_base.cpp xray-monolith/src/xrGame/game_sv_base.cpp
--- coc-1.4-xray-64/src/xrGame/game_sv_base.cpp	2023-10-20 20:54:51.087326500 +0100
+++ xray-monolith/src/xrGame/game_sv_base.cpp	2023-10-20 20:54:33.007036500 +0100
@@ -17,3 +17,3 @@
 
-ENGINE_API	bool g_dedicated_server;
+extern ENGINE_API bool g_dedicated_server;
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/game_sv_deathmatch.cpp xray-monolith/src/xrGame/game_sv_deathmatch.cpp
--- coc-1.4-xray-64/src/xrGame/game_sv_deathmatch.cpp	2023-10-20 20:54:51.091326700 +0100
+++ xray-monolith/src/xrGame/game_sv_deathmatch.cpp	2023-10-20 20:54:33.010036300 +0100
@@ -596,3 +633,3 @@
 
-#include "WeaponHUD.h"
+//#include "WeaponHUD.h"
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/GameObject.cpp xray-monolith/src/xrGame/GameObject.cpp
--- coc-1.4-xray-64/src/xrGame/GameObject.cpp	2023-10-20 20:54:50.611326900 +0100
+++ xray-monolith/src/xrGame/GameObject.cpp	2023-10-20 20:54:32.594035900 +0100
@@ -46,3 +46,3 @@
 
-ENGINE_API bool g_dedicated_server;
+extern ENGINE_API bool g_dedicated_server;
 
@@ -117,2 +118,9 @@
 	VERIFY					(m_spawned);
+
+	luabind::functor<void> funct;
+	if (ai().script_engine().functor("_G.CGameObject_NetDestroy", funct))
+	{
+		funct(this->lua_game_object());
+	}
+
 	if( m_anim_mov_ctrl )
@@ -425,2 +450,7 @@
 #else
+	luabind::functor<void> funct;
+	if (ai().script_engine().functor("_G.CGameObject_NetSpawn", funct))
+	{
+		funct(this->lua_game_object());
+	}
 	return						(CScriptBinder::net_Spawn(DC));
@@ -808,7 +841,7 @@
     if (!this) return NULL;
-#ifdef DEBUG
 	if (!m_spawned)
-		Msg							("! you are trying to use a destroyed object [%x]",this);
-#endif
-	THROW							(m_spawned);
+	{
+		Msg("! you are trying to use a destroyed object [%i]", ID());
+		return NULL;
+	}
 	if (!m_lua_game_object)
@@ -981,3 +1020,3 @@
 			destroy_anim_mov_ctrl();
-
+#ifdef DEBUG
 		VERIFY2			(
@@ -999,3 +1038,3 @@
 		);
-		
+#endif
 		VERIFY			(Visual());
@@ -1053,2 +1092,7 @@
 
+void CGameObject::FootStepCallback(float power, bool b_play, bool b_on_ground, bool b_hud_view)
+{
+	this->callback(GameObject::eOnFootStep)(this->lua_game_object(), power, b_play, b_on_ground, b_hud_view);
+}
+
 #ifdef DEBUG
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/GameObject.h xray-monolith/src/xrGame/GameObject.h
--- coc-1.4-xray-64/src/xrGame/GameObject.h	2023-10-20 20:54:50.611326900 +0100
+++ xray-monolith/src/xrGame/GameObject.h	2023-10-20 20:54:32.594035900 +0100
@@ -44,3 +44,3 @@
 class ai_obstacle;
-
+class CFlashlight;
 class IKinematics;
@@ -85,2 +85,4 @@
 	virtual CWeapon*					cast_weapon					()						{return NULL;}
+	virtual CMissile* cast_missile() { return NULL; }
+	virtual CFlashlight* cast_flashlight() { return NULL; }
 	virtual CExplosive*					cast_explosive				()						{return NULL;}
@@ -227,5 +243,8 @@
 			CScriptGameObject	*lua_game_object() const;
+
 			int				clsid			() const
 	{
+#ifdef DEBUG
 		THROW				(m_script_clsid >= 0);
+#endif
 		return				(m_script_clsid);
@@ -310,2 +335,4 @@
 	virtual void			on_matrix_change	(const Fmatrix &previous);
+
+	void FootStepCallback(float power, bool b_play, bool b_on_ground, bool b_hud_view);
 };
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/GamePersistent.cpp xray-monolith/src/xrGame/GamePersistent.cpp
--- coc-1.4-xray-64/src/xrGame/GamePersistent.cpp	2023-10-20 20:54:50.611326900 +0100
+++ xray-monolith/src/xrGame/GamePersistent.cpp	2023-10-20 20:54:32.595035900 +0100
@@ -8,2 +8,3 @@
 #include "MainMenu.h"
+#include "script_wallmarks_manager.h"
 #include "UICursor.h"
@@ -104,2 +105,4 @@
     SetBaseDof(*DofValue);
+
+	m_pWallmarksManager = nullptr;
 }
@@ -153,2 +161,3 @@
     m_pMainMenu = xr_new<CMainMenu>();
+	m_pWallmarksManager = xr_new<ScriptWallmarksManager>();
 }
@@ -163,2 +172,3 @@
     xr_delete(m_pUI_core);
+	xr_delete(m_pWallmarksManager);
 
@@ -283,5 +286,2 @@
 
-        CEnvDescriptor* const current_env = Environment().Current[0];
-        VERIFY(current_env);
-
         CEnvDescriptor* const _env = Environment().Current[data_set];
@@ -289,6 +289,6 @@
 
-        CEnvAmbient* env_amb = _env->env_ambient;
+		CEnvAmbient* env_amb = Environment().m_paused ? Environment().CurrentEnv->env_ambient : _env->env_ambient;
         if (env_amb)
         {
-            CEnvAmbient::SSndChannelVec& vec = current_env->env_ambient->get_snd_channels();
+			CEnvAmbient::SSndChannelVec& vec = env_amb->get_snd_channels();
             CEnvAmbient::SSndChannelVecIt I = vec.begin();
@@ -506,3 +516,2 @@
 
-extern int g_keypress_on_start;
 void CGamePersistent::game_loaded()
@@ -513,3 +522,3 @@
             g_pGameLevel->bReady &&
-            (allow_intro() && g_keypress_on_start) &&
+			(allow_intro() && psDeviceFlags2.test(rsKeypress)) &&
             load_screen_renderer.b_need_user_input	&&
@@ -522,2 +531,10 @@
             m_intro->m_on_destroy_event.bind(this, &CGamePersistent::update_game_loaded);
+
+			// demonized
+			// Callback for when loading screen happens and "Press Any Key to Continue" prompt appears
+			luabind::functor<void> funct;
+			if (ai().script_engine().functor("_G.OnLoadingScreenKeyPrompt", funct))
+			{
+				funct();
+			}
         }
@@ -532,2 +549,10 @@
     start_game_intro();
+
+	// demonized
+	// Callback for when player dismisses loading screen after "Press Any Key to Continue" pressed
+	luabind::functor<void> funct;
+	if (ai().script_engine().functor("_G.OnLoadingScreenDismissed", funct))
+	{
+		funct();
+	}
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/GametaskManager.cpp xray-monolith/src/xrGame/GametaskManager.cpp
--- coc-1.4-xray-64/src/xrGame/GametaskManager.cpp	2023-10-20 20:54:50.613326700 +0100
+++ xray-monolith/src/xrGame/GametaskManager.cpp	2023-10-20 20:54:32.597037100 +0100
@@ -13,2 +13,4 @@
 #include "ui/UIMapWnd.h"
+#include "..\..\xrEngine\x_ray.h"
+#include "string_table.h"
 
@@ -211,2 +221,6 @@
 
+	//Discord
+	if (psDeviceFlags2.test(rsDiscord))
+		RPC_UpdateTaskName();
+
 	m_flags.set					(eChanged, FALSE);
@@ -215,2 +229,9 @@
 
+void CGameTaskManager::RPC_UpdateTaskName()
+{
+	CGameTask* tr = ActiveTask();
+	if (tr)
+		snprintf(discord_gameinfo.task_name, 128, xr_ToUTF8(*CStringTable().translate(tr->m_Title)));
+}
+
 CGameTask* CGameTaskManager::ActiveTask()
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/GametaskManager.h xray-monolith/src/xrGame/GametaskManager.h
--- coc-1.4-xray-64/src/xrGame/GametaskManager.h	2023-10-20 20:54:50.614327800 +0100
+++ xray-monolith/src/xrGame/GametaskManager.h	2023-10-20 20:54:32.597037100 +0100
@@ -30,2 +32,4 @@
 
+	void RPC_UpdateTaskName();
+
 	void		__stdcall	UpdateTasks						();
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Grenade.cpp xray-monolith/src/xrGame/Grenade.cpp
--- coc-1.4-xray-64/src/xrGame/Grenade.cpp	2023-10-20 20:54:50.617338100 +0100
+++ xray-monolith/src/xrGame/Grenade.cpp	2023-10-20 20:54:32.599035900 +0100
@@ -18,5 +19,3 @@
 {
-
 	m_destroy_callback.clear();
-	m_eSoundCheckout = ESoundTypes(SOUND_TYPE_WEAPON_RECHARGING);
 }
@@ -32,4 +31,2 @@
 
-	m_sounds.LoadSound(section,"snd_checkout", "sndCheckout", false, m_eSoundCheckout);
-
 	//////////////////////////////////////
@@ -96,3 +96,3 @@
 
-void CGrenade::State(u32 state) 
+void CGrenade::State(u32 state, u32 old_state)
 {
@@ -100,8 +100,2 @@
 	{
-	case eThrowStart:
-		{
-			Fvector						C;
-			Center						(C);
-			PlaySound					("sndCheckout", C);
-		}break;
 	case eThrowEnd:
@@ -122,7 +116,7 @@
 				}
-				
 			};
-		}break;
+		}
+		break;
 	};
-	inherited::State( state );
+	inherited::State(state, old_state);
 }
@@ -146,4 +140,10 @@
 {
-	if(IsGameTypeSingle() && (GetState()==eReady || GetState()==eThrow) )
-		OnStateSwitch(eIdle);
+	if (IsGameTypeSingle())
+	{
+		u32 state = GetState();
+		if (state == eReady || state == eThrow)
+		{
+			OnStateSwitch(eIdle, state);
+		}
+	}
 }
@@ -296,18 +296,3 @@
 				if(m_pInventory)
-				{
-					TIItemContainer::iterator it = m_pInventory->m_ruck.begin();
-					TIItemContainer::iterator it_e = m_pInventory->m_ruck.end();
-					for(;it!=it_e;++it) 
-					{
-						CGrenade *pGrenade = smart_cast<CGrenade*>(*it);
-						if(pGrenade && xr_strcmp(pGrenade->cNameSect(), cNameSect())) 
-						{
-							m_pInventory->Ruck			(this);
-							m_pInventory->SetActiveSlot	(NO_ACTIVE_SLOT);
-							m_pInventory->Slot			(pGrenade->BaseSlot(),pGrenade);
-							return						true;
-						}
-					}
-					return true;
-				}
+					m_pInventory->ActivateDeffered();
 			}
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Grenade.h xray-monolith/src/xrGame/Grenade.h
--- coc-1.4-xray-64/src/xrGame/Grenade.h	2023-10-20 20:54:50.618326700 +0100
+++ xray-monolith/src/xrGame/Grenade.h	2023-10-20 20:54:32.600036400 +0100
@@ -38,3 +38,3 @@
 	virtual bool			Useful								() const;
-	virtual void			State								(u32 state);
+	virtual void State(u32 state, u32 old_state);
 
@@ -56,4 +56,2 @@
 	ALife::_TIME_ID			m_dwGrenadeIndependencyTime;
-protected:
-	ESoundTypes				m_eSoundCheckout;
 private:
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/HangingLamp.cpp xray-monolith/src/xrGame/HangingLamp.cpp
--- coc-1.4-xray-64/src/xrGame/HangingLamp.cpp	2023-10-20 20:54:50.621338100 +0100
+++ xray-monolith/src/xrGame/HangingLamp.cpp	2023-10-20 20:54:32.604036100 +0100
@@ -30,2 +30,3 @@
 	fHealth					= 100.f;
+	fBrightness = 1.0f;
 	light_bone				= BI_NONE;
@@ -33,2 +34,3 @@
 	lanim					= 0;
+	def_lanim = "";
 	ambient_power			= 0.f;
@@ -38,2 +40,7 @@
 	m_bState				= 1;
+	NeedUpdate = FALSE;
+	isFlickering = FALSE;
+	lastFlicker = 0.0f;
+	l_flickerChance = 0;
+	l_flickerDelay = 0;
 }
@@ -100,4 +114,6 @@
 	fBrightness				= lamp->brightness;
-	clr.set					(lamp->color);						clr.a = 1.f;
+	clr.set(lamp->color);
+	clr.a = 1.f;
 	clr.mul_rgb				(fBrightness);
+	def_clr = clr;
 
@@ -136,7 +156,13 @@
 
-	lanim					= LALib.FindItem(*lamp->color_animator);
+	def_lanim = *lamp->color_animator;
+	lanim = LALib.FindItem(def_lanim);
 
 	CPHSkeleton::Spawn(e);
-	if (smart_cast<IKinematicsAnimated*>(Visual()))	smart_cast<IKinematicsAnimated*>	(Visual())->PlayCycle("idle");
-	if (smart_cast<IKinematics*>(Visual())){
+	if (smart_cast<IKinematicsAnimated*>(Visual()))
+	{
+		smart_cast<IKinematicsAnimated*>(Visual())->PlayCycle("idle");
+		NeedUpdate = true;
+	}
+	if (smart_cast<IKinematics*>(Visual()))
+	{
 		smart_cast<IKinematics*>			(Visual())->CalculateBones_Invalidate	();
@@ -145,4 +171,7 @@
 	}
-	if (lamp->flags.is(CSE_ALifeObjectHangingLamp::flPhysic)&&!Visual())
-		Msg("! WARNING: lamp, obj name [%s],flag physics set, but has no visual",*cName());
+	if (lamp->flags.is(CSE_ALifeObjectHangingLamp::flPhysic))
+	{
+		if (!Visual()) Msg("! WARNING: lamp, obj name [%s],flag physics set, but has no visual", *cName());
+		NeedUpdate = true;
+	}
 //.	if (lamp->flags.is(CSE_ALifeObjectHangingLamp::flPhysic)&&Visual()&&!guid_physic_bone)	fHealth=0.f;
@@ -217,8 +250,12 @@
 
-	if (Alive() && light_render->get_active()){
+	if (Alive() && light_render->get_active())
+	{
 		if(Visual())	PKinematics(Visual())->CalculateBones();
 
+		if (NeedUpdate)
+		{
 		// update T&R from light (main) bone
 		Fmatrix xf;
-		if (light_bone!=BI_NONE){
+			if (light_bone != BI_NONE)
+			{
 			Fmatrix& M = smart_cast<IKinematics*>(Visual())->LL_GetTransform(light_bone);
@@ -247,4 +291,6 @@
 		}
+		}
 		
-		if (lanim){
+		if (lanim)
+		{
 			int frame;
@@ -262,4 +309,62 @@
 	}
+	if (Alive())
+	{
+		if (isFlickering)
+		{
+			float tg = Device.fTimeGlobal;
+			if (lastFlicker == NULL) lastFlicker = tg;
+			if (tg - lastFlicker >= l_flickerDelay)
+			{
+				int rando = rand() % 100 + 1;
+				if (rando >= l_flickerChance)
+				{
+					if (m_bState)
+						TurnOff();
+					else
+						TurnOn();
+				}
+				lastFlicker = tg;
+			}
+		}
+	}
 }
 
+void CHangingLamp::SetLanim(LPCSTR name, bool bFlicker, int flickerChance, float flickerDelay, float framerate)
+{
+	lanim = LALib.FindItem(name);
+	if (lanim && framerate)
+		lanim->SetFramerate(framerate);
+	isFlickering = bFlicker;
+	if (isFlickering)
+	{
+		l_flickerChance = flickerChance;
+		l_flickerDelay = flickerDelay;
+	}
+}
+
+void CHangingLamp::ResetLanim()
+{
+	if (lanim)
+	{
+		lanim->ResetFramerate();
+		if (lanim->cName != def_lanim)
+			lanim = LALib.FindItem(def_lanim);
+	}
+
+	light_render->set_color(def_clr);
+
+	if (glow_render)
+		glow_render->set_color(def_clr);
+
+	Fcolor amb_clr = def_clr;
+	amb_clr.mul_rgb(ambient_power);
+
+	if (light_ambient)
+		light_ambient->set_color(amb_clr);
+
+	isFlickering = false;
+	TurnOn();
+}
+
+
 void CHangingLamp::TurnOn	()
@@ -290,2 +395,39 @@
 	}
+
+	// update T&R from light (main) bone
+	Fmatrix xf;
+	if (light_bone != BI_NONE)
+	{
+		Fmatrix& M = smart_cast<IKinematics*>(Visual())->LL_GetTransform(light_bone);
+		xf.mul(XFORM(), M);
+		VERIFY(!fis_zero(DET(xf)));
+	}
+	else
+	{
+		xf.set(XFORM());
+	}
+	light_render->set_rotation(xf.k, xf.i);
+	light_render->set_position(xf.c);
+	if (glow_render)glow_render->set_position(xf.c);
+
+	// update T&R from ambient bone
+	if (light_ambient)
+	{
+		if (ambient_bone != light_bone)
+		{
+			if (ambient_bone != BI_NONE)
+			{
+				Fmatrix& M = smart_cast<IKinematics*>(Visual())->LL_GetTransform(ambient_bone);
+				xf.mul(XFORM(), M);
+				VERIFY(!fis_zero(DET(xf)));
+			}
+			else
+			{
+				xf.set(XFORM());
+			}
+		}
+		light_ambient->set_rotation(xf.k, xf.i);
+		light_ambient->set_position(xf.c);
+	}
+
 	processing_activate		();
@@ -410,2 +560,6 @@
 			.def("turn_off",	&CHangingLamp::TurnOff)
+		.def("set_color_animator", &CHangingLamp::SetLanim)
+		.def("reset_color_animator", &CHangingLamp::ResetLanim)
+		.def("is_on", &CHangingLamp::IsOn)
+		.def("is_flickering", &CHangingLamp::IsFlickering)
 	];
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/HangingLamp.h xray-monolith/src/xrGame/HangingLamp.h
--- coc-1.4-xray-64/src/xrGame/HangingLamp.h	2023-10-20 20:54:50.622326700 +0100
+++ xray-monolith/src/xrGame/HangingLamp.h	2023-10-20 20:54:32.604036100 +0100
@@ -29,2 +31,4 @@
 	CLAItem*		lanim;
+	LPCSTR def_lanim;
+	Fcolor def_clr;
 	float			ambient_power;
@@ -40,3 +44,7 @@
 	bool			Alive			(){return fHealth>0.f;}
-
+	bool NeedUpdate;
+	bool isFlickering;
+	float lastFlicker;
+	int l_flickerChance;
+	float l_flickerDelay;
 
@@ -45,4 +53,8 @@
 	virtual			~CHangingLamp	();
+	void SetLanim(LPCSTR name, bool bFlicker, int flickerChance, float flickerDelay, float framerate);
+	void ResetLanim();
 	void			TurnOn			();
 	void			TurnOff			();
+	bool IsOn() { return m_bState; }
+	bool IsFlickering() { return isFlickering; }
 	virtual void	Load			( LPCSTR section);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Helicopter.cpp xray-monolith/src/xrGame/Helicopter.cpp
--- coc-1.4-xray-64/src/xrGame/Helicopter.cpp	2023-10-20 20:54:50.622326700 +0100
+++ xray-monolith/src/xrGame/Helicopter.cpp	2023-10-20 20:54:32.604036100 +0100
@@ -30,7 +30,3 @@
 
-CHelicopter::~CHelicopter()
-{
-	HUD_SOUND_ITEM::DestroySound		(m_sndShot);
-	HUD_SOUND_ITEM::DestroySound		(m_sndShotRocket);
-}
+CHelicopter::~CHelicopter(){}
 
@@ -91,4 +87,7 @@
 	CShootingObject::Load				(section);
-	HUD_SOUND_ITEM::LoadSound				(section,"snd_shoot", m_sndShot, SOUND_TYPE_WEAPON_SHOOTING);
-	HUD_SOUND_ITEM::LoadSound				(section,"snd_shoot_rocket", m_sndShotRocket, SOUND_TYPE_WEAPON_SHOOTING);
+
+	m_layered_sounds.LoadSound(section, "snd_shoot", "sndShoot", false, ESoundTypes::SOUND_TYPE_WEAPON_SHOOTING);
+	m_layered_sounds.LoadSound(section, "snd_shoot_rocket", "sndRocket", false, ESoundTypes::SOUND_TYPE_WEAPON_SHOOTING);
+	m_layered_sounds.LoadSound(section, "explode_sound", "sndExplode", false, ESoundTypes::SOUND_TYPE_OBJECT_EXPLODING);
+
 	CRocketLauncher::Load				(section);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/helicopter.h xray-monolith/src/xrGame/helicopter.h
--- coc-1.4-xray-64/src/xrGame/helicopter.h	2023-10-20 20:54:51.113326800 +0100
+++ xray-monolith/src/xrGame/helicopter.h	2023-10-20 20:54:33.022036500 +0100
@@ -159,4 +170,4 @@
 	float							m_barrel_dir_tolerance;
-	HUD_SOUND_ITEM					m_sndShot;
-	HUD_SOUND_ITEM					m_sndShotRocket;
+
+	HUD_SOUND_COLLECTION_LAYERED m_layered_sounds;
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Helicopter2.cpp xray-monolith/src/xrGame/Helicopter2.cpp
--- coc-1.4-xray-64/src/xrGame/Helicopter2.cpp	2023-10-20 20:54:50.622326700 +0100
+++ xray-monolith/src/xrGame/Helicopter2.cpp	2023-10-20 20:54:32.605035700 +0100
@@ -114,3 +115,3 @@
 	m_brokenSound.stop					();
-
+	m_layered_sounds.PlaySound("sndExplode", Position(), this, false);
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/HelicopterWeapon.cpp xray-monolith/src/xrGame/HelicopterWeapon.cpp
--- coc-1.4-xray-64/src/xrGame/HelicopterWeapon.cpp	2023-10-20 20:54:50.623327200 +0100
+++ xray-monolith/src/xrGame/HelicopterWeapon.cpp	2023-10-20 20:54:32.605035700 +0100
@@ -146,4 +160,3 @@
 
-	HUD_SOUND_ITEM::PlaySound	(m_sndShot, fire_pos, this, false);
-
+	m_layered_sounds.PlaySound("sndShoot", fire_pos, this, false);
 }
@@ -315,4 +349,4 @@
 		m_last_launched_rocket = idx;
-		HUD_SOUND_ITEM::PlaySound(m_sndShotRocket, xform.c, this, false);
 
+		m_layered_sounds.PlaySound("sndRocket", xform.c, this, false);
 	}
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Hit.cpp xray-monolith/src/xrGame/Hit.cpp
--- coc-1.4-xray-64/src/xrGame/Hit.cpp	2023-10-20 20:54:50.623327200 +0100
+++ xray-monolith/src/xrGame/Hit.cpp	2023-10-20 20:54:32.606038000 +0100
@@ -8,3 +8,7 @@
 #include "../xrphysics/mathutils.h"
-SHit::SHit(float powerA, Fvector &dirA, CObject *whoA, u16 elementA, Fvector p_in_bone_spaceA,\
+#include "script_hit.h"
+#include "script_game_object.h"
+#include "GameObject.h"
+
+SHit::SHit(float powerA, Fvector& dirA, CObject* whoA, u16 elementA, Fvector p_in_bone_spaceA,
 		   float impulseA, ALife::EHitType hit_typeA, float armor_piercingA, bool AimBullet)
@@ -145,2 +149,13 @@
 
+void SHit::ApplyScriptHit(CScriptHit* tLuaHit)
+{
+	power = tLuaHit->m_fPower;
+	impulse = tLuaHit->m_fImpulse;
+	dir = tLuaHit->m_tDirection;
+	hit_type = (ALife::EHitType)(tLuaHit->m_tHitType);
+	who = smart_cast<CObject*>(&tLuaHit->m_tpDraftsman->object());
+	whoID = tLuaHit->m_tpDraftsman->ID();
+	weaponID = tLuaHit->m_tpWeaponID;
+}
+
 #ifdef DEBUG
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Hit.h xray-monolith/src/xrGame/Hit.h
--- coc-1.4-xray-64/src/xrGame/Hit.h	2023-10-20 20:54:50.624327600 +0100
+++ xray-monolith/src/xrGame/Hit.h	2023-10-20 20:54:32.606038000 +0100
@@ -2,5 +2,7 @@
 
+class CScriptHit;
+
 struct SHit
 {
-	SHit(float powerA, Fvector &dirA, CObject *whoA, u16 elementA, Fvector p_in_bone_spaceA,\
+	SHit(float powerA, Fvector& dirA, CObject* whoA, u16 elementA, Fvector p_in_bone_spaceA,
 		float impulseA, ALife::EHitType hit_typeA, float armor_piercingA/*=0.0f*/, bool AimBullet/*=false*/);
@@ -10,9 +12,46 @@
 	void				invalidate				()				;
-IC	float				damage					()		const	{VERIFY(is_valide());return power;}
-IC	const Fvector		&direction				()		const	{VERIFY(is_valide());return dir;}
-IC	const CObject		*initiator				()		const	{VERIFY(is_valide());return who;}
-IC			u16			bone					()		const	{VERIFY(is_valide());return boneID;}
-IC	const Fvector		&bone_space_position	()		const	{VERIFY(is_valide());return p_in_bone_space;}
-IC			float		phys_impulse			()		const	{VERIFY(is_valide());return impulse;}
-IC	ALife::EHitType		type					()		const	{VERIFY(is_valide());return hit_type;}								
+	IC float damage() const
+	{
+		VERIFY(is_valide());
+		return power;
+	}
+
+	IC const Fvector& direction() const
+	{
+		VERIFY(is_valide());
+		return dir;
+	}
+
+	IC const CObject* initiator() const
+	{
+		VERIFY(is_valide());
+		return who;
+	}
+
+	IC u16 bone() const
+	{
+		VERIFY(is_valide());
+		return boneID;
+	}
+
+	IC const Fvector& bone_space_position() const
+	{
+		VERIFY(is_valide());
+		return p_in_bone_space;
+	}
+
+	IC float phys_impulse() const
+	{
+		VERIFY(is_valide());
+		return impulse;
+	}
+
+	IC ALife::EHitType type() const
+	{
+		VERIFY(is_valide());
+		return hit_type;
+	}
+
+	void ApplyScriptHit(CScriptHit* tLuaHit);
+
 	void				Read_Packet				(NET_Packet	P);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/hit_immunity.h xray-monolith/src/xrGame/hit_immunity.h
--- coc-1.4-xray-64/src/xrGame/hit_immunity.h	2023-10-20 20:54:51.114329500 +0100
+++ xray-monolith/src/xrGame/hit_immunity.h	2023-10-20 20:54:33.023036500 +0100
@@ -23,2 +23,3 @@
 			float		GetHitImmunity	(ALife::EHitType hit_type) const				{return m_HitImmunityKoefs[hit_type];}
+	void SetHitImmunity(ALife::EHitType hit_type, float val) { m_HitImmunityKoefs[hit_type] = val; }
 			float		AffectHit		(float power, ALife::EHitType hit_type) const	{return power*GetHitImmunity(hit_type);}
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/holder_custom.h xray-monolith/src/xrGame/holder_custom.h
--- coc-1.4-xray-64/src/xrGame/holder_custom.h	2023-10-20 20:54:51.117327000 +0100
+++ xray-monolith/src/xrGame/holder_custom.h	2023-10-20 20:54:33.026036500 +0100
@@ -40,3 +50,3 @@
 	virtual void			SetExitLocked(bool v)	{ m_bExitLocked = v; }
-	virtual bool			Use					(const Fvector& pos,const Fvector& dir,const Fvector& foot_pos)=0;
+	virtual bool Use(const Fvector& pos, const Fvector& dir, const Fvector& foot_pos) { return true; }
 	virtual bool			attach_Actor		(CGameObject* actor);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/hud_item_object.cpp xray-monolith/src/xrGame/hud_item_object.cpp
--- coc-1.4-xray-64/src/xrGame/hud_item_object.cpp	2023-10-20 20:54:51.117327000 +0100
+++ xray-monolith/src/xrGame/hud_item_object.cpp	2023-10-20 20:54:33.027035900 +0100
@@ -36,5 +36,5 @@
 
-void CHudItemObject::OnStateSwitch		(u32 S)
+void CHudItemObject::OnStateSwitch(u32 S, u32 oldState)
 {
-	CHudItem::OnStateSwitch		(S);
+	CHudItem::OnStateSwitch(S, oldState);
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/hud_item_object.h xray-monolith/src/xrGame/hud_item_object.h
--- coc-1.4-xray-64/src/xrGame/hud_item_object.h	2023-10-20 20:54:51.118326800 +0100
+++ xray-monolith/src/xrGame/hud_item_object.h	2023-10-20 20:54:33.027035900 +0100
@@ -23,3 +23,3 @@
 	virtual void		SwitchState			(u32 S);
-	virtual void		OnStateSwitch		(u32 S);
+	virtual void OnStateSwitch(u32 S, u32 oldState);
 	virtual void		OnEvent				(NET_Packet& P, u16 type);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/HudItem.cpp xray-monolith/src/xrGame/HudItem.cpp
--- coc-1.4-xray-64/src/xrGame/HudItem.cpp	2023-10-20 20:54:50.625326600 +0100
+++ xray-monolith/src/xrGame/HudItem.cpp	2023-10-20 20:54:32.608035800 +0100
@@ -1,2 +1,2 @@
-#include "stdafx.h"
+ï»¿#include "stdafx.h"
 #include "HudItem.h"
@@ -15,2 +15,3 @@
 #include "ui_base.h"
+#include "ui\UIScriptWnd.h"
 
@@ -18,2 +19,8 @@
 #include "script_game_object.h"
+#include "Flashlight.h"
+#include "clsid_game.h"
+#include "weaponpistol.h"
+#include "HUDManager.h"
+
+ENGINE_API extern float psHUD_FOV_def;
 
@@ -27,2 +34,15 @@
     m_started_rnd_anim_idx = u8(-1);
+
+	m_fLR_CameraFactor = 0.f;
+	m_fLR_MovingFactor = 0.f;
+	m_fLR_InertiaFactor = 0.f;
+	m_fUD_InertiaFactor = 0.f;
+
+	m_nearwall_last_hud_fov = psHUD_FOV_def;
+	m_lastState = eHidden;
+
+	script_ui = nullptr;
+	script_ui_funct = nullptr;
+	script_ui_bone = nullptr;
+	script_ui_matrix.identity();
 }
@@ -49,2 +70,23 @@
     m_sounds.LoadSound(section, "snd_bore", "sndBore", true);
+
+	m_hud_fov_add_mod = READ_IF_EXISTS(pSettings, r_float, section, "hud_fov_addition_modifier", 0.f);
+	m_nearwall_dist_min = READ_IF_EXISTS(pSettings, r_float, section, "nearwall_dist_min", .2f);
+	m_nearwall_dist_max = READ_IF_EXISTS(pSettings, r_float, section, "nearwall_dist_max", 1.f);
+	m_nearwall_target_hud_fov = READ_IF_EXISTS(pSettings, r_float, section, "nearwall_target_hud_fov", 0.27f);
+	m_nearwall_speed_mod = READ_IF_EXISTS(pSettings, r_float, section, "nearwall_speed_mod", 10.f);
+	m_base_fov = READ_IF_EXISTS(pSettings, r_float, section, "hud_fov", 0.f);
+
+	// Rezy - Custom Script 3D UI
+	script_ui_funct = READ_IF_EXISTS(pSettings, r_string, section, "custom_ui_func", nullptr);
+
+	if (script_ui_funct)
+	{
+		script_ui_bone = READ_IF_EXISTS(pSettings, r_string, section, "custom_ui_bone", "wpn_body");
+		script_ui_offset[0] = READ_IF_EXISTS(pSettings, r_fvector3, section, "custom_ui_pos", Fvector().set(0.f, 0.f, 0.f));
+		script_ui_offset[1] = READ_IF_EXISTS(pSettings, r_fvector3, section, "custom_ui_rot", Fvector().set(0.f, 0.f, 0.f));
+
+		script_ui_offset[1].mul(PI / 180.f);
+		script_ui_matrix.setHPB(script_ui_offset[1].x, script_ui_offset[1].y, script_ui_offset[1].z);
+		script_ui_matrix.translate_over(script_ui_offset[0]);
+	}
 }
@@ -115,3 +157,3 @@
         P.r_u8(S);
-        OnStateSwitch(u32(S));
+			OnStateSwitch(u32(S), GetState());
     }
@@ -121,4 +163,5 @@
 
-void CHudItem::OnStateSwitch(u32 S)
+void CHudItem::OnStateSwitch(u32 S, u32 oldState)
 {
+	m_lastState = oldState;
     SetState(S);
@@ -133,3 +176,4 @@
 
-        PlayAnimBore();
+		if (TryPlayAnimBore())
+		{
         if (HudItemData())
@@ -139,5 +183,14 @@
         }
+		}
+		else
+			SwitchState(eIdle);
 
         break;
+	case eHidden:
+		if (HudItemData())
+			g_player_hud->detach_item(this);
+		break;
     }
+
+	g_player_hud->updateMovementLayerState();
 }
@@ -160,5 +215,11 @@
 
-void CHudItem::PlayAnimBore()
+bool CHudItem::TryPlayAnimBore() 
+{
+	if (HudAnimationExist("anm_bore"))
 {
     PlayHUDMotion("anm_bore", TRUE, this, GetState());
+		return true;
+	}
+
+	return false;
 }
@@ -195,4 +258,219 @@
 
-void CHudItem::UpdateHudAdditonal(Fmatrix& hud_trans)
-{}
+void CHudItem::UpdateHudAdditional(Fmatrix& trans)
+{
+	CActor* pActor = smart_cast<CActor*>(object().H_Parent());
+	if (!pActor)
+		return;
+
+	attachable_hud_item* hi = HudItemData();
+	R_ASSERT(hi);
+
+	if (!g_player_hud->inertion_allowed())
+		return;
+
+	static float fAvgTimeDelta = Device.fTimeDelta;
+	fAvgTimeDelta = _inertion(fAvgTimeDelta, Device.fTimeDelta, 0.8f);
+
+	float fYMag = pActor->fFPCamYawMagnitude;
+	float fPMag = pActor->fFPCamPitchMagnitude;
+
+	float fStrafeMaxTime = hi->m_measures.m_strafe_offset[2][0].y;
+	// ÐÐ°ÐºÑ. Ð²ÑÐµÐ¼Ñ Ð² ÑÐµÐºÑÐ½Ð´Ð°Ñ, Ð·Ð° ÐºÐ¾ÑÐ¾ÑÐ¾Ðµ Ð¼Ñ Ð½Ð°ÐºÐ»Ð¾Ð½Ð¸Ð¼ÑÑ Ð¸Ð· ÑÐµÐ½ÑÑÐ°Ð»ÑÐ½Ð¾Ð³Ð¾ Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ
+	if (fStrafeMaxTime <= EPS)
+		fStrafeMaxTime = 0.01f;
+
+	float fStepPerUpd = fAvgTimeDelta / fStrafeMaxTime; // ÐÐµÐ»Ð¸ÑÐ¸Ð½Ð° Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ ÑÐ°ÐºÑÐ¾ÑÐ° Ð¿Ð¾Ð²Ð¾ÑÐ¾ÑÐ°
+
+														// ÐÐ¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ Ð±Ð¾ÐºÐ¾Ð²Ð¾Ð¹ Ð½Ð°ÐºÐ»Ð¾Ð½ Ð¾Ñ Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ñ ÐºÐ°Ð¼ÐµÑÑ
+	float fCamReturnSpeedMod = 1.5f;
+	// ÐÐ¾ÑÐºÐ¾Ð»ÑÐºÐ¾ ÑÑÐºÐ¾ÑÑÐµÐ¼ Ð½Ð¾ÑÐ¼Ð°Ð»Ð¸Ð·Ð°ÑÐ¸Ñ Ð½Ð°ÐºÐ»Ð¾Ð½Ð°, Ð¿Ð¾Ð»ÑÑÐµÐ½Ð½Ð¾Ð³Ð¾ Ð¾Ñ Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ñ ÐºÐ°Ð¼ÐµÑÑ (ÑÐ¾Ð»ÑÐºÐ¾ Ð¾Ñ Ð±ÐµÐ´ÑÐ°)
+
+	// ÐÑÑÑÐ¸ÑÑÐ²Ð°ÐµÐ¼ Ð¼Ð¸Ð½Ð¸Ð¼Ð°Ð»ÑÐ½ÑÑ ÑÐºÐ¾ÑÐ¾ÑÑÑ Ð¿Ð¾Ð²Ð¾ÑÐ¾ÑÐ° ÐºÐ°Ð¼ÐµÑÑ Ð´Ð»Ñ Ð½Ð°ÑÐ°Ð»Ð° Ð¸Ð½ÐµÑÑÐ¸Ð¸
+	float fStrafeMinAngle = hi->m_measures.m_strafe_offset[3][0].y;
+
+	// ÐÑÑÑÐ¸ÑÑÐ²Ð°ÐµÐ¼ Ð¼ÐºÑÐ¸Ð¼Ð°Ð»ÑÐ½ÑÐ¹ Ð½Ð°ÐºÐ»Ð¾Ð½ Ð¾Ñ Ð¿Ð¾Ð²Ð¾ÑÐ¾ÑÐ° ÐºÐ°Ð¼ÐµÑÑ
+	float fCamLimitBlend = hi->m_measures.m_strafe_offset[3][0].x;
+
+	// Ð¡ÑÐ¸ÑÐ°ÐµÐ¼ ÑÑÑÐµÐ¹Ñ Ð¾Ñ Ð¿Ð¾Ð²Ð¾ÑÐ¾ÑÐ° ÐºÐ°Ð¼ÐµÑÑ
+	if (abs(fYMag) > (m_fLR_CameraFactor == 0.0f ? fStrafeMinAngle : 0.0f))
+	{
+		//--> ÐÐ°Ð¼ÐµÑÐ° ÐºÑÑÑÐ¸ÑÑÑ Ð¿Ð¾ Ð¾ÑÐ¸ Y
+		m_fLR_CameraFactor -= (fYMag * fAvgTimeDelta * 0.75f);
+		clamp(m_fLR_CameraFactor, -fCamLimitBlend, fCamLimitBlend);
+	}
+	else
+	{
+		//--> ÐÐ°Ð¼ÐµÑÐ° Ð½Ðµ Ð¿Ð¾Ð²Ð¾ÑÐ°ÑÐ¸Ð²Ð°ÐµÑÑÑ - ÑÐ±Ð¸ÑÐ°ÐµÐ¼ Ð½Ð°ÐºÐ»Ð¾Ð½
+		if (m_fLR_CameraFactor < 0.0f)
+		{
+			m_fLR_CameraFactor += fStepPerUpd * fCamReturnSpeedMod;
+			clamp(m_fLR_CameraFactor, -fCamLimitBlend, 0.0f);
+		}
+		else
+		{
+			m_fLR_CameraFactor -= fStepPerUpd * fCamReturnSpeedMod;
+			clamp(m_fLR_CameraFactor, 0.0f, fCamLimitBlend);
+		}
+	}
+
+	// ÐÐ¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ Ð±Ð¾ÐºÐ¾Ð²Ð¾Ð¹ Ð½Ð°ÐºÐ»Ð¾Ð½ Ð¾Ñ ÑÐ¾Ð´ÑÐ±Ñ Ð²Ð±Ð¾Ðº
+	float fChangeDirSpeedMod = 3;
+	// ÐÐ¾ÑÐºÐ¾Ð»ÑÐºÐ¾ Ð±ÑÑÑÑÐ¾ Ð¼ÐµÐ½ÑÐµÐ¼ Ð½Ð°Ð¿ÑÐ°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð½Ð°Ð¿ÑÐ°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð½Ð°ÐºÐ»Ð¾Ð½Ð°, ÐµÑÐ»Ð¸ Ð¾Ð½Ð¾ Ð² Ð´ÑÑÐ³ÑÑ ÑÑÐ¾ÑÐ¾Ð½Ñ Ð¾Ñ ÑÐµÐºÑÑÐµÐ³Ð¾
+	u32 iMovingState = pActor->MovingState();
+	if ((iMovingState & mcLStrafe) != 0)
+	{
+		// ÐÐ²Ð¸Ð¶ÐµÐ¼ÑÑ Ð²Ð»ÐµÐ²Ð¾
+		float fVal = (m_fLR_MovingFactor > 0.f ? fStepPerUpd * fChangeDirSpeedMod : fStepPerUpd);
+		m_fLR_MovingFactor -= fVal;
+	}
+	else if ((iMovingState & mcRStrafe) != 0)
+	{
+		// ÐÐ²Ð¸Ð¶ÐµÐ¼ÑÑ Ð²Ð¿ÑÐ°Ð²Ð¾
+		float fVal = (m_fLR_MovingFactor < 0.f ? fStepPerUpd * fChangeDirSpeedMod : fStepPerUpd);
+		m_fLR_MovingFactor += fVal;
+	}
+	else
+	{
+		// ÐÐ²Ð¸Ð³Ð°ÐµÐ¼ÑÑ Ð² Ð»ÑÐ±Ð¾Ð¼ Ð´ÑÑÐ³Ð¾Ð¼ Ð½Ð°Ð¿ÑÐ°Ð²Ð»ÐµÐ½Ð¸Ð¸ - Ð¿Ð»Ð°Ð²Ð½Ð¾ ÑÐ±Ð¸ÑÐ°ÐµÐ¼ Ð½Ð°ÐºÐ»Ð¾Ð½
+		if (m_fLR_MovingFactor < 0.0f)
+		{
+			m_fLR_MovingFactor += fStepPerUpd;
+			clamp(m_fLR_MovingFactor, -1.0f, 0.0f);
+		}
+		else
+		{
+			m_fLR_MovingFactor -= fStepPerUpd;
+			clamp(m_fLR_MovingFactor, 0.0f, 1.0f);
+		}
+	}
+	clamp(m_fLR_MovingFactor, -1.0f, 1.0f); // Ð¤Ð°ÐºÑÐ¾Ñ Ð±Ð¾ÐºÐ¾Ð²Ð¾Ð¹ ÑÐ¾Ð´ÑÐ±Ñ Ð½Ðµ Ð´Ð¾Ð»Ð¶ÐµÐ½ Ð¿ÑÐµÐ²ÑÑÐ°ÑÑ ÑÑÐ¸ Ð»Ð¸Ð¼Ð¸ÑÑ
+
+											// ÐÑÑÐ¸ÑÐ»ÑÐµÐ¼ Ð¸ Ð½Ð¾ÑÐ¼Ð°Ð»Ð¸Ð·Ð¸ÑÑÐµÐ¼ Ð¸ÑÐ¾Ð³Ð¾Ð²ÑÐ¹ ÑÐ°ÐºÑÐ¾Ñ Ð½Ð°ÐºÐ»Ð¾Ð½Ð°
+	float fLR_Factor = m_fLR_MovingFactor;
+
+	// No cam strafe inertia while in freelook mode
+	if (pActor->cam_freelook == eflDisabled)
+		fLR_Factor += m_fLR_CameraFactor;
+
+	clamp(fLR_Factor, -1.0f, 1.0f); // Ð¤Ð°ÐºÑÐ¾Ñ Ð±Ð¾ÐºÐ¾Ð²Ð¾Ð¹ ÑÐ¾Ð´ÑÐ±Ñ Ð½Ðµ Ð´Ð¾Ð»Ð¶ÐµÐ½ Ð¿ÑÐµÐ²ÑÑÐ°ÑÑ ÑÑÐ¸ Ð»Ð¸Ð¼Ð¸ÑÑ
+
+	Fvector curr_offs, curr_rot;
+	Fmatrix hud_rotation;
+	Fmatrix hud_rotation_y;
+
+	if ((hi->m_measures.m_strafe_offset[2][0].x != 0.0f))
+	{
+		// Ð¡Ð¼ÐµÑÐµÐ½Ð¸Ðµ Ð¿Ð¾Ð·Ð¸ÑÐ¸Ð¸ ÑÑÐ´Ð° Ð² ÑÑÑÐµÐ¹ÑÐµ
+		curr_offs = hi->m_measures.m_strafe_offset[0][0]; // pos
+		curr_offs.mul(fLR_Factor); // Ð£Ð¼Ð½Ð¾Ð¶Ð°ÐµÐ¼ Ð½Ð° ÑÐ°ÐºÑÐ¾Ñ ÑÑÑÐµÐ¹ÑÐ°
+
+								   // ÐÐ¾Ð²Ð¾ÑÐ¾Ñ ÑÑÐ´Ð° Ð² ÑÑÑÐµÐ¹ÑÐµ
+		curr_rot = hi->m_measures.m_strafe_offset[1][0]; // rot
+		curr_rot.mul(-PI / 180.f); // ÐÑÐµÐ¾Ð±ÑÐ°Ð·ÑÐµÐ¼ ÑÐ³Ð»Ñ Ð² ÑÐ°Ð´Ð¸Ð°Ð½Ñ
+		curr_rot.mul(fLR_Factor); // Ð£Ð¼Ð½Ð¾Ð¶Ð°ÐµÐ¼ Ð½Ð° ÑÐ°ÐºÑÐ¾Ñ ÑÑÑÐµÐ¹ÑÐ°
+
+		hud_rotation.identity();
+		hud_rotation.rotateX(curr_rot.x);
+
+		hud_rotation_y.identity();
+		hud_rotation_y.rotateY(curr_rot.y);
+		hud_rotation.mulA_43(hud_rotation_y);
+
+		hud_rotation_y.identity();
+		hud_rotation_y.rotateZ(curr_rot.z);
+		hud_rotation.mulA_43(hud_rotation_y);
+
+		hud_rotation.translate_over(curr_offs);
+		trans.mulB_43(hud_rotation);
+	}
+
+	//============= ÐÐ½ÐµÑÑÐ¸Ñ Ð¾ÑÑÐ¶Ð¸Ñ =============//
+	// ÐÐ°ÑÐ°Ð¼ÐµÑÑÑ Ð¸Ð½ÐµÑÑÐ¸Ð¸
+	float fInertiaSpeedMod = hi->m_measures.m_inertion_params.m_tendto_speed;
+
+	float fInertiaReturnSpeedMod = hi->m_measures.m_inertion_params.m_tendto_ret_speed;
+
+	float fInertiaMinAngle = hi->m_measures.m_inertion_params.m_min_angle;
+
+	Fvector4 vIOffsets; // x = L, y = R, z = U, w = D
+	vIOffsets.x = hi->m_measures.m_inertion_params.m_offset_LRUD.x;
+	vIOffsets.y = hi->m_measures.m_inertion_params.m_offset_LRUD.y;
+	vIOffsets.z = hi->m_measures.m_inertion_params.m_offset_LRUD.z;
+	vIOffsets.w = hi->m_measures.m_inertion_params.m_offset_LRUD.w;
+
+	// ÐÑÑÑÐ¸ÑÑÐ²Ð°ÐµÐ¼ Ð¸Ð½ÐµÑÑÐ¸Ñ Ð¸Ð· Ð¿Ð¾Ð²Ð¾ÑÐ¾ÑÐ¾Ð² ÐºÐ°Ð¼ÐµÑÑ
+	bool bIsInertionPresent = m_fLR_InertiaFactor != 0.0f || m_fUD_InertiaFactor != 0.0f;
+	if (abs(fYMag) > fInertiaMinAngle || bIsInertionPresent)
+	{
+		float fSpeed = fInertiaSpeedMod;
+		if (fYMag > 0.0f && m_fLR_InertiaFactor > 0.0f ||
+			fYMag < 0.0f && m_fLR_InertiaFactor < 0.0f)
+		{
+			fSpeed *= 2.f; //--> Ð£ÑÐºÐ¾ÑÑÐµÐ¼ Ð¸Ð½ÐµÑÑÐ¸Ñ Ð¿ÑÐ¸ Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ð¸ Ð² Ð¿ÑÐ¾ÑÐ¸Ð²Ð¾Ð¿Ð¾Ð»Ð¾Ð¶Ð½ÑÑ ÑÑÐ¾ÑÐ¾Ð½Ñ
+		}
+
+		m_fLR_InertiaFactor -= (fYMag * fAvgTimeDelta * fSpeed); // ÐÐ¾ÑÐ¸Ð·Ð¾Ð½ÑÐ°Ð»Ñ (Ð¼.Ð±. > |1.0|)
+	}
+
+	if (abs(fPMag) > fInertiaMinAngle || bIsInertionPresent)
+	{
+		float fSpeed = fInertiaSpeedMod;
+		if (fPMag > 0.0f && m_fUD_InertiaFactor > 0.0f ||
+			fPMag < 0.0f && m_fUD_InertiaFactor < 0.0f)
+		{
+			fSpeed *= 2.f; //--> Ð£ÑÐºÐ¾ÑÑÐµÐ¼ Ð¸Ð½ÐµÑÑÐ¸Ñ Ð¿ÑÐ¸ Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ð¸ Ð² Ð¿ÑÐ¾ÑÐ¸Ð²Ð¾Ð¿Ð¾Ð»Ð¾Ð¶Ð½ÑÑ ÑÑÐ¾ÑÐ¾Ð½Ñ
+		}
+
+		m_fUD_InertiaFactor -= (fPMag * fAvgTimeDelta * fSpeed); // ÐÐµÑÑÐ¸ÐºÐ°Ð»Ñ (Ð¼.Ð±. > |1.0|)
+	}
+
+	clamp(m_fLR_InertiaFactor, -1.0f, 1.0f);
+	clamp(m_fUD_InertiaFactor, -1.0f, 1.0f);
+
+	// ÐÐ»Ð°Ð²Ð½Ð¾Ðµ Ð·Ð°ÑÑÑÐ°Ð½Ð¸Ðµ Ð¸Ð½ÐµÑÑÐ¸Ð¸ (Ð¾ÑÐ½Ð¾Ð²Ð½Ð¾Ðµ, Ð½Ð¾ Ð±ÐµÐ· Ð»Ð¸Ð½ÐµÐ¹Ð½Ð¾Ð¹ Ð½Ð¸ÐºÐ¾Ð³Ð´Ð° Ð½Ðµ Ð¾Ð¿ÑÑÑÐ¸Ñ Ð¸Ð½ÐµÑÑÐ¸Ñ Ð´Ð¾ Ð¿Ð¾Ð»Ð½Ð¾Ð³Ð¾ 0.0f)
+	m_fLR_InertiaFactor *= clampr(1.f - fAvgTimeDelta * fInertiaReturnSpeedMod, 0.0f, 1.0f);
+	m_fUD_InertiaFactor *= clampr(1.f - fAvgTimeDelta * fInertiaReturnSpeedMod, 0.0f, 1.0f);
+
+	// ÐÐ¸Ð½Ð¸Ð¼Ð°Ð»ÑÐ½Ð¾Ðµ Ð»Ð¸Ð½ÐµÐ¹Ð½Ð¾Ðµ Ð·Ð°ÑÑÑÐ°Ð½Ð¸Ðµ Ð¸Ð½ÐµÑÑÐ¸Ð¸ Ð¿ÑÐ¸ Ð¿Ð¾ÐºÐ¾Ðµ (Ð³Ð¾ÑÐ¸Ð·Ð¾Ð½ÑÐ°Ð»Ñ)
+	if (fYMag == 0.0f)
+	{
+		float fRetSpeedMod = (fYMag == 0.0f ? 1.0f : 0.75f) * (fInertiaReturnSpeedMod * 0.075f);
+		if (m_fLR_InertiaFactor < 0.0f)
+		{
+			m_fLR_InertiaFactor += fAvgTimeDelta * fRetSpeedMod;
+			clamp(m_fLR_InertiaFactor, -1.0f, 0.0f);
+		}
+		else
+		{
+			m_fLR_InertiaFactor -= fAvgTimeDelta * fRetSpeedMod;
+			clamp(m_fLR_InertiaFactor, 0.0f, 1.0f);
+		}
+	}
+
+	// ÐÐ¸Ð½Ð¸Ð¼Ð°Ð»ÑÐ½Ð¾Ðµ Ð»Ð¸Ð½ÐµÐ¹Ð½Ð¾Ðµ Ð·Ð°ÑÑÑÐ°Ð½Ð¸Ðµ Ð¸Ð½ÐµÑÑÐ¸Ð¸ Ð¿ÑÐ¸ Ð¿Ð¾ÐºÐ¾Ðµ (Ð²ÐµÑÑÐ¸ÐºÐ°Ð»Ñ)
+	if (fPMag == 0.0f)
+	{
+		float fRetSpeedMod = (fPMag == 0.0f ? 1.0f : 0.75f) * (fInertiaReturnSpeedMod * 0.075f);
+		if (m_fUD_InertiaFactor < 0.0f)
+		{
+			m_fUD_InertiaFactor += fAvgTimeDelta * fRetSpeedMod;
+			clamp(m_fUD_InertiaFactor, -1.0f, 0.0f);
+		}
+		else
+		{
+			m_fUD_InertiaFactor -= fAvgTimeDelta * fRetSpeedMod;
+			clamp(m_fUD_InertiaFactor, 0.0f, 1.0f);
+		}
+	}
+
+	// ÐÑÐ¸Ð¼ÐµÐ½ÑÐµÐ¼ Ð¸Ð½ÐµÑÑÐ¸Ñ Ðº ÑÑÐ´Ñ
+	float fLR_lim = (m_fLR_InertiaFactor < 0.0f ? vIOffsets.x : vIOffsets.y);
+	float fUD_lim = (m_fUD_InertiaFactor < 0.0f ? vIOffsets.z : vIOffsets.w);
+
+	curr_offs = { fLR_lim * -1.f * m_fLR_InertiaFactor, fUD_lim * m_fUD_InertiaFactor, 0.0f };
+
+	hud_rotation.identity();
+	hud_rotation.translate_over(curr_offs);
+	trans.mulB_43(hud_rotation);
+}
 
@@ -239,2 +517,12 @@
     }
+
+	if (script_ui)
+		script_ui->Update();
+}
+
+void CHudItem::OnMotionMark(u32 state, const motion_marks& M)
+{
+	luabind::functor<bool> funct;
+	if (ai().script_engine().functor("_G.CHudItem__OnMotionMark", funct))
+		funct(state, *M.name);
 }
@@ -253,2 +542,3 @@
     UpdateXForm();
+	m_nearwall_last_hud_fov = psHUD_FOV_def;
 
@@ -281,22 +571,102 @@
 
-void CHudItem::on_a_hud_attach()
+void CHudItem::on_outfit_changed()
 {
     if (m_current_motion_def)
-    {
         PlayHUDMotion_noCB(m_current_motion, FALSE);
-#ifdef DEBUG
-        //		Msg("continue playing [%s][%d]",m_current_motion.c_str(), Device.dwFrame);
-#endif // #ifdef DEBUG
+}
+
+void CHudItem::on_a_hud_attach()
+{
+	if (script_ui_funct && nullptr == script_ui)
+	{
+		luabind::functor<CUIDialogWndEx*> funct;
+		if (ai().script_engine().functor(script_ui_funct, funct))
+		{
+			CUIDialogWndEx* ret = funct();
+			CUIWindow* pScriptWnd = ret ? smart_cast<CUIWindow*>(ret) : (0);
+			if (pScriptWnd)
+				script_ui = pScriptWnd;
+			else
+				Msg("[%s]: Failed to load script UI [%s]!", object().cNameSect_str(), script_ui_funct);
     }
     else
+			Msg("[%s]: Script UI functor [%s] does not exist!", object().cNameSect_str(), script_ui_funct);
+	}
+}
+
+void CHudItem::render_item_3d_ui()
     {
-#ifdef DEBUG
-        //		Msg("no active motion");
-#endif // #ifdef DEBUG
+	if (script_ui)
+	{
+		Fmatrix LM;
+		Fmatrix trans = HudItemData()->m_item_transform;
+		u16 bid = HudItemData()->m_model->LL_BoneID(script_ui_bone);
+		Fmatrix ui_bone = HudItemData()->m_model->LL_GetTransform(bid);
+		LM.mul(trans, ui_bone);
+
+		if (g_player_hud->m_adjust_mode)
+		{
+			Fmatrix script_ui_adjust_matrix;
+			script_ui_adjust_matrix.identity();
+			Fvector& pos = g_player_hud->m_adjust_ui_offset[0];
+			Fvector& rot = g_player_hud->m_adjust_ui_offset[1];
+
+			script_ui_adjust_matrix.setHPB(rot.x, rot.y, rot.z);
+			script_ui_adjust_matrix.translate_over(pos);
+			LM.mulB_43(script_ui_adjust_matrix);
+		}
+		else
+			LM.mulB_43(script_ui_matrix);
+
+		UIRender->CacheSetXformWorld(LM);
+		script_ui->Draw();
+	}
     }
+
+extern float g_end_modif;
+
+u32 CHudItem::PlayHUDMotion(shared_str M, BOOL bMixIn, CHudItem* W, u32 state, float speed, float end, bool bMixIn2)
+{
+	if (HudItemData())
+	{
+		luabind::functor<luabind::object> funct;
+		if (ai().script_engine().functor("_G.CHudItem__PlayHUDMotion", funct))
+		{
+			
+			luabind::object table = luabind::newtable(ai().script_engine().lua());
+			table["anm_name"] = *M;
+			table["anm_mixin"] = !!bMixIn;
+			table["anm_mixin2"] = bMixIn2;
+			table["anm_state"] = state;
+			table["anm_speed"] = speed;
+			table["anm_end"] = end;
+
+			luabind::object const& output = funct(table, object().lua_game_object());
+			if (output && output.type() == LUA_TTABLE)
+			{
+				M = luabind::object_cast<LPCSTR>(output["anm_name"]);
+				bMixIn = luabind::object_cast<bool>(output["anm_mixin"]);
+				bMixIn2 = luabind::object_cast<bool>(output["anm_mixin2"]);
+				state = luabind::object_cast<u32>(output["anm_state"]);
+				speed = luabind::object_cast<float>(output["anm_speed"]);
+				end = luabind::object_cast<float>(output["anm_end"]);
 }
 
-u32 CHudItem::PlayHUDMotion(const shared_str& M, BOOL bMixIn, CHudItem*  W, u32 state)
+			if (M == "$cancel")
 {
-    u32 anim_time = PlayHUDMotion_noCB(M, bMixIn);
+				m_sounds.StopAllSounds();
+				if (GetState() != m_lastState)
+					SwitchState(m_lastState);
+				return 0;
+			}
+		}
+
+		if (!HudAnimationExist(*M))
+		{
+			Msg("!Missing hud animation %s", *M);
+			return 0;
+		}
+	}
+
+	u32 anim_time = PlayHUDMotion_noCB(M, bMixIn, speed, bMixIn2);
     if (anim_time > 0)
@@ -308,2 +678,18 @@
         m_startedMotionState = state;
+
+		float end_modifier = 0.f;
+
+		if (HudItemData())
+		{
+			player_hud_motion* anm = HudItemData()->find_motion(M);
+			end_modifier = anm->m_anim_end;
+		}
+
+		if (end_modifier == 0.f)
+			end_modifier = end;
+
+		if (g_end_modif != 0.f)
+			end_modifier = g_end_modif;
+
+		m_dwMotionEndTm -= end_modifier * 1000;
     }
@@ -315,3 +701,3 @@
 
-u32 CHudItem::PlayHUDMotion_noCB(const shared_str& motion_name, BOOL bMixIn)
+u32 CHudItem::PlayHUDMotion_noCB(const shared_str& motion_name, BOOL bMixIn, float speed, bool bMixIn2)
 {
@@ -330,3 +716,3 @@
     {
-        return HudItemData()->anim_play(motion_name, bMixIn, m_current_motion_def, m_started_rnd_anim_idx);
+		return HudItemData()->anim_play(motion_name, bMixIn, m_current_motion_def, m_started_rnd_anim_idx, speed, bMixIn2);
     }
@@ -353,3 +739,3 @@
         CActor* A = smart_cast<CActor*>(object().H_Parent());
-        return (A && A->HUDview() && HudItemData() && HudItemData());
+		return (A && A->HUDview() && HudItemData());
     }
@@ -359,2 +745,10 @@
 
+void CHudItem::PlayBlendAnm(LPCSTR name, float speed, float power, bool stop_old)
+{
+	u8 part = (object().cast_weapon()->IsZoomed() ? 2 : (g_player_hud->attached_item(1) ? 0 : 2));
+
+	if (stop_old) g_player_hud->StopBlendAnm(name, true);
+	g_player_hud->PlayBlendAnm(name, part, speed, power, false);
+}
+
 void CHudItem::PlayAnimIdle()
@@ -371,4 +765,6 @@
         CActor* pActor = smart_cast<CActor*>(object().H_Parent());
-        if (pActor)
+		if (pActor && pActor->AnyMove())
         {
+			if (pActor->is_safemode() && !smart_cast<CCustomDevice*>(this)) return false;
+
             CEntity::SEntityState st;
@@ -380,4 +776,3 @@
             }
-            else
-                if (!st.bCrouch && pActor->AnyMove())
+			else if (!st.bCrouch)
                 {
@@ -386,7 +781,7 @@
                 }
-            
 #ifdef NEW_ANIMS //AVO: new crouch idle animation
-                else if (st.bCrouch && pActor->AnyMove()) 
+			else if (st.bCrouch)
                 {
-                    PlayAnimCrouchIdleMoving();
+				if (!PlayAnimCrouchIdleMoving())
+					PlayHUDMotion("anm_idle_moving", TRUE, NULL, GetState(), .7f);
                     return true;
@@ -411,2 +807,6 @@
             return true;
+
+		anm = HudItemData()->m_hand_motions.find_motion(anim_name);
+		if (anm)
+			return true;
     }
@@ -426,14 +826,28 @@
 //AVO: new crouch idle animation
-void CHudItem::PlayAnimCrouchIdleMoving()
+bool CHudItem::PlayAnimCrouchIdleMoving()
 {
     if (HudAnimationExist("anm_idle_moving_crouch"))
+	{
         PlayHUDMotion("anm_idle_moving_crouch", TRUE, NULL, GetState());
+		return true;
 }
+	return false;
+}
+
 //-AVO
 
+bool CHudItem::NeedBlendAnm() 
+{
+	u32 state = GetState();
+	return (state != eIdle && state != eHidden);
+}
+
 void CHudItem::PlayAnimIdleMoving()
 {
-    PlayHUDMotion("anm_idle_moving", TRUE, NULL, GetState());
+	PlayHUDMotion("anm_idle_moving", TRUE, NULL, GetState(), isActorAccelerated(Actor()->MovingState(), false) ? 1.f : .75f);
 }
 
+#include "weapon.h"
+#include "../xrEngine/SkeletonMotions.h"
+
 void CHudItem::PlayAnimIdleSprint()
@@ -447,3 +861,3 @@
     {
-        if ((cmd == ACTOR_DEFS::mcSprint) || (cmd == ACTOR_DEFS::mcAnyMove))
+		if ((cmd == ACTOR_DEFS::mcSprint) || (cmd == ACTOR_DEFS::mcAnyMove) || (cmd == ACTOR_DEFS::mcCrouch) || (cmd == ACTOR_DEFS::mcAccel))
         {
@@ -471 +885,40 @@
 }
\ No newline at end of file
+
+bool CHudItem::ParentIsActor()
+{
+	CObject* O = object().H_Parent();
+	if (!O)
+		return false;
+
+	CEntityAlive* EA = smart_cast<CEntityAlive*>(O);
+	if (!EA)
+		return false;
+
+	return !!EA->cast_actor();
+}
+
+collide::rq_result& CHudItem::GetRQ()
+{ 
+	return HUD().GetCurrentRayQuery(); 
+}
+
+float CHudItem::GetHudFov()
+{
+	if (ParentIsActor() && Level().CurrentViewEntity() == object().H_Parent())
+	{
+		float dist = GetRQ().range;
+
+		clamp(dist, m_nearwall_dist_min, m_nearwall_dist_max);
+		float fDistanceMod = ((dist - m_nearwall_dist_min) / (m_nearwall_dist_max - m_nearwall_dist_min));
+		// 0.f ... 1.f
+		float fBaseFov = (m_base_fov ? m_base_fov : psHUD_FOV_def) + m_hud_fov_add_mod;
+		clamp(fBaseFov, 0.0f, 1.f);
+		float src = m_nearwall_speed_mod * Device.fTimeDelta;
+		clamp(src, 0.f, 1.f);
+
+		float fTrgFov = m_nearwall_target_hud_fov + fDistanceMod * (fBaseFov - m_nearwall_target_hud_fov);
+		m_nearwall_last_hud_fov = m_nearwall_last_hud_fov * (1 - src) + fTrgFov * src;
+	}
+
+	return m_nearwall_last_hud_fov;
+}
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/HudItem.h xray-monolith/src/xrGame/HudItem.h
--- coc-1.4-xray-64/src/xrGame/HudItem.h	2023-10-20 20:54:50.626326800 +0100
+++ xray-monolith/src/xrGame/HudItem.h	2023-10-20 20:54:32.608035800 +0100
@@ -1,2 +1,2 @@
-#pragma once
+ï»¿#pragma once
 
@@ -7,2 +7,3 @@
 class CMotionDef;
+class CUIWindow;
 
@@ -12,2 +13,13 @@
 
+#define TENDTO_SPEED         1.0f     // ÐÐ¾Ð´Ð¸ÑÐ¸ÐºÐ°ÑÐ¾Ñ ÑÐ¸Ð»Ñ Ð¸Ð½ÐµÑÑÐ¸Ð¸ (Ð±Ð¾Ð»ÑÑÐµ - ÑÑÐ²ÑÑÐ²Ð¸ÑÐµÐ»ÑÐ½ÐµÐ¹)
+#define TENDTO_SPEED_AIM     1.0f     // (ÐÐ»Ñ Ð¿ÑÐ¸ÑÐµÐ»Ð¸Ð²Ð°Ð½Ð¸Ñ)
+#define TENDTO_SPEED_RET     5.0f     // ÐÐ¾Ð´Ð¸ÑÐ¸ÐºÐ°ÑÐ¾Ñ ÑÐ¸Ð»Ñ Ð¾ÑÐºÐ°ÑÐ° Ð¸Ð½ÐµÑÑÐ¸Ð¸ (Ð±Ð¾Ð»ÑÑÐµ - Ð±ÑÑÑÑÐµÐµ)
+#define TENDTO_SPEED_RET_AIM 5.0f     // (ÐÐ»Ñ Ð¿ÑÐ¸ÑÐµÐ»Ð¸Ð²Ð°Ð½Ð¸Ñ)
+#define INERT_MIN_ANGLE      0.0f     // ÐÐ¸Ð½Ð¸Ð¼Ð°Ð»ÑÐ½Ð°Ñ ÑÐ¸Ð»Ð° Ð½Ð°ÐºÐ»Ð¾Ð½Ð°, Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼Ð°Ñ Ð´Ð»Ñ ÑÑÐ°ÑÑÐ° Ð¸Ð½ÐµÑÑÐ¸Ð¸
+#define INERT_MIN_ANGLE_AIM  3.5f     // (ÐÐ»Ñ Ð¿ÑÐ¸ÑÐµÐ»Ð¸Ð²Ð°Ð½Ð¸Ñ)
+
+// ÐÑÐµÐ´ÐµÐ»Ñ ÑÐ¼ÐµÑÐµÐ½Ð¸Ñ Ð¿ÑÐ¸ Ð¸Ð½ÐµÑÑÐ¸Ð¸ (Ð»ÐµÐ²Ð¾ / Ð¿ÑÐ°Ð²Ð¾ / Ð²ÐµÑÑ / Ð½Ð¸Ð·)
+#define ORIGIN_OFFSET        0.04f,  0.04f,  0.04f, 0.02f
+#define ORIGIN_OFFSET_AIM    0.015f, 0.015f, 0.01f, 0.005f
+
 struct attachable_hud_item;
@@ -33,2 +46,3 @@
 	u32						m_dw_curr_substate_time;
+	u32 m_lastState;
 public:
@@ -43,3 +63,3 @@
 	virtual void			SwitchState			(u32 S)				= 0;
-	virtual void			OnStateSwitch		(u32 S)				= 0;
+	virtual void OnStateSwitch(u32 S, u32 oldState) = 0;
 };
@@ -71,2 +94,14 @@
 	};
+
+	float m_fLR_CameraFactor; // Ð¤Ð°ÐºÑÐ¾Ñ Ð±Ð¾ÐºÐ¾Ð²Ð¾Ð³Ð¾ Ð½Ð°ÐºÐ»Ð¾Ð½Ð° ÑÑÐ´Ð° Ð¿ÑÐ¸ ÑÐ¾Ð´ÑÐ±Ðµ [-1; +1]
+	float m_fLR_MovingFactor; // Ð¤Ð°ÐºÑÐ¾Ñ Ð±Ð¾ÐºÐ¾Ð²Ð¾Ð³Ð¾ Ð½Ð°ÐºÐ»Ð¾Ð½Ð° ÑÑÐ´Ð° Ð¿ÑÐ¸ Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ð¸ ÐºÐ°Ð¼ÐµÑÑ [-1; +1]
+	float m_fLR_InertiaFactor; // Ð¤Ð°ÐºÑÐ¾Ñ Ð³Ð¾ÑÐ¸Ð·Ð¾Ð½ÑÐ°Ð»ÑÐ½Ð¾Ð¹ Ð¸Ð½ÐµÑÑÐ¸Ð¸ ÑÑÐ´Ð° Ð¿ÑÐ¸ Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ð¸ ÐºÐ°Ð¼ÐµÑÑ [-1; +1]
+	float m_fUD_InertiaFactor; // Ð¤Ð°ÐºÑÐ¾Ñ Ð²ÐµÑÑÐ¸ÐºÐ°Ð»ÑÐ½Ð¾Ð¹ Ð¸Ð½ÐµÑÑÐ¸Ð¸ ÑÑÐ´Ð° Ð¿ÑÐ¸ Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ð¸ ÐºÐ°Ð¼ÐµÑÑ [-1; +1]
+
+	CUIWindow* script_ui;
+	LPCSTR script_ui_funct;
+	LPCSTR script_ui_bone;
+	Fvector script_ui_offset[2]; //pos, rot
+	Fmatrix script_ui_matrix;
+
 public:
@@ -86,3 +124,3 @@
 	virtual bool				Action				(u16 cmd, u32 flags)			{return false;}
-			void				OnMovementChanged	(ACTOR_DEFS::EMoveCommand cmd)	;
+	virtual void OnMovementChanged(ACTOR_DEFS::EMoveCommand cmd);
 	
@@ -91,3 +129,4 @@
 	BOOL						GetHUDmode			();
-	IC BOOL						IsPending			()		const					{ return !!m_huditem_flags.test(fl_pending);}
+	void PlayBlendAnm(LPCSTR name, float speed = 1.f, float power = 1.f, bool stop_old = true);
+	IC bool IsPending() const { return !!m_huditem_flags.test(fl_pending); }
 
@@ -106,9 +151,10 @@
 	virtual void				SwitchState			(u32 S);
-	virtual void				OnStateSwitch		(u32 S);
+	virtual void OnStateSwitch(u32 S, u32 oldState);
 
 	virtual void				OnAnimationEnd		(u32 state);
-	virtual void				OnMotionMark		(u32 state, const motion_marks&){};
+
+	virtual void OnMotionMark(u32 state, const motion_marks& M);
 
 	virtual void				PlayAnimIdle		();
-	virtual void				PlayAnimBore		();
+	virtual bool TryPlayAnimBore();
 	bool						TryPlayAnimIdle		();
@@ -116,2 +162,4 @@
 
+	virtual bool NeedBlendAnm();
+
 	virtual void				PlayAnimIdleMoving	();
@@ -123,3 +171,3 @@
 
-	virtual void				UpdateHudAdditonal	(Fmatrix&);
+	virtual void UpdateHudAdditional(Fmatrix& trans);
 
@@ -128,4 +176,4 @@
 
-	u32							PlayHUDMotion		(const shared_str& M, BOOL bMixIn, CHudItem*  W, u32 state);
-	u32							PlayHUDMotion_noCB	(const shared_str& M, BOOL bMixIn);
+	u32 PlayHUDMotion(shared_str M, BOOL bMixIn, CHudItem* W, u32 state, float speed = 1.f, float end = 0.f, bool bMixIn2 = true);
+	u32 PlayHUDMotion_noCB(const shared_str& M, BOOL bMixIn, float speed = 1.f, bool bMixIn2 = true);
 	void						StopCurrentAnimWithoutCallback();
@@ -135,2 +183,5 @@
 	attachable_hud_item*		HudItemData				();
+	virtual bool ParentIsActor();
+	virtual float GetHudFov();
+	virtual void on_outfit_changed();
 	virtual void				on_a_hud_attach			();
@@ -139,14 +190,21 @@
 	IC BOOL						HudInertionAllowed		()	const			{ return m_huditem_flags.test(fl_inertion_allow);}
-	virtual void				render_hud_mode			()					{};
+	virtual float GetInertionAimFactor() { return 1.f; }; //--#SM+#--
+	virtual void render_hud_mode()
+	{
+	};
 	virtual bool				need_renderable			()					{return true;};
-	virtual void				render_item_3d_ui		()					{}
-	virtual bool				render_item_3d_ui_query	()					{return false;}
+
+	virtual void render_item_3d_ui();
+
+	virtual bool render_item_3d_ui_query() { return true; }
 
 	virtual bool				CheckCompatibility		(CHudItem*)			{return true;}
+
+	virtual collide::rq_result& GetRQ();
 protected:
 
-	IC		void				SetPending			(BOOL H)			{ m_huditem_flags.set(fl_pending, H);}
+	IC void SetPending(bool H) { m_huditem_flags.set(fl_pending, H); }
 	shared_str					hud_sect;
 
-	//êàäðû ìîìåíòà ïåðåñ÷åòà XFORM è FirePos
+	//ÃªÃ Ã¤Ã°Ã» Ã¬Ã®Ã¬Ã¥Ã­Ã²Ã  Ã¯Ã¥Ã°Ã¥Ã±Ã·Ã¥Ã²Ã  XFORM Ã¨ FirePos
 	u32							dwFP_Frame;
@@ -159,3 +217,3 @@
 
-	HUD_SOUND_COLLECTION		m_sounds;
+	HUD_SOUND_COLLECTION_LAYERED m_sounds;
 
@@ -172,6 +240,17 @@
 	virtual void				on_renderable_Render	() = 0;
-	virtual void				debug_draw_firedeps		() {};
+
+	virtual void debug_draw_firedeps()
+	{
+	};
+
+	float m_hud_fov_add_mod;
+	float m_nearwall_dist_max;
+	float m_nearwall_dist_min;
+	float m_nearwall_last_hud_fov;
+	float m_nearwall_target_hud_fov;
+	float m_nearwall_speed_mod;
+	float m_base_fov;
 
 	virtual CHudItem*			cast_hud_item			()				{ return this; }
-    void PlayAnimCrouchIdleMoving(); //AVO: new crouch idle animation
+	virtual bool PlayAnimCrouchIdleMoving(); //AVO: new crouch idle animation
     bool HudAnimationExist(LPCSTR anim_name);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/HUDManager.cpp xray-monolith/src/xrGame/HUDManager.cpp
--- coc-1.4-xray-64/src/xrGame/HUDManager.cpp	2023-10-20 20:54:50.619327100 +0100
+++ xray-monolith/src/xrGame/HUDManager.cpp	2023-10-20 20:54:32.601036400 +0100
@@ -19,5 +19,9 @@
 
+#include "Flashlight.h"
+#include "Inventory.h"
+#include "map_manager.h"
+
 extern CUIGameCustom*	CurrentGameUI()
 {
-    return HUD().GetGameUI();
+	return g_hud ? HUD().GetGameUI() : nullptr;
 }
@@ -66,3 +70,3 @@
 {
-    static char* tex_names[] = {"texture800", "texture", "texture1600"};
+	static char* tex_names[] = {"texture800", "texture", "texture1600", "texture2160"};
     int def_idx = 1;//default 1024x768
@@ -80,3 +84,4 @@
     else if (h < 1024)	idx = 1;
-    else 			idx = 2;
+	else if (h < 1440) idx = 2;
+	else idx = 3;
 #endif
@@ -220,2 +228,8 @@
     // in other modes actor model already in scene graph and renders well
+
+	//Alun: Due to glitchy shadows this is forced
+	CFlashlight* flashlight = smart_cast<CFlashlight*>(A->inventory().ItemFromSlot(DETECTOR_SLOT));
+	if (flashlight && flashlight->torch_active())
+		return;
+
     ::Render->set_Object(O->H_Root());
@@ -337,2 +354,3 @@
 extern CUIXml*			pWpnScopeXml;
+extern CUIXml* g_uiSpotXml;
 
@@ -355,4 +373,8 @@
     xr_delete(pWpnScopeXml);
+	xr_delete(g_uiSpotXml);
 
     pUIGame->UnLoad();
+
+	Level().MapManager().ReloadSpots();
+
     pUIGame->Load();
@@ -360,2 +382,6 @@
     pUIGame->OnConnected();
+
+	luabind::functor<bool> funct;
+	if (ai().script_engine().functor("_G.CHUDManager_OnScreenResolutionChanged", funct))
+		funct();
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/HudSound.cpp xray-monolith/src/xrGame/HudSound.cpp
--- coc-1.4-xray-64/src/xrGame/HudSound.cpp	2023-10-20 20:54:50.626326800 +0100
+++ xray-monolith/src/xrGame/HudSound.cpp	2023-10-20 20:54:32.608035800 +0100
@@ -227,3 +231,2 @@
 //----------------------------------------------------------
-#ifdef	LAYERED_SND_SHOOT
 HUD_SOUND_COLLECTION_LAYERED::~HUD_SOUND_COLLECTION_LAYERED()
@@ -304,2 +308,5 @@
 {
+	if (!pSettings->line_exist(section, line))
+		return;
+
 	LPCSTR str = pSettings->r_string(section, line);
@@ -335,4 +342,8 @@
 
-void HUD_SOUND_COLLECTION_LAYERED::LoadSound(CInifile const *ini, LPCSTR section, LPCSTR line, LPCSTR alias, bool exclusive, int type)
+void HUD_SOUND_COLLECTION_LAYERED::LoadSound(CInifile const* ini, LPCSTR section, LPCSTR line, LPCSTR alias,
+                                             bool exclusive, int type)
 {
+	if (!ini->line_exist(section, line))
+		return;
+
 	LPCSTR str = ini->r_string(section, line);
@@ -367,3 +378,2 @@
 }
-#endif
 //-Alundaio
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/HudSound.h xray-monolith/src/xrGame/HudSound.h
--- coc-1.4-xray-64/src/xrGame/HudSound.h	2023-10-20 20:54:50.626326800 +0100
+++ xray-monolith/src/xrGame/HudSound.h	2023-10-20 20:54:32.609035600 +0100
@@ -64,9 +66,5 @@
 {
-    //xr_vector<HUD_SOUND_ITEM>	m_sound_items;
-    //HUD_SOUND_ITEM*				FindSoundItem	(	LPCSTR alias, bool b_assert);
 public:
     ~HUD_SOUND_COLLECTION();
-#ifdef	LAYERED_SND_SHOOT
 	shared_str		m_alias; //Alundaio: For use when it's part of a layered Collection
-#endif
 	xr_vector<HUD_SOUND_ITEM>	m_sound_items; //Alundaio: made public
@@ -85,3 +84,2 @@
 //Alundaio:
-#ifdef LAYERED_SND_SHOOT
 class HUD_SOUND_COLLECTION_LAYERED
@@ -96,6 +95,6 @@
 	void						LoadSound(LPCSTR section, LPCSTR line, LPCSTR alias, bool exclusive = false, int type = sg_SourceType);
-	void						LoadSound(CInifile const *ini, LPCSTR section, LPCSTR line, LPCSTR alias, bool exclusive = false, int type = sg_SourceType);
+	void LoadSound(CInifile const* ini, LPCSTR section, LPCSTR line, LPCSTR alias, bool exclusive = false,
+	               int type = sg_SourceType);
 	void						SetPosition(LPCSTR alias, const Fvector& pos);
 };
-#endif
 //-Alundaio
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/HUDTarget.cpp xray-monolith/src/xrGame/HUDTarget.cpp
--- coc-1.4-xray-64/src/xrGame/HUDTarget.cpp	2023-10-20 20:54:50.620338100 +0100
+++ xray-monolith/src/xrGame/HUDTarget.cpp	2023-10-20 20:54:32.602035900 +0100
@@ -135,2 +143,4 @@
 extern ENGINE_API BOOL g_bRendering; 
+u32 g_crosshair_color = C_DEFAULT;
+
 void CHUDTarget::Render()
@@ -312,6 +325,7 @@
 		UIRender->FlushPrimitive();
-
-	}else{
+	}
+	else
+	{
 		//îòðåíäåðèòü ïðèöåë
-		HUDCrosshair.cross_color	= C;
+		HUDCrosshair.cross_color = (C == C_DEFAULT ? g_crosshair_color : C );
 		HUDCrosshair.OnRender		();
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ik/IKLimb.cpp xray-monolith/src/xrGame/ik/IKLimb.cpp
--- coc-1.4-xray-64/src/xrGame/ik/IKLimb.cpp	2023-10-20 20:54:51.119326600 +0100
+++ xray-monolith/src/xrGame/ik/IKLimb.cpp	2023-10-20 20:54:33.029036100 +0100
@@ -539,5 +564,9 @@
 	get_blend_speed_limits(cd.l, cd.a, cd, sv_state );
-	cd.state.foot_step		= m_foot.GetFootStepMatrix( cd.state.goal, cd, cld, true, !!ik_allign_free_foot ) && cd.state.foot_step;
-
-	VERIFY2(fsimilar( 1.f , DET( cd.state.goal.get() ), det_tolerance ), dump_string( "cd.state.goal", cd.state.goal.get() ).c_str() );
+	cd.state.foot_step = m_foot.GetFootStepMatrix(cd.state.goal, cd, cld, true, !!ik_allign_free_foot) && cd
+	                                                                                                      .state.
+	                                                                                                      foot_step;
+#ifdef DEBUG
+	VERIFY2(fsimilar( 1.f , DET( cd.state.goal.get() ), det_tolerance ),
+	        dump_string( "cd.state.goal", cd.state.goal.get() ).c_str());
+#endif
 
@@ -714,15 +744,18 @@
 			ik_goal_matrix m;
+#ifdef DEBUG
 			VERIFY(fsimilar( 1.f , DET( sv_state.goal( m ).get() ), det_tolerance ));
 			VERIFY(fsimilar( 1.f , DET( sv_state.blend_to( m ).get() ), det_tolerance ));
-
-			Fmatrix diff;diff.mul_43( Fmatrix().invert( sv_state.blend_to( m ).get() ), Fmatrix ( sv_state.goal( m ).get() ) );
-
+#endif
+		Fmatrix diff;
+		diff.mul_43(Fmatrix().invert(sv_state.blend_to(m).get()), Fmatrix(sv_state.goal(m).get()));
+#ifdef DEBUG
 			VERIFY(fsimilar( 1.f , DET( diff ), det_tolerance ));
-
+#endif
 			Fmatrix blend = Fidentity;//cd.state.blend_to;
-			cd.state.blending = !clamp_change( blend, diff, cd.l, cd.a, linear_tolerance, angualar_tolerance );//0.01f //0.005f
-
+		cd.state.blending = !clamp_change(blend, diff, cd.l, cd.a, linear_tolerance, angualar_tolerance);
+		//0.01f //0.005f
+#ifdef DEBUG
 			VERIFY(fsimilar( 1.f , DET( blend ), det_tolerance ));
 			VERIFY(fsimilar( 1.f , DET( cd.state.blend_to.get() ), det_tolerance ));
-
+#endif
 			Fmatrix fm =Fmatrix().mul_43( cd.state.blend_to.get(), blend );
@@ -732,5 +765,7 @@
 				cd.state.goal.set( fm, cd.state.blend_to.collide_state() );
+#ifdef DEBUG
 			VERIFY( fsimilar( DET( cd.state.goal.get() ), 1.f, det_tolerance ) );
-
-		} else
+#endif
+	}
+	else
 		{
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ik/limb.cxx xray-monolith/src/xrGame/ik/limb.cxx
--- coc-1.4-xray-64/src/xrGame/ik/limb.cxx	2023-10-20 20:54:51.123326500 +0100
+++ xray-monolith/src/xrGame/ik/limb.cxx	2023-10-20 20:54:33.033036500 +0100
@@ -995,5 +993,5 @@
 	fprintf(fp, "%f %f %f %f\n", c[i][0],c[i][1],c[i][2],c[i][3]);
-    for (i = 0; i < 4; i++)
+	for (int i = 0; i < 4; i++)
 	fprintf(fp, "%f %f %f %f\n", s[i][0],s[i][1],s[i][2],s[i][3]);
-    for (i = 0; i < 4; i++)
+	for (int i = 0; i < 4; i++)
 	    fprintf(fp, "%f %f %f %f\n", o[i][0],o[i][1],o[i][2],o[i][3]);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/imotion_position.cpp xray-monolith/src/xrGame/imotion_position.cpp
--- coc-1.4-xray-64/src/xrGame/imotion_position.cpp	2023-10-20 20:54:51.130326900 +0100
+++ xray-monolith/src/xrGame/imotion_position.cpp	2023-10-20 20:54:33.039036100 +0100
@@ -157,3 +162,3 @@
 	blend = get_blend.blend;
-
+#ifdef DEBUG
 	VERIFY2( B.stop_at_end, 
@@ -162,2 +167,3 @@
 	);
+#endif
 	time_to_end = B.timeTotal - (SAMPLE_SPF+EPS) - B.timeCurrent;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ini_id_loader.h xray-monolith/src/xrGame/ini_id_loader.h
--- coc-1.4-xray-64/src/xrGame/ini_id_loader.h	2023-10-20 20:54:51.131326800 +0100
+++ xray-monolith/src/xrGame/ini_id_loader.h	2023-10-20 20:54:33.041036400 +0100
@@ -124,4 +125,4 @@
 {
-	for(T_VECTOR::iterator it = m_pItemDataVector->begin();
-		m_pItemDataVector->end() != it; ++it)
+	T_VECTOR::iterator it = m_pItemDataVector->begin();
+	for (; m_pItemDataVector->end() != it; ++it)
 	{
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Inventory.cpp xray-monolith/src/xrGame/Inventory.cpp
--- coc-1.4-xray-64/src/xrGame/Inventory.cpp	2023-10-20 20:54:50.630327100 +0100
+++ xray-monolith/src/xrGame/Inventory.cpp	2023-10-20 20:54:32.612037200 +0100
@@ -27,2 +27,3 @@
 #include "player_hud.h"
+#include "PDA.h"
 
@@ -102,2 +104,3 @@
 	m_next_item_iteration_time					= 0;
+	m_change_after_deactivate = false;
 }
@@ -289,3 +307,3 @@
 	if(it!=m_all.end())
-		m_all.erase(std::find(m_all.begin(), m_all.end(), pIItem));
+		m_all.erase(it);
 	else
@@ -309,3 +327,12 @@
 	};
-	pObj->H_SetParent(0, dont_create_shell);
+	if (smart_cast<CWeapon*>(pObj))
+	{
+		Fvector dir = Actor()->Direction();
+		dir.y = sin(-45.f * PI / 180.f);
+		dir.normalize();
+		smart_cast<CWeapon*>(pObj)->SetActivationSpeedOverride(dir.mul(7));
+		pObj->H_SetParent(nullptr, dont_create_shell);
+	}
+	else
+		pObj->H_SetParent(nullptr, dont_create_shell);
 	return							true;
@@ -318,3 +345,3 @@
 	
-	if(ItemFromSlot(slot_id) == pIItem)
+	if (slot_id == NO_ACTIVE_SLOT || ItemFromSlot(slot_id) == pIItem)
 		return false;
@@ -395,3 +425,4 @@
 
-	if (((m_iActiveSlot==slot_id) ||(m_iActiveSlot==NO_ACTIVE_SLOT) && m_iNextActiveSlot==NO_ACTIVE_SLOT) && (!bNotActivate))
+	if (((m_iActiveSlot == slot_id) || (m_iActiveSlot == NO_ACTIVE_SLOT) && m_iNextActiveSlot == NO_ACTIVE_SLOT) && (!
+		bNotActivate) && !smart_cast<CPda*>(pIItem))
 	{
@@ -624,3 +659,5 @@
 {
-	VERIFY(NO_ACTIVE_SLOT != slot);
+	if (slot == NO_ACTIVE_SLOT)
+		return nullptr;
+
 	return m_slots[slot].m_pIItem;
@@ -732,3 +776,22 @@
 			}
-		}break;
+	}
+	break;
+	case kACTIVE_JOBS:
+	{
+		b_send_event = true;
+		if (flags & CMD_START)
+		{
+			if (!psActorFlags.test(AF_3D_PDA)) return false;
+
+			if (smart_cast<CPda*>(ActiveItem()))
+			{
+				Activate(NO_ACTIVE_SLOT);
+			}
+			else
+			{
+				Activate(PDA_SLOT);
+			}
+		}
+	}
+	break;
 	}
@@ -746,6 +809,3 @@
 	{
-		if ( IsGameTypeSingle() )
 			Activate(NO_ACTIVE_SLOT);
-		else
-			ActivateNextItemInActiveSlot();
 
@@ -754,23 +814,2 @@
 	Activate(slot);
-/*
-	if ( IsGameTypeSingle() )
-	{
-		Activate(slot);
-		return;
-	}
-	if ( GetActiveSlot() == slot )
-	{
-		return;
-	}
-
-	Activate(slot);
-	if ( slot != NO_ACTIVE_SLOT && ItemFromSlot(slot) == NULL )
-	{
-		u16 prev_activ = GetActiveSlot();
-		m_iActiveSlot  = slot;
-		if ( !ActivateNextItemInActiveSlot() )
-		{
-			m_iActiveSlot = prev_activ;
-		}
-	}*/
 }
@@ -806,2 +845,5 @@
 			
+			if (m_change_after_deactivate)
+				ActivateNextGrenage();
+
 			if (GetNextActiveSlot() != NO_ACTIVE_SLOT)
@@ -822,11 +865,14 @@
 			
-//			if ( m_iActiveSlot != GetNextActiveSlot() ) {
-//				LPCSTR const name = smart_cast<CGameObject const*>(m_pOwner)->cName().c_str();
-//				if ( !xr_strcmp("jup_b43_stalker_assistant_pri6695", name) )
-//					LogStackTrace	("");
-//				Msg					("[%6d][%s] CInventory::Activate changing active slot from %d to next active slot %d", Device.dwTimeGlobal, name, m_iActiveSlot, GetNextActiveSlot() );
-//			}
+			// demonized: add on changed slot callback
+			luabind::functor<void> funct;
+			auto prev_obj = ActiveItem() ? ActiveItem()->object().lua_game_object() : NULL;
+			auto prev_slot = m_iActiveSlot;
 			m_iActiveSlot			= GetNextActiveSlot();
+			auto obj = ActiveItem() ? ActiveItem()->object().lua_game_object() : NULL;
+			if (ai().script_engine().functor("_G.CActor_OnChangedSlot", funct))
+			{
+				funct(m_iActiveSlot, obj, prev_slot, prev_obj);
 		}
-		if((GetNextActiveSlot()!=NO_ACTIVE_SLOT) && ActiveItem() && ActiveItem()->cast_hud_item()->IsHidden())
+		}
+		else if ((GetNextActiveSlot() != NO_ACTIVE_SLOT) && ActiveItem() && ActiveItem()->cast_hud_item()->IsHidden())
 				ActiveItem()->ActivateItem();
@@ -846,3 +892,3 @@
 
-	for(i = 0; i < 2; ++i)	
+	for (u16 i = 0; i < 2; ++i)
 	{
@@ -1077,3 +1125,3 @@
 #endif // MP_LOGGING
-
+	/*
 	luabind::functor<bool>	funct;
@@ -1084,3 +1132,3 @@
 	}
-	
+	*/
 	if (Actor()->m_inventory == this)
@@ -1166,2 +1214,9 @@
 
+	if (slot_id == BACKPACK_SLOT)
+	{
+		CCustomOutfit* pOutfit = m_pOwner->GetOutfit();
+		if (pOutfit && !pOutfit->bIsBackpackAvaliable)
+			return false;
+	}
+
 	if(slot_id!=NO_ACTIVE_SLOT && 
@@ -1227,2 +1287,12 @@
 
+CInventoryItem* CInventory::GetItemFromInventory(u16 id)
+{
+	TIItemContainer& l_list = m_all;
+
+	for (TIItemContainer::iterator l_it = l_list.begin(); l_list.end() != l_it; ++l_it)
+		if ((*l_it)->object().ID() == id)
+			return (*l_it);
+
+	return (0);
+}
 
@@ -1237,3 +1307,4 @@
 
-	for(TIItemContainer::const_iterator it = m_all.begin(); it != m_all.end(); it++)
+	TIItemContainer::const_iterator it;
+	for (it = m_all.begin(); it != m_all.end(); it++)
 		if((*it)->object().ID() == inventory_item->object().ID()) break;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Inventory.h xray-monolith/src/xrGame/Inventory.h
--- coc-1.4-xray-64/src/xrGame/Inventory.h	2023-10-20 20:54:50.631327000 +0100
+++ xray-monolith/src/xrGame/Inventory.h	2023-10-20 20:54:32.612037200 +0100
@@ -69,2 +69,5 @@
 	void					Activate			(u16 slot, /*EActivationReason reason=eGeneral, */bool bForce=false);
+	void ActivateDeffered();
+	PIItem GetNextActiveGrenade();
+	bool ActivateNextGrenage();
 	
@@ -105,2 +108,3 @@
 	PIItem					GetItemFromInventory(LPCSTR caItemName);
+	PIItem GetItemFromInventory(u16 id);
 
@@ -180,2 +184,4 @@
 
+	bool m_change_after_deactivate;
+
 	void				SendActionEvent		(u16 cmd, u32 flags);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/inventory_item.cpp xray-monolith/src/xrGame/inventory_item.cpp
--- coc-1.4-xray-64/src/xrGame/inventory_item.cpp	2023-10-20 20:54:51.133326700 +0100
+++ xray-monolith/src/xrGame/inventory_item.cpp	2023-10-20 20:54:33.043035600 +0100
@@ -104,2 +104,11 @@
 
+	if (pSettings->line_exist(section, "kind"))
+		m_kind._set(pSettings->r_string(section, "kind"));
+	else
+	{
+		m_kind = NULL;
+		if (FS.m_Flags.test(FS.flPrintLTX))
+			Log("'kind' for section %s doesn't exist!", section);
+	}
+
 	m_weight			= pSettings->r_float(section, "inv_weight");
@@ -132,2 +141,3 @@
 
+	m_fLowestBatteryCharge = READ_IF_EXISTS(pSettings, r_float, section, "power_critical", .03f);
 }
@@ -308,3 +322,3 @@
 			else
-				D->ID_Parent	= NULL;
+				D->ID_Parent = 0xffff;
 		}
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/inventory_item.h xray-monolith/src/xrGame/inventory_item.h
--- coc-1.4-xray-64/src/xrGame/inventory_item.h	2023-10-20 20:54:51.134326400 +0100
+++ xray-monolith/src/xrGame/inventory_item.h	2023-10-20 20:54:33.043035600 +0100
@@ -18,4 +18,6 @@
 #include "xrserver_objects_alife_items.h"
+#include "script_export_space.h"
 
-enum EHandDependence{
+enum EHandDependence
+{
 	hdNone	= 0,
@@ -100,3 +109,3 @@
 	
-	virtual bool				Useful				() const;									// !!! Ïåðåîïðåäåëèòü. (ñì. â Inventory.cpp)
+	virtual bool Useful() const; // !!! ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½. (ï¿½ï¿½. ï¿½ Inventory.cpp)
 	virtual bool				IsUsingCondition() const { return ( m_flags.test( FUsingCondition ) > 0 ); };
@@ -105,3 +114,3 @@
 	virtual bool				Detach				(PIItem pIItem) {return false;}
-	//ïðè äåòà÷å ñïàóíèòñÿ íîâàÿ âåùü ïðè çàäàííî íàçâàíèè ñåêöèè
+	//ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
 	virtual bool				Detach				(const char* item_section_name, bool b_spawn_item);
@@ -112,6 +121,8 @@
 	virtual bool				IsSingleHanded		()	const	{return true;};	
-	virtual bool				ActivateItem		();									// !!! Ïåðåîïðåäåëèòü. (ñì. â Inventory.cpp)
-	virtual void				DeactivateItem		();								// !!! Ïåðåîïðåäåëèòü. (ñì. â Inventory.cpp)
-	virtual bool				Action				(u16 cmd, u32 flags) {return false;}	// true åñëè èçâåñòíàÿ êîìàíäà, èíà÷å false
-	virtual void				DiscardState		() {};
+	virtual bool ActivateItem(); // !!! ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½. (ï¿½ï¿½. ï¿½ Inventory.cpp)
+	virtual void DeactivateItem(); // !!! ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½. (ï¿½ï¿½. ï¿½ Inventory.cpp)
+	virtual bool Action(u16 cmd, u32 flags) { return false; } // true ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½, ï¿½ï¿½ï¿½ï¿½ï¿½ false
+	virtual void DiscardState()
+	{
+	};
 
@@ -150,2 +163,3 @@
 	shared_str					m_nameComplex;
+	shared_str m_kind;
 	bool						m_highlight_equipped;
@@ -168,2 +190,3 @@
 			void				ChangeCondition		(float fDeltaCondition);
+	IC float GetLowestBatteryCharge() const { return m_fLowestBatteryCharge; }
 
@@ -180,2 +203,3 @@
 	virtual bool				CanTake				() const					{return !!m_flags.test(FCanTake);}
+	void SetCanTake(BOOL val) { m_flags.set(FCanTake, val); }
 			bool				CanTrade			() const;
@@ -270,2 +305,3 @@
 	virtual CMissile			*cast_missile				()	{return 0;}
+	virtual CFlashlight* cast_flashlight() { return 0; }
 	virtual CHudItem			*cast_hud_item				()	{return 0;}
@@ -320,3 +358,3 @@
 	bool								m_activated;
-
+	float m_fLowestBatteryCharge;
 public:
@@ -324,2 +362,3 @@
 	IC void	set_is_helper				(bool is_helper) { m_flags.set(FIsHelperItem,is_helper); }
+	DECLARE_SCRIPT_REGISTER_FUNCTION
 }; // class CInventoryItem
@@ -327 +366,5 @@
 #include "inventory_item_inline.h"
+
+add_to_type_list(CInventoryItem)
+#undef script_type_list
+#define script_type_list save_type_list(CInventoryItem)
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/inventory_item_object.h xray-monolith/src/xrGame/inventory_item_object.h
--- coc-1.4-xray-64/src/xrGame/inventory_item_object.h	2023-10-20 20:54:51.135326900 +0100
+++ xray-monolith/src/xrGame/inventory_item_object.h	2023-10-20 20:54:33.044036100 +0100
@@ -29,2 +29,3 @@
 	virtual CMissile		*cast_missile					()	{return 0;}
+	virtual CFlashlight* cast_flashlight() { return 0; }
 	virtual CHudItem		*cast_hud_item					()	{return 0;}
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/inventory_quickswitch.cpp xray-monolith/src/xrGame/inventory_quickswitch.cpp
--- coc-1.4-xray-64/src/xrGame/inventory_quickswitch.cpp	2023-10-20 20:54:51.136326700 +0100
+++ xray-monolith/src/xrGame/inventory_quickswitch.cpp	2023-10-20 20:54:33.046036700 +0100
@@ -1,2 +1,2 @@
-#include "stdafx.h"
+ï»¿#include "stdafx.h"
 #include "inventory.h"
@@ -5,2 +5,3 @@
 #include "../xrCore/xr_ini.h"
+#include "Grenade.h"
 
@@ -266 +273,96 @@
 }
\ No newline at end of file
+
+////////////////////////////////////
+
+void CInventory::ActivateDeffered()
+{
+	m_change_after_deactivate = true;
+	Activate(NO_ACTIVE_SLOT);
+}
+
+PIItem CInventory::GetNextActiveGrenade()
+{
+	// (c) NanoBot
+	xr_vector<shared_str> types_sect_grn; // Ã²Ã¥ÃªÃ³Ã¹Ã¨Ã© Ã±Ã¯Ã¨Ã±Ã®Ãª Ã±Ã¥ÃªÃ¶Ã¨Ã© Ã£Ã°Ã Ã­Ã Ã²
+	// ÃÃ ÃµÃ®Ã¤Ã¨Ã¬ Ã±Ã¯Ã¨Ã±Ã®Ãª Ã±Ã¥ÃªÃ¶Ã¨Ã© Ã£Ã°Ã Ã­Ã Ã² Ã°Ã Ã§Ã­Ã»Ãµ Ã²Ã¨Ã¯Ã®Ã¢ Ã¢ Ã ÃªÃ²Ã¨Ã¢Ã¥
+	// Ã¢ m_belt Ã¨Ã«Ã¨ m_ruck Ã­Ã¥Ã² Ã£Ã°Ã Ã­Ã Ã²Ã» ÃªÃ®Ã²Ã®Ã°Ã³Ã¾ Ã ÃªÃ²Ã®Ã° Ã¤Ã¥Ã°Ã¦Ã¨Ã² Ã¢ Ã°Ã³ÃªÃ Ãµ, Ã².Ã¥. this
+	types_sect_grn.push_back(ActiveItem()->cast_game_object()->cNameSect());
+	int count_types = 1; // Ã²Ã¥ÃªÃ³Ã¹Ã¨Ã¥ ÃªÃ®Ã«Ã¨Ã·Ã¥Ã±Ã²Ã¢Ã® Ã²Ã¨Ã¯Ã®Ã¢ Ã£Ã°Ã Ã­Ã Ã² Ã¢ Ã ÃªÃ²Ã¨Ã¢Ã¥
+	TIItemContainer::iterator it = m_ruck.begin();
+	TIItemContainer::iterator it_e = m_ruck.end();
+	for (; it != it_e; ++it)
+	{
+		CGrenade* pGrenade = smart_cast<CGrenade*>(*it);
+		if (pGrenade)
+		{
+			// Ã±Ã®Ã±Ã²Ã Ã¢Ã«Ã¿Ã¥Ã¬ Ã±Ã¯Ã¨Ã±Ã®Ãª Ã²Ã¨Ã¯Ã®Ã¢ Ã£Ã°Ã Ã­Ã Ã² (Ã±) ÃÃ Ã­Ã®ÃÃ®Ã²
+			xr_vector<shared_str>::const_iterator I = types_sect_grn.begin();
+			xr_vector<shared_str>::const_iterator E = types_sect_grn.end();
+			bool new_type = true;
+			for (; I != E; ++I)
+			{
+				if (!xr_strcmp(pGrenade->cNameSect(), *I)) // Ã¥Ã±Ã«Ã¨ Ã±Ã®Ã¢Ã¯Ã Ã¤Ã Ã¾Ã²
+					new_type = false;
+			}
+			if (new_type) // Ã­Ã®Ã¢Ã»Ã© Ã²Ã¨Ã¯ Ã£Ã°Ã Ã­Ã Ã²Ã»?, Ã¤Ã®Ã¡Ã Ã¢Ã«Ã¿Ã¥Ã¬
+			{
+				types_sect_grn.push_back(pGrenade->cNameSect());
+				count_types++;
+			}
+		}
+	}
+	// ÃÃ±Ã«Ã¨ Ã²Ã¨Ã¯Ã®Ã¢ Ã¡Ã®Ã«Ã¼Ã¸Ã¥ 1 Ã²Ã®, Ã±Ã®Ã°Ã²Ã¨Ã°Ã³Ã¥Ã¬ Ã±Ã¯Ã¨Ã±Ã®Ãª Ã¯Ã® Ã Ã«Ã´Ã Ã¢Ã¨Ã²Ã³
+	// Ã¨ Ã­Ã ÃµÃ®Ã¤Ã¨Ã¬ Ã­Ã®Ã¬Ã¥Ã° Ã²Ã¥ÃªÃ³Ã¹Ã¥Ã© Ã£Ã°Ã Ã­Ã Ã²Ã» Ã¢ Ã±Ã¯Ã¨Ã±ÃªÃ¥.
+	if (count_types > 1)
+	{
+		int curr_num = 0; // Ã­Ã®Ã¬Ã¥Ã° Ã²Ã¨Ã¯Ã  Ã²Ã¥ÃªÃ³Ã¹Ã¥Ã© Ã£Ã°Ã Ã­Ã Ã²Ã»
+		std::sort(types_sect_grn.begin(), types_sect_grn.end());
+		xr_vector<shared_str>::const_iterator I = types_sect_grn.begin();
+		xr_vector<shared_str>::const_iterator E = types_sect_grn.end();
+		for (; I != E; ++I)
+		{
+			if (!xr_strcmp(ActiveItem()->cast_game_object()->cNameSect(), *I)) // Ã¥Ã±Ã«Ã¨ Ã±Ã®Ã¢Ã¯Ã Ã¤Ã Ã¾Ã²
+				break;
+			curr_num++;
+		}
+		int next_num = curr_num + 1; // Ã­Ã®Ã¬Ã¥Ã° Ã±Ã¥ÃªÃ¶Ã¨Ã¨ Ã±Ã«Ã¥Ã¤Ã³Ã¾Ã¹Ã¥Ã© Ã£Ã°Ã Ã­Ã Ã²Ã»
+		if (next_num >= count_types)
+			next_num = 0;
+
+		shared_str sect_next_grn = types_sect_grn[next_num]; // Ã±Ã¥ÃªÃ¶Ã¨Ã¿ Ã±Ã«Ã¥Ã¤Ã³Ã¹Ã¥Ã© Ã£Ã°Ã Ã­Ã Ã²Ã»
+		// ÃÃ¹Ã¥Ã¬ Ã¢ Ã ÃªÃ²Ã¨Ã¢Ã¥ Ã£Ã°Ã Ã­Ã Ã²Ã³ Ã± Ã±Ã¥ÃªÃ¶Ã¨Ã¥Ã© Ã±Ã«Ã¥Ã¤Ã³Ã¹Ã¥Ã£Ã® Ã²Ã¨Ã¯Ã 
+		it = m_ruck.begin();
+		it_e = m_ruck.end();
+		for (; it != it_e; ++it)
+		{
+			CGrenade* pGrenade = smart_cast<CGrenade*>(*it);
+			if (pGrenade && !xr_strcmp(pGrenade->cNameSect(), sect_next_grn))
+				return *it;
+		}
+	}
+
+	return nullptr;
+}
+
+bool CInventory::ActivateNextGrenage()
+{
+	if (m_iActiveSlot == NO_ACTIVE_SLOT)
+		return false;
+
+	CObject* pActor_owner = smart_cast<CObject*>(m_pOwner);
+	if (Level().CurrentViewEntity() != pActor_owner)
+		return false;
+
+	PIItem new_item = GetNextActiveGrenade();
+	if (!new_item)
+		return false;
+
+	PIItem current_item = ActiveItem();
+	if (current_item)
+	{
+		m_change_after_deactivate = false;
+		Ruck(current_item);
+		Slot(new_item->BaseSlot(), new_item);
+	}
+	return true;
+}
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/InventoryBox.cpp xray-monolith/src/xrGame/InventoryBox.cpp
--- coc-1.4-xray-64/src/xrGame/InventoryBox.cpp	2023-10-20 20:54:50.631327000 +0100
+++ xray-monolith/src/xrGame/InventoryBox.cpp	2023-10-20 20:54:32.613035400 +0100
@@ -86,5 +92,7 @@
 #include "../xrServerEntities/xrServer_Objects_Alife.h"
+
 BOOL CInventoryBox::net_Spawn(CSE_Abstract* DC)
 {
-	inherited::net_Spawn	(DC);
+	if (!inherited::net_Spawn(DC)) return FALSE;
+
 	setVisible				(TRUE);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/InventoryBox.h xray-monolith/src/xrGame/InventoryBox.h
--- coc-1.4-xray-64/src/xrGame/InventoryBox.h	2023-10-20 20:54:50.631327000 +0100
+++ xray-monolith/src/xrGame/InventoryBox.h	2023-10-20 20:54:32.613035400 +0100
@@ -3,2 +3,3 @@
 #include "GameObject.h"
+#include "script_export_space.h"
 
@@ -40,2 +41,7 @@
 
+	DECLARE_SCRIPT_REGISTER_FUNCTION
 };
+
+add_to_type_list(CInventoryBox)
+#undef script_type_list
+#define script_type_list save_type_list(CInventoryBox)
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/InventoryOwner.cpp xray-monolith/src/xrGame/InventoryOwner.cpp
--- coc-1.4-xray-64/src/xrGame/InventoryOwner.cpp	2023-10-20 20:54:50.632326900 +0100
+++ xray-monolith/src/xrGame/InventoryOwner.cpp	2023-10-20 20:54:32.614035200 +0100
@@ -28,2 +28,3 @@
 #include "Bolt.h"
+#include "string_table.h"
 
@@ -49,2 +50,4 @@
     m_play_show_hide_reload_sounds = true;
+
+	m_trader_flags.zero();
 }
@@ -143,2 +146,3 @@
         }
+		m_game_name_str = pTrader->m_character_name_str;
         m_game_name = pTrader->m_character_name;
@@ -147,2 +151,3 @@
         m_deadbody_closed = pTrader->m_deadbody_closed;
+		m_trader_flags.assign(pTrader->m_trader_flags.get());
     }
@@ -177,3 +184,3 @@
     CharacterInfo().save(output_packet);
-    save_data(m_game_name, output_packet);
+	save_data(m_game_name_str, output_packet);
     save_data(m_money, output_packet);
@@ -191,4 +199,11 @@
     CharacterInfo().load(input_packet);
-    load_data(m_game_name, input_packet);
+	load_data(m_game_name_str, input_packet);
     load_data(m_money, input_packet);
+	if (this->object_id() != Actor()->object_id())
+		m_game_name = TranslateName(m_game_name_str.c_str());
+}
+
+void CInventoryOwner::refresh_npc_name()
+{
+	m_game_name = TranslateName(m_game_name_str.c_str());
 }
@@ -362,4 +378,6 @@
     if (use_bolts())
-        Level().spawn_item("bolt", game_object->Position(), game_object->ai_location().level_vertex_id(), game_object->ID());
+		Level().spawn_item("bolt", game_object->Position(), game_object->ai_location().level_vertex_id(),
+		                   game_object->ID());
 
+	/*
     if (!ai().get_alife() && IsGameTypeSingle())
@@ -375,2 +393,3 @@
     }
+	*/
 }
@@ -423,2 +444,5 @@
     trader->m_community_index = new_community;
+
+	if (EA->ID() == Actor()->ID())
+		Actor()->RPC_UpdateFaction();
 }
@@ -435,2 +460,5 @@
     trader->m_rank = rank;
+
+	if (EA->ID() == Actor()->ID())
+		Actor()->RPC_UpdateRank();
 }
@@ -453,2 +482,5 @@
     trader->m_reputation = reputation;
+
+	if (EA->ID() == Actor()->ID())
+		Actor()->RPC_UpdateReputation();
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/InventoryOwner.h xray-monolith/src/xrGame/InventoryOwner.h
--- coc-1.4-xray-64/src/xrGame/InventoryOwner.h	2023-10-20 20:54:50.632326900 +0100
+++ xray-monolith/src/xrGame/InventoryOwner.h	2023-10-20 20:54:32.614035200 +0100
@@ -12,2 +12,5 @@
 #include "inventory_space.h"
+#include "script_export_space.h"
+
+extern xr_string TranslateName(LPCSTR nameStr);
 
@@ -52,2 +56,3 @@
 
+	void refresh_npc_name();
 	
@@ -57,2 +62,7 @@
 
+	void ChangeName(LPCSTR name)
+	{
+		m_game_name_str = name;
+		m_game_name = TranslateName(name);
+	}
 
@@ -108,2 +121,3 @@
 	u32					m_money;
+	Flags32 m_trader_flags;
 	// òîðãîâëÿ
@@ -181,2 +212,3 @@
 	xr_string				m_game_name;
+	xr_string m_game_name_str;
 
@@ -239,2 +278,3 @@
 	IC		bool				deadbody_closed_status	() const { return m_deadbody_closed; }
+	DECLARE_SCRIPT_REGISTER_FUNCTION
 };
@@ -242 +282,5 @@
 #include "inventory_owner_inline.h"
\ No newline at end of file
+
+add_to_type_list(CInventoryOwner)
+#undef script_type_list
+#define script_type_list save_type_list(CInventoryOwner)
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/key_binding_registrator_script.cpp xray-monolith/src/xrGame/key_binding_registrator_script.cpp
--- coc-1.4-xray-64/src/xrGame/key_binding_registrator_script.cpp	2023-10-20 20:54:51.144327100 +0100
+++ xray-monolith/src/xrGame/key_binding_registrator_script.cpp	2023-10-20 20:54:33.054035700 +0100
@@ -4,2 +4,3 @@
 #include "xr_level_controller.h"
+#include "xrEngine/xr_input.h"
 
@@ -11,2 +13,7 @@
 
+BOOL key_state(int key)
+{
+	return pInput->iGetAsyncKeyState(key);
+}
+
 #pragma optimize("s",on)
@@ -17,2 +24,4 @@
 		def("dik_to_bind",		&dik_to_bind),
+		def("bind_to_dik", &get_action_dik),
+		def("key_state", &key_state),
 
@@ -21,9 +30,2 @@
 			[
-				value("kFWD",						int(kFWD)),
-				value("kARTEFACT",					int(kARTEFACT)),
-				value("kBACK",						int(kBACK)),
-				value("kL_STRAFE",					int(kL_STRAFE)),
-				value("kR_STRAFE",					int(kR_STRAFE)),
-				value("kL_LOOKOUT",					int(kL_LOOKOUT)),
-				value("kR_LOOKOUT",					int(kR_LOOKOUT)),
 				value("kLEFT",						int(kLEFT)),
@@ -35,2 +37,9 @@
 				value("kACCEL",						int(kACCEL)),
+			value("kSPRINT_TOGGLE", int(kSPRINT_TOGGLE)),
+			value("kFWD", int(kFWD)),
+			value("kBACK", int(kBACK)),
+			value("kL_STRAFE", int(kL_STRAFE)),
+			value("kR_STRAFE", int(kR_STRAFE)),
+			value("kL_LOOKOUT", int(kL_LOOKOUT)),
+			value("kR_LOOKOUT", int(kR_LOOKOUT)),
 				value("kCAM_1",						int(kCAM_1)),
@@ -40,22 +49,5 @@
 				value("kCAM_ZOOM_OUT",				int(kCAM_ZOOM_OUT)),
-				value("kQUICK_SAVE",				int(kQUICK_SAVE)),
-				value("kQUICK_LOAD",				int(kQUICK_LOAD)),
-				value("kCAM_AUTOAIM",				int(kCAM_AUTOAIM)),
-				value("kCUSTOM1",					int(kCUSTOM1)),
-				value("kCUSTOM2",					int(kCUSTOM2)),
-				value("kCUSTOM3",					int(kCUSTOM3)),
-				value("kCUSTOM4",					int(kCUSTOM4)),
-				value("kCUSTOM5",					int(kCUSTOM5)),
-				value("kCUSTOM6",					int(kCUSTOM6)),
-				value("kCUSTOM7",					int(kCUSTOM7)),
-				value("kCUSTOM8",					int(kCUSTOM8)),
-				value("kCUSTOM9",					int(kCUSTOM9)),
-				value("kCUSTOM10",					int(kCUSTOM10)),
-				value("kCUSTOM11",					int(kCUSTOM11)),
-				value("kCUSTOM12",					int(kCUSTOM12)),
-				value("kCUSTOM13",					int(kCUSTOM13)),
-				value("kCUSTOM14",					int(kCUSTOM14)),
-				value("kCUSTOM15",					int(kCUSTOM15)),
 				value("kTORCH",						int(kTORCH)),
 				value("kNIGHT_VISION",				int(kNIGHT_VISION)),
+			value("kDETECTOR", int(kDETECTOR)),
 				value("kWPN_1",						int(kWPN_1)),
@@ -66,11 +58,18 @@
 				value("kWPN_6",						int(kWPN_6)),
+			value("kARTEFACT", int(kARTEFACT)),
 				value("kWPN_NEXT",					int(kWPN_NEXT)),
 				value("kWPN_FIRE",					int(kWPN_FIRE)),
-				value("kWPN_RELOAD",				int(kWPN_RELOAD)),
 				value("kWPN_ZOOM",					int(kWPN_ZOOM)),
+			value("kWPN_ZOOM_INC", int(kWPN_ZOOM_INC)),
+			value("kWPN_ZOOM_DEC", int(kWPN_ZOOM_DEC)),
+			value("kWPN_RELOAD", int(kWPN_RELOAD)),
 				value("kWPN_FUNC",					int(kWPN_FUNC)),
-				value("kUSE",						int(kUSE)),
+			value("kWPN_FIREMODE_PREV", int(kWPN_FIREMODE_PREV)),
+			value("kWPN_FIREMODE_NEXT", int(kWPN_FIREMODE_NEXT)),
+			value("kPAUSE", int(kPAUSE)),
 				value("kDROP",						int(kDROP)),
+			value("kUSE", int(kUSE)),
 				value("kSCORES",					int(kSCORES)),
 				value("kCHAT",						int(kCHAT)),
+			value("kCHAT_TEAM", int(kCHAT_TEAM)),
 				value("kSCREENSHOT",				int(kSCREENSHOT)),
@@ -81,3 +80,47 @@
 				value("kSKIN",						int(kSKIN)),
-				value("kTEAM",						int(kTEAM))
+			value("kTEAM", int(kTEAM)),
+			value("kACTIVE_JOBS", int(kACTIVE_JOBS)),
+			value("kVOTE_BEGIN", int(kVOTE_BEGIN)),
+			value("kSHOW_ADMIN_MENU", int(kSHOW_ADMIN_MENU)),
+			value("kVOTE", int(kVOTE)),
+			value("kVOTEYES", int(kVOTEYES)),
+			value("kVOTENO", int(kVOTENO)),
+			value("kNEXT_SLOT", int(kNEXT_SLOT)),
+			value("kPREV_SLOT", int(kPREV_SLOT)),
+			value("kSPEECH_MENU_0", int(kSPEECH_MENU_0)),
+			value("kSPEECH_MENU_1", int(kSPEECH_MENU_1)),
+			value("kQUICK_USE_1", int(kQUICK_USE_1)),
+			value("kQUICK_USE_2", int(kQUICK_USE_2)),
+			value("kQUICK_USE_3", int(kQUICK_USE_3)),
+			value("kQUICK_USE_4", int(kQUICK_USE_4)),
+			value("kQUICK_SAVE", int(kQUICK_SAVE)),
+			value("kQUICK_LOAD", int(kQUICK_LOAD)),
+			value("kCUSTOM1", int(kCUSTOM1)),
+			value("kCUSTOM2", int(kCUSTOM2)),
+			value("kCUSTOM3", int(kCUSTOM3)),
+			value("kCUSTOM4", int(kCUSTOM4)),
+			value("kCUSTOM5", int(kCUSTOM5)),
+			value("kCUSTOM6", int(kCUSTOM6)),
+			value("kCUSTOM7", int(kCUSTOM7)),
+			value("kCUSTOM8", int(kCUSTOM8)),
+			value("kCUSTOM9", int(kCUSTOM9)),
+			value("kCUSTOM10", int(kCUSTOM10)),
+			value("kCUSTOM11", int(kCUSTOM11)),
+			value("kCUSTOM12", int(kCUSTOM12)),
+			value("kCUSTOM13", int(kCUSTOM13)),
+			value("kCUSTOM14", int(kCUSTOM14)),
+			value("kCUSTOM15", int(kCUSTOM15)),
+			value("kCUSTOM16", int(kCUSTOM16)),
+			value("kCUSTOM17", int(kCUSTOM17)),
+			value("kCUSTOM18", int(kCUSTOM18)),
+			value("kCUSTOM19", int(kCUSTOM19)),
+			value("kCUSTOM20", int(kCUSTOM20)),
+			value("kCUSTOM21", int(kCUSTOM21)),
+			value("kCUSTOM22", int(kCUSTOM22)),
+			value("kCUSTOM23", int(kCUSTOM23)),
+			value("kCUSTOM24", int(kCUSTOM24)),
+			value("kCUSTOM25", int(kCUSTOM25)),
+			value("kSAFEMODE", int(kSAFEMODE)),
+			value("kFREELOOK", int(kFREELOOK)),
+			value("kCAM_AUTOAIM", int(kCAM_AUTOAIM))
 			],
@@ -210,2 +253,7 @@
 				value("MOUSE_3",						int(MOUSE_3			)),
+			value("MOUSE_4", int(MOUSE_4)),
+			value("MOUSE_5", int(MOUSE_5)),
+			value("MOUSE_6", int(MOUSE_6)),
+			value("MOUSE_7", int(MOUSE_7)),
+			value("MOUSE_8", int(MOUSE_8)),
 				value("DIK_RETURN",						int(DIK_RETURN		)),
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Level.cpp xray-monolith/src/xrGame/Level.cpp
--- coc-1.4-xray-64/src/xrGame/Level.cpp	2023-10-20 20:54:50.632326900 +0100
+++ xray-monolith/src/xrGame/Level.cpp	2023-10-20 20:54:32.615036700 +0100
@@ -53,2 +53,8 @@
 
+#include "UIGameCustom.h"
+#include "ui/UIPdaWnd.h"
+#include "UICursor.h"
+#include "debug_renderer.h"
+#include "LevelDebugScript.h"
+
 #ifdef DEBUG
@@ -56,3 +62,2 @@
 #include "ai/stalker/ai_stalker.h"
-#include "debug_renderer.h"
 #include "PhysicObject.h"
@@ -61,3 +66,3 @@
 #endif
-ENGINE_API bool g_dedicated_server;
+extern ENGINE_API bool g_dedicated_server;
 //AVO: used by SPAWN_ANTIFREEZE (by alpet)
@@ -94,2 +99,70 @@
 
+namespace crash_saving {
+	extern void(*save_impl)();
+	static bool g_isSaving = false;
+	int saveCountMax = 10;
+
+	void _save_impl()
+	{
+		if (g_isSaving) return;
+		if (saveCountMax <= 0) return;
+
+		int saveCount = -1;
+		g_isSaving = true;
+		NET_Packet net_packet;
+		net_packet.w_begin(M_SAVE_GAME);
+
+		std::string path = "fatal_ctd_save_";
+		std::string path_mask(path);
+		std::string path_ext = ".scop";
+		path_mask.append("*").append(path_ext);
+
+		FS_FileSet fset_temp;
+		FS.file_list(fset_temp, "$game_saves$", FS_ListFiles | FS_RootOnly, path_mask.c_str());
+
+		std::vector<FS_File> fset(fset_temp.begin(), fset_temp.end());
+		struct {
+			bool operator()(FS_File& a, FS_File& b) {
+				return a.time_write > b.time_write;
+			}
+		} sortFilesDesc;
+		std::sort(fset.begin(), fset.end(), sortFilesDesc);
+
+		//Msg("save mask %s", path_mask.c_str());
+
+		for (auto &file : fset)
+		{
+			string128 name;
+			xr_strcpy(name, sizeof(name), file.name.c_str());
+			std::string name_string(name);
+			name_string.erase(name_string.length() - path_ext.length());
+
+			//Msg("found save file %s, save_name %s", name, name_string.c_str());
+
+			try {
+				//Msg("save number %s", name_string.substr(path.length()).c_str());
+				int name_count = std::stoi(name_string.substr(path.length()));
+				saveCount = name_count;
+				break;
+			} catch (...) {
+				Msg("!error getting save number from %s", name);
+			}
+		}
+
+		saveCount++;
+		if (saveCount >= saveCountMax) {
+			saveCount = 0;
+		}
+
+		path.append(std::to_string(saveCount));
+		net_packet.w_stringZ(path.c_str());
+		net_packet.w_u8(1);
+		CLevel& level = Level();
+		if (&level != nullptr)
+		{
+			level.Send(net_packet, net_flags(1));
+		}
+
+	}
+}
 
@@ -139,2 +212,3 @@
     Msg("%s", Core.Params);
+	crash_saving::save_impl = crash_saving::_save_impl; // CLevel ready, we can save now
 }
@@ -145,2 +219,3 @@
 {
+	crash_saving::save_impl = nullptr; // CLevel not available, disable crash save
     xr_delete(g_player_hud);
@@ -178,5 +253,4 @@
     xr_delete(m_autosave_manager);
-#ifdef DEBUG
     xr_delete(m_debug_renderer);
-#endif
+	delete_data(m_debug_render_queue);
     if (!g_dedicated_server)
@@ -690,3 +766,4 @@
 
-int psLUA_GCSTEP = 10;
+int psLUA_GCSTEP = 100;
+
 void CLevel::script_gc()
@@ -705,2 +782,4 @@
 extern void draw_wnds_rects();
+extern bool use_reshade;
+extern void render_reshade_effects();
 
@@ -708,2 +787,56 @@
 {
+	// PDA
+	if (game && CurrentGameUI() && &CurrentGameUI()->GetPdaMenu() != nullptr)
+	{
+		CUIPdaWnd* pda = &CurrentGameUI()->GetPdaMenu();
+		if (psActorFlags.test(AF_3D_PDA) && pda->IsShown())
+		{
+			pda->Draw();
+			CUICursor* cursor = &UI().GetUICursor();
+
+			if (cursor)
+			{
+				static bool need_reset;
+				bool is_top = CurrentGameUI()->TopInputReceiver() == pda;
+
+				if (pda->IsEnabled() && is_top && !Console->bVisible)
+				{
+					if (need_reset)
+					{
+						need_reset = false;
+						pda->ResetCursor();
+					}
+
+					Frect &pda_border = pda->m_cursor_box;
+					Fvector2 cursor_pos = cursor->GetCursorPosition();
+
+					if (!pda_border.in(cursor_pos))
+					{
+						clamp(cursor_pos.x, pda_border.left, pda_border.right);
+						clamp(cursor_pos.y, pda_border.top, pda_border.bottom);
+						cursor->SetUICursorPosition(cursor_pos);
+					}
+
+					Fvector2 cursor_pos_dif;
+					cursor_pos_dif.set(cursor_pos);
+					cursor_pos_dif.sub(pda->last_cursor_pos);
+					pda->last_cursor_pos.set(cursor_pos);
+					pda->MouseMovement(cursor_pos_dif.x, cursor_pos_dif.y);
+				}
+				else
+					need_reset = true;
+
+				if (is_top)
+					cursor->OnRender();
+			}
+			Render->RenderToTarget(Render->rtPDA);
+		}
+
+		if (Actor() && Actor()->m_bDelayDrawPickupItems)
+		{
+			Actor()->m_bDelayDrawPickupItems = false;
+			Actor()->DrawPickupItems();
+		}
+	}
+
     inherited::OnRender();
@@ -712,6 +845,14 @@
     Game().OnRender();
-    //Device.Statistic->TEST1.Begin();
     BulletManager().Render();
-    //Device.Statistic->TEST1.End();
+
+	if (Device.m_SecondViewport.IsSVPFrame())
+		Render->RenderToTarget(Render->rtSVP);
+
+	if (use_reshade)
+		render_reshade_effects();
+
     HUD().RenderUI();
+
+	ScriptDebugRender();
+
 #ifdef DEBUG
@@ -788,3 +929,3 @@
 #endif
-
+	debug_renderer().render();
 #ifdef DEBUG
@@ -796,3 +937,2 @@
     }
-    debug_renderer().render();
     DBG().draw_debug_text();
@@ -824,2 +964,24 @@
 
+void CLevel::ScriptDebugRender()
+{
+	if (!m_debug_render_queue.size())
+		return;
+
+	bool hasVisibleObj = false;
+	xr_map<u16, DBG_ScriptObject*>::iterator it = m_debug_render_queue.begin();
+	xr_map<u16, DBG_ScriptObject*>::iterator it_e = m_debug_render_queue.end();
+	for (; it != it_e; ++it)
+	{
+		DBG_ScriptObject* obj = (*it).second;
+		if (obj->m_visible) {
+			hasVisibleObj = true;
+			obj->Render();
+		}
+	}
+
+	// demonized: fix of showing console window when there are no visible gizmos 
+	if (hasVisibleObj)
+		DRender->OnFrameEnd();
+}
+
 void CLevel::OnEvent(EVENT E, u64 P1, u64 /**P2/**/)
@@ -1067,3 +1230,3 @@
 {
-    return (game->GetGameTimeFactor());
+	return (game ? game->GetGameTimeFactor() : 1.0f);
 }
@@ -1107,2 +1270,3 @@
     GameTaskManager().ResetStorage();
+	delete_data(m_debug_render_queue);
 }
@@ -1113,2 +1277,3 @@
     GameTaskManager().ResetStorage();
+	delete_data(m_debug_render_queue);
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Level.h xray-monolith/src/xrGame/Level.h
--- coc-1.4-xray-64/src/xrGame/Level.h	2023-10-20 20:54:50.633327100 +0100
+++ xray-monolith/src/xrGame/Level.h	2023-10-20 20:54:32.615036700 +0100
@@ -35,6 +35,4 @@
 class demo_info;
-
-#ifdef DEBUG
 class CDebugRenderer;
-#endif
+class DBG_ScriptObject;
 
@@ -72,5 +70,3 @@
     CAutosaveManager* m_autosave_manager = nullptr;
-#ifdef DEBUG
     CDebugRenderer* m_debug_renderer = nullptr;
-#endif
     CPHCommander* m_ph_commander = nullptr;
@@ -223,2 +219,15 @@
     virtual void OnRender();
+
+	enum DBG_RENDER_FLAGS
+	{
+		DBG_Script = 1 << 0,
+		DBG_SpaceRestrictors = 1 << 1,
+		DBG_GameGraph = 1 << 2
+	};
+
+	Flags32 m_debug_render_flags;
+	xr_map<u16, DBG_ScriptObject*> m_debug_render_queue;
+	xr_map<u16, DBG_ScriptObject*>* getScriptRenderQueue() { return &m_debug_render_queue; }
+	void ScriptDebugRender();
+
     virtual	shared_str OpenDemoFile(const char* demo_file_name);
@@ -264,5 +273,3 @@
     IC CAutosaveManager& autosave_manager();
-#ifdef DEBUG
     IC CDebugRenderer& debug_renderer();
-#endif
     void __stdcall script_gc(); // GC-cycle
@@ -377,3 +384,2 @@
 
-#ifdef DEBUG
 IC CDebugRenderer& CLevel::debug_renderer()
@@ -383,3 +389,2 @@
 }
-#endif
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Level_Bullet_Manager.cpp xray-monolith/src/xrGame/Level_Bullet_Manager.cpp
--- coc-1.4-xray-64/src/xrGame/Level_Bullet_Manager.cpp	2023-10-20 20:54:50.634326700 +0100
+++ xray-monolith/src/xrGame/Level_Bullet_Manager.cpp	2023-10-20 20:54:32.616036300 +0100
@@ -14,2 +14,3 @@
 #include "reward_event_generator.h"
+#include "material_manager.h"
 
@@ -43,2 +44,3 @@
 
+u32 SBullet::bulletCount = 0;
 
@@ -60,2 +62,3 @@
 	bullet_pos 				= position;
+	starting_speed *= cartridge.param_s.kBulletSpeed;
 	speed = max_speed		= starting_speed;
@@ -107,2 +110,33 @@
 	density_mode			= 0;
+
+	catridgeSection = cartridge.m_ammoSect.c_str();
+	bulletId = bulletCount++;
+}
+
+// demonized: construct bullet table for Lua
+void populateBulletTable (
+	luabind::object& table,
+	const Fvector& position,
+	const Fvector& direction,
+	float speed,
+	float fly_dist,
+	LPCSTR catridgeSection,
+	u32 bulletId,
+	u16 weaponId,
+	u16 parentId,
+	u16 targetId,
+	LPCSTR materialName,
+	float life_time
+) {
+	table["position"] = position;
+	table["direction"] = direction;
+	table["speed"] = speed;
+	table["distance"] = fly_dist;
+	table["section"] = catridgeSection;
+	table["bullet_id"] = bulletId;
+	table["weapon_id"] = weaponId;
+	table["parent_id"] = parentId;
+	table["target_id"] = targetId;
+	table["material"] = materialName;
+	table["life_time"] = life_time;
 }
@@ -217,3 +251,5 @@
 {
+#ifdef DEBUG
 	VERIFY						( m_thread_id == GetCurrentThreadId() );
+#endif
 
@@ -224,5 +260,28 @@
 	SBullet& bullet				= m_Bullets.back();
-	bullet.Init					(position, direction, starting_speed, power, /*power_critical,*/ impulse, sender_id, sendersweapon_id, e_hit_type, maximum_distance, cartridge, air_resistance_factor, SendHit, iShotNum);
+	bullet.Init(position, direction, starting_speed, power, /*power_critical,*/ impulse, sender_id, sendersweapon_id,
+	            e_hit_type, maximum_distance, cartridge, air_resistance_factor, SendHit, iShotNum);
 //	bullet.frame_num			= Device.dwFrame;
 	bullet.flags.aim_bullet		= AimBullet;
+
+	// demonized - bullet on init callback
+	luabind::functor<void> funct;
+	if (ai().script_engine().functor("_G.CBulletOnInit", funct)) {
+		luabind::object table = luabind::newtable(ai().script_engine().lua());
+		populateBulletTable(
+			table,
+			position,
+			direction,
+			starting_speed,
+			0,
+			bullet.catridgeSection,
+			bullet.bulletId,
+			bullet.weapon_id,
+			bullet.parent_id,
+			65535,
+			NULL,
+			bullet.life_time
+		);
+		funct(table);
+	}
+
 	if (!IsGameTypeSingle())
@@ -797,2 +893,9 @@
 	bullet.life_time		= 0.f;
+
+	// Add RQ range to the bullet fly dist
+	for (auto i = storage.r_begin(); i != storage.r_end();) {
+		bullet.fly_dist += i->range;
+		break;
+	}
+	
 	return					(false);
@@ -827,2 +931,37 @@
 	bullet.life_time			= time;
+
+	// demonized: bullet on update callback
+	luabind::functor<void> funct;
+	if (ai().script_engine().functor("_G.CBulletOnUpdate", funct)) {
+		luabind::object table = luabind::newtable(ai().script_engine().lua());
+		populateBulletTable(
+			table,
+			bullet.bullet_pos,
+			bullet.dir,
+			bullet.speed,
+			bullet.fly_dist,
+			bullet.catridgeSection,
+			bullet.bulletId,
+			bullet.weapon_id,
+			bullet.parent_id,
+			65535,
+			NULL,
+			bullet.life_time
+		);
+		funct(table);
+
+		/*
+		luabind::object output = funct(table);
+
+		if (output && output.type() == LUA_TTABLE) {
+			bullet.bullet_pos = luabind::object_cast<Fvector>(table["position"]);
+			bullet.dir = luabind::object_cast<Fvector>(table["direction"]);
+			bullet.speed = luabind::object_cast<float>(table["speed"]);
+			bullet.fly_dist = luabind::object_cast<float>(table["distance"]);
+			bullet.weapon_id = luabind::object_cast<u16>(table["weapon_id"]);
+			bullet.parent_id = luabind::object_cast<u16>(table["parent_id"]);
+		}
+		*/
+	}
+
 	return						(true);
@@ -1047,4 +1204,8 @@
 
-	for (u32 _it=0; _it<m_Events.size(); _it++)	{
+	for (u32 _it = 0; _it < m_Events.size(); _it++)
+	{
 		_event&		E	= m_Events[_it];
+		SBullet* bullet = &E.bullet;
+		Fvector& end_point = E.point;
+		SGameMtl* mt = GMLib.GetMaterialByIdx(E.tgt_material);
 		switch (E.Type)
@@ -1053,7 +1214,51 @@
 			{
+				// demonized: bullet on impact callback
+				luabind::functor<void> funct;
+				if (ai().script_engine().functor("_G.CBulletOnImpact", funct)) {
+					luabind::object table = luabind::newtable(ai().script_engine().lua());
+					populateBulletTable(
+						table,
+						!fis_zero(end_point.x) && !fis_zero(end_point.y) && !fis_zero(end_point.z) ? end_point : bullet->bullet_pos,
+						bullet->dir,
+						bullet->speed,
+						bullet->fly_dist + E.R.range,
+						bullet->catridgeSection,
+						bullet->bulletId,
+						bullet->weapon_id,
+						bullet->parent_id,
+						E.dynamic && E.R.O ? E.R.O->ID() : 65535,
+						mt ? mt->m_Name.c_str() : NULL,
+						bullet->life_time
+					);
+					funct(table);
+				}
+
 				if (E.dynamic)	DynamicObjectHit	(E);
 				else			StaticObjectHit		(E);
-			}break;
+			}
+
+			break;
 		case EVENT_REMOVE:
 			{
+				// demonized: bullet on remove callback
+				luabind::functor<void> funct;
+				if (ai().script_engine().functor("_G.CBulletOnRemove", funct)) {
+					luabind::object table = luabind::newtable(ai().script_engine().lua());
+					populateBulletTable(
+						table,
+						!fis_zero(end_point.x) && !fis_zero(end_point.y) && !fis_zero(end_point.z) ? end_point : bullet->bullet_pos,
+						bullet->dir,
+						bullet->speed,
+						bullet->fly_dist,
+						bullet->catridgeSection,
+						bullet->bulletId,
+						bullet->weapon_id,
+						bullet->parent_id,
+						65535,
+						NULL,
+						bullet->life_time
+					);
+					funct(table);
+				}
+
 				if (E.bullet.flags.allow_sendhit && GameID() != eGameIDSingle)
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Level_Bullet_Manager.h xray-monolith/src/xrGame/Level_Bullet_Manager.h
--- coc-1.4-xray-64/src/xrGame/Level_Bullet_Manager.h	2023-10-20 20:54:50.634326700 +0100
+++ xray-monolith/src/xrGame/Level_Bullet_Manager.h	2023-10-20 20:54:32.617035500 +0100
@@ -42,2 +47,5 @@
 	u16				weapon_id			;			//ID îðóæèÿ èç êîòîðîãî áûëà âûïóùåíû ïóëÿ
+	LPCSTR catridgeSection;
+	static u32 bulletCount;
+	u32 bulletId;
 	
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Level_bullet_manager_firetrace.cpp xray-monolith/src/xrGame/Level_bullet_manager_firetrace.cpp
--- coc-1.4-xray-64/src/xrGame/Level_bullet_manager_firetrace.cpp	2023-10-20 20:54:50.636326800 +0100
+++ xray-monolith/src/xrGame/Level_bullet_manager_firetrace.cpp	2023-10-20 20:54:32.618035500 +0100
@@ -161,3 +177,2 @@
 	{
-/*  add_SkeletonWallmark not implemented now...
 		particle_dir		 = vDir;
@@ -181,3 +196,2 @@
 		}
-*/
 	} 
@@ -247,2 +263,4 @@
 static bool g_clear = false;
+extern float hit_modifier;
+
 void CBulletManager::DynamicObjectHit	(CBulletManager::_event& E)
@@ -325,3 +343,3 @@
 
-		SHit	Hit = SHit(	hit_param.power,
+		SHit Hit = SHit((E.bullet.parent_id == 0 ? hit_param.power * hit_modifier : hit_param.power), //Make sure only damage dealt by actor is modified
 							original_dir,
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Level_GameSpy_Funcs.cpp xray-monolith/src/xrGame/Level_GameSpy_Funcs.cpp
--- coc-1.4-xray-64/src/xrGame/Level_GameSpy_Funcs.cpp	2023-10-20 20:54:50.635326800 +0100
+++ xray-monolith/src/xrGame/Level_GameSpy_Funcs.cpp	2023-10-20 20:54:32.617035500 +0100
@@ -4,3 +4,2 @@
 #include "../xrEngine/x_ray.h"
-#include "GameSpy/GameSpy_GCD_Client.h"
 
@@ -20,4 +20,4 @@
 	string128 ResponseStr="";
-	CGameSpy_GCD_Client GCD;
-	GCD.CreateRespond(ResponseStr, ChallengeStr, Reauth);
+	//CGameSpy_GCD_Client GCD;
+	//GCD.CreateRespond(ResponseStr, ChallengeStr, Reauth);
 	//--------- Send Respond ---------------------------------------------
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/level_graph.cpp xray-monolith/src/xrGame/level_graph.cpp
--- coc-1.4-xray-64/src/xrGame/level_graph.cpp	2023-10-20 20:54:51.147326700 +0100
+++ xray-monolith/src/xrGame/level_graph.cpp	2023-10-20 20:54:33.057035900 +0100
@@ -217,2 +235,8 @@
 
+	if (!valid_vertex_position(position))
+	{
+		Msg("{@} --- Invalid position for CLevelGraph::vertex_id specified: [%f][%f][%f]", VPUSH(position));
+		return (u32(-1));
+	}
+
 	CPosition			_vertex_position = vertex_position(position);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/level_graph_vertex.cpp xray-monolith/src/xrGame/level_graph_vertex.cpp
--- coc-1.4-xray-64/src/xrGame/level_graph_vertex.cpp	2023-10-20 20:54:51.149328600 +0100
+++ xray-monolith/src/xrGame/level_graph_vertex.cpp	2023-10-20 20:54:33.059035800 +0100
@@ -221,11 +252,18 @@
 
-bool CLevelGraph::create_straight_path(u32 start_vertex_id, const Fvector &start_point, const Fvector &finish_point, xr_vector<Fvector> &tpaOutputPoints, xr_vector<u32> &tpaOutputNodes, bool bAddFirstPoint, bool bClearPath) const
+bool CLevelGraph::create_straight_path(u32 start_vertex_id, const Fvector& start_point, const Fvector& finish_point,
+                                       xr_vector<Fvector>& tpaOutputPoints, xr_vector<u32>& tpaOutputNodes,
+                                       bool bAddFirstPoint, bool bClearPath) const
 {
-	return					(create_straight_path(start_vertex_id,v2d(start_point),v2d(finish_point),tpaOutputPoints,tpaOutputNodes,bAddFirstPoint,bClearPath));
+	return (create_straight_path(start_vertex_id, v2d(start_point), v2d(finish_point), tpaOutputPoints, tpaOutputNodes,
+	                             bAddFirstPoint, bClearPath));
 }
 
-u32	 CLevelGraph::check_position_in_direction_slow	(u32 start_vertex_id, const Fvector2 &start_position, const Fvector2 &finish_position) const
+u32 CLevelGraph::check_position_in_direction_slow(u32 start_vertex_id, const Fvector2& start_position,
+                                                  const Fvector2& finish_position) const
 {
 	if (!valid_vertex_position(v3d(finish_position)))
+	{
+		Msg("{@} --- Invalid destination [%f][%f]", finish_position.x, finish_position.y);
 		return				(u32(-1));
+	}
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Level_input.cpp xray-monolith/src/xrGame/Level_input.cpp
--- coc-1.4-xray-64/src/xrGame/Level_input.cpp	2023-10-20 20:54:50.636326800 +0100
+++ xray-monolith/src/xrGame/Level_input.cpp	2023-10-20 20:54:32.619035700 +0100
@@ -23,2 +23,3 @@
 #include "saved_game_wrapper.h"
+#include "ui\UIPdaWnd.h"
 
@@ -57,3 +58,14 @@
 #ifdef MOUSE_INPUT_CALLBACKS
-    if (g_actor) g_actor->callback(GameObject::eMouseWheel)(direction);
+    if (g_actor) {
+        // demonized: add mouse wheel callback with consuming input
+        luabind::functor<bool> funct;
+        if (ai().script_engine().functor("_G.COnMouseWheel", funct))
+        {
+            if (!funct(direction))
+            {
+                return;
+            }
+        }
+        //g_actor->callback(GameObject::eMouseWheel)(direction);
+    }
 #endif
@@ -75,3 +88,3 @@
 
-static int mouse_button_2_key[] = {MOUSE_1, MOUSE_2, MOUSE_3};
+ENGINE_API int mouse_button_2_key[] = { MOUSE_1, MOUSE_2, MOUSE_3, MOUSE_4, MOUSE_5, MOUSE_6, MOUSE_7, MOUSE_8 };
 
@@ -111,2 +127,8 @@
     }
+
+    POINT p;
+    p.x = Device.dwWidth / 2;
+    p.y = Device.dwHeight / 2;
+    ClientToScreen(Device.m_hWnd, &p);
+    SetCursorPos(p.x, p.y);
 }
@@ -115,2 +137,3 @@
 extern bool g_block_pause;
+extern bool g_block_all_except_movement;
 
@@ -125,2 +148,5 @@
 #include "ai_space.h"
+#include "ui\UIActorMenu.h"
+
+extern string_path g_last_saved_game;
 
@@ -140,2 +166,8 @@
 
+	if (g_block_all_except_movement)
+	{
+		if (!(_curr < kCAM_1 || _curr == kWPN_FIRE || _curr == kPAUSE || _curr == kDROP || _curr == kSCREENSHOT || _curr == kQUIT || _curr == kCONSOLE || _curr == kQUICK_LOAD || _curr == kQUICK_SAVE))
+			return;
+	}
+
     /* avo: script callback */
@@ -164,3 +196,39 @@
 
-    if (g_bDisableAllInput)	return;
+	if (b_ui_exist && CurrentGameUI()->GetActorMenu().IsShown() && CurrentGameUI()->GetActorMenu().b_sort_hotkeys)
+	{
+		switch (key)
+		{
+		case DIK_1:
+		case DIK_2:
+		case DIK_3:
+		case DIK_4:
+		case DIK_5:
+		case DIK_6:
+		case DIK_7:
+		case DIK_8:
+		case DIK_9:
+		case DIK_0:
+		{
+			u16 tab = u16(key - DIK_1);
+			if (CurrentGameUI()->GetActorMenu().m_sort_buttons.size() > tab && CurrentGameUI()->GetActorMenu().m_sort_buttons.at(tab)->IsEnabled())
+				CurrentGameUI()->GetActorMenu().SelectInventoryTab(tab);
+			return;
+		}
+		break;
+		}
+	}
+
+    luabind::functor<bool> funct;
+    if (ai().script_engine().functor("level_input.on_key_press", funct))
+    {
+        if (funct(key, _curr, g_bDisableAllInput))
+            return;
+    }
+
+    if (!g_bDisableAllInput)
+    {
+        CUIPdaWnd* pda = b_ui_exist ? &CurrentGameUI()->GetPdaMenu() : nullptr;
+        if (pda && CurrentGameUI()->TopInputReceiver() == pda) // Fix PDA hotkey input for disabled state
+            if (pda->IsShown() && !pda->IsEnabled() && pda->OnKeyboardAction(key, WINDOW_KEY_PRESSED)) return;
+    }
 
@@ -188,7 +256,9 @@
                       Console->Execute("main_menu");
-                  }return;
-    }break;
+			}
+			return;
+		}
+		break;
     };
 
-    if (!bReady || !b_ui_exist)			return;
+	if (g_bDisableAllInput || !bReady || !b_ui_exist) return;
 
@@ -204,9 +275,3 @@
 
-	luabind::functor<bool>	funct;
-	if (ai().script_engine().functor("level_input.on_key_press", funct))
-	{
-		if (funct(key, _curr))
-			return;
-	}
-
+    /*
     if (_curr == kQUICK_SAVE && IsGameTypeSingle())
@@ -223,11 +288,6 @@
 #endif // DEBUG
-        string_path					saved_game, command;
-        strconcat(sizeof(saved_game), saved_game, Core.UserName, " - ", "quicksave");
-        if (!CSavedGameWrapper::valid_saved_game(saved_game))
-            return;
-
-        strconcat(sizeof(command), command, "load ", saved_game);
-        Console->Execute(command);
+		Console->Execute("load_last_save");
         return;
     }
+    */
 
@@ -403,3 +463,3 @@
                                  {
-                                     pHudItem->OnStateSwitch(pHudItem->GetState());
+									 pHudItem->OnStateSwitch(pHudItem->GetState(), pHudItem->GetState());
                                  }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Level_load.cpp xray-monolith/src/xrGame/Level_load.cpp
--- coc-1.4-xray-64/src/xrGame/Level_load.cpp	2023-10-20 20:54:50.637327400 +0100
+++ xray-monolith/src/xrGame/Level_load.cpp	2023-10-20 20:54:32.619035700 +0100
@@ -15,4 +15,9 @@
 #include "../xrEngine/Rain.h"
+#include "character_community.h"
+#include "character_rank.h"
+#include "character_reputation.h"
+#include "monster_community.h"
+#include "HudManager.h"
 
-ENGINE_API	bool g_dedicated_server;
+extern ENGINE_API bool g_dedicated_server;
 
@@ -34,2 +41,7 @@
 
+	CHARACTER_COMMUNITY::Reset();
+	CHARACTER_RANK::Reset();
+	CHARACTER_REPUTATION::Reset();
+	MONSTER_COMMUNITY::Reset();
+
 	return								(TRUE);
@@ -160,2 +181,4 @@
 
+	HUD().SetRenderable(true);
+
 	return TRUE;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Level_network.cpp xray-monolith/src/xrGame/Level_network.cpp
--- coc-1.4-xray-64/src/xrGame/Level_network.cpp	2023-10-20 20:54:50.637327400 +0100
+++ xray-monolith/src/xrGame/Level_network.cpp	2023-10-20 20:54:32.619035700 +0100
@@ -23,3 +23,3 @@
 #include "../xrphysics/physicscommon.h"
-ENGINE_API bool g_dedicated_server;
+extern ENGINE_API bool g_dedicated_server;
 
@@ -101,3 +100,5 @@
 	{
+#ifdef DEBUG
 		VERIFY										(client_spawn_manager().registry().empty());
+#endif
 		client_spawn_manager().clear			();
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Level_network_digest_computer.cpp xray-monolith/src/xrGame/Level_network_digest_computer.cpp
--- coc-1.4-xray-64/src/xrGame/Level_network_digest_computer.cpp	2023-10-20 20:54:50.638326900 +0100
+++ xray-monolith/src/xrGame/Level_network_digest_computer.cpp	2023-10-20 20:54:32.621035300 +0100
@@ -2,3 +2,4 @@
 #include "Level.h"
-#include "../xrGameSpy/gamespy/md5.h"
+
+#define DEFAULT_MODULE_HASH "3CAABCFCFF6F3A810019C6A72180F166"
 
@@ -5,17 +6,6 @@
 extern	void	GetCDKey_FromRegistry(char* CDKeyStr);
+
 char const * ComputeClientDigest(string128& dest)
 {
-	string128 cd_key;
-	string128 md5hash;
-	GetCDKey_FromRegistry(cd_key);		//cd_key is not longer than 64 bytes !
-	int cd_keylen = xr_strlen(cd_key);
-	if (!cd_keylen)
-	{
-		dest[0] = 0;
-		return dest;
-	}
-	strupr(cd_key);
-	MD5Digest(reinterpret_cast<unsigned char*>(cd_key), cd_keylen, md5hash);
-	md5hash[33] = 0;
-	xr_strcpy(dest, sizeof(dest), md5hash);
+	xr_strcpy(dest, sizeof(dest), DEFAULT_MODULE_HASH);
 	return dest;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/level_path_builder.h xray-monolith/src/xrGame/level_path_builder.h
--- coc-1.4-xray-64/src/xrGame/level_path_builder.h	2023-10-20 20:54:51.151326600 +0100
+++ xray-monolith/src/xrGame/level_path_builder.h	2023-10-20 20:54:33.061036000 +0100
@@ -23,3 +24,3 @@
 	const Fvector				*m_precise_position;
-	u32							m_last_fail_time;
+	u32 m_next_retry_time;
 	bool						m_extrapolate_path;
@@ -28,4 +29,6 @@
 private:
-	enum {
-		time_to_wait_after_fail	= u32(2000),
+	enum
+	{
+		time_to_wait_after_fail_min = u32(1500),
+		time_to_wait_after_fail_max = u32(2500),
 	};
@@ -35,3 +38,3 @@
 		inherited				( object ),
-		m_last_fail_time		( 0 ),
+		m_next_retry_time(0),
 		m_use_delay_after_fail	( true )
@@ -48,5 +51,7 @@
 		m_use_delay_after_fail	= value;
+		if (!value) m_next_retry_time = 0;
 	}
 
-	IC		void			setup				(const u32 &start_vertex_id, const u32 &dest_vertex_id, bool extrapolate_path, const Fvector *precise_position)
+	IC void setup(const u32& start_vertex_id, const u32& dest_vertex_id, bool extrapolate_path,
+	              const Fvector* precise_position)
 	{
@@ -70,3 +76,3 @@
 		m_object->m_wait_for_distributed_computation	= true;
-		if ( Device.dwTimeGlobal < m_last_fail_time + time_to_wait_after_fail )
+		if (Device.dwTimeGlobal < m_next_retry_time)
 			return;
@@ -81,5 +87,6 @@
 
-		if (m_object->level_path().failed()) {
+		if (m_object->level_path().failed())
+		{
 			if ( m_use_delay_after_fail )
-				m_last_fail_time			= Device.dwTimeGlobal;
+				m_next_retry_time = Device.dwTimeGlobal + Random.randI(time_to_wait_after_fail_min, time_to_wait_after_fail_max);
 
@@ -106,3 +113,3 @@
 	{
-		if ( Device.dwTimeGlobal < m_last_fail_time + time_to_wait_after_fail )
+		if (Device.dwTimeGlobal < m_next_retry_time)
 			return;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/level_path_manager_inline.h xray-monolith/src/xrGame/level_path_manager_inline.h
--- coc-1.4-xray-64/src/xrGame/level_path_manager_inline.h	2023-10-20 20:54:51.151326600 +0100
+++ xray-monolith/src/xrGame/level_path_manager_inline.h	2023-10-20 20:54:33.061036000 +0100
@@ -57,5 +59,7 @@
 TEMPLATE_SPECIALIZATION
-IC	void CLevelManagerTemplate::before_search			(const _vertex_id_type start_vertex_id, const _vertex_id_type dest_vertex_id)
+IC void CLevelManagerTemplate::before_search(const _vertex_id_type start_vertex_id,
+                                             const _vertex_id_type dest_vertex_id)
+{
+	if (m_object)
 {
-	if (m_object) {
 		m_object->add_border	(start_vertex_id,dest_vertex_id);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/level_script.cpp xray-monolith/src/xrGame/level_script.cpp
--- coc-1.4-xray-64/src/xrGame/level_script.cpp	2023-10-20 20:54:51.152326700 +0100
+++ xray-monolith/src/xrGame/level_script.cpp	2023-10-20 20:54:33.062043200 +0100
@@ -39,5 +39,17 @@
 #include "hudmanager.h"
-
+#include "ui\UIMainIngameWnd.h"
+#include "ui\UIHudStatesWnd.h"
 #include "raypick.h"
 #include "../xrcdb/xr_collide_defs.h"
+#include "../xrEngine/Rain.h"
+
+#include "../xrEngine/xr_efflensflare.h"
+#include "../xrEngine/thunderbolt.h"
+#include "GametaskManager.h"
+#include "xr_level_controller.h"
+#include "../xrEngine/GameMtlLib.h"
+#include "../xrEngine/xr_input.h"
+#include "script_ini_file.h"
+#include "EffectorBobbing.h"
+#include "LevelDebugScript.h"
 
@@ -45,2 +57,7 @@
 
+extern ENGINE_API float ps_r2_sun_shafts_min;
+extern ENGINE_API float ps_r2_sun_shafts_value;
+bool g_block_all_except_movement;
+bool g_actor_allow_ladder = true;
+
 LPCSTR command_line	()
@@ -99,2 +117,3 @@
 
+// demonized: add u16 id version of function to improve performance
 CScriptGameObject *get_object_by_id(u16 id)
@@ -103,3 +122,3 @@
 	if(!pGameObject)
-		return NULL;
+		return nullptr;
 
@@ -108,2 +127,20 @@
 
+CScriptGameObject* get_object_by_id()
+{
+	Msg("!WARNING : level.object_by_id(nil) called!");
+	return nullptr;
+}
+
+CScriptGameObject* get_object_by_id(const luabind::object& ob)
+{
+	if (!ob || ob.type() == LUA_TNIL)
+	{
+		Msg("!WARNING : level.object_by_id(nil) called!");
+		return nullptr;
+	}
+
+	u16 id = luabind::object_cast<u16>(ob);
+	return get_object_by_id(id);
+}
+
 LPCSTR get_weather	()
@@ -252,2 +294,32 @@
 
+float rain_wetness()
+{
+	return (g_pGamePersistent->Environment().wetness_factor);
+}
+
+float rain_hemi()
+{
+	CEffect_Rain* rain = g_pGamePersistent->pEnvironment->eff_Rain;
+
+	if (rain)
+	{
+		return rain->GetRainHemi();
+	}
+	else
+	{
+		CObject* E = g_pGameLevel->CurrentViewEntity();
+		if (E && E->renderable_ROS())
+		{
+			float* hemi_cube = E->renderable_ROS()->get_luminocity_hemi_cube();
+			float hemi_val = _max(hemi_cube[0], hemi_cube[1]);
+			hemi_val = _max(hemi_val, hemi_cube[2]);
+			hemi_val = _max(hemi_val, hemi_cube[3]);
+			hemi_val = _max(hemi_val, hemi_cube[5]);
+
+			return hemi_val;
+		}
+		return 0;
+	}
+}
+
 u32	vertex_in_direction(u32 level_vertex_id, Fvector direction, float max_distance)
@@ -306,2 +378,8 @@
 
+// demonized: remove all map object spots by id
+void map_remove_all_object_spots(u16 id)
+{
+	Level().MapManager().RemoveAllMapLocationsById(id);
+}
+
 u16 map_has_object_spot(u16 id, LPCSTR spot_type)
@@ -469,4 +551,7 @@
 extern bool g_bDisableAllInput;
+
 void disable_input()
 {
+	// "unpress" all keys when we disable level input! (but keep input devices aquired)
+	pInput->DeactivateSoft();
 	g_bDisableAllInput = true;
@@ -538,7 +626,10 @@
 
-float add_cam_effector2(LPCSTR fn, int id, bool cyclic, LPCSTR cb_func, float cam_fov)
+float add_cam_effector(LPCSTR fn, int id, bool cyclic, LPCSTR cb_func, float cam_fov)
 {
 	CAnimatorCamEffectorScriptCB* e		= xr_new<CAnimatorCamEffectorScriptCB>(cb_func);
+	if (cam_fov)
+	{
 	e->m_bAbsolutePositioning	= true;
 	e->m_fov					= cam_fov;
+	}
 	e->SetType					((ECamEffectorType)id);
@@ -550,2 +641,136 @@
 
+float add_cam_effector(LPCSTR fn, int id, bool cyclic, LPCSTR cb_func, float cam_fov, bool b_hud)
+{
+	CAnimatorCamEffectorScriptCB* e = xr_new<CAnimatorCamEffectorScriptCB>(cb_func);
+	if (cam_fov)
+	{
+		e->m_bAbsolutePositioning = true;
+		e->m_fov = cam_fov;
+	}
+	e->SetHudAffect(b_hud);
+	e->SetType((ECamEffectorType)id);
+	e->SetCyclic(cyclic);
+	e->Start(fn);
+	Actor()->Cameras().AddCamEffector(e);
+	return e->GetAnimatorLength();
+}
+
+float add_cam_effector(LPCSTR fn, int id, bool cyclic, LPCSTR cb_func, float cam_fov, bool b_hud, float power)
+{
+	CAnimatorCamEffectorScriptCB* e = xr_new<CAnimatorCamEffectorScriptCB>(cb_func);
+	if (cam_fov)
+	{
+		e->m_bAbsolutePositioning = true;
+		e->m_fov = cam_fov;
+	}
+	if (power)
+	{
+		e->SetPower(power);
+	}
+	e->SetHudAffect(b_hud);
+	e->SetType((ECamEffectorType)id);
+	e->SetCyclic(cyclic);
+	e->Start(fn);
+	Actor()->Cameras().AddCamEffector(e);
+	return e->GetAnimatorLength();
+}
+
+// demonized: Get cam effector transform data from "*.anm" file
+#include "../xrEngine/motion.h"
+#include "../xrEngine/envelope.h"
+bool getCamEffectorTransformData(luabind::object& t, LPCSTR animationFile)
+{
+	string_path full_path;
+	if (!FS.exist(full_path, "$level$", animationFile))
+		if (!FS.exist(full_path, "$game_anims$", animationFile)) {
+			Msg("![getCamEffectorTransformData] Can't find motion file '%s'.", animationFile);
+			return false;
+		}
+
+	LPCSTR ext = strext(full_path);
+	if (ext)
+	{
+		if (0 == xr_strcmp(ext, ".anm"))
+		{
+			COMotion M;
+			if (M.LoadMotion(full_path)) {
+				std::map<EChannelType, std::string> mapOrder;
+				mapOrder[EChannelType::ctPositionX] = "positionX";
+				mapOrder[EChannelType::ctPositionY] = "positionY";
+				mapOrder[EChannelType::ctPositionZ] = "positionZ";
+				mapOrder[EChannelType::ctRotationH] = "positionH";
+				mapOrder[EChannelType::ctRotationP] = "positionP";
+				mapOrder[EChannelType::ctRotationB] = "positionB";
+
+				for (const auto& p : mapOrder) {
+					auto k = p.first;
+					auto v = p.second;
+					xr_vector<st_Key*>& keys = M.envs[k]->keys;
+					luabind::object keyData = luabind::newtable(ai().script_engine().lua());
+					int i = 1;
+					for (KeyIt k_it = keys.begin(); k_it != keys.end(); k_it++) {
+						luabind::object data = luabind::newtable(ai().script_engine().lua());
+						data["time"] = (*k_it)->time;
+						data["value"] = (*k_it)->value;
+						data["shape"] = (*k_it)->shape;
+						data["tension"] = (*k_it)->tension;
+						data["continuity"] = (*k_it)->continuity;
+						data["bias"] = (*k_it)->bias;
+						data["param0"] = (*k_it)->param[0];
+						data["param1"] = (*k_it)->param[1];
+						data["param2"] = (*k_it)->param[2];
+						data["param3"] = (*k_it)->param[3];
+						keyData[i] = data;
+						i++;
+					}
+					t[v] = keyData;
+				}
+
+				return true;
+			} else {
+				Msg("![getCamEffectorTransformData] failed to load file '%s'.", animationFile);
+				return false;
+			}
+		} else {
+			Msg("![getCamEffectorTransformData] file has incorrect extension '%s'.", animationFile);
+			return false;
+		}
+	}
+	Msg("![getCamEffectorTransformData] unknown error, file '%s'.", animationFile);
+	return false;
+}
+
+// demonized: Set custom camera position and direction with movement smoothing (for cutscenes, etc)
+void set_cam_position_direction(Fvector& position, Fvector& direction, unsigned int smoothing, bool hudEnabled, bool hudAffect)
+{
+	CActor* actor = Actor();
+	actor->initFPCam();
+	actor->m_FPCam->m_HPB.set(direction);
+	actor->m_FPCam->m_Position.set(position);
+	actor->m_FPCam->m_customSmoothing = smoothing;
+	actor->m_FPCam->hudEnabled = hudEnabled;
+	actor->m_FPCam->SetHudAffect(hudAffect);
+}
+
+void set_cam_position_direction(Fvector& position, Fvector& direction)
+{
+	set_cam_position_direction(position, direction, 1, false, false);
+}
+
+void set_cam_position_direction(Fvector& position, Fvector& direction, unsigned int smoothing)
+{
+	set_cam_position_direction(position, direction, smoothing, false, false);
+}
+
+void set_cam_position_direction(Fvector& position, Fvector& direction, unsigned int smoothing, bool hudEnabled)
+{
+	set_cam_position_direction(position, direction, smoothing, hudEnabled, false);
+}
+
+void remove_cam_position_direction() 
+{
+	CActor* actor = Actor();
+	actor->removeFPCam();
+}
+
 void remove_cam_effector(int id)
@@ -555,2 +780,33 @@
 		
+void set_cam_effector_factor(int id, float factor)
+{
+	CAnimatorCamEffectorScriptCB* e = smart_cast<CAnimatorCamEffectorScriptCB*>(Actor()->Cameras().GetCamEffector((ECamEffectorType)id));
+	if (e)
+		e->SetPower(factor);
+}
+
+float get_cam_effector_factor(int id)
+{
+	CAnimatorCamEffectorScriptCB* e = smart_cast<CAnimatorCamEffectorScriptCB*>(Actor()->Cameras().GetCamEffector((ECamEffectorType)id));
+	return e ? e->GetPower() : 0.0f;
+}
+
+float get_cam_effector_length(int id)
+{
+	CAnimatorCamEffectorScriptCB* e = smart_cast<CAnimatorCamEffectorScriptCB*>(Actor()->Cameras().GetCamEffector((ECamEffectorType)id));
+	return e ? e->GetAnimatorLength() : 0.0f;
+}
+
+
+bool check_cam_effector(int id)
+{
+	CAnimatorCamEffectorScriptCB* e = smart_cast<CAnimatorCamEffectorScriptCB*>(Actor()->Cameras().GetCamEffector((ECamEffectorType)id));
+	if (e)
+	{
+		return e->Valid();
+	}
+	return false;
+}
+
+
 float get_snd_volume()
@@ -560,2 +816,8 @@
 
+float get_rain_volume()
+{
+	CEffect_Rain* rain = g_pGamePersistent->pEnvironment->eff_Rain;
+	return rain ? rain->GetRainVolume() : 0.0f;
+}
+
 void set_snd_volume(float v)
@@ -565,2 +827,12 @@
 }
+
+float get_music_volume() {
+	return psSoundVMusicFactor;
+}
+
+void set_music_volume(float v) {
+	psSoundVMusicFactor = v;
+	clamp(psSoundVMusicFactor, 0.0f, 1.0f);
+}
+
 #include "actor_statistic_mgr.h"
@@ -685,2 +962,60 @@
 
+void refresh_npc_names()
+{
+	CALifeObjectRegistry::OBJECT_REGISTRY alobjs = ai().alife().objects().objects();
+	CALifeObjectRegistry::OBJECT_REGISTRY::iterator it = alobjs.begin();
+	CALifeObjectRegistry::OBJECT_REGISTRY::iterator it_e = alobjs.end();
+
+	for (; it != it_e; it++)
+	{
+		CSE_ALifeTraderAbstract* tr = smart_cast<CSE_ALifeTraderAbstract*>(it->second);
+		if (tr)
+		{
+			tr->m_character_name = TranslateName(tr->m_character_name_str.c_str());
+
+			if (g_pGameLevel)
+			{
+				CObject* obj = g_pGameLevel->Objects.net_Find(it->first);
+				CInventoryOwner* owner = smart_cast<CInventoryOwner*>(obj);
+				if (owner)
+					owner->refresh_npc_name();
+			}
+		}
+	}
+
+	if (psDeviceFlags2.test(rsDiscord))
+	{
+		Actor()->RPC_UpdateFaction();
+		Actor()->RPC_UpdateRank();
+		Actor()->RPC_UpdateReputation();
+
+		Level().GameTaskManager().RPC_UpdateTaskName();
+	}
+}
+
+
+void LevelPressAction(int cmd)
+{
+	if ((cmd == MOUSE_1 || cmd == MOUSE_2) && !!GetSystemMetrics(SM_SWAPBUTTON))
+		cmd = cmd == MOUSE_1 ? MOUSE_2 : MOUSE_1;
+
+	Level().IR_OnKeyboardPress(cmd);
+}
+
+void LevelReleaseAction(int cmd)
+{
+	if ((cmd == MOUSE_1 || cmd == MOUSE_2) && !!GetSystemMetrics(SM_SWAPBUTTON))
+		cmd = cmd == MOUSE_1 ? MOUSE_2 : MOUSE_1;
+
+	Level().IR_OnKeyboardRelease(cmd);
+}
+
+void LevelHoldAction(int cmd)
+{
+	if ((cmd == MOUSE_1 || cmd == MOUSE_2) && !!GetSystemMetrics(SM_SWAPBUTTON))
+		cmd = cmd == MOUSE_1 ? MOUSE_2 : MOUSE_1;
+
+	Level().IR_OnKeyboardHold(cmd);
+}
+
 u32 vertex_id	(Fvector position)
@@ -728,2 +1063,574 @@
 
+float get_weather_value_numric(LPCSTR name)
+{
+	CEnvDescriptor& E = *environment()->CurrentEnv;
+
+	if (0 == xr_strcmp(name, "sky_rotation"))
+		return E.sky_rotation;
+	else if (0 == xr_strcmp(name, "far_plane"))
+		return E.far_plane;
+	else if (0 == xr_strcmp(name, "fog_density"))
+		return E.fog_density;
+	else if (0 == xr_strcmp(name, "fog_distance"))
+		return E.fog_distance;
+	else if (0 == xr_strcmp(name, "rain_density"))
+		return E.rain_density;
+	else if (0 == xr_strcmp(name, "thunderbolt_period"))
+		return E.bolt_period;
+	else if (0 == xr_strcmp(name, "thunderbolt_duration"))
+		return E.bolt_duration;
+	else if (0 == xr_strcmp(name, "wind_velocity"))
+		return E.wind_velocity;
+	else if (0 == xr_strcmp(name, "wind_direction"))
+		return E.wind_direction;
+	else if (0 == xr_strcmp(name, "sun_shafts_intensity"))
+		return E.m_fSunShaftsIntensity;
+	else if (0 == xr_strcmp(name, "water_intensity"))
+		return E.m_fWaterIntensity;
+	else if (0 == xr_strcmp(name, "tree_amplitude_intensity"))
+		return E.m_fTreeAmplitudeIntensity;
+	else if (0 == xr_strcmp(name, "volumetric_intensity_factor"))
+		return E.volumetric_intensity_factor;
+	else if (0 == xr_strcmp(name, "volumetric_distance_factor"))
+		return E.volumetric_distance_factor;
+
+	return (0);
+}
+
+void set_weather_value_numric(LPCSTR name, float val)
+{
+	CEnvDescriptorMixer& E = *environment()->CurrentEnv;
+
+	if (0 == xr_strcmp(name, "sky_rotation"))
+		E.sky_rotation = val;
+	else if (0 == xr_strcmp(name, "far_plane"))
+		E.far_plane = val * psVisDistance;
+	else if (0 == xr_strcmp(name, "fog_density"))
+	{
+		E.fog_density = val;
+		E.fog_near = (1.0f - E.fog_density) * 0.85f * E.fog_distance;
+	}
+	else if (0 == xr_strcmp(name, "fog_distance"))
+	{
+		E.fog_distance = val;
+		clamp(E.fog_distance, 1.f, E.far_plane - 10);
+		E.fog_near = (1.0f - E.fog_density) * 0.85f * E.fog_distance;
+		E.fog_far = 0.99f * E.fog_distance;
+	}
+	else if (0 == xr_strcmp(name, "rain_density"))
+		E.rain_density = val;
+	else if (0 == xr_strcmp(name, "thunderbolt_period"))
+		E.bolt_period = val;
+	else if (0 == xr_strcmp(name, "thunderbolt_duration"))
+		E.bolt_duration = val;
+	else if (0 == xr_strcmp(name, "wind_velocity"))
+		E.wind_velocity = val;
+	else if (0 == xr_strcmp(name, "wind_direction"))
+		E.wind_direction = val;
+	else if (0 == xr_strcmp(name, "sun_shafts_intensity"))
+	{
+		E.m_fSunShaftsIntensity = val;
+		E.m_fSunShaftsIntensity *= 1.0f - ps_r2_sun_shafts_min;
+		E.m_fSunShaftsIntensity += ps_r2_sun_shafts_min;
+		E.m_fSunShaftsIntensity *= ps_r2_sun_shafts_value;
+		clamp(E.m_fSunShaftsIntensity, 0.0f, 1.0f);
+	}
+	else if (0 == xr_strcmp(name, "water_intensity"))
+		E.m_fWaterIntensity = val;
+	else if (0 == xr_strcmp(name, "tree_amplitude_intensity"))
+		E.m_fTreeAmplitudeIntensity = val;
+	else if (0 == xr_strcmp(name, "volumetric_intensity_factor"))
+		E.volumetric_intensity_factor = val;
+	else if (0 == xr_strcmp(name, "volumetric_distance_factor"))
+		E.volumetric_distance_factor = val;
+	else
+		Msg("~xrGame\level_script.cpp (set_weather_value_numric) | [%s] is not a valid numric weather parameter to set", name);
+}
+
+Fvector3 get_weather_value_vector(LPCSTR name)
+{
+	CEnvDescriptor& E = *environment()->CurrentEnv;
+
+	if (0 == xr_strcmp(name, "sky_color"))
+		return E.sky_color;
+	else if (0 == xr_strcmp(name, "fog_color"))
+		return E.fog_color;
+	else if (0 == xr_strcmp(name, "rain_color"))
+		return E.rain_color;
+	else if (0 == xr_strcmp(name, "ambient_color"))
+		return E.ambient;
+	else if (0 == xr_strcmp(name, "sun_color"))
+		return E.sun_color;
+	else if (0 == xr_strcmp(name, "sun_dir"))
+		return E.sun_dir;
+
+	Fvector3 vec;
+	vec.set(0, 0, 0);
+
+	if (0 == xr_strcmp(name, "clouds_color"))
+	{
+		Fvector4 temp = E.clouds_color;
+		vec.set(temp.x, temp.y, temp.z);
+	}
+	else if (0 == xr_strcmp(name, "hemisphere_color"))
+	{
+		Fvector4 temp = E.hemi_color;
+		vec.set(temp.x, temp.y, temp.z);
+	}
+
+	return vec;
+}
+
+void set_weather_value_vector(LPCSTR name, float x, float y, float z, float w = 0)
+{
+	CEnvDescriptor& E = *environment()->CurrentEnv;
+
+	if (0 == xr_strcmp(name, "sky_color"))
+		E.sky_color.set(x, y, z);
+	else if (0 == xr_strcmp(name, "fog_color"))
+		E.fog_color.set(x, y, z);
+	else if (0 == xr_strcmp(name, "rain_color"))
+		E.rain_color.set(x, y, z);
+	else if (0 == xr_strcmp(name, "ambient_color"))
+		E.ambient.set(x, y, z);
+	else if (0 == xr_strcmp(name, "sun_color"))
+		E.sun_color.set(x, y, z);
+	else if (0 == xr_strcmp(name, "clouds_color"))
+		E.clouds_color.set(x, y, z, w);
+	else if (0 == xr_strcmp(name, "hemisphere_color"))
+		E.hemi_color.set(x, y, z, w);
+	else
+		Msg("~xrGame\level_script.cpp (set_weather_value_vector) | [%s] is not a valid vector weather parameter to set", name);
+}
+
+LPCSTR get_weather_value_string(LPCSTR name)
+{
+	CEnvDescriptor& E = *environment()->CurrentEnv;
+
+	if (0 == xr_strcmp(name, "clouds_texture"))
+		return E.clouds_texture_name.c_str();
+
+	else if (0 == xr_strcmp(name, "sky_texture"))
+		return E.sky_texture_name.c_str();
+
+	else if (0 == xr_strcmp(name, "ambient"))
+		return E.env_ambient->name().c_str();
+
+	return "";
+}
+
+void set_weather_value_string(LPCSTR name, LPCSTR newval)
+{
+	CEnvDescriptor& E = *environment()->CurrentEnv;
+
+	if (0 == xr_strcmp(name, "clouds_texture"))
+	{
+		if (E.clouds_texture_name._get() != shared_str(newval)._get())
+		{
+			E.m_pDescriptor->OnDeviceDestroy();
+			E.clouds_texture_name = newval;
+			E.m_pDescriptor->OnDeviceCreate(E);
+		}
+	}
+	else if (0 == xr_strcmp(name, "sky_texture"))
+	{
+		if (E.sky_texture_name._get() != shared_str(newval)._get())
+		{
+			string_path st_env;
+			strconcat(sizeof(st_env), st_env, newval, "#small");
+			E.m_pDescriptor->OnDeviceDestroy();
+			E.sky_texture_name = newval;
+			E.sky_texture_env_name = st_env;
+			E.m_pDescriptor->OnDeviceCreate(E);
+		}
+	}
+	else if (0 == xr_strcmp(name, "sun"))
+	{
+		E.lens_flare_id = environment()->eff_LensFlare->AppendDef(*environment(), environment()->m_suns_config, newval);
+	}
+	else if (0 == xr_strcmp(name, "thunderbolt_collection"))
+	{
+		E.tb_id = environment()->eff_Thunderbolt->AppendDef(*environment(),
+		                                                    environment()->m_thunderbolt_collections_config,
+		                                                    environment()->m_thunderbolts_config, newval);
+	}
+	else if (0 == xr_strcmp(name, "ambient"))
+	{
+		E.env_ambient = environment()->AppendEnvAmb(newval);
+	}
+	else
+		Msg("~xrGame\level_script.cpp (set_weather_value_string) | [%s] is not a valid string weather parameter to set", name);
+}
+
+void pause_weather(bool b_pause)
+{
+	environment()->m_paused = b_pause;
+}
+
+bool is_weather_paused()
+{
+	return environment()->m_paused;
+}
+
+void reload_weather()
+{
+	environment()->Reload();
+}
+
+void boost_weather_value(LPCSTR name, float value)
+{
+	if (0 == xr_strcmp(name, "ambient_color"))
+		environment()->env_boost.ambient = value;
+	else if (0 == xr_strcmp(name, "hemisphere_color"))
+		environment()->env_boost.hemi = value;
+	else if (0 == xr_strcmp(name, "fog_color"))
+		environment()->env_boost.fog_color = value;
+	else if (0 == xr_strcmp(name, "rain_color"))
+		environment()->env_boost.rain_color = value;
+	else if (0 == xr_strcmp(name, "sky_color"))
+		environment()->env_boost.sky_color = value;
+	else if (0 == xr_strcmp(name, "clouds_color"))
+		environment()->env_boost.clouds_color = value;
+	else if (0 == xr_strcmp(name, "sun_color"))
+		environment()->env_boost.sun_color = value;
+	else
+		Msg("~xrGame\level_script.cpp (boost_weather_value)| [%s] is not a valid weather parameter to boost", name);
+}
+
+void boost_weather_reset()
+{
+	environment()->env_boost.ambient = 0.f;
+	environment()->env_boost.hemi = 0.f;
+	environment()->env_boost.fog_color = 0.f;
+	environment()->env_boost.rain_color = 0.f;
+	environment()->env_boost.sky_color = 0.f;
+	environment()->env_boost.sun_color = 0.f;
+}
+
+void sun_time(int hour, int minute)
+{
+	float real_sun_alt, real_sun_long;
+	float s_alt = environment()->sun_hp[hour].x;
+	float s_long = environment()->sun_hp[hour].y;
+
+	if (minute > 0)
+	{
+		float s_weight = minute / 60.f;
+		int next_hour = hour == 23 ? 0 : hour + 1;
+		float s_alt2 = environment()->sun_hp[next_hour].x;
+		float s_long2 = environment()->sun_hp[next_hour].y;
+
+		real_sun_alt = _lerp(s_alt, s_alt2, s_weight);
+		real_sun_long = _lerp(s_long, s_long2, s_weight);
+	}
+	else
+	{
+		real_sun_alt = s_alt;
+		real_sun_long = s_long;
+	}
+
+	R_ASSERT(_valid(real_sun_alt));
+	R_ASSERT(_valid(real_sun_long));
+
+	CEnvDescriptor& E = *environment()->CurrentEnv;
+	E.sun_dir.setHP(
+		deg2rad(real_sun_alt),
+		deg2rad(real_sun_long)
+	);
+
+	R_ASSERT(_valid(E.sun_dir));
+}
+
+void reload_language()
+{
+	CStringTable().ReloadLanguage();
+}
+
+#include "player_hud.h"
+
+void hud_adj_offs(int off, int idx, float x, float y, float z)
+{
+	// Script UI
+	if (idx == 20)
+	{
+		g_player_hud->m_adjust_ui_offset[off].set(x, y, z);
+
+		if (off == 1)
+			g_player_hud->m_adjust_ui_offset[1].mul(PI / 180.f);
+	}
+
+	// Fire point/dir ; shell point
+	else if (idx == 10 || idx == 11)
+	{
+		g_player_hud->m_adjust_firepoint_shell[off][idx-10].set(x, y, z);
+	}
+
+	// Object pos/dir
+	else if (idx == 12)
+	{
+		g_player_hud->m_adjust_obj[off].set(x, y, z);
+	}
+
+	// Hud offsets
+	else
+		g_player_hud->m_adjust_offset[off][idx].set(x, y, z);
+}
+
+#include "Inventory.h"
+#include "Weapon.h"
+
+void hud_adj_value(LPCSTR name, float val)
+{
+	if (0 == xr_strcmp(name, "scope_zoom_factor"))
+		g_player_hud->m_adjust_zoom_factor[0] = val;
+	else if (0 == xr_strcmp(name, "gl_zoom_factor"))
+		g_player_hud->m_adjust_zoom_factor[1] = val;
+	else if (0 == xr_strcmp(name, "scope_zoom_factor_alt"))
+		g_player_hud->m_adjust_zoom_factor[2] = val;
+}
+
+void hud_adj_state(bool state)
+{
+	g_player_hud->m_adjust_mode = state;
+}
+
+LPCSTR vid_modes_string()
+{
+	xr_string resolutions = "";
+
+	xr_token* tok = vid_mode_token;
+	while (tok->name)
+	{
+		if (strlen(resolutions.c_str()) > 0)
+			resolutions.append(",");
+
+		resolutions.append(tok->name);
+		tok++;
+	}
+
+	return resolutions.c_str();
+}
+
+u32 PlayHudMotion(u8 hand, LPCSTR itm_name, LPCSTR anm_name, bool bMixIn = true, float speed = 1.f)
+{
+	return g_player_hud->script_anim_play(hand, itm_name, anm_name, bMixIn, speed);
+}
+
+void StopHudMotion()
+{
+	g_player_hud->StopScriptAnim();
+}
+
+float MotionLength(LPCSTR section, LPCSTR name, float speed)
+{
+	return g_player_hud->motion_length_script(section, name, speed);
+}
+
+bool AllowHudMotion()
+{
+	return g_player_hud->allow_script_anim();
+}
+
+void PlayBlendAnm(LPCSTR name, u8 part, float speed, float power, bool bLooped, bool no_restart)
+{
+	g_player_hud->PlayBlendAnm(name, part, speed, power, bLooped, no_restart);
+}
+
+void StopBlendAnm(LPCSTR name, bool bForce)
+{
+	g_player_hud->StopBlendAnm(name, bForce);
+}
+
+void StopAllBlendAnms(bool bForce)
+{
+	g_player_hud->StopAllBlendAnms(bForce);
+}
+
+float SetBlendAnmTime(LPCSTR name, float time)
+{
+	return g_player_hud->SetBlendAnmTime(name, time);
+}
+
+void block_all_except_movement(bool b)
+{
+	g_block_all_except_movement = b;
+}
+
+bool only_movement_allowed()
+{
+	return g_block_all_except_movement;
+}
+
+void set_actor_allow_ladder(bool b)
+{
+	g_actor_allow_ladder = b;
+}
+
+void set_nv_lumfactor(float factor)
+{
+	g_pGamePersistent->nv_shader_data.lum_factor = factor;
+}
+
+void remove_hud_model(LPCSTR section)
+{
+	LPCSTR hud_section = READ_IF_EXISTS(pSettings, r_string, section, "hud", nullptr);
+	if (hud_section != nullptr)
+		g_player_hud->remove_from_model_pool(hud_section);
+	else
+		Msg("can't find hud section for [%s]", section);
+}
+
+const u32 ActorMovingState()
+{
+	return g_actor->MovingState();
+}
+
+extern ENGINE_API float psHUD_FOV;
+
+const Fvector2 world2ui(Fvector pos, bool hud = false, bool allow_offscreen = false)
+{
+	Fmatrix world, res;
+	world.identity();
+	world.c = pos;
+
+	if (hud)
+	{
+		Fmatrix FP, FT, FV;
+		FV.build_camera_dir(Device.vCameraPosition, Device.vCameraDirection, Device.vCameraTop);
+		FP.build_projection(
+			deg2rad(psHUD_FOV * 83.f),
+			Device.fASPECT, R_VIEWPORT_NEAR,
+			g_pGamePersistent->Environment().CurrentEnv->far_plane);
+
+		FT.mul(FP, FV);
+		res.mul(FT, world);
+	}
+	else
+		res.mul(Device.mFullTransform, world);
+	
+	Fvector4 v_res;
+
+	v_res.w = res._44;
+	v_res.x = res._41 / v_res.w;
+	v_res.y = res._42 / v_res.w;
+	v_res.z = res._43 / v_res.w;
+
+	if (!allow_offscreen)
+	{
+		if (v_res.z < 0 || v_res.w < 0) return { -9999,0 };
+		if (abs(v_res.x) > 1.f || abs(v_res.y) > 1.f) return { -9999,0 };
+	}
+
+	float x = (1.f + v_res.x) / 2.f * (Device.dwWidth);
+	float y = (1.f - v_res.y) / 2.f * (Device.dwHeight);
+
+	float width_fk = Device.dwWidth / UI_BASE_WIDTH;
+	float height_fk = Device.dwHeight / UI_BASE_HEIGHT;
+
+	x /= width_fk;
+	y /= height_fk;
+
+	return { x,y };
+}
+
+// demonized: unproject ui coordinates (ie mouse cursor coordinates) to world coordinates
+// returns position and underlying object id if found. If there is no object, obj_id will be 65535
+void ui2world(Fvector2 pos, Fvector& res, u16& obj_id)
+{
+	res.set(0, 0, 0);
+	if (pos.x < 0 || pos.x > UI_BASE_WIDTH || pos.y < 0 || pos.y > UI_BASE_HEIGHT) {
+		return;
+	}
+
+	// Convert to [-1; 1] NDC space
+	pos.x = 2 * pos.x / UI_BASE_WIDTH - 1;
+	pos.y = 1 - 2 * pos.y / UI_BASE_HEIGHT;
+
+	Fmatrix mProject = Device.mFullTransform;
+
+	// 4x4 invert of camera matrix
+	{
+		Fmatrix& m = mProject;
+
+		float mProjectDet = m._11 * (m._22*m._33*m._44 + m._23*m._34*m._42 + m._24*m._32*m._43 - m._24*m._33*m._42 - m._23*m._32*m._44 - m._22*m._34*m._43)
+						-   m._21 * (m._12*m._33*m._44 + m._13*m._34*m._42 + m._14*m._32*m._43 - m._14*m._33*m._42 - m._13*m._32*m._44 - m._12*m._34*m._43)
+						+   m._31 * (m._12*m._23*m._44 + m._13*m._24*m._42 + m._14*m._22*m._43 - m._14*m._23*m._42 - m._13*m._22*m._44 - m._12*m._24*m._43)
+						-   m._41 * (m._12*m._23*m._34 + m._13*m._24*m._32 + m._14*m._22*m._33 - m._14*m._23*m._32 - m._13*m._22*m._34 - m._12*m._24*m._33);
+
+		Fmatrix mProjectAdjugate;
+		mProjectAdjugate._11 = m._22*m._33*m._44 + m._23*m._34*m._42 + m._24*m._32*m._43 - m._24*m._33*m._42 - m._23*m._32*m._44 - m._22*m._34*m._43;
+		mProjectAdjugate._12 = -m._12*m._33*m._44 - m._13*m._34*m._42 - m._14*m._32*m._43 + m._14*m._33*m._42 + m._13*m._32*m._44 + m._12*m._34*m._43;
+		mProjectAdjugate._13 = m._12*m._23*m._44 + m._13*m._24*m._42 + m._14*m._22*m._43 - m._14*m._23*m._42 - m._13*m._22*m._44 - m._12*m._24*m._43;
+		mProjectAdjugate._14 = -m._12*m._23*m._34 - m._13*m._24*m._32 - m._14*m._22*m._33 + m._14*m._23*m._32 + m._13*m._22*m._34 + m._12*m._24*m._33;
+
+		mProjectAdjugate._21 = -m._21*m._33*m._44 - m._23*m._34*m._41 - m._24*m._31*m._43 + m._24*m._33*m._41 + m._23*m._31*m._44 + m._21*m._34*m._43;
+		mProjectAdjugate._22 = m._11*m._33*m._44 + m._13*m._34*m._41 + m._14*m._31*m._43 - m._14*m._33*m._41 - m._13*m._31*m._44 - m._11*m._34*m._43;
+		mProjectAdjugate._23 = -m._11*m._23*m._44 - m._13*m._24*m._41 - m._14*m._21*m._43 + m._14*m._23*m._41 + m._13*m._21*m._44 + m._11*m._24*m._43;
+		mProjectAdjugate._24 = m._11*m._23*m._34 + m._13*m._24*m._31 + m._14*m._21*m._33 - m._14*m._23*m._31 - m._13*m._21*m._34 - m._11*m._24*m._33;
+
+		mProjectAdjugate._31 = m._21*m._32*m._44 + m._22*m._34*m._41 + m._24*m._31*m._42 - m._24*m._32*m._41 - m._22*m._31*m._44 - m._21*m._34*m._42;
+		mProjectAdjugate._32 = -m._11*m._32*m._44 - m._12*m._34*m._41 - m._14*m._31*m._42 + m._14*m._32*m._41 + m._12*m._31*m._44 + m._11*m._34*m._42;
+		mProjectAdjugate._33 = m._11*m._22*m._44 + m._12*m._24*m._41 + m._14*m._21*m._42 - m._14*m._22*m._41 - m._12*m._21*m._44 - m._11*m._24*m._42;
+		mProjectAdjugate._34 = -m._11*m._22*m._34 - m._12*m._24*m._31 - m._14*m._21*m._32 + m._14*m._22*m._31 + m._12*m._21*m._34 + m._11*m._24*m._32;
+
+		mProjectAdjugate._41 = -m._21*m._32*m._43 - m._22*m._33*m._41 - m._23*m._31*m._42 + m._23*m._32*m._41 + m._22*m._31*m._43 + m._21*m._33*m._42;
+		mProjectAdjugate._42 = m._11*m._32*m._43 + m._12*m._33*m._41 + m._13*m._31*m._42 - m._13*m._32*m._41 - m._12*m._31*m._43 - m._11*m._33*m._42;
+		mProjectAdjugate._43 = -m._11*m._22*m._43 - m._12*m._23*m._41 - m._13*m._21*m._42 + m._13*m._22*m._41 + m._12*m._21*m._43 + m._11*m._23*m._42;
+		mProjectAdjugate._44 = m._11*m._22*m._33 + m._12*m._23*m._31 + m._13*m._21*m._32 - m._13*m._22*m._31 - m._12*m._21*m._33 - m._11*m._23*m._32;
+
+		mProjectDet = 1.0 / mProjectDet;
+		mProjectAdjugate.mul(mProjectDet);
+		mProject.set(mProjectAdjugate);
+	}
+		
+	// get position at arbitrary depth
+	res.set(pos.x, pos.y, 1);
+	{
+		auto& e = mProject.m;
+		auto x = res.x;
+		auto y = res.y;
+		auto z = res.z;
+		float w = 1.0 / (e[0][3] * x + e[1][3] * y + e[2][3] * z + e[3][3]);
+
+		res.x = (e[0][0] * x + e[1][0] * y + e[2][0] * z + e[3][0]) * w;
+		res.y = (e[0][1] * x + e[1][1] * y + e[2][1] * z + e[3][1]) * w;
+		res.z = (e[0][2] * x + e[1][2] * y + e[2][2] * z + e[3][2]) * w;
+	}
+
+	// perform ray cast to get actual position
+	collide::rq_result R;
+	CObject* ignore = Actor();
+	Fvector start = Device.vCameraPosition;
+	Fvector dir;
+	dir.set(res).sub(start).normalize();
+	start.mad(dir, R_VIEWPORT_NEAR);
+	float range = g_pGamePersistent->Environment().CurrentEnv->far_plane;
+
+	obj_id = 65535;
+	if (Level().ObjectSpace.RayPick(start, dir, range, collide::rqtBoth, R, ignore))
+	{
+		res.mad(start, dir, R.range);
+
+		if (R.O) {
+			CGameObject* o = smart_cast<CGameObject*>(R.O);
+			if (o) {
+				obj_id = o->ID();
+			}
+		}
+	}
+}
+
+void ui2world(Fvector& pos, Fvector& res, u16& obj_id)
+{
+	ui2world(Fvector2().set(pos.x, pos.y), res, obj_id);
+}
+
+const float get_env_rads()
+{
+	if (!CurrentGameUI())
+		return 0.f;
+
+	return CurrentGameUI()->UIMainIngameWnd->get_hud_states()->get_main_sensor_value();
+}
+
 //Alundaio: namespace level exports extension
@@ -773,2 +1680,24 @@
 
+// demonized: get world position under crosshair
+Fvector g_get_target_pos()
+{
+	collide::rq_result& RQ = HUD().GetCurrentRayQuery();
+	if (RQ.range)
+	{
+		return Fvector().mad(Device.vCameraPosition, Device.vCameraDirection, RQ.range);
+	}
+	return Fvector().set(0, 0, 0);
+}
+
+// demonized: get result of crosshair ray query
+script_rq_result g_get_target_result()
+{
+	collide::rq_result& RQ = HUD().GetCurrentRayQuery();
+	auto script_rq = script_rq_result();
+	if (RQ.range) {
+		script_rq.set(RQ);
+	}
+	return script_rq;
+}
+
 u8 get_active_cam()
@@ -788,2 +1717,35 @@
 }
+
+void reload_hud_xml()
+{
+	HUD().OnScreenResolutionChanged();
+}
+
+bool actor_safemode()
+{
+	return Actor()->is_safemode();
+}
+
+void actor_set_safemode(bool status)
+{
+	if (Actor()->is_safemode() != status)
+	{
+		CWeapon* wep = smart_cast<CWeapon*>(Actor()->inventory().ActiveItem());
+		if (wep && wep->m_bCanBeLowered)
+		{
+			wep->Action(kSAFEMODE, CMD_START);
+			Actor()->set_safemode(status);
+		}
+	}
+}
+
+void prefetch_texture(LPCSTR name)
+{
+	Device.m_pRender->ResourcesPrefetchCreateTexture( name );
+}
+
+void prefetch_model(LPCSTR name)
+{
+	::Render->models_PrefetchOne(name);
+}
 #endif
@@ -807,2 +1770,18 @@
 
+CScriptGameObject* get_view_entity_script()
+{
+	CGameObject* pGameObject = smart_cast<CGameObject*>(Level().CurrentViewEntity());
+	if (!pGameObject)
+		return (0);
+
+	return pGameObject->lua_game_object();
+}
+
+void set_view_entity_script(CScriptGameObject* go)
+{
+	CObject* o = smart_cast<CObject*>(&go->object());
+	if (o)
+		Level().SetViewEntity(o);
+}
+
 xrTime get_start_time()
@@ -812,2 +1791,143 @@
 
+void iterate_nearest(const Fvector& pos, float radius, luabind::functor<bool> functor)
+{
+	xr_vector<CObject*> m_nearest;
+	Level().ObjectSpace.GetNearest(m_nearest, pos, radius, NULL);
+
+	if (!m_nearest.size()) return;
+
+	xr_vector<CObject*>::iterator it = m_nearest.begin();
+	xr_vector<CObject*>::iterator it_e = m_nearest.end();
+	for (; it != it_e; it++)
+	{
+		CGameObject* obj = smart_cast<CGameObject*>(*it);
+		if (!obj) continue;
+		if (functor(obj->lua_game_object())) break;
+	}
+}
+
+LPCSTR PickMaterial(const Fvector& start_pos, const Fvector& dir, float trace_dist, CScriptGameObject* ignore_obj)
+{
+	collide::rq_result result;
+	BOOL reach_wall =
+		Level().ObjectSpace.RayPick(
+			start_pos,
+			dir,
+			trace_dist,
+			collide::rqtStatic,
+			result,
+			ignore_obj ? &ignore_obj->object() : nullptr
+		)
+		&&
+		!result.O;
+
+	if (reach_wall)
+	{
+		CDB::TRI* pTri = Level().ObjectSpace.GetStaticTris() + result.element;
+		SGameMtl* pMaterial = GMLib.GetMaterialByIdx(pTri->material);
+
+		if (pMaterial)
+		{
+			return *pMaterial->m_Name;
+		}
+	}
+
+	return "$null";
+}
+
+CScriptIniFile* GetVisualUserdata(LPCSTR visual)
+{
+	string_path low_name, fn;
+
+	VERIFY(xr_strlen(visual) < sizeof(low_name));
+	xr_strcpy(low_name, visual);
+	strlwr(low_name);
+
+	if (strext(low_name)) *strext(low_name) = 0;
+	xr_strcat(low_name, sizeof(low_name), ".ogf");
+
+	if (!FS.exist(low_name))
+	{
+		if (!FS.exist(fn, "$level$", low_name))
+		{
+			if (!FS.exist(fn, "$game_meshes$", low_name))
+			{
+				Msg("!Can't find model file '%s'.", low_name);
+				return nullptr;
+			}
+		}
+	}
+	else
+	{
+		xr_strcpy(fn, low_name);
+	}
+
+	IReader* data = FS.r_open(fn);
+	if (!data) return nullptr;
+
+	IReader* UD = data->open_chunk(17); //OGF_S_USERDATA
+	if (!UD) return nullptr;
+
+	CScriptIniFile* ini = xr_new<CScriptIniFile>(UD, FS.get_path("$game_config$")->m_Path);
+	FS.r_close(data);
+	UD->close();
+
+	return ini;
+}
+
+DBG_ScriptObject* get_object(u16 id)
+{
+	xr_map<u16, DBG_ScriptObject*>::iterator it = Level().getScriptRenderQueue()->find(id);
+	if (it == Level().getScriptRenderQueue()->end())
+		return nullptr;
+
+	return it->second;
+}
+
+void remove_object(u16 id)
+{
+	DBG_ScriptObject* dbg_obj = get_object(id);
+	if (!dbg_obj)
+		return;
+
+	xr_delete(dbg_obj);
+	Level().getScriptRenderQueue()->erase(id);
+}
+
+DBG_ScriptObject* add_object(u16 id, DebugRenderType type)
+{
+	remove_object(id);
+	DBG_ScriptObject* dbg_obj = nullptr;
+
+	switch (type)
+	{
+	case eDBGSphere:
+		dbg_obj = xr_new<DBG_ScriptSphere>();
+		break;
+	case eDBGBox:
+		dbg_obj = xr_new<DBG_ScriptBox>();
+		break;
+	case eDBGLine:
+		dbg_obj = xr_new<DBG_ScriptLine>();
+		break;
+	default:
+		R_ASSERT2(false, "Wrong debug object type used!");
+	}
+
+	R_ASSERT(dbg_obj);
+	Level().getScriptRenderQueue()->emplace(mk_pair(id, dbg_obj));
+
+	return dbg_obj;
+}
+
+u32 get_flags()
+{
+	return Level().m_debug_render_flags.get();
+}
+
+void set_flags(u32 flags)
+{
+	Level().m_debug_render_flags.assign(flags);
+}
+
 #pragma optimize("s",on)
@@ -815,2 +1935,4 @@
 {
+	module(L)
+		[
 	class_<CEnvDescriptor>("CEnvDescriptor")
@@ -820,3 +1942,39 @@
 	class_<CEnvironment>("CEnvironment")
-		.def("current",							current_environment);
+		.def("current", current_environment),
+
+		class_<DBG_ScriptObject>("DBG_ScriptObject")
+		.enum_("dbg_type")
+		[
+			value("line", (int)DebugRenderType::eDBGLine),
+			value("sphere", (int)DebugRenderType::eDBGSphere),
+			value("box", (int)DebugRenderType::eDBGBox)
+		]
+	.def("cast_dbg_sphere", &DBG_ScriptObject::cast_dbg_sphere)
+		.def("cast_dbg_box", &DBG_ScriptObject::cast_dbg_box)
+		.def("cast_dbg_line", &DBG_ScriptObject::cast_dbg_line)
+		.def_readwrite("color", &DBG_ScriptObject::m_color)
+		.def_readwrite("hud", &DBG_ScriptObject::m_hud)
+		.def_readwrite("visible", &DBG_ScriptObject::m_visible),
+
+		class_<DBG_ScriptSphere, DBG_ScriptObject>("DBG_ScriptSphere")
+		.def_readwrite("matrix", &DBG_ScriptSphere::m_mat),
+
+		class_<DBG_ScriptBox, DBG_ScriptObject>("DBG_ScriptBox")
+		.def_readwrite("matrix", &DBG_ScriptBox::m_mat)
+		.def_readwrite("size", &DBG_ScriptBox::m_size),
+
+		class_<DBG_ScriptLine, DBG_ScriptObject>("DBG_ScriptLine")
+		.def_readwrite("point_a", &DBG_ScriptLine::m_point_a)
+		.def_readwrite("point_b", &DBG_ScriptLine::m_point_b)
+		];
+
+	module(L, "debug_render")
+		[
+			def("add_object", add_object),
+			def("remove_object", remove_object),
+			def("get_object", get_object),
+			def("get_flags", get_flags),
+			def("set_flags", set_flags)
+		];
+
 
@@ -830,2 +1988,9 @@
 		def("get_target_element", &g_get_target_element), //Can get bone cursor is targetting
+			
+			// demonized: get world position under crosshair
+			def("get_target_pos", &g_get_target_pos),
+
+			// demonized: get result of crosshair ray query
+			def("get_target_result", &g_get_target_result),
+
 		def("spawn_item", &spawn_section),
@@ -834,2 +1999,4 @@
 		def("get_start_time", &get_start_time),
+			def("get_view_entity", &get_view_entity_script),
+			def("set_view_entity", &set_view_entity_script),
 #endif
@@ -837,3 +2004,6 @@
 		// obsolete\deprecated
-		def("object_by_id",						get_object_by_id),
+			// demonized: add u16 override for better performance
+			def("object_by_id", ((CScriptGameObject * (*)(u16)) & get_object_by_id)),
+			def("object_by_id", ((CScriptGameObject* (*)()) & get_object_by_id)),
+			def("object_by_id", ((CScriptGameObject* (*)(const luabind::object&)) & get_object_by_id)),
 #ifdef DEBUG
@@ -869,2 +2039,4 @@
 		def("rain_factor",						rain_factor),
+			def("rain_wetness", rain_wetness),
+			def("rain_hemi", rain_hemi),
 		def("patrol_path_exists",				patrol_path_exists),
@@ -883,2 +2055,5 @@
 
+			// demonized: remove all map object spots by id
+			def("map_remove_all_object_spots", map_remove_all_object_spots),
+
 		def("add_dialog_to_render",				add_dialog_to_render),
@@ -908,6 +2086,23 @@
 		def("get_snd_volume",					&get_snd_volume),
+			def("get_rain_volume", &get_rain_volume),
 		def("set_snd_volume",					&set_snd_volume),
-		def("add_cam_effector",					&add_cam_effector),
-		def("add_cam_effector2",				&add_cam_effector2),
+			def("get_music_volume", &get_music_volume),
+			def("set_music_volume", &set_music_volume),
+			def("add_cam_effector", ((float (*)(LPCSTR, int, bool, LPCSTR))&add_cam_effector)),
+			def("add_cam_effector", ((float (*)(LPCSTR, int, bool, LPCSTR, float))&add_cam_effector)),
+			def("add_cam_effector", ((float (*)(LPCSTR, int, bool, LPCSTR, float, bool))&add_cam_effector)),
+			def("add_cam_effector", ((float (*)(LPCSTR, int, bool, LPCSTR, float, bool, float))&add_cam_effector)),
+
+			// demonized: Set custom camera position and direction with movement smoothing (for cutscenes, etc)
+			def("set_cam_custom_position_direction", ((void (*)(Fvector&, Fvector&, unsigned int, bool, bool))& set_cam_position_direction)),
+			def("set_cam_custom_position_direction", ((void (*)(Fvector&, Fvector&, unsigned int, bool))&set_cam_position_direction)),
+			def("set_cam_custom_position_direction", ((void (*)(Fvector&, Fvector&, unsigned int))&set_cam_position_direction)),
+			def("set_cam_custom_position_direction", ((void (*)(Fvector&, Fvector&))&set_cam_position_direction)),
+			def("remove_cam_custom_position_direction", &remove_cam_position_direction),
+
 		def("remove_cam_effector",				&remove_cam_effector),
+			def("set_cam_effector_factor", &set_cam_effector_factor),
+			def("get_cam_effector_factor", &get_cam_effector_factor),
+			def("get_cam_effector_length", &get_cam_effector_length),
+			def("check_cam_effector", &check_cam_effector),
 		def("add_pp_effector",					&add_pp_effector),
@@ -923,3 +2118,12 @@
 		def("game_id",							&GameID),
-    	def("ray_pick", &ray_pick)    
+			def("ray_pick", &ray_pick),
+
+			def("press_action", &LevelPressAction),
+			def("release_action", &LevelReleaseAction),
+			def("hold_action", &LevelHoldAction),
+
+			def("actor_moving_state", &ActorMovingState),
+			def("get_env_rads", &get_env_rads),
+			def("iterate_nearest", &iterate_nearest),
+			def("pick_material", &PickMaterial)
 	],
@@ -951,2 +2155,17 @@
       .def_readonly("element",		&script_rq_result::element)
+		.def_readonly("material_name", &script_rq_result::pMaterialName)
+		.def_readonly("material_flags", &script_rq_result::pMaterialFlags)
+		.def_readonly("material_phfriction", &script_rq_result::fPHFriction)
+		.def_readonly("material_phdamping", &script_rq_result::fPHDamping)
+		.def_readonly("material_phspring", &script_rq_result::fPHSpring)
+		.def_readonly("material_phbounce_start_velocity", &script_rq_result::fPHBounceStartVelocity)
+		.def_readonly("material_phbouncing", &script_rq_result::fPHBouncing)
+		.def_readonly("material_flotation_factor", &script_rq_result::fFlotationFactor)
+		.def_readonly("material_shoot_factor", &script_rq_result::fShootFactor)
+		.def_readonly("material_shoot_factor_mp", &script_rq_result::fShootFactorMP)
+		.def_readonly("material_bounce_damage_factor", &script_rq_result::fBounceDamageFactor)
+		.def_readonly("material_injurious_speed", &script_rq_result::fInjuriousSpeed)
+		.def_readonly("material_vis_transparency_factor", &script_rq_result::fVisTransparencyFactor)
+		.def_readonly("material_snd_occlusion_factor", &script_rq_result::fSndOcclusionFactor)
+		.def_readonly("material_density_factor", &script_rq_result::fDensityFactor)
       .def(								constructor<>()), 	
@@ -974,2 +2193,26 @@
 
+	module(L, "weather")
+	[
+		def("get_value_numric", get_weather_value_numric),
+		def("get_value_vector", get_weather_value_vector),
+		def("get_value_string", get_weather_value_string),
+		def("pause", pause_weather),
+		def("is_paused",is_weather_paused),
+		def("set_value_numric", set_weather_value_numric),
+		def("set_value_vector", set_weather_value_vector),
+		def("set_value_string", set_weather_value_string),
+		def("reload", reload_weather),
+		def("boost_value", boost_weather_value),
+		def("boost_reset", boost_weather_reset),
+		def("sun_time", sun_time)
+	];
+
+	module(L, "hud_adjust")
+		[
+		def("enabled", hud_adj_state),
+		def("set_vector", hud_adj_offs),
+		def("set_value", hud_adj_value),
+		def("remove_hud_model", remove_hud_model)
+	];
+
 	module(L,"relation_registry")
@@ -1029,4 +2274,26 @@
 	def("has_active_tutorial",	&has_active_tutotial),
-	def("translate_string",		&translate_string)
-
+		def("translate_string", &translate_string),
+		def("reload_language", &reload_language),
+		def("get_resolutions", &vid_modes_string),
+		def("play_hud_motion", PlayHudMotion),
+		def("stop_hud_motion", StopHudMotion),
+		def("get_motion_length", MotionLength),
+		def("hud_motion_allowed", AllowHudMotion),
+		def("play_hud_anm", PlayBlendAnm),
+		def("stop_hud_anm", StopBlendAnm),
+		def("stop_all_hud_anms", StopAllBlendAnms),
+		def("set_hud_anm_time", SetBlendAnmTime),
+		def("only_allow_movekeys", block_all_except_movement),
+		def("only_movekeys_allowed", only_movement_allowed),
+		def("set_actor_allow_ladder", set_actor_allow_ladder),
+		def("set_nv_lumfactor", set_nv_lumfactor),
+		def("reload_ui_xml", reload_hud_xml),
+		def("actor_weapon_lowered", actor_safemode),
+		def("actor_lower_weapon", actor_set_safemode),
+		def("prefetch_texture", prefetch_texture),
+		def("prefetch_model", prefetch_model),
+		def("get_visual_userdata", GetVisualUserdata),
+		def("world2ui", world2ui),
+		def("ui2world", (void (*)(Fvector2, Fvector&, u16&))&ui2world, pure_out_value(_2) + pure_out_value(_3)),
+		def("ui2world", (void (*)(Fvector&, Fvector&, u16&))&ui2world, pure_out_value(_2) + pure_out_value(_3))
 	];
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/level_sounds.cpp xray-monolith/src/xrGame/level_sounds.cpp
--- coc-1.4-xray-64/src/xrGame/level_sounds.cpp	2023-10-20 20:54:51.152326700 +0100
+++ xray-monolith/src/xrGame/level_sounds.cpp	2023-10-20 20:54:33.063037100 +0100
@@ -1,2 +1,4 @@
 #include "stdafx.h"
+#include <random>
+#include <algorithm>
 #pragma hdrstop
@@ -30,19 +32,34 @@
 {
-	if ((0==m_ActiveTime.x)&&(0==m_ActiveTime.y)||((int(game_time)>=m_ActiveTime.x)&&(int(game_time)<m_ActiveTime.y))){
-		if (0==m_Source._feedback()){
-			if ((0==m_PauseTime.x)&&(0==m_PauseTime.y)){    
+	if ((0 == m_ActiveTime.x) && (0 == m_ActiveTime.y) || ((int(game_time) >= m_ActiveTime.x) && (int(game_time) <
+		m_ActiveTime.y)))
+	{
+		if (0 == m_Source._feedback())
+		{
+			Fvector occ[3];
+			const float occluder_volume = Sound->get_occlusion(m_Position, .2f, occ);
+			const float vol = m_Volume * occluder_volume;
+
+			if ((0 == m_PauseTime.x) && (0 == m_PauseTime.y))
+			{
 				m_Source.play_at_pos	(0,m_Position,sm_Looped);
-				m_Source.set_volume		(m_Volume);
+				m_Source.set_volume(vol);
 				m_Source.set_frequency	(m_Freq);
 				m_StopTime				= 0xFFFFFFFF;
-			}else{
-				if (global_time>=m_NextTime){
+			}
+			else
+			{
+				if (global_time >= m_NextTime)
+				{
 					bool bFullPlay		= (0==m_PlayTime.x)&&(0==m_PlayTime.y);
 					m_Source.play_at_pos	(0,m_Position,bFullPlay?0:sm_Looped);
-					m_Source.set_volume		(m_Volume);
+					m_Source.set_volume(vol);
 					m_Source.set_frequency	(m_Freq);
-					if (bFullPlay){
+					if (bFullPlay)
+					{
 						m_StopTime		= 0xFFFFFFFF;
-						m_NextTime		= global_time+iFloor(m_Source.get_length_sec()*1000.0f)+Random.randI(m_PauseTime.x,m_PauseTime.y);
-					}else{
+						m_NextTime = global_time + iFloor(m_Source.get_length_sec() * 1000.0f) + Random.randI(
+							m_PauseTime.x, m_PauseTime.y);
+					}
+					else
+					{
 						m_StopTime		= bFullPlay?0:global_time+Random.randI(m_PlayTime.x,m_PlayTime.y);
@@ -164,5 +192,9 @@
 				CInifile::Sect&	S	= gameLtx.r_section	(music_sect);
+				std::random_device rd;
+				std::mt19937 g(rd());
+				std::shuffle(S.Data.begin(), S.Data.end(), g);
 				CInifile::SectCIt it	= S.Data.begin(), end = S.Data.end();
 				m_MusicTracks.reserve	(S.Data.size());
-				for (;it!=end; it++){
+				for (; it != end; it++)
+				{
 					m_MusicTracks.push_back	(SMusicTrack());
@@ -181,2 +213,3 @@
 	m_MusicTracks.clear			();
+	m_PlayedMusicIndices.clear();
 }
@@ -203,10 +236,14 @@
 			U32Vec				indices;
-			for (u32 k=0; k<m_MusicTracks.size(); ++k)
+			for (u32 k = 0; k < m_MusicTracks.size(); k++)
 			{
+				// Msg("Checking track %d", k);
 				SMusicTrack& T		= m_MusicTracks[k];
-				if (T.IsPlaying())	
+				if (T.IsPlaying()) {
 					T.Stop();
-				
-				if( T.in(game_time) )
+					// Msg("Stopping track %d", k);
+				}
+				if ((T.in(game_time) && m_PlayedMusicIndices.empty()) || 
+					(T.in(game_time) && !(std::find(m_PlayedMusicIndices.begin(), m_PlayedMusicIndices.end(), k) != m_PlayedMusicIndices.end()))) {
 					indices.push_back	(k);
+					// Msg("Pushing track %d", k);
 /*
@@ -217,5 +254,7 @@
 			}
+			}
 			if (!indices.empty())
 			{
-				u32 idx			= Random.randI(indices.size());
+				//u32 idx = Random.randI(indices.size());
+				u32 idx = 0;
 				m_CurrentTrack	= indices[idx];
@@ -223,2 +262,4 @@
 				T.Play			();
+				m_PlayedMusicIndices.push_back(indices[idx]);
+				// Msg("Starting track %d", indices[idx]);
 #ifdef DEBUG
@@ -226,3 +267,11 @@
 #endif
-			}else{
+			}
+			else
+			{
+				// Msg("m_PlayedMusicIndices.size %d", m_PlayedMusicIndices.size());
+				m_PlayedMusicIndices.clear();
+				std::random_device rd;
+				std::mt19937 g(rd());
+				std::shuffle(m_MusicTracks.begin(), m_MusicTracks.end(), g);
+				// Msg("Refreshing tracks");
 				m_NextTrackTime	= engine_time+10000; // next check after 10 sec
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/level_sounds.h xray-monolith/src/xrGame/level_sounds.h
--- coc-1.4-xray-64/src/xrGame/level_sounds.h	2023-10-20 20:54:51.152326700 +0100
+++ xray-monolith/src/xrGame/level_sounds.h	2023-10-20 20:54:33.063037100 +0100
@@ -46,2 +46,3 @@
 	MusicTrackVec	m_MusicTracks;
+	U32Vec m_PlayedMusicIndices; //Already played music array
 	u32				m_NextTrackTime;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/login_manager.cpp xray-monolith/src/xrGame/login_manager.cpp
--- coc-1.4-xray-64/src/xrGame/login_manager.cpp	2023-10-20 20:54:51.154326700 +0100
+++ xray-monolith/src/xrGame/login_manager.cpp	2023-10-20 20:54:33.064036900 +0100
@@ -4,8 +4,3 @@
 #include "MainMenu.h"
-#include "gamespy/GameSpy_Full.h"
-#include "gamespy/GameSpy_GP.h"
-#include "gamespy/GameSpy_ATLAS.h"
-#include "gamespy/GameSpy_Patching.h"
 #include "RegistryFuncs.h"
-#include "../xrGameSpy/xrGameSpy_MainDefs.h"
 #include "player_name_modifyer.h"
@@ -19,12 +15,11 @@
 {
-
 login_manager::login_manager(CGameSpy_Full* fullgs_obj)
 {
-	VERIFY(fullgs_obj);
-	m_gamespy_gp			= fullgs_obj->GetGameSpyGP();
-	VERIFY(m_gamespy_gp);
-	m_gamespy_atlas			= fullgs_obj->GetGameSpyATLAS();
-	VERIFY(m_gamespy_atlas);
-	m_gamespy_patching		= fullgs_obj->GetGameSpyPatching();
-	VERIFY(m_gamespy_patching);
+		//VERIFY(fullgs_obj);
+		//m_gamespy_gp			= fullgs_obj->GetGameSpyGP();
+		//VERIFY(m_gamespy_gp);
+		//m_gamespy_atlas			= fullgs_obj->GetGameSpyATLAS();
+		//VERIFY(m_gamespy_atlas);
+		//m_gamespy_patching		= fullgs_obj->GetGameSpyPatching();
+		//VERIFY(m_gamespy_patching);
 	m_current_profile		= NULL;
@@ -74,16 +69,16 @@
 	
-	GPResult tmp_res = m_gamespy_gp->Connect(
-		m_last_email,
-		m_last_nick,
-		m_last_password,
-		&login_manager::login_cb,
-		this
-	);
-	
-	if (tmp_res != GP_NO_ERROR)
-	{
-		m_login_operation_cb.clear();
-		logincb(NULL, CGameSpy_GP::TryToTranslate(tmp_res).c_str());
-		return;
-	}
+		//GPResult tmp_res = m_gamespy_gp->Connect(
+		//	m_last_email,
+		//	m_last_nick,
+		//	m_last_password,
+		//	&login_manager::login_cb,
+		//	this
+		//);
+		//
+		//if (tmp_res != GP_NO_ERROR)
+		//{
+		//	m_login_operation_cb.clear();
+		//	logincb(NULL, CGameSpy_GP::TryToTranslate(tmp_res).c_str());
+		//	return;
+		//}
 }
@@ -207,14 +203,14 @@
 
-	GPResult tmp_res = m_gamespy_gp->SetUniqueNick(
-		m_last_unick,
-		&login_manager::setunick_cb,
-		this
-	);
-	
-	if (tmp_res != GP_NO_ERROR)
-	{
-		m_login_operation_cb.clear();
-		logincb(NULL, CGameSpy_GP::TryToTranslate(tmp_res).c_str());
-		return;
-	}
+		//GPResult tmp_res = m_gamespy_gp->SetUniqueNick(
+		//	m_last_unick,
+		//	&login_manager::setunick_cb,
+		//	this
+		//);
+		//
+		//if (tmp_res != GP_NO_ERROR)
+		//{
+		//	m_login_operation_cb.clear();
+		//	logincb(NULL, CGameSpy_GP::TryToTranslate(tmp_res).c_str());
+		//	return;
+		//}
 }
@@ -224,6 +220,6 @@
 	VERIFY2(m_current_profile, "not logged in");
-	if (m_current_profile->online())
-	{
-		m_gamespy_gp->Disconnect	(); 
-	}
+		//if (m_current_profile->online())
+		//{
+		//	m_gamespy_gp->Disconnect	(); 
+		//}
 	delete_profile_obj();
@@ -234,18 +230,18 @@
 {
-	account_manager* tmp_acc_mngr = MainMenu()->GetAccountMngr();
-	if (tmp_acc_mngr->is_get_account_profiles_active())
-	{
-		Msg("! WARNING: reiniting get account profiles");
-		tmp_acc_mngr->reinit_get_account_profiles();
-	}
-	if (tmp_acc_mngr->is_email_searching_active())
-	{
-		Msg("! WARNING: reiniting searching emails");
-		tmp_acc_mngr->reinit_email_searching();
-	}
-	if (tmp_acc_mngr->is_suggest_unique_nicks_active())
-	{
-		Msg("! WARNING: reiniting suggesting unique nicks");
-		tmp_acc_mngr->reinit_suggest_unique_nicks();
-	}
+		//account_manager* tmp_acc_mngr = MainMenu()->GetAccountMngr();
+		//if (tmp_acc_mngr->is_get_account_profiles_active())
+		//{
+		//	Msg("! WARNING: reiniting get account profiles");
+		//	tmp_acc_mngr->reinit_get_account_profiles();
+		//}
+		//if (tmp_acc_mngr->is_email_searching_active())
+		//{
+		//	Msg("! WARNING: reiniting searching emails");
+		//	tmp_acc_mngr->reinit_email_searching();
+		//}
+		//if (tmp_acc_mngr->is_suggest_unique_nicks_active())
+		//{
+		//	Msg("! WARNING: reiniting suggesting unique nicks");
+		//	tmp_acc_mngr->reinit_suggest_unique_nicks();
+		//}
 }
@@ -279,15 +274,15 @@
 
-	GPRegisterUniqueNickResponseArg* tmp_res = static_cast<GPRegisterUniqueNickResponseArg*>(arg);
-	VERIFY(my_inst);
-	VERIFY(tmp_res);
-	VERIFY(my_inst->m_current_profile);
-
-	if (tmp_res->result != GP_NO_ERROR)
-	{
-		tmp_cb(NULL, CGameSpy_GP::TryToTranslate(tmp_res->result).c_str());
-		return;
-	}
+		//GPRegisterUniqueNickResponseArg* tmp_res = static_cast<GPRegisterUniqueNickResponseArg*>(arg);
+		//VERIFY(my_inst);
+		//VERIFY(tmp_res);
+		//VERIFY(my_inst->m_current_profile);
+
+		//if (tmp_res->result != GP_NO_ERROR)
+		//{
+		//	tmp_cb(NULL, CGameSpy_GP::TryToTranslate(tmp_res->result).c_str());
+		//	return;
+		//}
 
-	my_inst->m_current_profile->m_unique_nick = my_inst->m_last_unick;
-	tmp_cb(my_inst->m_current_profile, "mp_change_unick_success");
+		//my_inst->m_current_profile->m_unique_nick = my_inst->m_last_unick;
+		//tmp_cb(my_inst->m_current_profile, "mp_change_unick_success");
 }
@@ -298,76 +293,76 @@
 {
-	login_manager* my_inst = static_cast<login_manager*>(param);
-	GPConnectResponseArg* tmp_res = static_cast<GPConnectResponseArg*>(arg);
-	
-	login_operation_cb tmp_cb = my_inst->m_login_operation_cb;
-
-	VERIFY(my_inst);
-	VERIFY(tmp_res);
-
-	if (tmp_res->result != GP_NO_ERROR)
-	{
-		my_inst->m_login_operation_cb.clear();
-		tmp_cb(NULL, CGameSpy_GP::TryToTranslate(tmp_res->result).c_str());
-		return;
-	}
-
-	char tmp_ticket_dest[GP_LOGIN_TICKET_LEN];
-	ZeroMemory(tmp_ticket_dest, sizeof(tmp_ticket_dest));
-
-	VERIFY(my_inst->m_gamespy_gp);
-	GPResult tmp_lticket_res = my_inst->m_gamespy_gp->GetLoginTicket(tmp_ticket_dest);
-	VERIFY(tmp_lticket_res == GP_NO_ERROR);
-	if (tmp_lticket_res != GP_NO_ERROR)
-	{
-		Msg("! ERROR: failed to get login ticket");
-		tmp_ticket_dest[0] = 0;
-	}
-
-	my_inst->m_current_profile = xr_new<profile>(
-		tmp_res->profile,
-		tmp_res->uniquenick,
-		tmp_ticket_dest,
-		true
-	);
-	my_inst->m_gamespy_patching->PtTrackUsage(tmp_res->profile);
-	
-	my_inst->m_gamespy_atlas->WSLoginProfile(
-		my_inst->m_last_email,
-		my_inst->m_last_nick,
-		my_inst->m_last_password,
-		&login_manager::wslogin_cb,
-		my_inst
-	);
-}
-
-void __cdecl login_manager::wslogin_cb(GHTTPResult httpResult,
-									   WSLoginResponse * response,
-									   void * userData)
-{
-	login_manager* my_inst = static_cast<login_manager*>(userData);
-	login_operation_cb tmp_cb = my_inst->m_login_operation_cb;
-	my_inst->m_login_operation_cb.clear();
-
-	if (httpResult != GHTTPSuccess)
-	{
-		tmp_cb(NULL, CGameSpy_ATLAS::TryToTranslate(httpResult).c_str());
-		my_inst->delete_profile_obj();
-		return;
-	}
-	VERIFY(response);
-	
-	if (response->mLoginResult != WSLogin_Success)
-	{
-		tmp_cb(NULL, CGameSpy_ATLAS::TryToTranslate(response->mLoginResult).c_str());
-		my_inst->delete_profile_obj();
-		return;
-	}
-
-	VERIFY(my_inst->m_current_profile);	
-	
-	my_inst->m_current_profile->mCertificate = response->mCertificate;
-	my_inst->m_current_profile->mPrivateData = response->mPrivateData;
-
-	tmp_cb(my_inst->m_current_profile, "mp_login_success");
-}
+		//login_manager* my_inst = static_cast<login_manager*>(param);
+		//GPConnectResponseArg* tmp_res = static_cast<GPConnectResponseArg*>(arg);
+		//
+		//login_operation_cb tmp_cb = my_inst->m_login_operation_cb;
+
+		//VERIFY(my_inst);
+		//VERIFY(tmp_res);
+
+		//if (tmp_res->result != GP_NO_ERROR)
+		//{
+		//	my_inst->m_login_operation_cb.clear();
+		//	tmp_cb(NULL, CGameSpy_GP::TryToTranslate(tmp_res->result).c_str());
+		//	return;
+		//}
+
+		//char tmp_ticket_dest[GP_LOGIN_TICKET_LEN];
+		//ZeroMemory(tmp_ticket_dest, sizeof(tmp_ticket_dest));
+
+		//VERIFY(my_inst->m_gamespy_gp);
+		//GPResult tmp_lticket_res = my_inst->m_gamespy_gp->GetLoginTicket(tmp_ticket_dest);
+		//VERIFY(tmp_lticket_res == GP_NO_ERROR);
+		//if (tmp_lticket_res != GP_NO_ERROR)
+		//{
+		//	Msg("! ERROR: failed to get login ticket");
+		//	tmp_ticket_dest[0] = 0;
+		//}
+
+		//my_inst->m_current_profile = xr_new<profile>(
+		//	tmp_res->profile,
+		//	tmp_res->uniquenick,
+		//	tmp_ticket_dest,
+		//	true
+		//);
+		//my_inst->m_gamespy_patching->PtTrackUsage(tmp_res->profile);
+		//
+		//my_inst->m_gamespy_atlas->WSLoginProfile(
+		//	my_inst->m_last_email,
+		//	my_inst->m_last_nick,
+		//	my_inst->m_last_password,
+		//	&login_manager::wslogin_cb,
+		//	my_inst
+		//);
+	}
+
+	//void __cdecl login_manager::wslogin_cb(GHTTPResult httpResult,
+	//									   WSLoginResponse * response,
+	//									   void * userData)
+	//{
+	//	login_manager* my_inst = static_cast<login_manager*>(userData);
+	//	login_operation_cb tmp_cb = my_inst->m_login_operation_cb;
+	//	my_inst->m_login_operation_cb.clear();
+	//
+	//	if (httpResult != GHTTPSuccess)
+	//	{
+	//		tmp_cb(NULL, CGameSpy_ATLAS::TryToTranslate(httpResult).c_str());
+	//		my_inst->delete_profile_obj();
+	//		return;
+	//	}
+	//	VERIFY(response);
+	//	
+	//	if (response->mLoginResult != WSLogin_Success)
+	//	{
+	//		tmp_cb(NULL, CGameSpy_ATLAS::TryToTranslate(response->mLoginResult).c_str());
+	//		my_inst->delete_profile_obj();
+	//		return;
+	//	}
+	//
+	//	VERIFY(my_inst->m_current_profile);	
+	//	
+	//	my_inst->m_current_profile->mCertificate = response->mCertificate;
+	//	my_inst->m_current_profile->mPrivateData = response->mPrivateData;
+	//
+	//	tmp_cb(my_inst->m_current_profile, "mp_login_success");
+	//}
 
@@ -375,8 +370,8 @@
 {
-	if (!email || (xr_strlen(email) == 0))
-	{
-		Msg("! ERROR: email is empty");
-		return;
-	}
-	WriteRegistry_StrValue(REGISTRY_VALUE_USEREMAIL, email);
+		//if (!email || (xr_strlen(email) == 0))
+		//{
+		//	Msg("! ERROR: email is empty");
+		//	return;
+		//}
+		//WriteRegistry_StrValue(REGISTRY_VALUE_USEREMAIL, email);
 }
@@ -386,3 +381,3 @@
 	m_reg_email[0] = 0;
-	ReadRegistry_StrValue(REGISTRY_VALUE_USEREMAIL, m_reg_email);
+		//ReadRegistry_StrValue(REGISTRY_VALUE_USEREMAIL, m_reg_email);
 	return m_reg_email;
@@ -395,17 +390,17 @@
 {
-	using namespace secure_messaging;
-	if (!password || (xr_strlen(password) == 0))
-	{
-		Msg("! ERROR: password is empty");
-		return;
-	}
-
-	key_t			pass_key;
-	generate_key	(pass_key_seed, pass_key);
-	u32		buffer_size = xr_strlen(password) + 1;
-	u8 *	buffer = static_cast<u8*>(_alloca(buffer_size));
-	xr_strcpy	((char*)buffer, buffer_size, password);
-	buffer[buffer_size - 1] = 0;
-	encrypt(buffer, buffer_size, pass_key);
-	WriteRegistry_BinaryValue(REGISTRY_VALUE_USERPASSWORD, buffer, buffer_size);
+		//using namespace secure_messaging;
+		//if (!password || (xr_strlen(password) == 0))
+		//{
+		//	Msg("! ERROR: password is empty");
+		//	return;
+		//}
+
+		//key_t			pass_key;
+		//generate_key	(pass_key_seed, pass_key);
+		//u32		buffer_size = xr_strlen(password) + 1;
+		//u8 *	buffer = static_cast<u8*>(_alloca(buffer_size));
+		//xr_strcpy	((char*)buffer, buffer_size, password);
+		//buffer[buffer_size - 1] = 0;
+		//encrypt(buffer, buffer_size, pass_key);
+		//WriteRegistry_BinaryValue(REGISTRY_VALUE_USERPASSWORD, buffer, buffer_size);
 }
@@ -416,16 +411,16 @@
 	xr_strcpy(m_reg_password, "");
-	u8	tmp_password_dest[128];	//max password length is 30 symbols...
-	
-	u32 pass_size = ReadRegistry_BinaryValue(
-		REGISTRY_VALUE_USERPASSWORD,
-		tmp_password_dest,
-		sizeof(tmp_password_dest));
-	
-	if (pass_size)
-	{
-		key_t			pass_key;
-		generate_key	(pass_key_seed, pass_key);
-		decrypt(tmp_password_dest, pass_size, pass_key);
-		xr_strcpy		(m_reg_password, (char*)tmp_password_dest);
-	}
+		//u8	tmp_password_dest[128];	//max password length is 30 symbols...
+		//
+		//u32 pass_size = ReadRegistry_BinaryValue(
+		//	REGISTRY_VALUE_USERPASSWORD,
+		//	tmp_password_dest,
+		//	sizeof(tmp_password_dest));
+		//
+		//if (pass_size)
+		//{
+		//	key_t			pass_key;
+		//	generate_key	(pass_key_seed, pass_key);
+		//	decrypt(tmp_password_dest, pass_size, pass_key);
+		//	xr_strcpy		(m_reg_password, (char*)tmp_password_dest);
+		//}
 	return m_reg_password;
@@ -435,4 +430,4 @@
 {
-	DWORD tmp_value = remember ? 1 : 0;
-	WriteRegistry_DWValue(REGISTRY_VALUE_REMEMBER_PROFILE, tmp_value);
+		//DWORD tmp_value = remember ? 1 : 0;
+		//WriteRegistry_DWValue(REGISTRY_VALUE_REMEMBER_PROFILE, tmp_value);
 }
@@ -441,5 +436,5 @@
 {
-	string256 tmp_str;
-	xr_strcpy(tmp_str, nickname);
-	WritePlayerName_ToRegistry(tmp_str);
+		//string256 tmp_str;
+		//xr_strcpy(tmp_str, nickname);
+		//WritePlayerName_ToRegistry(tmp_str);
 }
@@ -449,3 +444,3 @@
 	m_reg_nick[0] = 0;
-	GetPlayerName_FromRegistry(m_reg_nick, sizeof(m_reg_nick));
+		//GetPlayerName_FromRegistry(m_reg_nick, sizeof(m_reg_nick));
 	return m_reg_nick;
@@ -456,3 +451,3 @@
 	DWORD tmp_value = 0;
-	ReadRegistry_DWValue(REGISTRY_VALUE_REMEMBER_PROFILE, tmp_value);
+		//ReadRegistry_DWValue(REGISTRY_VALUE_REMEMBER_PROFILE, tmp_value);
 	return tmp_value != 0;
@@ -462,5 +457,5 @@
 {
-	LPCSTR params = NULL;
-	STRCONCAT(params, "/C start ", url);
-	ShellExecute(0, "open", "cmd.exe", params, NULL, SW_SHOW);
+		//LPCSTR params = NULL;
+		//STRCONCAT(params, "/C start ", url);
+		//ShellExecute(0, "open", "cmd.exe", params, NULL, SW_SHOW);
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/login_manager.h xray-monolith/src/xrGame/login_manager.h
--- coc-1.4-xray-64/src/xrGame/login_manager.h	2023-10-20 20:54:51.154326700 +0100
+++ xray-monolith/src/xrGame/login_manager.h	2023-10-20 20:54:33.065035400 +0100
@@ -6,3 +6,2 @@
 #include "mixed_delegate.h"
-#include "../xrGameSpy/GameSpy/GP/gp.h"
 #include "account_manager.h"
@@ -17,2 +16,4 @@
 
+typedef unsigned int GPProfile;
+
 namespace gamespy_gp
@@ -27,4 +27,4 @@
 		
-	GSLoginCertificate	mCertificate;
-	GSLoginPrivateData	mPrivateData;
+		//GSLoginCertificate	mCertificate;
+		//GSLoginPrivateData	mPrivateData;
 	
@@ -139,5 +140,5 @@
 
-	static void __cdecl			wslogin_cb			(GHTTPResult httpResult,
-													 WSLoginResponse * response,
-													 void * userData);
+		//static void __cdecl			wslogin_cb			(GHTTPResult httpResult,
+		//												 WSLoginResponse * response,
+		//												 void * userData);
 	static void	__cdecl			setunick_cb			(GPConnection * connection,
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/MainMenu.cpp xray-monolith/src/xrGame/MainMenu.cpp
--- coc-1.4-xray-64/src/xrGame/MainMenu.cpp	2023-10-20 20:54:50.642326900 +0100
+++ xray-monolith/src/xrGame/MainMenu.cpp	2023-10-20 20:54:32.624037400 +0100
@@ -13,5 +13,2 @@
 #include "UICursor.h"
-#include "gamespy/GameSpy_Full.h"
-#include "gamespy/GameSpy_HTTP.h"
-#include "gamespy/GameSpy_Available.h"
 #include "gamespy/CdkeyDecode/cdkeydecode.h"
@@ -80,8 +77,8 @@
 	m_sPatchURL						= "";
-	m_pGameSpyFull					= NULL;
-	m_account_mngr					= NULL;
-	m_login_mngr					= NULL;
-	m_profile_store					= NULL;
-	m_stats_submitter				= NULL;
-	m_atlas_submit_queue			= NULL;
+	//m_pGameSpyFull					= NULL;
+	//m_account_mngr					= NULL;
+	//m_login_mngr					= NULL;
+	//m_profile_store					= NULL;
+	//m_stats_submitter				= NULL;
+	//m_atlas_submit_queue			= NULL;
 
@@ -103,3 +100,3 @@
 		g_statHint						= xr_new<CUIButtonHint>();
-		m_pGameSpyFull					= xr_new<CGameSpy_Full>();
+		//m_pGameSpyFull					= xr_new<CGameSpy_Full>();
 		
@@ -112,13 +109,20 @@
 
-		m_pMB_ErrDlgs[PatchDownloadSuccess]->AddCallbackStr("button_yes", MESSAGE_BOX_YES_CLICKED, CUIWndCallback::void_function(this, &CMainMenu::OnRunDownloadedPatch));
-		m_pMB_ErrDlgs[PatchDownloadSuccess]->AddCallbackStr("button_yes", MESSAGE_BOX_OK_CLICKED, CUIWndCallback::void_function(this, &CMainMenu::OnConnectToMasterServerOkClicked));
-
-		m_pMB_ErrDlgs[DownloadMPMap]->AddCallbackStr("button_copy", MESSAGE_BOX_COPY_CLICKED, CUIWndCallback::void_function(this, &CMainMenu::OnDownloadMPMap_CopyURL));
-		m_pMB_ErrDlgs[DownloadMPMap]->AddCallbackStr("button_yes", MESSAGE_BOX_YES_CLICKED, CUIWndCallback::void_function(this, &CMainMenu::OnDownloadMPMap));
-
-		m_account_mngr			= xr_new<gamespy_gp::account_manager>		(m_pGameSpyFull->GetGameSpyGP());
-		m_login_mngr			= xr_new<gamespy_gp::login_manager>			(m_pGameSpyFull);
-		m_profile_store			= xr_new<gamespy_profile::profile_store>	(m_pGameSpyFull);
-		m_stats_submitter		= xr_new<gamespy_profile::stats_submitter>	(m_pGameSpyFull);
-		m_atlas_submit_queue	= xr_new<atlas_submit_queue>				(m_stats_submitter);
+		m_pMB_ErrDlgs[PatchDownloadSuccess]->AddCallbackStr("button_yes", MESSAGE_BOX_YES_CLICKED,
+		                                                    CUIWndCallback::void_function(
+			                                                    this, &CMainMenu::OnRunDownloadedPatch));
+		m_pMB_ErrDlgs[PatchDownloadSuccess]->AddCallbackStr("button_yes", MESSAGE_BOX_OK_CLICKED,
+		                                                    CUIWndCallback::void_function(
+			                                                    this, &CMainMenu::OnConnectToMasterServerOkClicked));
+
+		m_pMB_ErrDlgs[DownloadMPMap]->AddCallbackStr("button_copy", MESSAGE_BOX_COPY_CLICKED,
+		                                             CUIWndCallback::void_function(
+			                                             this, &CMainMenu::OnDownloadMPMap_CopyURL));
+		m_pMB_ErrDlgs[DownloadMPMap]->AddCallbackStr("button_yes", MESSAGE_BOX_YES_CLICKED,
+		                                             CUIWndCallback::void_function(this, &CMainMenu::OnDownloadMPMap));
+
+		//m_account_mngr			= xr_new<gamespy_gp::account_manager>		(m_pGameSpyFull->GetGameSpyGP());
+		//m_login_mngr			= xr_new<gamespy_gp::login_manager>			(m_pGameSpyFull);
+		//m_profile_store			= xr_new<gamespy_profile::profile_store>	(m_pGameSpyFull);
+		//m_stats_submitter		= xr_new<gamespy_profile::stats_submitter>	(m_pGameSpyFull);
+		//m_atlas_submit_queue	= xr_new<atlas_submit_queue>				(m_stats_submitter);
 	}
@@ -136,9 +140,9 @@
 	
-	xr_delete						(m_account_mngr);
-	xr_delete						(m_login_mngr);
-	xr_delete						(m_profile_store);
-	xr_delete						(m_stats_submitter);
-	xr_delete						(m_atlas_submit_queue);
-	
-	xr_delete						(m_pGameSpyFull);
+	//xr_delete						(m_account_mngr);
+	//xr_delete						(m_login_mngr);
+	//xr_delete						(m_profile_store);
+	//xr_delete						(m_stats_submitter);
+	//xr_delete						(m_atlas_submit_queue);
+	//
+	//xr_delete						(m_pGameSpyFull);
 
@@ -169,2 +172,4 @@
 
+#include "..\..\xrEngine\x_ray.h"
+
 void CMainMenu::Activate	(bool bActivate)
@@ -181,2 +187,7 @@
 
+	//Discord
+	discord_gameinfo.mainmenu = bActivate;
+	if (bActivate && psDeviceFlags2.test(rsDiscord))
+		updateDiscordPresence();
+
 	if(bActivate)
@@ -305,3 +321,4 @@
 //IInputReceiver
-static int mouse_button_2_key []	=	{MOUSE_1,MOUSE_2,MOUSE_3};
+extern int mouse_button_2_key[];
+
 void	CMainMenu::IR_OnMousePress				(int btn)	
@@ -347,3 +363,4 @@
 	}
-	if (DIK_F12 == dik){
+	if (is_binded(kSCREENSHOT, dik))
+	{
 		Render->Screenshot();
@@ -384,2 +401,5 @@
 extern void draw_wnds_rects();
+extern bool use_reshade;
+extern void render_reshade_effects();
+
 void CMainMenu::OnRender	()
@@ -392,2 +412,5 @@
 
+	if (use_reshade)
+		render_reshade_effects();
+
 	Render->Render				();
@@ -408,2 +432,5 @@
 
+	if (use_reshade)
+		render_reshade_effects();
+
 	UI().pp_start();
@@ -471,4 +499,4 @@
 	{
-		m_pGameSpyFull->Update();
-		m_atlas_submit_queue->update();
+		//m_pGameSpyFull->Update();
+		//m_atlas_submit_queue->update();
 	}
@@ -487,4 +515,10 @@
 
+extern u32 g_screenmode;
+
 void CMainMenu::OnDeviceCreate()
 {
+	RECT winRect;
+	GetClientRect(Device.m_hWnd, &winRect);
+	MapWindowPoints(Device.m_hWnd, nullptr, reinterpret_cast<LPPOINT>(&winRect), 2);
+	ClipCursor(&winRect);
 }
@@ -582,32 +620,32 @@
 {
-	CGameSpy_Available GSA;
-	shared_str result_string;
-	if (!GSA.CheckAvailableServices(result_string))
-	{
-		Msg(*result_string);
-		return;
-	};
-	
-	LPCSTR fileName = *m_sPatchURL;
-	if (!fileName) return;
-
-	string4096 FilePath = "";
-	char* FileName = NULL;
-	GetFullPathName(fileName, 4096, FilePath, &FileName);
-
-	string_path		fname;
-	if (FS.path_exist("$downloads$"))
-	{
-		FS.update_path(fname, "$downloads$", FileName);
-		m_sPatchFileName = fname;
-	}
-	else
-		m_sPatchFileName.printf	("downloads\\%s", FileName);	
-	
-	m_sPDProgress.IsInProgress	= true;
-	m_sPDProgress.Progress		= 0;
-	m_sPDProgress.FileName		= m_sPatchFileName;
-	m_sPDProgress.Status		= "";
+	//CGameSpy_Available GSA;
+	//shared_str result_string;
+	//if (!GSA.CheckAvailableServices(result_string))
+	//{
+	//	Msg(*result_string);
+	//	return;
+	//};
+	//
+	//LPCSTR fileName = *m_sPatchURL;
+	//if (!fileName) return;
+
+	//string4096 FilePath = "";
+	//char* FileName = NULL;
+	//GetFullPathName(fileName, 4096, FilePath, &FileName);
+
+	//string_path		fname;
+	//if (FS.path_exist("$downloads$"))
+	//{
+	//	FS.update_path(fname, "$downloads$", FileName);
+	//	m_sPatchFileName = fname;
+	//}
+	//else
+	//	m_sPatchFileName.printf	("downloads\\%s", FileName);	
+	//
+	//m_sPDProgress.IsInProgress	= true;
+	//m_sPDProgress.Progress		= 0;
+	//m_sPDProgress.FileName		= m_sPatchFileName;
+	//m_sPDProgress.Status		= "";
 
-	m_pGameSpyFull->GetGameSpyHTTP()->DownloadFile(*m_sPatchURL, *m_sPatchFileName);
+	//m_pGameSpyFull->GetGameSpyHTTP()->DownloadFile(*m_sPatchURL, *m_sPatchFileName);
 }
@@ -678,3 +717,3 @@
 {
-	m_pGameSpyFull->GetGameSpyHTTP()->StopDownload();
+	//m_pGameSpyFull->GetGameSpyHTTP()->StopDownload();
 	m_sPDProgress.IsInProgress	= false;
@@ -739,18 +778,19 @@
 {
-	if (!m_pGameSpyFull || !m_pGameSpyFull->GetGameSpyHTTP()) return false;
-	string64 CDKey = "";
-	GetCDKey_FromRegistry(CDKey);
-
-#ifndef DEMO_BUILD
-	if (!xr_strlen(CDKey)) return true;
-#endif
-
-	int GameID = 0;
-	for (int i=0; i<4; i++)
-	{
-		m_pGameSpyFull->GetGameSpyHTTP()->xrGS_GetGameID(&GameID, i);
-		if (VerifyClientCheck(CDKey, unsigned short (GameID)) == 1)
 			return true;
-	};	
-	return false;
+	//	if (!m_pGameSpyFull || !m_pGameSpyFull->GetGameSpyHTTP()) return false;
+	//	string64 CDKey = "";
+	//	GetCDKey_FromRegistry(CDKey);
+	//
+	//#ifndef DEMO_BUILD
+	//	if (!xr_strlen(CDKey)) return true;
+	//#endif
+	//
+	//	int GameID = 0;
+	//	for (int i=0; i<4; i++)
+	//	{
+	//		m_pGameSpyFull->GetGameSpyHTTP()->xrGS_GetGameID(&GameID, i);
+	//		if (VerifyClientCheck(CDKey, unsigned short (GameID)) == 1)
+	//			return true;
+	//	};	
+	//	return false;
 }
@@ -786,6 +826,6 @@
 	static string256	buff;
-	if(m_pGameSpyFull)
-	{
-		xr_strcpy(buff, m_pGameSpyFull->GetGameVersion());
-	}else
+	//if(m_pGameSpyFull)
+	//{
+	//	xr_strcpy(buff, m_pGameSpyFull->GetGameVersion());
+	//}else
 	{
@@ -799,15 +839,16 @@
 {
-	gamespy_gp::login_manager* l_mngr		= GetLoginMngr();
-	gamespy_gp::profile const * tmp_prof	= l_mngr ? 
-		l_mngr->get_current_profile() : NULL;
-
-	if (tmp_prof)
-	{
-		m_player_name = tmp_prof->unique_nick();
-	} else
-	{
-		string512 name;
-		GetPlayerName_FromRegistry( name, sizeof(name) );
-		m_player_name = name;
-	}
+	m_player_name = "Stalker";
+	//gamespy_gp::login_manager* l_mngr		= GetLoginMngr();
+	//gamespy_gp::profile const * tmp_prof	= l_mngr ? 
+	//	l_mngr->get_current_profile() : NULL;
+
+	//if (tmp_prof)
+	//{
+	//	m_player_name = tmp_prof->unique_nick();
+	//} else
+	//{
+	//	string512 name;
+	//	GetPlayerName_FromRegistry( name, sizeof(name) );
+	//	m_player_name = name;
+	//}
 	return m_player_name.c_str();
@@ -846,3 +887,3 @@
 	STRCONCAT(params, "/C start ", url);
-	ShellExecute(0, "open", "cmd.exe", params, NULL, SW_SHOW);
+	//ShellExecute(0, "open", "cmd.exe", params, NULL, SW_SHOW);
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/MainMenu.h xray-monolith/src/xrGame/MainMenu.h
--- coc-1.4-xray-64/src/xrGame/MainMenu.h	2023-10-20 20:54:50.642326900 +0100
+++ xray-monolith/src/xrGame/MainMenu.h	2023-10-20 20:54:32.624037400 +0100
@@ -75,8 +76,8 @@
 
-	CGameSpy_Full*						m_pGameSpyFull;
-	gamespy_gp::account_manager*		m_account_mngr;
-	gamespy_gp::login_manager*			m_login_mngr;
-	gamespy_profile::profile_store*		m_profile_store;
-	gamespy_profile::stats_submitter*	m_stats_submitter;
-	atlas_submit_queue*					m_atlas_submit_queue;
+	//CGameSpy_Full*						m_pGameSpyFull;
+	//gamespy_gp::account_manager*		m_account_mngr;
+	//gamespy_gp::login_manager*			m_login_mngr;
+	//gamespy_profile::profile_store*		m_profile_store;
+	//gamespy_profile::stats_submitter*	m_stats_submitter;
+	//atlas_submit_queue*					m_atlas_submit_queue;
 
@@ -112,8 +113,8 @@
 	
-	CGameSpy_Full*						GetGS			()	{return m_pGameSpyFull;};
-	gamespy_gp::account_manager*		GetAccountMngr	()	{ return m_account_mngr; };
-	gamespy_gp::login_manager*			GetLoginMngr	()	{ return m_login_mngr; };
-	gamespy_profile::profile_store*		GetProfileStore	()	{ return m_profile_store; };
-	gamespy_profile::stats_submitter*	GetStatsSubmitter()	{ return m_stats_submitter; };
-	atlas_submit_queue*					GetSubmitQueue	()	{ return m_atlas_submit_queue; };
+	//CGameSpy_Full*						GetGS			()	{return m_pGameSpyFull;};
+	//gamespy_gp::account_manager*		GetAccountMngr	()	{ return m_account_mngr; };
+	//gamespy_gp::login_manager*			GetLoginMngr	()	{ return m_login_mngr; };
+	//gamespy_profile::profile_store*		GetProfileStore	()	{ return m_profile_store; };
+	//gamespy_profile::stats_submitter*	GetStatsSubmitter()	{ return m_stats_submitter; };
+	//atlas_submit_queue*					GetSubmitQueue	()	{ return m_atlas_submit_queue; };
 protected:
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/map_location.cpp xray-monolith/src/xrGame/map_location.cpp
--- coc-1.4-xray-64/src/xrGame/map_location.cpp	2023-10-20 20:54:51.158326600 +0100
+++ xray-monolith/src/xrGame/map_location.cpp	2023-10-20 20:54:33.068035900 +0100
@@ -30,2 +30,3 @@
 #include "Inventory.h"
+#include "HUDManager.h"
 //#include "CustomMonster.h"
@@ -55,3 +56,4 @@
 	m_flags.set				(eHintEnabled, TRUE);
-	LoadSpot				(type, false);
+	spot_type = type;
+	LoadSpot(spot_type, false);
 	
@@ -642,2 +663,9 @@
 	R_ASSERT(sp);
+
+	if (!g_uiSpotXml)
+	{
+		g_uiSpotXml = xr_new<CUIXml>();
+		g_uiSpotXml->Load(CONFIG_PATH, UI_PATH, "map_spots.xml");
+	}
+
 	if ( PointerEnabled() )
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/map_location.h xray-monolith/src/xrGame/map_location.h
--- coc-1.4-xray-64/src/xrGame/map_location.h	2023-10-20 20:54:51.158326600 +0100
+++ xray-monolith/src/xrGame/map_location.h	2023-10-20 20:54:33.069036500 +0100
@@ -61,8 +61,11 @@
 	};
+
 	SCachedValues			m_cached;
 private:
-							CMapLocation					(const CMapLocation&){R_ASSERT(0);} //disable copy ctor
+	CMapLocation(const CMapLocation&)
+	{
+		R_ASSERT(0);
+	} //disable copy ctor
 
 protected :
-	void					LoadSpot						(LPCSTR type, bool bReload); 
 	void					UpdateSpot						(CUICustomMap* map, CMapSpot* sp );
@@ -111,2 +114,5 @@
 
+	void LoadSpot(LPCSTR type, bool bReload);
+	LPCSTR spot_type;
+
 #ifdef DEBUG
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/map_manager.cpp xray-monolith/src/xrGame/map_manager.cpp
--- coc-1.4-xray-64/src/xrGame/map_manager.cpp	2023-10-20 20:54:51.159326600 +0100
+++ xray-monolith/src/xrGame/map_manager.cpp	2023-10-20 20:54:33.069036500 +0100
@@ -151,2 +172,17 @@
 
+// demonized: remove all map object spots by id
+void CMapManager::RemoveAllMapLocationsById(u16 id)
+{
+	for (Locations_it it = Locations().begin(); it != Locations().end(); ) {
+		if (it->object_id == id) {
+			if (IsGameTypeSingle())
+				Level().GameTaskManager().MapLocationRelcase((*it).location);
+			Destroy((*it).location);
+			it = Locations().erase(it);
+		} else {
+			it++;
+		}
+	}
+}
+
 void CMapManager::RemoveMapLocationByObjectID(u16 id) //call on destroy object
@@ -261,2 +296,10 @@
 
+void CMapManager::ReloadSpots()
+{
+	Locations_it it = Locations().begin();
+	Locations_it it_e = Locations().end();
+
+	for (; it != it_e; ++it)
+		(*it).location->LoadSpot((*it).location->spot_type, false);
+}
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/map_manager.h xray-monolith/src/xrGame/map_manager.h
--- coc-1.4-xray-64/src/xrGame/map_manager.h	2023-10-20 20:54:51.159326600 +0100
+++ xray-monolith/src/xrGame/map_manager.h	2023-10-20 20:54:33.070039800 +0100
@@ -22,2 +23,6 @@
 	void					RemoveMapLocation			(const shared_str& spot_type, u16 id);
+
+	// demonized: remove all map object spots by id
+	void RemoveAllMapLocationsById(u16 id);
+
 	bool					HasMapLocation				(const shared_str& spot_type, u16 id);
@@ -28,2 +33,3 @@
 	void					DisableAllPointers			();
+	void ReloadSpots();
 	bool					GetMapLocationsForObject	(u16 id, xr_vector<CMapLocation*>& res);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/medkit.h xray-monolith/src/xrGame/medkit.h
--- coc-1.4-xray-64/src/xrGame/medkit.h	2023-10-20 20:54:51.162326500 +0100
+++ xray-monolith/src/xrGame/medkit.h	2023-10-20 20:54:33.072035600 +0100
@@ -9,5 +9,6 @@
 #include "eatable_item_object.h"
+#include "script_export_space.h"
 
-class CMedkit: public CEatableItemObject {
-
+class CMedkit : public CEatableItemObject
+{
 public:
@@ -15,2 +16,8 @@
 	virtual		 ~CMedkit			();
+	
+	DECLARE_SCRIPT_REGISTER_FUNCTION
 };
+
+add_to_type_list(CMedkit)
+#undef script_type_list
+#define script_type_list save_type_list(CMedkit)
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Mincer.cpp xray-monolith/src/xrGame/Mincer.cpp
--- coc-1.4-xray-64/src/xrGame/Mincer.cpp	2023-10-20 20:54:50.645326700 +0100
+++ xray-monolith/src/xrGame/Mincer.cpp	2023-10-20 20:54:32.626035800 +0100
@@ -128,2 +134,5 @@
 	CParticlesPlayer* PP = smart_cast<CParticlesPlayer*>(obj);
+
+	if (smart_cast<CEntityAlive*>(obj))
+	{
 	if(PP && *m_torn_particles)
@@ -133,2 +142,3 @@
 	m_tearing_sound.play_at_pos(0,m_telekinetics.Center());
+	}
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Missile.cpp xray-monolith/src/xrGame/Missile.cpp
--- coc-1.4-xray-64/src/xrGame/Missile.cpp	2023-10-20 20:54:50.646326900 +0100
+++ xray-monolith/src/xrGame/Missile.cpp	2023-10-20 20:54:32.627035700 +0100
@@ -1,2 +1,2 @@
-#include "stdafx.h"
+ï»¿#include "stdafx.h"
 #include "missile.h"
@@ -17,2 +17,4 @@
 #include "../xrEngine/IGame_Persistent.h"
+#include "../xrServerEntities/ai_sounds.h"
+#include "player_hud.h"
 #ifdef DEBUG
@@ -78,2 +80,14 @@
 	m_ef_weapon_type	= READ_IF_EXISTS(pSettings,r_u32,section,"ef_weapon_type",u32(-1));
+
+	if (pSettings->line_exist(section, "snd_draw"))
+		m_sounds.LoadSound(section, "snd_draw", "sndShow", false, SOUND_TYPE_ITEM_HIDING);
+
+	if (pSettings->line_exist(section, "snd_holster"))
+		m_sounds.LoadSound(section, "snd_holster", "sndHide", false, SOUND_TYPE_ITEM_HIDING);
+
+	if (pSettings->line_exist(section, "snd_throw"))
+		m_sounds.LoadSound(section, "snd_throw", "sndThrow", false, SOUND_TYPE_ITEM_HIDING);
+
+	if (pSettings->line_exist(section, "snd_checkout"))
+		m_sounds.LoadSound(section, "snd_checkout", "sndCheckout", false, SOUND_TYPE_WEAPON_RECHARGING);
 }
@@ -218,4 +231,5 @@
 	{
-		if (hud_adj_mode==0 && GetState()==eIdle && (Device.dwTimeGlobal-m_dw_curr_substate_time>20000) )
+		if (hud_adj_mode == 0 && g_player_hud->script_anim_part == u8(-1) && GetState() == eIdle && (Device.dwTimeGlobal - m_dw_curr_substate_time > 20000))
 		{
+			if (!pActor->is_safemode())
 			SwitchState			(eBore);
@@ -242,2 +258,18 @@
 
+	if (Device.dwFrame == dwUpdateSounds_Frame)
+		return;
+
+	dwUpdateSounds_Frame = Device.dwFrame;
+
+	Fvector P;
+	Center(P);
+
+	if (m_sounds.FindSoundItem("sndShow", false))
+		m_sounds.SetPosition("sndShow", P);
+	if (m_sounds.FindSoundItem("sndHide", false))
+		m_sounds.SetPosition("sndHide", P);
+	if (m_sounds.FindSoundItem("sndThrow", false) && m_fake_missile)
+		m_sounds.SetPosition("sndThrow", m_fake_missile->Position());
+	if (m_sounds.FindSoundItem("sndCheckout", false))
+		m_sounds.SetPosition("sndCheckout", P);
 }
@@ -258,5 +291,5 @@
 
-void CMissile::State(u32 state) 
+void CMissile::State(u32 state, u32 old_state)
 {
-	switch(GetState()) 
+	switch (state)
 	{
@@ -264,5 +297,10 @@
         {
+			if (ParentIsActor()) g_player_hud->attach_item(this);
 			SetPending			(TRUE);
-			PlayHUDMotion("anm_show", FALSE, this, GetState());
-		} break;
+			PlayHUDMotion("anm_show", FALSE, this, GetState(), 1.f, 0.f, false);
+
+			if (m_sounds.FindSoundItem("sndShow", false))
+				m_sounds.PlaySound("sndShow", H_Root()->Position(), H_Root(), !!GetHUDmode());
+		}
+		break;
 	case eIdle:
@@ -276,6 +315,13 @@
 			{
+				if (old_state != eHiding)
+				{
 				SetPending			(TRUE);
 				PlayHUDMotion		("anm_hide", TRUE, this, GetState());
+
+					if (m_sounds.FindSoundItem("sndHide", false))
+						m_sounds.PlaySound("sndHide", H_Root()->Position(), H_Root(), !!GetHUDmode());
 			}
-		} break;
+			}
+		}
+		break;
 	case eHidden:
@@ -300,3 +346,11 @@
 			PlayHUDMotion		("anm_throw_begin", TRUE, this, GetState());
-		} break;
+
+			if (m_sounds.FindSoundItem("sndCheckout", false))
+			{
+				Fvector C;
+				Center(C);
+				PlaySound("sndCheckout", C);
+			}
+		}
+		break;
 	case eReady:
@@ -310,3 +365,11 @@
 			PlayHUDMotion		("anm_throw", TRUE, this, GetState());
-		} break;
+
+			if (m_sounds.FindSoundItem("sndThrow", false))
+			{
+				Fvector C;
+				Center(C);
+				PlaySound("sndThrow", C);
+			}
+		}
+		break;
 	case eThrowEnd:
@@ -324,7 +388,7 @@
 
-void CMissile::OnStateSwitch	(u32 S)
+void CMissile::OnStateSwitch(u32 S, u32 oldState)
 {
 	m_dwStateTime				= 0;
-	inherited::OnStateSwitch	(S);
-	State						(S);
+	inherited::OnStateSwitch(S, oldState);
+	State(S, oldState);
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Missile.h xray-monolith/src/xrGame/Missile.h
--- coc-1.4-xray-64/src/xrGame/Missile.h	2023-10-20 20:54:50.646326900 +0100
+++ xray-monolith/src/xrGame/Missile.h	2023-10-20 20:54:32.627035700 +0100
@@ -47,4 +50,4 @@
 
-	virtual void 			State						(u32 state);
-	virtual void 			OnStateSwitch				(u32 S);
+	virtual void State(u32 state, u32 old_state);
+	virtual void OnStateSwitch(u32 S, u32 oldState);
 	virtual bool			GetBriefInfo				(II_BriefInfo& info);
@@ -77,2 +80,4 @@
 
+	u32 dwUpdateSounds_Frame;
+
 	//ïàðàìåòðû áðîñêà
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/monster_community.h xray-monolith/src/xrGame/monster_community.h
--- coc-1.4-xray-64/src/xrGame/monster_community.h	2023-10-20 20:54:51.167326900 +0100
+++ xray-monolith/src/xrGame/monster_community.h	2023-10-20 20:54:33.083035500 +0100
@@ -56,2 +57,4 @@
 	static void					DeleteIdToIndexData	();
+
+	static void Reset() { m_relation_table.clear(); }
 private:
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/MosquitoBald_script.cpp xray-monolith/src/xrGame/MosquitoBald_script.cpp
--- coc-1.4-xray-64/src/xrGame/MosquitoBald_script.cpp	2023-10-20 20:54:50.647329000 +0100
+++ xray-monolith/src/xrGame/MosquitoBald_script.cpp	2023-10-20 20:54:32.628035600 +0100
@@ -15,3 +15,10 @@
 		class_<CMosquitoBald,CGameObject>("CMosquitoBald")
-			.def(constructor<>()),
+			.def(constructor<>())
+	];
+}
+
+void CZoneCampfire::script_register(lua_State* L)
+{
+	module(L)
+		[
 		class_<CZoneCampfire,CGameObject>("CZoneCampfire")
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/movement_manager.cpp xray-monolith/src/xrGame/movement_manager.cpp
--- coc-1.4-xray-64/src/xrGame/movement_manager.cpp	2023-10-20 20:54:51.167326900 +0100
+++ xray-monolith/src/xrGame/movement_manager.cpp	2023-10-20 20:54:33.083035500 +0100
@@ -343,5 +360,11 @@
 
+BOOL monsterStuckFix = FALSE;
 bool CMovementManager::can_use_distributed_computations(u32 option) const
 {
-	return							(!m_build_at_once && g_mt_config.test(option) && !object().getDestroy());
+	//return (!m_build_at_once && g_mt_config.test(option) && !object().getDestroy());
+
+	// Fix for bug which makes mutants running in one place. Something happens with the thread, and the mutants will wait for a thread which will never finish running.
+	// Many thanks to Arszi for finding this <3
+	// demonized: add cvar switch for toggling it
+	return (!monsterStuckFix && !m_build_at_once && g_mt_config.test(option) && !object().getDestroy());
 }
@@ -358,2 +381,5 @@
 	move_along_path					(movement_control,dest_position,object().client_update_fdelta());
+
+	// Update Grass benders
+	g_pGamePersistent->GrassBendersUpdate(object().ID(), grassbender_id, grassbender_frame, object().Position(), -1.0f, 1.0f, true);
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/movement_manager.h xray-monolith/src/xrGame/movement_manager.h
--- coc-1.4-xray-64/src/xrGame/movement_manager.h	2023-10-20 20:54:51.168326600 +0100
+++ xray-monolith/src/xrGame/movement_manager.h	2023-10-20 20:54:33.083035500 +0100
@@ -78,3 +84,8 @@
 
-class CMovementManager {
+class CMovementManager
+{
+public:
+	u8 grassbender_id;
+	u32 grassbender_frame;
+
 private:
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/moving_objects.cpp xray-monolith/src/xrGame/moving_objects.cpp
--- coc-1.4-xray-64/src/xrGame/moving_objects.cpp	2023-10-20 20:54:51.172328000 +0100
+++ xray-monolith/src/xrGame/moving_objects.cpp	2023-10-20 20:54:33.093035700 +0100
@@ -32,2 +33,3 @@
 {
+#ifdef DEBUG
 	VERIFY2					(
@@ -37,3 +39,2 @@
 
-#ifdef DEBUG
 	m_objects.insert		(moving_object);
@@ -47,2 +48,3 @@
 {
+#ifdef DEBUG
 	VERIFY2					(
@@ -52,3 +54,2 @@
 
-#ifdef DEBUG
 	m_objects.erase			(m_objects.find(moving_object));
@@ -62,2 +63,3 @@
 {
+#ifdef DEBUG
 	VERIFY2					(
@@ -66,3 +68,3 @@
 	);
-
+#endif
 #pragma todo("this place can be optimized in case of slowdowns")
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/NET_Queue.h xray-monolith/src/xrGame/NET_Queue.h
--- coc-1.4-xray-64/src/xrGame/NET_Queue.h	2023-10-20 20:54:50.647329000 +0100
+++ xray-monolith/src/xrGame/NET_Queue.h	2023-10-20 20:54:32.629035700 +0100
@@ -53,3 +57,4 @@
 	}
-	void				export		(NET_Packet& P)
+
+	void export_(NET_Packet& P)
 	{
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/object_handler_planner.cpp xray-monolith/src/xrGame/object_handler_planner.cpp
--- coc-1.4-xray-64/src/xrGame/object_handler_planner.cpp	2023-10-20 20:54:51.178326700 +0100
+++ xray-monolith/src/xrGame/object_handler_planner.cpp	2023-10-20 20:54:33.103035900 +0100
@@ -23,5 +23,7 @@
 
-IC	ObjectHandlerSpace::EWorldProperties CObjectHandlerPlanner::object_property(MonsterSpace::EObjectAction object_action) const
+IC ObjectHandlerSpace::EWorldProperties CObjectHandlerPlanner::object_property(
+	MonsterSpace::EObjectAction object_action) const
+{
+	switch (object_action)
 {
-	switch (object_action) {
 		case MonsterSpace::eObjectActionSwitch1			: return(ObjectHandlerSpace::eWorldPropertySwitch1);
@@ -317 +329,7 @@
 }
+
+CObjectHandlerPlanner::_condition_type CObjectHandlerPlanner::uid(const u32 id0, const u32 id1) const
+{
+	VERIFY(!((id0 << 16) & id1));
+	return ((id0 << 16) | id1);
+}
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/object_handler_planner.h xray-monolith/src/xrGame/object_handler_planner.h
--- coc-1.4-xray-64/src/xrGame/object_handler_planner.h	2023-10-20 20:54:51.178326700 +0100
+++ xray-monolith/src/xrGame/object_handler_planner.h	2023-10-20 20:54:33.103035900 +0100
@@ -60,3 +63,3 @@
 public:
-	IC		_condition_type	uid						(const u32 id1, const u32 id0) const;
+	_condition_type uid(const u32 id1, const u32 id0) const;
 	IC		bool			object_action			(_condition_type action_id, CObject *object);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/object_handler_planner_impl.h xray-monolith/src/xrGame/object_handler_planner_impl.h
--- coc-1.4-xray-64/src/xrGame/object_handler_planner_impl.h	2023-10-20 20:54:51.178326700 +0100
+++ xray-monolith/src/xrGame/object_handler_planner_impl.h	2023-10-20 20:54:33.104035500 +0100
@@ -10,8 +10,2 @@
 
-IC	CObjectHandlerPlanner::_condition_type CObjectHandlerPlanner::uid(const u32 id0, const u32 id1) const
-{
-	VERIFY				(!((id0 << 16) & id1));
-	return				((id0 << 16) | id1);
-}
-
 IC	bool CObjectHandlerPlanner::object_action	(u32 action_id, CObject *object)
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ParticlesPlayer.cpp xray-monolith/src/xrGame/ParticlesPlayer.cpp
--- coc-1.4-xray-64/src/xrGame/ParticlesPlayer.cpp	2023-10-20 20:54:50.682327400 +0100
+++ xray-monolith/src/xrGame/ParticlesPlayer.cpp	2023-10-20 20:54:32.640035700 +0100
@@ -80,9 +87,13 @@
 	CInifile* ini		= K->LL_UserData();
-	if(ini&&ini->section_exist("particle_bones")){
+	if (ini && ini->section_exist("particle_bones"))
+	{
 		bone_mask		= 0;
 		CInifile::Sect& data		= ini->r_section("particle_bones");
-		for (CInifile::SectCIt I=data.Data.begin(); I!=data.Data.end(); I++){
+		for (CInifile::SectCIt I = data.Data.begin(); I != data.Data.end(); I++)
+		{
 			const CInifile::Item& item	= *I;
 			u16 index				= K->LL_BoneID(*item.first); 
-			R_ASSERT3(index != BI_NONE, "Particles bone not found", *item.first);
+			VERIFY3(index != BI_NONE, "Particles bone not found", *item.first);
+			if (index != BI_NONE)
+			{
 			Fvector					offs;
@@ -93,2 +104,3 @@
 	}
+	}
 	if(m_Bones.empty())
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/patrol_point.cpp xray-monolith/src/xrGame/patrol_point.cpp
--- coc-1.4-xray-64/src/xrGame/patrol_point.cpp	2023-10-20 20:54:51.198326700 +0100
+++ xray-monolith/src/xrGame/patrol_point.cpp	2023-10-20 20:54:33.128035800 +0100
@@ -129,2 +135,3 @@
 	CGameGraph::CVertex const*	vertex = ai().game_graph().vertex(m_game_vertex_id);
+#ifdef DEBUG
 	VERIFY2				(
@@ -140,3 +147,3 @@
 	);
-
+#endif
 	if (vertex->level_id() == ai().level_graph().level_id())
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/patrol_point_inline.h xray-monolith/src/xrGame/patrol_point_inline.h
--- coc-1.4-xray-64/src/xrGame/patrol_point_inline.h	2023-10-20 20:54:51.198326700 +0100
+++ xray-monolith/src/xrGame/patrol_point_inline.h	2023-10-20 20:54:33.129036100 +0100
@@ -12,3 +12,5 @@
 {
+#ifdef DEBUG
 	VERIFY				(m_initialized);
+#endif
 	return				(m_position);
@@ -18,3 +20,5 @@
 {
+#ifdef DEBUG
 	VERIFY				(m_initialized);
+#endif
 	return				(m_flags);
@@ -24,3 +28,5 @@
 {
+#ifdef DEBUG
 	VERIFY				(m_initialized);
+#endif
 	return				(m_name);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/PDA.cpp xray-monolith/src/xrGame/PDA.cpp
--- coc-1.4-xray-64/src/xrGame/PDA.cpp	2023-10-20 20:54:50.650327200 +0100
+++ xray-monolith/src/xrGame/PDA.cpp	2023-10-20 20:54:32.631038400 +0100
@@ -1,2 +1,2 @@
-#include "pch_script.h"
+ï»¿#include "pch_script.h"
 #include "pda.h"
@@ -14,2 +14,7 @@
 
+#include "player_hud.h"
+#include "UIGameCustom.h"
+#include "ui\UIPdaWnd.h"
+#include "ai_sounds.h"
+#include "Inventory.h"
 
@@ -20,6 +25,14 @@
 	TurnOff					();
+	m_bZoomed = false;
+	m_eDeferredEnable = eDefault;
+	joystick = BI_NONE;
+	target_screen_switch = 0.f;
+	m_fLR_CameraFactor = 0.f;
+	m_fLR_MovingFactor = 0.f;
+	m_fLR_InertiaFactor = 0.f;
+	m_fUD_InertiaFactor = 0.f;
+	m_bNoticedEmptyBattery = false;
 }
 
-CPda::~CPda() 
-{}
+CPda::~CPda() {}
 
@@ -27,3 +40,3 @@
 {
-	inherited::net_Spawn		(DC);
+	BOOL res = inherited::net_Spawn(DC);
 	CSE_Abstract				*abstract = (CSE_Abstract*)(DC);
@@ -34,3 +47,3 @@
 
-	return						(TRUE);
+	return (res);
 }
@@ -51,2 +64,309 @@
 	m_functor_str = READ_IF_EXISTS(pSettings,r_string,section,"play_function",""); 
+	m_fDisplayBrightnessPowerSaving = READ_IF_EXISTS(pSettings, r_float, section, "power_saving_brightness", .6f);
+	m_fPowerSavingCharge = READ_IF_EXISTS(pSettings, r_float, section, "power_saving_charge", .15f);
+	m_joystick_bone = READ_IF_EXISTS(pSettings, r_string, section, "joystick_bone", nullptr);
+	m_sounds.LoadSound(section, "snd_draw", "sndShow", true);
+	m_sounds.LoadSound(section, "snd_holster", "sndHide", true);
+	m_sounds.LoadSound(section, "snd_draw_empty", "sndShowEmpty", true);
+	m_sounds.LoadSound(section, "snd_holster_empty", "sndHideEmpty", true);
+	m_sounds.LoadSound(section, "snd_btn_press", "sndButtonPress");
+	m_sounds.LoadSound(section, "snd_btn_release", "sndButtonRelease"); 
+	m_sounds.LoadSound(section, "snd_empty", "sndEmptyBattery", true);
+	m_screen_on_delay = READ_IF_EXISTS(pSettings, r_float, section, "screen_on_delay", 0.f);
+	m_screen_off_delay = READ_IF_EXISTS(pSettings, r_float, section, "screen_off_delay", 0.f);
+	m_thumb_rot[0] = READ_IF_EXISTS(pSettings, r_float, section, "thumb_rot_x", 0.f);
+	m_thumb_rot[1] = READ_IF_EXISTS(pSettings, r_float, section, "thumb_rot_y", 0.f);
+}
+
+void CPda::OnStateSwitch(u32 S, u32 oldState)
+{
+	inherited::OnStateSwitch(S, oldState);
+
+	if (!ParentIsActor())
+		return;
+
+	switch (S)
+	{
+	case eShowing:
+	{
+		g_player_hud->attach_item(this);
+		g_pGamePersistent->pda_shader_data.pda_display_factor = 0.f;
+
+		m_sounds.PlaySound(hasEnoughBatteryPower() ? "sndShow" : "sndShowEmpty", Position(), H_Root(), !!GetHUDmode(), false);
+		PlayHUDMotion(!m_bNoticedEmptyBattery ? "anm_show" : "anm_show_empty", FALSE, this, GetState(), 1.f, 0.f, false);
+		
+		SetPending(TRUE);
+		target_screen_switch = Device.fTimeGlobal + m_screen_on_delay;
+	}
+	break;
+	case eHiding:
+	{
+		if (oldState != eHiding)
+		{
+			m_sounds.PlaySound(hasEnoughBatteryPower() ? "sndHide" : "sndHideEmpty", Position(), H_Root(), !!GetHUDmode(), false);
+			PlayHUDMotion(!m_bNoticedEmptyBattery ? "anm_hide" : "anm_hide_empty", TRUE, this, GetState());
+			SetPending(TRUE);
+			m_bZoomed = false;
+			CurrentGameUI()->GetPdaMenu().Enable(false);
+			g_player_hud->reset_thumb(false);
+			CurrentGameUI()->GetPdaMenu().ResetJoystick(false);
+			if (joystick != BI_NONE && HudItemData())
+				HudItemData()->m_model->LL_GetBoneInstance(joystick).reset_callback();
+			target_screen_switch = Device.fTimeGlobal + m_screen_off_delay;
+		}
+	}
+	break;
+	case eHidden:
+	{
+		if (oldState != eHidden)
+		{
+			m_bZoomed = false;
+			m_fZoomfactor = 0.f;
+			CUIPdaWnd* pda = &CurrentGameUI()->GetPdaMenu();
+
+			if (pda->IsShown())
+			{
+				if (!psActorFlags.test(AF_3D_PDA))
+					pda->Enable(true);
+				else
+					pda->HideDialog();
+			}
+
+			g_player_hud->reset_thumb(true);
+			pda->ResetJoystick(true);
+		}
+		SetPending(FALSE);
+	}
+	break;
+	case eIdle:
+	{
+		PlayAnimIdle();
+
+		if (m_joystick_bone && joystick == BI_NONE && HudItemData())
+			joystick = HudItemData()->m_model->LL_BoneID(m_joystick_bone);
+
+		if (joystick != BI_NONE && HudItemData())
+		{
+			CBoneInstance* bi = &HudItemData()->m_model->LL_GetBoneInstance(joystick);
+			if (bi)
+				bi->set_callback(bctCustom, JoystickCallback, this);
+		}
+	}
+	break;
+	case eEmptyBattery:
+	{
+		SetPending(TRUE);
+		m_sounds.PlaySound("sndEmptyBattery", Position(), H_Root(), !!GetHUDmode(), false);
+		PlayHUDMotion("anm_empty", TRUE, this, GetState());
+		m_bNoticedEmptyBattery = true;
+	}
+	}
+}
+
+void CPda::OnAnimationEnd(u32 state)
+{
+	inherited::OnAnimationEnd(state);
+	switch (state)
+	{
+	case eShowing:
+	{
+		if (!hasEnoughBatteryPower() && !m_bNoticedEmptyBattery)
+		{
+			SwitchState(eEmptyBattery);
+			return;
+		}
+		SetPending(FALSE);
+		SwitchState(eIdle);
+	}
+	break;
+	case eHiding:
+	{
+		SetPending(FALSE);
+		SwitchState(eHidden);
+		g_player_hud->detach_item(this);
+	}
+	break;
+	case eEmptyBattery:
+	{
+		SetPending(FALSE);
+		SwitchState(eIdle);
+	}
+	break;
+	}
+}
+
+void CPda::JoystickCallback(CBoneInstance* B)
+{
+	CPda* Pda = static_cast<CPda*>(B->callback_param());
+	CUIPdaWnd* pda = &CurrentGameUI()->GetPdaMenu();
+
+	static float fAvgTimeDelta = Device.fTimeDelta;
+	fAvgTimeDelta = _inertion(fAvgTimeDelta, Device.fTimeDelta, 0.8f);
+
+	Fvector& target = pda->target_joystickrot;
+	Fvector& current = pda->joystickrot;
+	float& target_press = pda->target_buttonpress;
+	float& press = pda->buttonpress;
+
+	if (!target.similar(current, .0001f))
+	{
+		Fvector diff;
+		diff = target;
+		diff.sub(current);
+		diff.mul(fAvgTimeDelta / .1f);
+		current.add(diff);
+	}
+	else
+		current.set(target);
+
+	if (!fsimilar(target_press, press, .0001f))
+	{
+		float prev_press = press;
+
+		float diff = target_press;
+		diff -= press;
+		diff *= (fAvgTimeDelta / .1f);
+		press += diff;
+
+		if (prev_press == 0.f && press < 0.f)
+			Pda->m_sounds.PlaySound("sndButtonPress", B->mTransform.c, Pda->H_Root(), !!Pda->GetHUDmode());
+		else if (prev_press < -.001f && press >= -.001f)
+			Pda->m_sounds.PlaySound("sndButtonRelease", B->mTransform.c, Pda->H_Root(), !!Pda->GetHUDmode());
+	}
+	else
+		press = target_press;
+
+	Fmatrix rotation;
+	rotation.identity();
+	rotation.rotateX(current.x);
+
+	Fmatrix rotation_y;
+	rotation_y.identity();
+	rotation_y.rotateY(current.y);
+	rotation.mulA_43(rotation_y);
+
+	rotation_y.identity();
+	rotation_y.rotateZ(current.z);
+	rotation.mulA_43(rotation_y);
+
+	rotation.translate_over(0.f, press, 0.f);
+
+	B->mTransform.mulB_43(rotation);
+}
+
+extern bool IsMainMenuActive();
+
+void CPda::UpdateCL()
+{
+	inherited::UpdateCL();
+
+	if (!ParentIsActor() || Actor()->inventory().ActiveItem() != this)
+		return;
+
+	// For battery icon
+	float condition = GetCondition();
+	CUIPdaWnd* pda = &CurrentGameUI()->GetPdaMenu();
+	pda->m_power = condition;
+
+	if (!psActorFlags.test(AF_3D_PDA))
+	{
+		if (GetState() != eHidden)
+			Actor()->inventory().Activate(NO_ACTIVE_SLOT);
+		return;
+	}
+
+	u32 state = GetState();
+	bool enoughBatteryPower = hasEnoughBatteryPower();
+
+	if (pda->IsShown())
+	{
+		// Hide PDA UI on low condition (battery) or when the item is hidden.
+		if (!enoughBatteryPower || state == eHidden)
+		{
+			pda->HideDialog();
+			m_bZoomed = false;
+
+			if (state == eIdle)
+				SwitchState(eEmptyBattery);
+		}
+		else
+		{
+			// Force update PDA UI if it's disabled (no input) and check for deferred enable or zoom in.
+			if (!pda->IsEnabled())
+			{
+				pda->Update();
+				if (m_eDeferredEnable == eEnable || m_eDeferredEnable == eEnableZoomed)
+				{
+					if (Actor()->cam_freelook == eflDisabled && g_player_hud->script_anim_part == u8(-1))
+					{
+						pda->Enable(true);
+						m_bZoomed = m_eDeferredEnable == eEnableZoomed;
+						m_eDeferredEnable = eDefault;
+					}
+				}
+			}
+
+			// Turn on "power saving" on low battery charge (dims the screen).
+			if (IsUsingCondition() && condition < m_fPowerSavingCharge)
+			{
+				if (!m_bPowerSaving)
+				{
+					luabind::functor<void> funct;
+					if (ai().script_engine().functor("pda.on_low_battery", funct))
+						funct();
+					m_bPowerSaving = true;
+				}
+			}
+
+			// Turn off "power saving" if battery has sufficient charge.
+			else if (m_bPowerSaving)
+				m_bPowerSaving = false;
+		}
+	}
+	else
+	{
+		// Show PDA UI if possible
+		if (!IsMainMenuActive() && state != eHiding && state != eHidden && enoughBatteryPower)
+		{
+			pda->ShowDialog(false); // Don't hide indicators
+			m_bNoticedEmptyBattery = false;
+			if (m_eDeferredEnable == eEnable) // Don't disable input if it was enabled before opening the Main Menu.
+				m_eDeferredEnable = eDefault;
+			else
+				pda->Enable(false);
+		}
+	}
+
+	if (GetState() != eHidden)
+	{
+		float& brightness = g_pGamePersistent->pda_shader_data.pda_displaybrightness;
+		float& display = g_pGamePersistent->pda_shader_data.pda_display_factor;
+
+		// Adjust screen brightness (smooth)
+		if (m_bPowerSaving)
+		{
+			if (brightness > m_fDisplayBrightnessPowerSaving)
+				brightness -= Device.fTimeDelta / .25f;
+		}
+		else
+			brightness = 1.f;
+
+		clamp(brightness, m_fDisplayBrightnessPowerSaving, 1.f);
+
+		// Screen "Glitch" factor
+		g_pGamePersistent->pda_shader_data.pda_psy_influence = m_psy_factor;
+
+		// Update Display Visibility (turn on/off)
+		if (target_screen_switch < Device.fTimeGlobal)
+		{
+			if (!enoughBatteryPower || state == eHiding)
+				// Change screen transparency (towards 0 = not visible).
+				display -= Device.fTimeDelta / .25f;
+			else
+				// Change screen transparency (towards 1 = fully visible).
+				display += Device.fTimeDelta / .75f;
+		}
+
+		clamp(display, 0.f, 1.f);
+	}
 }
@@ -74,2 +394,461 @@
 
+void CPda::OnMovementChanged(ACTOR_DEFS::EMoveCommand cmd)
+{
+	inherited::OnMovementChanged(cmd);
+
+	if (cmd == mcSprint)
+	{
+		CEntity::SEntityState st;
+		Actor()->g_State(st);
+
+		CUIPdaWnd* pda = &CurrentGameUI()->GetPdaMenu();
+		if (pda->IsShown() && pda->IsEnabled() && st.bSprint)
+		{
+			m_bZoomed = false;
+			pda->Enable(false);
+		}
+	}
+}
+
+bool CPda::Action(u16 cmd, u32 flags)
+{
+	CUIPdaWnd* pda = &CurrentGameUI()->GetPdaMenu();
+
+	switch (cmd)
+	{
+		case kQUIT:
+		case kACTIVE_JOBS:
+		{
+			if (flags & CMD_START)
+			{
+				if (pda->IsShown() || cmd != kQUIT)
+				{
+					if (GetState() != eHidden && GetState() != eHiding)
+					{
+						Actor()->inventory().Activate(NO_ACTIVE_SLOT);
+						pda->HideDialog();
+						return true;
+					}
+				}
+			}
+		}
+		break;
+
+		case kWPN_RELOAD:
+		if (flags & CMD_START && !IsPending())
+		{
+			m_bZoomed = !m_bZoomed;
+			if (m_bZoomed)
+			{
+				pda->Enable(true);
+				Actor()->StopSprint();
+			}
+			else if (psActorFlags.test(AF_SIMPLE_PDA))
+				pda->Enable(false);
+			return true;
+		}
+		break;
+
+		case kWPN_ZOOM:
+		case kWPN_FIRE:
+		{
+			if (flags & CMD_START && !IsPending())
+			{
+				pda->Enable(true);
+				if (psActorFlags.test(AF_SIMPLE_PDA)) m_bZoomed = true;
+				Actor()->StopSprint();
+				return true;
+			}
+		}
+		break;
+
+		case kWPN_FUNC:
+		{
+			if (flags & CMD_START && !IsPending() && !psActorFlags.test(AF_SIMPLE_PDA))
+			{
+				pda->Enable(!pda->IsEnabled());
+				if (m_bZoomed && !pda->IsEnabled()) m_bZoomed = false;
+				if (pda->IsEnabled()) Actor()->StopSprint();
+				return true;
+			}
+		}
+		break;
+
+		case kINVENTORY:
+		{
+			if (flags & CMD_START && pda->IsEnabled())
+			{
+				if (GetState() != eHidden && GetState() != eHiding)
+				{
+					Actor()->inventory().Activate(NO_ACTIVE_SLOT);
+					pda->HideDialog();
+				}
+
+				CurrentGameUI()->ShowActorMenu();
+				return true;
+			}
+		}
+	}
+
+	return inherited::Action(cmd, flags);
+}
+
+void CPda::OnMoveToRuck(const SInvItemPlace& prev)
+{
+	inherited::OnMoveToRuck(prev);
+
+	if (!ParentIsActor())
+		return;
+
+	if (prev.type == eItemPlaceSlot)
+	{
+		SwitchState(eHidden);
+		if (joystick != BI_NONE && HudItemData())
+			HudItemData()->m_model->LL_GetBoneInstance(joystick).reset_callback();
+		g_player_hud->detach_item(this);
+	}
+	CUIPdaWnd* pda = &CurrentGameUI()->GetPdaMenu();
+	if (pda->IsShown()) pda->HideDialog();
+	StopCurrentAnimWithoutCallback();
+	SetPending(FALSE);
+}
+
+void CPda::UpdateHudAdditional(Fmatrix& trans)
+{
+	CActor* pActor = smart_cast<CActor*>(H_Parent());
+	if (!pActor)
+		return;
+
+	attachable_hud_item* hi = HudItemData();
+	R_ASSERT(hi);
+
+	if (pActor->cam_freelook == eflEnabled || pActor->cam_freelook == eflEnabling || g_player_hud->script_anim_part != u8(-1))
+	{
+		CUIPdaWnd* pda = &CurrentGameUI()->GetPdaMenu();
+
+		if (pda->IsEnabled())
+		{
+			if (m_bZoomed)
+			{
+				m_bZoomed = false;
+				m_eDeferredEnable = eEnableZoomed;
+			}
+			else
+			{
+				m_eDeferredEnable = eEnable;
+			}
+
+			pda->Enable(false);
+		}
+	}
+
+	Fvector curr_offs, curr_rot;
+	curr_offs = g_player_hud->m_adjust_mode ? g_player_hud->m_adjust_offset[0][1] : hi->m_measures.m_hands_offset[0][1];
+	curr_rot = g_player_hud->m_adjust_mode ? g_player_hud->m_adjust_offset[1][1] : hi->m_measures.m_hands_offset[1][1];
+
+	curr_offs.mul(m_fZoomfactor);
+	curr_rot.mul(m_fZoomfactor);
+
+	Fmatrix hud_rotation;
+	hud_rotation.identity();
+	hud_rotation.rotateX(curr_rot.x);
+
+	Fmatrix hud_rotation_y;
+	hud_rotation_y.identity();
+	hud_rotation_y.rotateY(curr_rot.y);
+	hud_rotation.mulA_43(hud_rotation_y);
+
+	hud_rotation_y.identity();
+	hud_rotation_y.rotateZ(curr_rot.z);
+	hud_rotation.mulA_43(hud_rotation_y);
+
+	hud_rotation.translate_over(curr_offs);
+	trans.mulB_43(hud_rotation);
+
+	if (m_bZoomed)
+		m_fZoomfactor += Device.fTimeDelta / .25f;
+	else
+		m_fZoomfactor -= Device.fTimeDelta / .25f;
+
+	clamp(m_fZoomfactor, 0.f, 1.f);
+
+	if (!g_player_hud->inertion_allowed())
+		return;
+
+	static float fAvgTimeDelta = Device.fTimeDelta;
+	fAvgTimeDelta = _inertion(fAvgTimeDelta, Device.fTimeDelta, 0.8f);
+
+	u8 idx = m_bZoomed ? 1 : 0;
+
+	float fYMag = pActor->fFPCamYawMagnitude;
+	float fPMag = pActor->fFPCamPitchMagnitude;
+
+	float fStrafeMaxTime = hi->m_measures.m_strafe_offset[2][idx].y;
+	// ÐÐ°ÐºÑ. Ð²ÑÐµÐ¼Ñ Ð² ÑÐµÐºÑÐ½Ð´Ð°Ñ, Ð·Ð° ÐºÐ¾ÑÐ¾ÑÐ¾Ðµ Ð¼Ñ Ð½Ð°ÐºÐ»Ð¾Ð½Ð¸Ð¼ÑÑ Ð¸Ð· ÑÐµÐ½ÑÑÐ°Ð»ÑÐ½Ð¾Ð³Ð¾ Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ
+	if (fStrafeMaxTime <= EPS)
+		fStrafeMaxTime = 0.01f;
+
+	float fStepPerUpd = fAvgTimeDelta / fStrafeMaxTime; // ÐÐµÐ»Ð¸ÑÐ¸Ð½Ð° Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ ÑÐ°ÐºÑÐ¾ÑÐ° Ð¿Ð¾Ð²Ð¾ÑÐ¾ÑÐ°
+
+														// ÐÐ¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ Ð±Ð¾ÐºÐ¾Ð²Ð¾Ð¹ Ð½Ð°ÐºÐ»Ð¾Ð½ Ð¾Ñ Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ñ ÐºÐ°Ð¼ÐµÑÑ
+	float fCamReturnSpeedMod = 1.5f;
+	// ÐÐ¾ÑÐºÐ¾Ð»ÑÐºÐ¾ ÑÑÐºÐ¾ÑÑÐµÐ¼ Ð½Ð¾ÑÐ¼Ð°Ð»Ð¸Ð·Ð°ÑÐ¸Ñ Ð½Ð°ÐºÐ»Ð¾Ð½Ð°, Ð¿Ð¾Ð»ÑÑÐµÐ½Ð½Ð¾Ð³Ð¾ Ð¾Ñ Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ñ ÐºÐ°Ð¼ÐµÑÑ (ÑÐ¾Ð»ÑÐºÐ¾ Ð¾Ñ Ð±ÐµÐ´ÑÐ°)
+
+	// ÐÑÑÑÐ¸ÑÑÐ²Ð°ÐµÐ¼ Ð¼Ð¸Ð½Ð¸Ð¼Ð°Ð»ÑÐ½ÑÑ ÑÐºÐ¾ÑÐ¾ÑÑÑ Ð¿Ð¾Ð²Ð¾ÑÐ¾ÑÐ° ÐºÐ°Ð¼ÐµÑÑ Ð´Ð»Ñ Ð½Ð°ÑÐ°Ð»Ð° Ð¸Ð½ÐµÑÑÐ¸Ð¸
+	float fStrafeMinAngle = _lerp(
+		hi->m_measures.m_strafe_offset[3][0].y,
+		hi->m_measures.m_strafe_offset[3][1].y,
+		m_fZoomfactor);
+
+	// ÐÑÑÑÐ¸ÑÑÐ²Ð°ÐµÐ¼ Ð¼ÐºÑÐ¸Ð¼Ð°Ð»ÑÐ½ÑÐ¹ Ð½Ð°ÐºÐ»Ð¾Ð½ Ð¾Ñ Ð¿Ð¾Ð²Ð¾ÑÐ¾ÑÐ° ÐºÐ°Ð¼ÐµÑÑ
+	float fCamLimitBlend = _lerp(
+		hi->m_measures.m_strafe_offset[3][0].x,
+		hi->m_measures.m_strafe_offset[3][1].x,
+		m_fZoomfactor);
+
+	// Ð¡ÑÐ¸ÑÐ°ÐµÐ¼ ÑÑÑÐµÐ¹Ñ Ð¾Ñ Ð¿Ð¾Ð²Ð¾ÑÐ¾ÑÐ° ÐºÐ°Ð¼ÐµÑÑ
+	if (abs(fYMag) > (m_fLR_CameraFactor == 0.0f ? fStrafeMinAngle : 0.0f))
+	{
+		//--> ÐÐ°Ð¼ÐµÑÐ° ÐºÑÑÑÐ¸ÑÑÑ Ð¿Ð¾ Ð¾ÑÐ¸ Y
+		m_fLR_CameraFactor -= (fYMag * fAvgTimeDelta * 0.75f);
+		clamp(m_fLR_CameraFactor, -fCamLimitBlend, fCamLimitBlend);
+	}
+	else
+	{
+		//--> ÐÐ°Ð¼ÐµÑÐ° Ð½Ðµ Ð¿Ð¾Ð²Ð¾ÑÐ°ÑÐ¸Ð²Ð°ÐµÑÑÑ - ÑÐ±Ð¸ÑÐ°ÐµÐ¼ Ð½Ð°ÐºÐ»Ð¾Ð½
+		if (m_fLR_CameraFactor < 0.0f)
+		{
+			m_fLR_CameraFactor += fStepPerUpd * (m_bZoomed ? 1.0f : fCamReturnSpeedMod);
+			clamp(m_fLR_CameraFactor, -fCamLimitBlend, 0.0f);
+		}
+		else
+		{
+			m_fLR_CameraFactor -= fStepPerUpd * (m_bZoomed ? 1.0f : fCamReturnSpeedMod);
+			clamp(m_fLR_CameraFactor, 0.0f, fCamLimitBlend);
+		}
+	}
+
+	// ÐÐ¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ Ð±Ð¾ÐºÐ¾Ð²Ð¾Ð¹ Ð½Ð°ÐºÐ»Ð¾Ð½ Ð¾Ñ ÑÐ¾Ð´ÑÐ±Ñ Ð²Ð±Ð¾Ðº
+	float fChangeDirSpeedMod = 3;
+	// ÐÐ¾ÑÐºÐ¾Ð»ÑÐºÐ¾ Ð±ÑÑÑÑÐ¾ Ð¼ÐµÐ½ÑÐµÐ¼ Ð½Ð°Ð¿ÑÐ°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð½Ð°Ð¿ÑÐ°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð½Ð°ÐºÐ»Ð¾Ð½Ð°, ÐµÑÐ»Ð¸ Ð¾Ð½Ð¾ Ð² Ð´ÑÑÐ³ÑÑ ÑÑÐ¾ÑÐ¾Ð½Ñ Ð¾Ñ ÑÐµÐºÑÑÐµÐ³Ð¾
+	u32 iMovingState = pActor->MovingState();
+	if ((iMovingState & mcLStrafe) != 0)
+	{
+		// ÐÐ²Ð¸Ð¶ÐµÐ¼ÑÑ Ð²Ð»ÐµÐ²Ð¾
+		float fVal = (m_fLR_MovingFactor > 0.f ? fStepPerUpd * fChangeDirSpeedMod : fStepPerUpd);
+		m_fLR_MovingFactor -= fVal;
+	}
+	else if ((iMovingState & mcRStrafe) != 0)
+	{
+		// ÐÐ²Ð¸Ð¶ÐµÐ¼ÑÑ Ð²Ð¿ÑÐ°Ð²Ð¾
+		float fVal = (m_fLR_MovingFactor < 0.f ? fStepPerUpd * fChangeDirSpeedMod : fStepPerUpd);
+		m_fLR_MovingFactor += fVal;
+	}
+	else
+	{
+		// ÐÐ²Ð¸Ð³Ð°ÐµÐ¼ÑÑ Ð² Ð»ÑÐ±Ð¾Ð¼ Ð´ÑÑÐ³Ð¾Ð¼ Ð½Ð°Ð¿ÑÐ°Ð²Ð»ÐµÐ½Ð¸Ð¸ - Ð¿Ð»Ð°Ð²Ð½Ð¾ ÑÐ±Ð¸ÑÐ°ÐµÐ¼ Ð½Ð°ÐºÐ»Ð¾Ð½
+		if (m_fLR_MovingFactor < 0.0f)
+		{
+			m_fLR_MovingFactor += fStepPerUpd;
+			clamp(m_fLR_MovingFactor, -1.0f, 0.0f);
+		}
+		else
+		{
+			m_fLR_MovingFactor -= fStepPerUpd;
+			clamp(m_fLR_MovingFactor, 0.0f, 1.0f);
+		}
+	}
+	clamp(m_fLR_MovingFactor, -1.0f, 1.0f); // Ð¤Ð°ÐºÑÐ¾Ñ Ð±Ð¾ÐºÐ¾Ð²Ð¾Ð¹ ÑÐ¾Ð´ÑÐ±Ñ Ð½Ðµ Ð´Ð¾Ð»Ð¶ÐµÐ½ Ð¿ÑÐµÐ²ÑÑÐ°ÑÑ ÑÑÐ¸ Ð»Ð¸Ð¼Ð¸ÑÑ
+
+											// ÐÑÑÐ¸ÑÐ»ÑÐµÐ¼ Ð¸ Ð½Ð¾ÑÐ¼Ð°Ð»Ð¸Ð·Ð¸ÑÑÐµÐ¼ Ð¸ÑÐ¾Ð³Ð¾Ð²ÑÐ¹ ÑÐ°ÐºÑÐ¾Ñ Ð½Ð°ÐºÐ»Ð¾Ð½Ð°
+	float fLR_Factor = m_fLR_MovingFactor;
+
+	// No cam strafe inertia while in freelook mode
+	if (pActor->cam_freelook == eflDisabled)
+		fLR_Factor += m_fLR_CameraFactor;
+
+	clamp(fLR_Factor, -1.0f, 1.0f); // Ð¤Ð°ÐºÑÐ¾Ñ Ð±Ð¾ÐºÐ¾Ð²Ð¾Ð¹ ÑÐ¾Ð´ÑÐ±Ñ Ð½Ðµ Ð´Ð¾Ð»Ð¶ÐµÐ½ Ð¿ÑÐµÐ²ÑÑÐ°ÑÑ ÑÑÐ¸ Ð»Ð¸Ð¼Ð¸ÑÑ
+
+									// ÐÑÐ¾Ð¸Ð·Ð²Ð¾Ð´Ð¸Ð¼ Ð½Ð°ÐºÐ»Ð¾Ð½ ÑÑÐ²Ð¾Ð»Ð° Ð´Ð»Ñ Ð½Ð¾ÑÐ¼Ð°Ð»ÑÐ½Ð¾Ð³Ð¾ ÑÐµÐ¶Ð¸Ð¼Ð° Ð¸ Ð°Ð¸Ð¼Ð°
+	for (int _idx = 0; _idx <= 1; _idx++) //<-- ÐÐ»Ñ Ð¿Ð»Ð°Ð²Ð½Ð¾Ð³Ð¾ Ð¿ÐµÑÐµÑÐ¾Ð´Ð°
+	{
+		bool bEnabled = (hi->m_measures.m_strafe_offset[2][_idx].x != 0.0f);
+		if (!bEnabled)
+			continue;
+
+		Fvector curr_offs, curr_rot;
+
+		// Ð¡Ð¼ÐµÑÐµÐ½Ð¸Ðµ Ð¿Ð¾Ð·Ð¸ÑÐ¸Ð¸ ÑÑÐ´Ð° Ð² ÑÑÑÐµÐ¹ÑÐµ
+		curr_offs = hi->m_measures.m_strafe_offset[0][_idx]; // pos
+		curr_offs.mul(fLR_Factor); // Ð£Ð¼Ð½Ð¾Ð¶Ð°ÐµÐ¼ Ð½Ð° ÑÐ°ÐºÑÐ¾Ñ ÑÑÑÐµÐ¹ÑÐ°
+
+								   // ÐÐ¾Ð²Ð¾ÑÐ¾Ñ ÑÑÐ´Ð° Ð² ÑÑÑÐµÐ¹ÑÐµ
+		curr_rot = hi->m_measures.m_strafe_offset[1][_idx]; // rot
+		curr_rot.mul(-PI / 180.f); // ÐÑÐµÐ¾Ð±ÑÐ°Ð·ÑÐµÐ¼ ÑÐ³Ð»Ñ Ð² ÑÐ°Ð´Ð¸Ð°Ð½Ñ
+		curr_rot.mul(fLR_Factor); // Ð£Ð¼Ð½Ð¾Ð¶Ð°ÐµÐ¼ Ð½Ð° ÑÐ°ÐºÑÐ¾Ñ ÑÑÑÐµÐ¹ÑÐ°
+
+								  // ÐÑÐ³ÐºÐ¸Ð¹ Ð¿ÐµÑÐµÑÐ¾Ð´ Ð¼ÐµÐ¶Ð´Ñ Ð±ÐµÐ´ÑÐ¾Ð¼ \ Ð¿ÑÐ¸ÑÐµÐ»Ð¾Ð¼
+		if (_idx == 0)
+		{
+			// ÐÑ Ð±ÐµÐ´ÑÐ°
+			curr_offs.mul(1.f - m_fZoomfactor);
+			curr_rot.mul(1.f - m_fZoomfactor);
+		}
+		else
+		{
+			// ÐÐ¾ Ð²ÑÐµÐ¼Ñ Ð°Ð¸Ð¼Ð°
+			curr_offs.mul(m_fZoomfactor);
+			curr_rot.mul(m_fZoomfactor);
+		}
+
+		Fmatrix hud_rotation;
+		Fmatrix hud_rotation_y;
+
+		hud_rotation.identity();
+		hud_rotation.rotateX(curr_rot.x);
+
+		hud_rotation_y.identity();
+		hud_rotation_y.rotateY(curr_rot.y);
+		hud_rotation.mulA_43(hud_rotation_y);
+
+		hud_rotation_y.identity();
+		hud_rotation_y.rotateZ(curr_rot.z);
+		hud_rotation.mulA_43(hud_rotation_y);
+
+		hud_rotation.translate_over(curr_offs);
+		trans.mulB_43(hud_rotation);
+	}
+
+	//============= ÐÐ½ÐµÑÑÐ¸Ñ Ð¾ÑÑÐ¶Ð¸Ñ =============//
+	// ÐÐ°ÑÐ°Ð¼ÐµÑÑÑ Ð¸Ð½ÐµÑÑÐ¸Ð¸
+	float fInertiaSpeedMod = _lerp(
+		hi->m_measures.m_inertion_params.m_tendto_speed,
+		hi->m_measures.m_inertion_params.m_tendto_speed_aim,
+		m_fZoomfactor);
+
+	float fInertiaReturnSpeedMod = _lerp(
+		hi->m_measures.m_inertion_params.m_tendto_ret_speed,
+		hi->m_measures.m_inertion_params.m_tendto_ret_speed_aim,
+		m_fZoomfactor);
+
+	float fInertiaMinAngle = _lerp(
+		hi->m_measures.m_inertion_params.m_min_angle,
+		hi->m_measures.m_inertion_params.m_min_angle_aim,
+		m_fZoomfactor);
+
+	Fvector4 vIOffsets; // x = L, y = R, z = U, w = D
+	vIOffsets.x = _lerp(
+		hi->m_measures.m_inertion_params.m_offset_LRUD.x,
+		hi->m_measures.m_inertion_params.m_offset_LRUD_aim.x,
+		m_fZoomfactor);
+	vIOffsets.y = _lerp(
+		hi->m_measures.m_inertion_params.m_offset_LRUD.y,
+		hi->m_measures.m_inertion_params.m_offset_LRUD_aim.y,
+		m_fZoomfactor);
+	vIOffsets.z = _lerp(
+		hi->m_measures.m_inertion_params.m_offset_LRUD.z,
+		hi->m_measures.m_inertion_params.m_offset_LRUD_aim.z,
+		m_fZoomfactor);
+	vIOffsets.w = _lerp(
+		hi->m_measures.m_inertion_params.m_offset_LRUD.w,
+		hi->m_measures.m_inertion_params.m_offset_LRUD_aim.w,
+		m_fZoomfactor);
+
+	// ÐÑÑÑÐ¸ÑÑÐ²Ð°ÐµÐ¼ Ð¸Ð½ÐµÑÑÐ¸Ñ Ð¸Ð· Ð¿Ð¾Ð²Ð¾ÑÐ¾ÑÐ¾Ð² ÐºÐ°Ð¼ÐµÑÑ
+	bool bIsInertionPresent = m_fLR_InertiaFactor != 0.0f || m_fUD_InertiaFactor != 0.0f;
+	if (abs(fYMag) > fInertiaMinAngle || bIsInertionPresent)
+	{
+		float fSpeed = fInertiaSpeedMod;
+		if (fYMag > 0.0f && m_fLR_InertiaFactor > 0.0f ||
+			fYMag < 0.0f && m_fLR_InertiaFactor < 0.0f)
+		{
+			fSpeed *= 2.f; //--> Ð£ÑÐºÐ¾ÑÑÐµÐ¼ Ð¸Ð½ÐµÑÑÐ¸Ñ Ð¿ÑÐ¸ Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ð¸ Ð² Ð¿ÑÐ¾ÑÐ¸Ð²Ð¾Ð¿Ð¾Ð»Ð¾Ð¶Ð½ÑÑ ÑÑÐ¾ÑÐ¾Ð½Ñ
+		}
+
+		m_fLR_InertiaFactor -= (fYMag * fAvgTimeDelta * fSpeed); // ÐÐ¾ÑÐ¸Ð·Ð¾Ð½ÑÐ°Ð»Ñ (Ð¼.Ð±. > |1.0|)
+	}
+
+	if (abs(fPMag) > fInertiaMinAngle || bIsInertionPresent)
+	{
+		float fSpeed = fInertiaSpeedMod;
+		if (fPMag > 0.0f && m_fUD_InertiaFactor > 0.0f ||
+			fPMag < 0.0f && m_fUD_InertiaFactor < 0.0f)
+		{
+			fSpeed *= 2.f; //--> Ð£ÑÐºÐ¾ÑÑÐµÐ¼ Ð¸Ð½ÐµÑÑÐ¸Ñ Ð¿ÑÐ¸ Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ð¸ Ð² Ð¿ÑÐ¾ÑÐ¸Ð²Ð¾Ð¿Ð¾Ð»Ð¾Ð¶Ð½ÑÑ ÑÑÐ¾ÑÐ¾Ð½Ñ
+		}
+
+		m_fUD_InertiaFactor -= (fPMag * fAvgTimeDelta * fSpeed); // ÐÐµÑÑÐ¸ÐºÐ°Ð»Ñ (Ð¼.Ð±. > |1.0|)
+	}
+
+	clamp(m_fLR_InertiaFactor, -1.0f, 1.0f);
+	clamp(m_fUD_InertiaFactor, -1.0f, 1.0f);
+
+	// ÐÐ»Ð°Ð²Ð½Ð¾Ðµ Ð·Ð°ÑÑÑÐ°Ð½Ð¸Ðµ Ð¸Ð½ÐµÑÑÐ¸Ð¸ (Ð¾ÑÐ½Ð¾Ð²Ð½Ð¾Ðµ, Ð½Ð¾ Ð±ÐµÐ· Ð»Ð¸Ð½ÐµÐ¹Ð½Ð¾Ð¹ Ð½Ð¸ÐºÐ¾Ð³Ð´Ð° Ð½Ðµ Ð¾Ð¿ÑÑÑÐ¸Ñ Ð¸Ð½ÐµÑÑÐ¸Ñ Ð´Ð¾ Ð¿Ð¾Ð»Ð½Ð¾Ð³Ð¾ 0.0f)
+	m_fLR_InertiaFactor *= clampr(1.f - fAvgTimeDelta * fInertiaReturnSpeedMod, 0.0f, 1.0f);
+	m_fUD_InertiaFactor *= clampr(1.f - fAvgTimeDelta * fInertiaReturnSpeedMod, 0.0f, 1.0f);
+
+	// ÐÐ¸Ð½Ð¸Ð¼Ð°Ð»ÑÐ½Ð¾Ðµ Ð»Ð¸Ð½ÐµÐ¹Ð½Ð¾Ðµ Ð·Ð°ÑÑÑÐ°Ð½Ð¸Ðµ Ð¸Ð½ÐµÑÑÐ¸Ð¸ Ð¿ÑÐ¸ Ð¿Ð¾ÐºÐ¾Ðµ (Ð³Ð¾ÑÐ¸Ð·Ð¾Ð½ÑÐ°Ð»Ñ)
+	if (fYMag == 0.0f)
+	{
+		float fRetSpeedMod = (fYMag == 0.0f ? 1.0f : 0.75f) * (fInertiaReturnSpeedMod * 0.075f);
+		if (m_fLR_InertiaFactor < 0.0f)
+		{
+			m_fLR_InertiaFactor += fAvgTimeDelta * fRetSpeedMod;
+			clamp(m_fLR_InertiaFactor, -1.0f, 0.0f);
+		}
+		else
+		{
+			m_fLR_InertiaFactor -= fAvgTimeDelta * fRetSpeedMod;
+			clamp(m_fLR_InertiaFactor, 0.0f, 1.0f);
+		}
+	}
+
+	// ÐÐ¸Ð½Ð¸Ð¼Ð°Ð»ÑÐ½Ð¾Ðµ Ð»Ð¸Ð½ÐµÐ¹Ð½Ð¾Ðµ Ð·Ð°ÑÑÑÐ°Ð½Ð¸Ðµ Ð¸Ð½ÐµÑÑÐ¸Ð¸ Ð¿ÑÐ¸ Ð¿Ð¾ÐºÐ¾Ðµ (Ð²ÐµÑÑÐ¸ÐºÐ°Ð»Ñ)
+	if (fPMag == 0.0f)
+	{
+		float fRetSpeedMod = (fPMag == 0.0f ? 1.0f : 0.75f) * (fInertiaReturnSpeedMod * 0.075f);
+		if (m_fUD_InertiaFactor < 0.0f)
+		{
+			m_fUD_InertiaFactor += fAvgTimeDelta * fRetSpeedMod;
+			clamp(m_fUD_InertiaFactor, -1.0f, 0.0f);
+		}
+		else
+		{
+			m_fUD_InertiaFactor -= fAvgTimeDelta * fRetSpeedMod;
+			clamp(m_fUD_InertiaFactor, 0.0f, 1.0f);
+		}
+	}
+
+	// ÐÑÐ¸Ð¼ÐµÐ½ÑÐµÐ¼ Ð¸Ð½ÐµÑÑÐ¸Ñ Ðº ÑÑÐ´Ñ
+	float fLR_lim = (m_fLR_InertiaFactor < 0.0f ? vIOffsets.x : vIOffsets.y);
+	float fUD_lim = (m_fUD_InertiaFactor < 0.0f ? vIOffsets.z : vIOffsets.w);
+
+	curr_offs = { fLR_lim * -1.f * m_fLR_InertiaFactor, fUD_lim * m_fUD_InertiaFactor, 0.0f };
+
+	hud_rotation.identity();
+	hud_rotation.translate_over(curr_offs);
+	trans.mulB_43(hud_rotation);
+}
+
+void CPda::UpdateXForm()
+{
+	CInventoryItem::UpdateXForm();
+}
+
+void CPda::OnActiveItem()
+{
+	if (!ParentIsActor())
+		return;
+
+	SwitchState(eShowing);
+}
+
+void CPda::OnHiddenItem()
+{
+	if (!ParentIsActor())
+		return;
+
+	SwitchState(eHiding);
+}
+
 void CPda::UpdateActiveContacts	()
@@ -132,6 +915,8 @@
 
-	//âêëþ÷èòü PDA òîëüêî åñëè îíî íàõîäèòñÿ ó ïåðâîãî âëàäåëüöà
-	if(H_Parent()->ID() == m_idOriginalOwner){
+	//Switch on PDA only in case of a new product with auxiliary control
+	if (H_Parent()->ID() == m_idOriginalOwner)
+	{
 		TurnOn					();
-		if(m_sFullName.empty()){
+		if (m_sFullName.empty())
+		{
 			m_sFullName.assign( NameItem() );
@@ -147,7 +932,27 @@
 	inherited::OnH_B_Independent(just_before_destroy);
-	
-	//âûêëþ÷èòü
 	TurnOff();
-}
 
+	if (!ParentIsActor() || !g_player_hud->attached_item(0))
+		return;
+
+	if (g_player_hud->attached_item(0)->m_parent_hud_item != this)
+		return;
+
+	m_sounds.PlaySound(hasEnoughBatteryPower() ? "sndHide" : "sndHideEmpty", Position(), H_Root(), !!GetHUDmode(), false);
+
+	SwitchState(eHidden);
+	SetPending(FALSE);
+	m_bZoomed = false;
+	m_fZoomfactor = 0.f;
+
+	CUIPdaWnd* pda = &CurrentGameUI()->GetPdaMenu();
+	if (pda->IsShown()) pda->HideDialog();
+	g_player_hud->reset_thumb(true);
+	pda->ResetJoystick(true);
+
+	if (joystick != BI_NONE && HudItemData())
+		HudItemData()->m_model->LL_GetBoneInstance(joystick).reset_callback();
+
+	g_player_hud->detach_item(this);
+}
 
@@ -193,21 +996,2 @@
 }
-/* remove must
-LPCSTR		CPda::Name				()
-{
-	if( !m_SpecificChracterOwner.size() )
-		return inherited::Name();
-
-	if(m_sFullName.empty())
-	{
-		m_sFullName.assign(inherited::Name());
-		
-		CSpecificCharacter spec_char;
-		spec_char.Load(m_SpecificChracterOwner);
-		m_sFullName += " ";
-		m_sFullName += xr_string(spec_char.Name());
-	}
-	
-	return m_sFullName.c_str();
-}
-*/
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/PDA.h xray-monolith/src/xrGame/PDA.h
--- coc-1.4-xray-64/src/xrGame/PDA.h	2023-10-20 20:54:50.650327200 +0100
+++ xray-monolith/src/xrGame/PDA.h	2023-10-20 20:54:32.631038400 +0100
@@ -3,3 +3,3 @@
 #include "../xrEngine/feel_touch.h"
-#include "inventory_item_object.h"
+#include "hud_item_object.h"
 
@@ -16,6 +16,6 @@
 class CPda :
-	public CInventoryItemObject,
+	public CHudItemObject,
 	public Feel::Touch
 {
-	typedef	CInventoryItemObject inherited;
+	typedef CHudItemObject inherited;
 public:
@@ -33,2 +33,5 @@
 
+	virtual bool Action(u16 cmd, u32 flags);
+	virtual void OnMovementChanged(ACTOR_DEFS::EMoveCommand cmd);
+
 	virtual void 							feel_touch_new			(CObject* O);
@@ -61,4 +69,2 @@
 
-//*	virtual LPCSTR							Name					();
-
 protected:
@@ -76,2 +81,46 @@
 	shared_str								m_functor_str;
+	float m_fZoomfactor;
+	float m_fDisplayBrightnessPowerSaving;
+	float m_fPowerSavingCharge;
+	bool bButtonL;
+	bool bButtonR;
+	LPCSTR m_joystick_bone;
+	u16 joystick;
+	float m_screen_on_delay, m_screen_off_delay;
+	float target_screen_switch;
+	float m_fLR_CameraFactor;
+	float m_fLR_MovingFactor;
+	float m_fLR_InertiaFactor;
+	float m_fUD_InertiaFactor;
+	bool hasEnoughBatteryPower(){ return (!IsUsingCondition() || (IsUsingCondition() && GetCondition() > m_fLowestBatteryCharge)); }
+	static void _BCL JoystickCallback(CBoneInstance* B);
+	bool m_bNoticedEmptyBattery;
+public:
+	virtual void OnStateSwitch(u32 S, u32 oldState);
+	virtual void OnAnimationEnd(u32 state);
+	virtual void UpdateHudAdditional(Fmatrix& trans);
+	virtual void OnMoveToRuck(const SInvItemPlace& prev);
+	virtual void UpdateCL();
+	virtual void UpdateXForm();
+	virtual void OnActiveItem();
+	virtual void OnHiddenItem();
+
+	enum eDeferredEnableState
+	{
+		eDefault,
+		eDisable,
+		eEnable,
+		eEnableZoomed
+	};
+
+	enum ePDAState
+	{
+		eEmptyBattery = 7
+	};
+
+	bool m_bZoomed;
+	eDeferredEnableState m_eDeferredEnable;
+	bool m_bPowerSaving;
+	float m_psy_factor;
+	float m_thumb_rot[2];
 };
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/PHDestroyable.cpp xray-monolith/src/xrGame/PHDestroyable.cpp
--- coc-1.4-xray-64/src/xrGame/PHDestroyable.cpp	2023-10-20 20:54:50.658326500 +0100
+++ xray-monolith/src/xrGame/PHDestroyable.cpp	2023-10-20 20:54:32.633038200 +0100
@@ -341,3 +343,5 @@
 	VERIFY(m_depended_objects);
+#ifdef DEBUG
 	VERIFY(!physics_world()->Processing());
+#endif
 	m_depended_objects--;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/PHMovementControl.cpp xray-monolith/src/xrGame/PHMovementControl.cpp
--- coc-1.4-xray-64/src/xrGame/PHMovementControl.cpp	2023-10-20 20:54:50.669328400 +0100
+++ xray-monolith/src/xrGame/PHMovementControl.cpp	2023-10-20 20:54:32.635036400 +0100
@@ -522,4 +523,5 @@
 	float temp;
+	int i = 0;
 
-	for(int i=0;i<m_path_size-1;++i)
+	for (; i < m_path_size - 1; ++i)
 	{
@@ -614,4 +612,5 @@
 	dir.set		(0,0,1);
+	int i = m_start_index;
 
-	for(int i=m_start_index;i<m_path_size-1;++i)
+	for (; i < m_path_size - 1; ++i)
 	{
@@ -703,3 +699,5 @@
 	dir.set(0,0,1);
-	for(int i=m_start_index;i>1;--i)
+	int i = m_start_index;
+
+	for (; i > 1; --i)
 	{
@@ -1109,2 +1131,7 @@
 	VERIFY( m_character );
+
+	// Remove Grass bender if PHCharacter is not NULL
+	if (m_character->PhysicsRefObject() != NULL)
+		g_pGamePersistent->GrassBendersRemoveById(m_character->PhysicsRefObject()->ObjectID());
+
 	m_character->Destroy();
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/PhraseDialogDefs.h xray-monolith/src/xrGame/PhraseDialogDefs.h
--- coc-1.4-xray-64/src/xrGame/PhraseDialogDefs.h	2023-10-20 20:54:50.685327400 +0100
+++ xray-monolith/src/xrGame/PhraseDialogDefs.h	2023-10-20 20:54:32.642035600 +0100
@@ -9,3 +9,5 @@
 #include "PhraseDialog.h"
+#include "ui\UI3tButton.h"
 
 DEFINE_VECTOR	( shared_str, DIALOG_ID_VECTOR, DIALOG_ID_IT );
\ No newline at end of file
+DEFINE_VECTOR(CUI3tButton*, ButtonVector, ButtonVec_IT);
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/PhraseScript.cpp xray-monolith/src/xrGame/PhraseScript.cpp
--- coc-1.4-xray-64/src/xrGame/PhraseScript.cpp	2023-10-20 20:54:50.686326800 +0100
+++ xray-monolith/src/xrGame/PhraseScript.cpp	2023-10-20 20:54:32.644035600 +0100
@@ -54,4 +55,6 @@
 
-	for(i=0; i<m_DontHasInfo.size(); i++) {
-		if (Actor()->HasInfo(m_DontHasInfo[i])) {
+	for (u32 i = 0; i < m_DontHasInfo.size(); i++)
+	{
+		if (Actor()->HasInfo(m_DontHasInfo[i]))
+		{
 #ifdef DEBUG
@@ -74,3 +77,3 @@
 
-	for(i=0; i<m_DisableInfo.size(); ++i)
+	for (u32 i = 0; i < m_DisableInfo.size(); ++i)
 		Actor()->TransferInfo(m_DisableInfo[i], false);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/PHSoundPlayer.cpp xray-monolith/src/xrGame/PHSoundPlayer.cpp
--- coc-1.4-xray-64/src/xrGame/PHSoundPlayer.cpp	2023-10-20 20:54:50.678327100 +0100
+++ xray-monolith/src/xrGame/PHSoundPlayer.cpp	2023-10-20 20:54:32.639035600 +0100
@@ -18,9 +18,12 @@
 {
-
 	if(!m_sound._feedback())
 	{
-		Fvector vel;m_object->PHGetLinearVell(vel);
+		Fvector vel;
+		m_object->PHGetLinearVell(vel);
 		if(vel.square_magnitude()>0.01f)
 		{
-			CLONE_MTL_SOUND(m_sound, mtl_pair, CollideSounds);
+#ifdef DEBUG
+			CLONE_MTL_SOUND_CHECK(m_sound, mtl_pair, CollideSounds);
+#endif
+			CLONE_MTL_SOUND_DO(m_sound, mtl_pair, CollideSounds);
 			m_sound.play_at_pos(smart_cast<CPhysicsShellHolder*>(m_object),pos);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/PhysicObject.cpp xray-monolith/src/xrGame/PhysicObject.cpp
--- coc-1.4-xray-64/src/xrGame/PhysicObject.cpp	2023-10-20 20:54:50.687326500 +0100
+++ xray-monolith/src/xrGame/PhysicObject.cpp	2023-10-20 20:54:32.645035600 +0100
@@ -46,3 +47,5 @@
 	m_anim_blend			= 0;
-	inherited::net_Spawn	( DC );
+	if (!inherited::net_Spawn(DC)) return FALSE;
+
+	if (!Visual()) return FALSE;
 
@@ -220,4 +219,7 @@
 			R_ASSERT2					(*visual->startup_animation,"no startup animation");
-	
-			VERIFY2( (!!PKinematicsAnimated->LL_MotionID( visual->startup_animation.c_str() ) .valid() ) , ( make_string(" animation %s not faund ",visual->startup_animation.c_str() ) + dbg_object_base_dump_string( this )).c_str() );
+#ifdef DEBUG
+			VERIFY2((!!PKinematicsAnimated->LL_MotionID( visual->startup_animation.c_str() ) .valid() ),
+			        ( make_string(" animation %s not faund ",visual->startup_animation.c_str() ) +
+				        dbg_object_base_dump_string( this )).c_str());
+#endif
 			m_anim_blend				= m_anim_script_callback.play_cycle( PKinematicsAnimated, visual->startup_animation );
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/physics_element_scripted.cpp xray-monolith/src/xrGame/physics_element_scripted.cpp
--- coc-1.4-xray-64/src/xrGame/physics_element_scripted.cpp	2023-10-20 20:54:51.201326500 +0100
+++ xray-monolith/src/xrGame/physics_element_scripted.cpp	2023-10-20 20:54:33.131035700 +0100
@@ -18,3 +18,9 @@
 			class_<cphysics_element_scripted>("physics_element")
-			.def("apply_force",					(void (cphysics_element_scripted::*)(float,float,float))(&cphysics_element_scripted::applyForce))
+		.def("apply_force",
+		     (void (cphysics_element_scripted::*)(float, float, float))(&cphysics_element_scripted::applyForce))
+
+		// demonized: apply_torque
+		.def("apply_torque",
+			(void (cphysics_element_scripted::*)(float, float, float))(&cphysics_element_scripted::applyTorque))
+
 			.def("is_breakable",				&cphysics_element_scripted::isBreakable)
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/physics_element_scripted.h xray-monolith/src/xrGame/physics_element_scripted.h
--- coc-1.4-xray-64/src/xrGame/physics_element_scripted.h	2023-10-20 20:54:51.201326500 +0100
+++ xray-monolith/src/xrGame/physics_element_scripted.h	2023-10-20 20:54:33.131035700 +0100
@@ -10,5 +11,11 @@
 public:
-	cphysics_element_scripted(CPhysicsElement* imp ):cphysics_game_scripted<CPhysicsElement>(imp){}
+	cphysics_element_scripted(CPhysicsElement* imp): cphysics_game_scripted<CPhysicsElement>(imp)
+	{
+	}
 
 	void	applyForce			( float x, float y, float z )	{ physics_impl().applyForce( x, y, z ); }
+
+	// demonized: apply_torque
+	void applyTorque(float x, float y, float z) { physics_impl().applyTorque(x, y, z); }
+
 	bool	isBreakable			( )								{ return physics_impl(). isBreakable( ); }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/physics_game.cpp xray-monolith/src/xrGame/physics_game.cpp
--- coc-1.4-xray-64/src/xrGame/physics_game.cpp	2023-10-20 20:54:51.201326500 +0100
+++ xray-monolith/src/xrGame/physics_game.cpp	2023-10-20 20:54:33.132035800 +0100
@@ -175,2 +190,3 @@
 #else
+	if (data->ph_ref_object)
 						sp=data->ph_ref_object->ObjectPhSoundPlayer();
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/physics_shell_scripted.cpp xray-monolith/src/xrGame/physics_shell_scripted.cpp
--- coc-1.4-xray-64/src/xrGame/physics_shell_scripted.cpp	2023-10-20 20:54:51.203326500 +0100
+++ xray-monolith/src/xrGame/physics_shell_scripted.cpp	2023-10-20 20:54:33.134035600 +0100
@@ -55,2 +57,22 @@
 
+void cphysics_shell_scripted::freeze()
+{
+	u16 max_elements = get_ElementsNumber();
+	for (u16 i = 0; i < max_elements; ++i)
+	{
+		get_ElementByStoreOrder(i)->Fix();
+	}
+	physics_impl().collide_class_bits().set(2, TRUE); //cbNCStatic
+}
+
+void cphysics_shell_scripted::unfreeze()
+{
+	u16 max_elements = get_ElementsNumber();
+	for (u16 i = 0; i < max_elements; ++i)
+	{
+		get_ElementByStoreOrder(i)->ReleaseFixed();
+	}
+	physics_impl().collide_class_bits().set(2, FALSE); //cbNCStatic
+}
+
 #pragma optimize("s",on)
@@ -61,9 +83,21 @@
 			class_<cphysics_shell_scripted>("physics_shell")
-			.def("apply_force",					(void (cphysics_shell_scripted::*)(float,float,float))(&cphysics_shell_scripted::applyForce))
-			.def("get_element_by_bone_name",	(cphysics_element_scripted*(cphysics_shell_scripted::*)(LPCSTR))(&cphysics_shell_scripted::get_Element))
-			.def("get_element_by_bone_id",		(cphysics_element_scripted*(cphysics_shell_scripted::*)(u16))(&cphysics_shell_scripted::get_Element))
-			.def("get_element_by_order",		(cphysics_element_scripted*(cphysics_shell_scripted::*)(u16))(&cphysics_shell_scripted::get_ElementByStoreOrder))
+		.def("apply_force",
+		     (void (cphysics_shell_scripted::*)(float, float, float))(&cphysics_shell_scripted::applyForce))
+
+		// demonized: apply_torque
+		.def("apply_torque",
+			(void (cphysics_shell_scripted::*)(float, float, float))(&cphysics_shell_scripted::applyTorque))
+
+		.def("get_element_by_bone_name",
+		     (cphysics_element_scripted*(cphysics_shell_scripted::*)(LPCSTR))(&cphysics_shell_scripted::get_Element))
+		.def("get_element_by_bone_id",
+		     (cphysics_element_scripted*(cphysics_shell_scripted::*)(u16))(&cphysics_shell_scripted::get_Element))
+		.def("get_element_by_order",
+		     (cphysics_element_scripted*(cphysics_shell_scripted::*)(u16))(&cphysics_shell_scripted::
+			     get_ElementByStoreOrder))
 			.def("get_elements_number",			&cphysics_shell_scripted::get_ElementsNumber)
-			.def("get_joint_by_bone_name",		(cphysics_joint_scripted*(cphysics_shell_scripted::*)(LPCSTR))(&cphysics_shell_scripted::get_Joint))
-			.def("get_joint_by_bone_id",		(cphysics_joint_scripted*(cphysics_shell_scripted::*)(u16))(&cphysics_shell_scripted::get_Joint))
+		.def("get_joint_by_bone_name",
+		     (cphysics_joint_scripted*(cphysics_shell_scripted::*)(LPCSTR))(&cphysics_shell_scripted::get_Joint))
+		.def("get_joint_by_bone_id",
+		     (cphysics_joint_scripted*(cphysics_shell_scripted::*)(u16))(&cphysics_shell_scripted::get_Joint))
 			.def("get_joint_by_order",			&cphysics_shell_scripted::get_JointByStoreOrder)
@@ -76,2 +110,4 @@
 			.def("get_angular_vel",				&cphysics_shell_scripted::get_AngularVel)
+		.def("freeze", &cphysics_shell_scripted::freeze)
+		.def("unfreeze", &cphysics_shell_scripted::unfreeze)
 		];
@@ -79,30 +115,3 @@
 
-
 /*
-Fmatrix	global_transform(CPhysicsElement* E)
-{
-	Fmatrix m;
-	E->GetGlobalTransformDynamic(&m);
-	return m;
-}
-
-void CPhysicsElement::script_register(lua_State *L)
-{
-	module(L)
-		[
-			class_<CPhysicsElement>("physics_element")
-			.def("apply_force",					(void (CPhysicsElement::*)(float,float,float))(&CPhysicsElement::applyForce))
-			.def("is_breakable",				&CPhysicsElement::isBreakable)
-			.def("get_linear_vel",				&CPhysicsElement::get_LinearVel)
-			.def("get_angular_vel",				&CPhysicsElement::get_AngularVel)
-			.def("get_mass",					&CPhysicsElement::getMass)
-			.def("get_density",					&CPhysicsElement::getDensity)
-			.def("get_volume",					&CPhysicsElement::getVolume)
-			.def("fix",							&CPhysicsElement::Fix)
-			.def("release_fixed",				&CPhysicsElement::ReleaseFixed)
-			.def("is_fixed",					&CPhysicsElement::isFixed)
-			.def("global_transform",			&global_transform)
-		];
-}
-
 void CPhysicsJoint::script_register(lua_State *L)
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/physics_shell_scripted.h xray-monolith/src/xrGame/physics_shell_scripted.h
--- coc-1.4-xray-64/src/xrGame/physics_shell_scripted.h	2023-10-20 20:54:51.204327200 +0100
+++ xray-monolith/src/xrGame/physics_shell_scripted.h	2023-10-20 20:54:33.134035600 +0100
@@ -18,2 +20,6 @@
 	void						applyForce					( float x, float y, float z )	{ physics_impl().applyForce( x, y, z ); }
+
+	// demonized: applyTorque
+	void applyTorque(float x, float y, float z) { physics_impl().applyTorque(x, y, z); }
+
 	cphysics_element_scripted*	get_Element					( LPCSTR bone_name )			;
@@ -37,2 +43,4 @@
 	void	get_AngularVel		(Fvector& velocity)	const	{ physics_impl().get_AngularVel( velocity ); }
+	void freeze();
+	void unfreeze();
 	DECLARE_SCRIPT_REGISTER_FUNCTION
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/PhysicsSkeletonObject.cpp xray-monolith/src/xrGame/PhysicsSkeletonObject.cpp
--- coc-1.4-xray-64/src/xrGame/PhysicsSkeletonObject.cpp	2023-10-20 20:54:50.693326900 +0100
+++ xray-monolith/src/xrGame/PhysicsSkeletonObject.cpp	2023-10-20 20:54:32.647036400 +0100
@@ -24,3 +22,3 @@
 
-	inherited::net_Spawn	(DC);
+	BOOL res = inherited::net_Spawn(DC);
 	xr_delete(collidable.model);
@@ -30,5 +28,5 @@
 	setEnabled(TRUE);
-	if(!PPhysicsShell()->isBreakable())
+	if (!PPhysicsShell() || !PPhysicsShell()->isBreakable())
 		SheduleUnregister		();
-	return TRUE;
+	return res;
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/player_account.cpp xray-monolith/src/xrGame/player_account.cpp
--- coc-1.4-xray-64/src/xrGame/player_account.cpp	2023-10-20 20:54:51.204327200 +0100
+++ xray-monolith/src/xrGame/player_account.cpp	2023-10-20 20:54:33.135036500 +0100
@@ -22,35 +22,35 @@
 {
-	gamespy_gp::login_manager* tmp_lmngr		= MainMenu()->GetLoginMngr();
-	VERIFY(tmp_lmngr);
-	gamespy_profile::profile_store* tmp_store	= MainMenu()->GetProfileStore();
-	VERIFY(tmp_store);
-	gamespy_gp::profile const * tmp_curr_prof	= tmp_lmngr->get_current_profile();
-
-	if (!tmp_curr_prof)
-	{
-		Msg("* WARNING: player not logged in");
-	}
-
-	if (tmp_curr_prof)
-	{
-		m_player_name		= tmp_curr_prof->m_unique_nick;
-		m_online_account	= tmp_curr_prof->online();
-		m_profile_id		= static_cast<u32>(tmp_curr_prof->profile_id());
-	} else
-	{
-		m_player_name		= "";
-		m_online_account	= false;
-		m_profile_id		= 0;
-	}
-	m_clan_name			= "";
-	m_clan_leader		= false;
-
-	
-
-	gamespy_profile::all_awards_t const & tmp_awards = tmp_store->get_awards();
-	for (gamespy_profile::all_awards_t::const_iterator i = tmp_awards.begin(),
-		ie = tmp_awards.end(); i != ie; ++i)
-	{
-		m_awards.insert(*i);
-	}
+	//gamespy_gp::login_manager* tmp_lmngr		= MainMenu()->GetLoginMngr();
+	//VERIFY(tmp_lmngr);
+	//gamespy_profile::profile_store* tmp_store	= MainMenu()->GetProfileStore();
+	//VERIFY(tmp_store);
+	//gamespy_gp::profile const * tmp_curr_prof	= tmp_lmngr->get_current_profile();
+
+	//if (!tmp_curr_prof)
+	//{
+	//	Msg("* WARNING: player not logged in");
+	//}
+
+	//if (tmp_curr_prof)
+	//{
+	//	m_player_name		= tmp_curr_prof->m_unique_nick;
+	//	m_online_account	= tmp_curr_prof->online();
+	//	m_profile_id		= static_cast<u32>(tmp_curr_prof->profile_id());
+	//} else
+	//{
+	//	m_player_name		= "";
+	//	m_online_account	= false;
+	//	m_profile_id		= 0;
+	//}
+	//m_clan_name			= "";
+	//m_clan_leader		= false;
+
+	//
+
+	//gamespy_profile::all_awards_t const & tmp_awards = tmp_store->get_awards();
+	//for (gamespy_profile::all_awards_t::const_iterator i = tmp_awards.begin(),
+	//	ie = tmp_awards.end(); i != ie; ++i)
+	//{
+	//	m_awards.insert(*i);
+	//}
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/player_hud.cpp xray-monolith/src/xrGame/player_hud.cpp
--- coc-1.4-xray-64/src/xrGame/player_hud.cpp	2023-10-20 20:54:51.205326600 +0100
+++ xray-monolith/src/xrGame/player_hud.cpp	2023-10-20 20:54:33.136035800 +0100
@@ -1,2 +1,2 @@
-#include "stdafx.h"
+ï»¿#include "stdafx.h"
 #include "player_hud.h"
@@ -9,2 +9,4 @@
 #include "../xrEngine/IGame_Persistent.h"
+#include "inventory_item.h"
+#include "weapon.h"
 
@@ -14,11 +16,2 @@
 
-float CalcMotionSpeed(const shared_str& anim_name)
-{
-
-	if(!IsGameTypeSingle() && (anim_name=="anm_show" || anim_name=="anm_hide") )
-		return 2.0f;
-	else
-		return 1.0f;
-}
-
 player_hud_motion* player_hud_motion_container::find_motion(const shared_str& name)
@@ -60,5 +53,6 @@
 				pm->m_additional_name	= anm;
-			}else
+			}
+			else
 			{
-				R_ASSERT2(_GetItemCount(anm.c_str())==2, anm.c_str());
+				R_ASSERT2(_GetItemCount(anm.c_str())<=4, anm.c_str());
 				string512				str_item;
@@ -69,2 +63,8 @@
 				pm->m_additional_name	= str_item;
+
+				_GetItem(anm.c_str(), 2, str_item);
+				pm->m_anim_speed = atof(str_item);
+
+				_GetItem(anm.c_str(), 3, str_item);
+				pm->m_anim_end = atof(str_item);
 			}
@@ -102,2 +102,4 @@
 {
+	if (g_player_hud->m_adjust_mode)
+		return g_player_hud->m_adjust_offset[0][0];
 	return m_measures.m_hands_attach[0];
@@ -107,2 +109,4 @@
 {
+	if (g_player_hud->m_adjust_mode)
+		return g_player_hud->m_adjust_offset[1][0];
 	return m_measures.m_hands_attach[1];
@@ -145,8 +151,8 @@
 
-	Fvector ypr						= m_measures.m_item_attach[1];
+	Fvector ypr = m_parent->m_adjust_mode ? m_parent->m_adjust_obj[1] : m_measures.m_item_attach[1];
 	ypr.mul							(PI/180.f);
 	m_attach_offset.setHPB			(ypr.x,ypr.y,ypr.z);
-	m_attach_offset.translate_over	(m_measures.m_item_attach[0]);
+	m_attach_offset.translate_over(m_parent->m_adjust_mode ? m_parent->m_adjust_obj[0] : m_measures.m_item_attach[0]);
 
-	m_parent->calc_transform		(m_attach_place_idx, m_attach_offset, m_item_transform);
+	m_parent->calc_transform(m_attach_place_idx, m_attach_offset, m_item_transform, m_measures.m_bLeadGunLeftHand);
 	m_upd_firedeps_frame			= Device.dwFrame;
@@ -162,10 +168,2 @@
 
-void attachable_hud_item::update_hud_additional(Fmatrix& trans)
-{
-	if(m_parent_hud_item)
-	{
-		m_parent_hud_item->UpdateHudAdditonal(trans);
-	}
-}
-
 void attachable_hud_item::setup_firedeps(firedeps& fd)
@@ -177,9 +175,8 @@
 		Fmatrix& fire_mat								= m_model->LL_GetTransform(m_measures.m_fire_bone);
-		fire_mat.transform_tiny							(fd.vLastFP, m_measures.m_fire_point_offset);
+		fire_mat.transform_tiny(fd.vLastFP, m_parent->m_adjust_mode ? m_parent->m_adjust_firepoint_shell[0][0] : m_measures.m_fire_point_offset);
 		m_item_transform.transform_tiny					(fd.vLastFP);
 
-		fd.vLastFD.set									(0.f,0.f,1.f);
+		fd.vLastFD.set(m_parent->m_adjust_mode ? m_parent->m_adjust_firepoint_shell[1][0] : m_measures.m_fire_direction);
 		m_item_transform.transform_dir					(fd.vLastFD);
 		VERIFY(_valid(fd.vLastFD));
-		VERIFY(_valid(fd.vLastFD));
 
@@ -196,5 +194,5 @@
 		Fmatrix& fire_mat			= m_model->LL_GetTransform(m_measures.m_fire_bone2);
-		fire_mat.transform_tiny		(fd.vLastFP2,m_measures.m_fire_point2_offset);
+		fire_mat.transform_tiny(fd.vLastFP2, m_parent->m_adjust_mode ? m_parent->m_adjust_firepoint_shell[0][1] : m_measures.m_fire_point2_offset);
 		m_item_transform.transform_tiny	(fd.vLastFP2);
-		VERIFY(_valid(fd.vLastFP2));
+		fd.vLastFD.set(m_parent->m_adjust_mode ? m_parent->m_adjust_firepoint_shell[1][0] : m_measures.m_fire_direction);
 		VERIFY(_valid(fd.vLastFP2));
@@ -205,6 +203,5 @@
 		Fmatrix& fire_mat			= m_model->LL_GetTransform(m_measures.m_shell_bone);
-		fire_mat.transform_tiny		(fd.vLastSP,m_measures.m_shell_point_offset);
+		fire_mat.transform_tiny(fd.vLastSP, m_parent->m_adjust_mode ? m_parent->m_adjust_firepoint_shell[1][1] : m_measures.m_shell_point_offset);
 		m_item_transform.transform_tiny	(fd.vLastSP);
 		VERIFY(_valid(fd.vLastSP));
-		VERIFY(_valid(fd.vLastSP));
 	}
@@ -221,3 +218,3 @@
 	::Render->add_Visual		(m_model->dcast_RenderVisual());
-	debug_draw_firedeps			();
+
 	m_parent_hud_item->render_hud_mode();
@@ -257,3 +254,6 @@
 		m_fire_point_offset		= pSettings->r_fvector3(sect_name, "fire_point");
-	}else
+		m_fire_direction = READ_IF_EXISTS(pSettings, r_fvector3, sect_name, "fire_direction",
+		                                  Fvector().set(0.f, 0.f, 1.0f));
+	}
+	else
 		m_fire_point_offset.set(0,0,0);
@@ -291,8 +293,97 @@
 
-
-	R_ASSERT2(pSettings->line_exist(sect_name,"fire_point")==pSettings->line_exist(sect_name,"fire_bone"),		sect_name.c_str());
-	R_ASSERT2(pSettings->line_exist(sect_name,"fire_point2")==pSettings->line_exist(sect_name,"fire_bone2"),	sect_name.c_str());
-	R_ASSERT2(pSettings->line_exist(sect_name,"shell_point")==pSettings->line_exist(sect_name,"shell_bone"),	sect_name.c_str());
+	R_ASSERT2(pSettings->line_exist(sect_name,"fire_point")==pSettings->line_exist(sect_name,"fire_bone"),
+	          sect_name.c_str());
+	R_ASSERT2(pSettings->line_exist(sect_name,"fire_point2")==pSettings->line_exist(sect_name,"fire_bone2"),
+	          sect_name.c_str());
+	R_ASSERT2(pSettings->line_exist(sect_name,"shell_point")==pSettings->line_exist(sect_name,"shell_bone"),
+	          sect_name.c_str());
 
 	m_prop_flags.set(e_16x9_mode_now,is_16x9);
+
+	////////////////////////////////////////////
+	//--#SM+# Begin--
+	const Fvector vZero = {0.f, 0.f, 0.f};
+
+	// ÐÐ»ÑÑÐµÑÐ½Ð°ÑÐ¸Ð²Ð½Ð¾Ðµ Ð¿ÑÐ¸ÑÐµÐ»Ð¸Ð²Ð°Ð½Ð¸Ðµ
+	strconcat(sizeof(val_name), val_name, "aim_hud_offset_alt_pos", _prefix);
+	m_hands_offset[0][3] = READ_IF_EXISTS(pSettings, r_fvector3, sect_name, val_name, vZero);
+	strconcat(sizeof(val_name), val_name, "aim_hud_offset_alt_rot", _prefix);
+	m_hands_offset[1][3] = READ_IF_EXISTS(pSettings, r_fvector3, sect_name, val_name, vZero);
+
+	// Safemode / lowered weapon position
+	strconcat(sizeof(val_name), val_name, "lowered_hud_offset_pos", _prefix);
+	m_hands_offset[0][4] = READ_IF_EXISTS(pSettings, r_fvector3, sect_name, val_name, vZero);
+	strconcat(sizeof(val_name), val_name, "lowered_hud_offset_rot", _prefix);
+	m_hands_offset[1][4] = READ_IF_EXISTS(pSettings, r_fvector3, sect_name, val_name, vZero);
+
+	// ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ¸ ÑÑÑÐµÐ¹ÑÐ° (Ð±Ð¾ÐºÐ¾Ð²Ð°Ñ ÑÐ¾Ð´ÑÐ±Ð°)
+	Fvector vDefStrafeValue;
+	vDefStrafeValue.set(vZero);
+
+	//--> Ð¡Ð¼ÐµÑÐµÐ½Ð¸Ðµ Ð² ÑÑÑÐµÐ¹ÑÐµ
+	strconcat(sizeof(val_name), val_name, "strafe_hud_offset_pos", _prefix);
+	m_strafe_offset[0][0] = READ_IF_EXISTS(pSettings, r_fvector3, sect_name, val_name, vDefStrafeValue);
+	strconcat(sizeof(val_name), val_name, "strafe_hud_offset_rot", _prefix);
+	m_strafe_offset[1][0] = READ_IF_EXISTS(pSettings, r_fvector3, sect_name, val_name, vDefStrafeValue);
+
+	//--> ÐÐ¾Ð²Ð¾ÑÐ¾Ñ Ð² ÑÑÑÐµÐ¹ÑÐµ
+	strconcat(sizeof(val_name), val_name, "strafe_aim_hud_offset_pos", _prefix);
+	m_strafe_offset[0][1] = READ_IF_EXISTS(pSettings, r_fvector3, sect_name, val_name, vDefStrafeValue);
+	strconcat(sizeof(val_name), val_name, "strafe_aim_hud_offset_rot", _prefix);
+	m_strafe_offset[1][1] = READ_IF_EXISTS(pSettings, r_fvector3, sect_name, val_name, vDefStrafeValue);
+
+	//--> ÐÐ°ÑÐ°Ð¼ÐµÑÑÑ ÑÑÑÐµÐ¹ÑÐ°
+	bool bStrafeEnabled = READ_IF_EXISTS(pSettings, r_bool, sect_name, "strafe_enabled", false);
+	bool bStrafeEnabled_aim = READ_IF_EXISTS(pSettings, r_bool, sect_name, "strafe_aim_enabled", false);
+	float fFullStrafeTime = READ_IF_EXISTS(pSettings, r_float, sect_name, "strafe_transition_time", .5f);
+	float fFullStrafeTime_aim = READ_IF_EXISTS(pSettings, r_float, sect_name, "strafe_aim_transition_time", .5f);
+	float fStrafeCamLFactor = READ_IF_EXISTS(pSettings, r_float, sect_name, "strafe_cam_limit_factor", 0.5f);
+	float fStrafeCamLFactor_aim = READ_IF_EXISTS(pSettings, r_float, sect_name, "strafe_cam_limit_aim_factor", 1.0f);
+	float fStrafeMinAngle = READ_IF_EXISTS(pSettings, r_float, sect_name, "strafe_cam_min_angle", 0.0f);
+	float fStrafeMinAngle_aim = READ_IF_EXISTS(pSettings, r_float, sect_name, "strafe_cam_aim_min_angle", 7.0f);
+
+	//--> (Data 1)
+	m_strafe_offset[2][0].set((bStrafeEnabled ? 1.0f : 0.0f), fFullStrafeTime, NULL); // normal
+	m_strafe_offset[2][1].set((bStrafeEnabled_aim ? 1.0f : 0.0f), fFullStrafeTime_aim, NULL); // aim-GL
+
+	//--> (Data 2)
+	m_strafe_offset[3][0].set(fStrafeCamLFactor, fStrafeMinAngle, NULL); // normal
+	m_strafe_offset[3][1].set(fStrafeCamLFactor_aim, fStrafeMinAngle_aim, NULL); // aim-GL
+
+	// ÐÐ°Ð³ÑÑÐ·ÐºÐ° Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¾Ð² ÑÐ¼ÐµÑÐµÐ½Ð¸Ñ / Ð¸Ð½ÐµÑÑÐ¸Ð¸
+	m_inertion_params.m_tendto_speed = READ_IF_EXISTS(pSettings, r_float, sect_name, "inertion_tendto_speed",
+	                                                  TENDTO_SPEED);
+	m_inertion_params.m_tendto_speed_aim = READ_IF_EXISTS(pSettings, r_float, sect_name, "inertion_tendto_aim_speed",
+	                                                      TENDTO_SPEED_AIM);
+	m_inertion_params.m_tendto_ret_speed = READ_IF_EXISTS(pSettings, r_float, sect_name, "inertion_tendto_ret_speed",
+	                                                      TENDTO_SPEED_RET);
+	m_inertion_params.m_tendto_ret_speed_aim = READ_IF_EXISTS(pSettings, r_float, sect_name,
+	                                                          "inertion_tendto_ret_aim_speed", TENDTO_SPEED_RET_AIM);
+
+	m_inertion_params.m_min_angle =
+		READ_IF_EXISTS(pSettings, r_float, sect_name, "inertion_min_angle", INERT_MIN_ANGLE);
+	m_inertion_params.m_min_angle_aim = READ_IF_EXISTS(pSettings, r_float, sect_name, "inertion_min_angle_aim",
+	                                                   INERT_MIN_ANGLE_AIM);
+
+	m_inertion_params.m_offset_LRUD = READ_IF_EXISTS(pSettings, r_fvector4, sect_name, "inertion_offset_LRUD",
+	                                                 Fvector4().set(ORIGIN_OFFSET));
+	m_inertion_params.m_offset_LRUD_aim = READ_IF_EXISTS(pSettings, r_fvector4, sect_name, "inertion_offset_LRUD_aim",
+	                                                     Fvector4().set(ORIGIN_OFFSET_AIM));
+
+	// ÐÐ°Ð³ÑÑÐ·ÐºÐ° Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¾Ð² ÑÐ¼ÐµÑÐµÐ½Ð¸Ñ Ð¿ÑÐ¸ ÑÑÑÐµÐ»ÑÐ±Ðµ
+	m_shooting_params.bShootShake = READ_IF_EXISTS(pSettings, r_bool, sect_name, "shooting_hud_effect", false);
+	m_shooting_params.m_shot_max_offset_LRUD = READ_IF_EXISTS(pSettings, r_fvector4, sect_name, "shooting_max_LRUD",
+	                                                          Fvector4().set(0, 0, 0, 0));
+	m_shooting_params.m_shot_max_offset_LRUD_aim = READ_IF_EXISTS(pSettings, r_fvector4, sect_name,
+	                                                              "shooting_max_LRUD_aim", Fvector4().set(0, 0, 0, 0));
+	m_shooting_params.m_shot_offset_BACKW = READ_IF_EXISTS(pSettings, r_fvector2, sect_name, "shooting_backward_offset",
+	                                                       Fvector2().set(0, 0));
+	m_shooting_params.m_ret_speed = READ_IF_EXISTS(pSettings, r_float, sect_name, "shooting_ret_speed", 1.0f);
+	m_shooting_params.m_ret_speed_aim = READ_IF_EXISTS(pSettings, r_float, sect_name, "shooting_ret_aim_speed", 1.0f);
+	m_shooting_params.m_min_LRUD_power = READ_IF_EXISTS(pSettings, r_float, sect_name, "shooting_min_LRUD_power", 0.0f);
+
+	//--#SM+# End--
+
+	m_fFreelookZOffset = READ_IF_EXISTS(pSettings, r_float, sect_name, "freelook_z_offset_mul", 0.f);
+	m_bLeadGunLeftHand = READ_IF_EXISTS(pSettings, r_bool, sect_name, "lh_lead_gun", false);
 }
@@ -303,3 +394,3 @@
 	::Render->model_Delete		(v);
-	m_model						= NULL;
+	m_model = nullptr;
 }
@@ -311,4 +402,8 @@
 	// Visual
-	const shared_str& visual_name = pSettings->r_string(sect_name, "item_visual");
-	m_model						 = smart_cast<IKinematics*>(::Render->model_Create(visual_name.c_str()));
+	LPCSTR visual_name = pSettings->r_string(sect_name, "item_visual");
+	::Render->hud_loading = true;
+	IKinematicsAnimated* visual = ::Render->model_Create(visual_name)->dcast_PKinematicsAnimated();
+	::Render->hud_loading = false;
+	R_ASSERT2(visual, make_string("could not create model %s, section %s", visual_name, sect_name.c_str()));
+	m_model = smart_cast<IKinematics*>(visual);
 
@@ -318,17 +413,31 @@
 
-u32 attachable_hud_item::anim_play(const shared_str& anm_name_b, BOOL bMixIn, const CMotionDef*& md, u8& rnd_idx)
+player_hud_motion* attachable_hud_item::find_motion(const shared_str& anm_name)
 {
-	float speed				= CalcMotionSpeed(anm_name_b);
-
-	R_ASSERT				(strstr(anm_name_b.c_str(),"anm_")==anm_name_b.c_str());
+	R_ASSERT(strstr(anm_name.c_str(), "anm_") == anm_name.c_str());
 	string256				anim_name_r;
 	bool is_16x9			= UI().is_widescreen();
-	xr_sprintf				(anim_name_r,"%s%s",anm_name_b.c_str(),((m_attach_place_idx==1)&&is_16x9)?"_16x9":"");
+	xr_sprintf(anim_name_r, "%s%s", anm_name.c_str(), ((m_attach_place_idx == 1) && is_16x9) ? "_16x9" : "");
 
 	player_hud_motion* anm	= m_hand_motions.find_motion(anim_name_r);
-	R_ASSERT2				(anm, make_string("model [%s] has no motion alias defined [%s]", m_sect_name.c_str(), anim_name_r).c_str());
-	VERIFY2					(anm->m_animations.size(), make_string("model [%s] has no motion defined in motion_alias [%s]", pSettings->r_string(m_sect_name, "item_visual"), anim_name_r).c_str());
 	
+	if (!anm)
+		anm = m_hand_motions.find_motion(anm_name);
+
+	R_ASSERT2(anm, make_string("model [%s] has no motion alias defined [%s]", m_sect_name.c_str(), anim_name_r).c_str())
+	;
+	VERIFY2(anm->m_animations.size(),
+	        make_string("model [%s] has no motion defined in motion_alias [%s]", pSettings->r_string(m_sect_name,
+		        "item_visual"), anim_name_r).c_str());
+
+	return anm;
+}
+
+u32 attachable_hud_item::anim_play(const shared_str& anm_name_b, BOOL bMixIn, const CMotionDef*& md, u8& rnd_idx,
+                                   float speed, bool bMixIn2)
+{
+	player_hud_motion* anm = find_motion(anm_name_b);
 	rnd_idx					= (u8)Random.randI(anm->m_animations.size()) ;
 	const motion_descr& M	= anm->m_animations[ rnd_idx ];
+	if (speed == 1.f)
+		speed = anm->m_anim_speed != 0 ? anm->m_anim_speed : 1.f;
 
@@ -349,7 +458,6 @@
 			M2							= ka->ID_Cycle_Safe("idle");
-		else
-			if(bDebug)
+		else if (bDebug)
 				Msg						("playing item animation [%s]",item_anm_name.c_str());
 		
-		R_ASSERT3(M2.valid(),"model has no motion [idle] ", pSettings->r_string(m_sect_name, "item_visual"));
+		R_ASSERT3(M2.valid(), make_string("model has no motion [idle], section %s", m_sect_name.c_str()).c_str(), pSettings->r_string(m_sect_name, "item_visual"));
 
@@ -362,7 +470,3 @@
 		for(u16 pid=0; pid<pc; ++pid)
-		{
-			CBlend* B					= ka->PlayCycle(pid, M2, bMixIn);
-			R_ASSERT					(B);
-			B->speed					*= speed;
-		}
+			CBlend* B = ka->PlayCycle(pid, M2, (!!bMixIn && bMixIn2), 0, 0, 0, speed);
 
@@ -380,7 +484,3 @@
 		VERIFY					(current_actor);
-		CEffectorCam* ec		= current_actor->Cameras().GetCamEffector(eCEWeaponAction);
-
 	
-		if(NULL==ec)
-		{
 			string_path			ce_path;
@@ -390,4 +490,5 @@
 			{
+			int rand = ::Random.randI(5000, 10000);
 				CAnimatorCamEffector* e		= xr_new<CAnimatorCamEffector>();
-				e->SetType					(eCEWeaponAction);
+			e->SetType(ECamEffectorType(rand));
 				e->SetHudAffect				(false);
@@ -398,3 +499,2 @@
 		}
-	}
 	return ret;
@@ -402,9 +502,48 @@
 
-
 player_hud::player_hud()
 {
-	m_model					= NULL;
-	m_attached_items[0]		= NULL;
-	m_attached_items[1]		= NULL;
+	m_model = nullptr;
+	m_model_2 = nullptr;
+	m_attached_items[0] = nullptr;
+	m_attached_items[1] = nullptr;
+	m_attach_offset.identity();
+	m_attach_offset_2.identity();
 	m_transform.identity	();
+	m_transform_2.identity();
+	m_adjust_mode = false;
+	script_anim_part = u8(-1);
+	script_anim_offset_factor = 0.f;
+	m_item_pos.identity();
+	script_override_arms = false;
+
+	//Bone Callback Params
+	m_bone_callback_params.insert(mk_pair(r_finger0, xr_new<BoneCallbackParams>()));
+	m_bone_callback_params.insert(mk_pair(r_finger01, xr_new<BoneCallbackParams>()));
+	m_bone_callback_params.insert(mk_pair(r_finger02, xr_new<BoneCallbackParams>()));
+	//m_bone_callback_params.insert(mk_pair(bip01_r_finger1, xr_new<BoneCallbackParams>()));
+	//m_bone_callback_params.insert(mk_pair(bip01_r_finger11, xr_new<BoneCallbackParams>()));
+	//m_bone_callback_params.insert(mk_pair(bip01_r_finger12, xr_new<BoneCallbackParams>()));
+	
+	//Movement Layers
+	m_movement_layers.reserve(move_anms_end);
+
+	for (int i = 0; i < move_anms_end; i++)
+	{
+		movement_layer* anm = xr_new<movement_layer>();
+
+		char temp[20];
+		string512 tmp;
+		strconcat(sizeof(temp), temp, "movement_layer_", std::to_string(i).c_str());
+		R_ASSERT2(pSettings->line_exist("hud_movement_layers", temp), make_string("Missing definition for [hud_movement_layers] %s", temp));
+		LPCSTR layer_def = pSettings->r_string("hud_movement_layers", temp);
+		R_ASSERT2(_GetItemCount(layer_def) > 0, make_string("Wrong definition for [hud_movement_layers] %s", temp));
+		
+		_GetItem(layer_def, 0, tmp);
+		anm->Load(tmp);
+		_GetItem(layer_def, 1, tmp);
+		anm->anm->Speed() = (atof(tmp) ? atof(tmp) : 1.f);
+		_GetItem(layer_def, 2, tmp);
+		anm->m_power = (atof(tmp) ? atof(tmp) : 1.f);
+		m_movement_layers.push_back(anm);
+	}
 }
@@ -416,18 +554,57 @@
 	::Render->model_Delete		(v);
-	m_model						= NULL;
+	m_model = nullptr;
 
-	xr_vector<attachable_hud_item*>::iterator it	= m_pool.begin();
-	xr_vector<attachable_hud_item*>::iterator it_e	= m_pool.end();
-	for(;it!=it_e;++it)
+	v = m_model_2->dcast_RenderVisual();
+	::Render->model_Delete(v);
+	m_model_2 = nullptr;
+
+	delete_data(m_pool);
+	delete_data(m_hand_motions);
+	delete_data(m_script_layers);
+	delete_data(m_movement_layers);
+	delete_data(m_bone_callback_params);
+}
+
+void player_hud::FingerCallback(CBoneInstance* B)
 	{
-		attachable_hud_item* a	= *it;
-		xr_delete				(a);
+	BoneCallbackParams* params = static_cast<BoneCallbackParams*>(B->callback_param());
+
+	Fvector& target = params->m_target;
+	Fvector& current = params->m_current;
+
+	if (!target.similar(current))
+	{
+		Fvector diff[2];
+		diff[0] = target;
+		diff[0].sub(current);
+		diff[0].mul(Device.fTimeDelta / .1f);
+		current.add(diff[0]);
 	}
-	m_pool.clear				();
+	else
+		current.set(target);
+
+	Fmatrix rotation;
+	rotation.identity();
+	rotation.rotateX(current.x);
+
+	Fmatrix rotation_y;
+	rotation_y.identity();
+	rotation_y.rotateY(current.y);
+	rotation.mulA_43(rotation_y);
+
+	rotation_y.identity();
+	rotation_y.rotateZ(current.z);
+	rotation.mulA_43(rotation_y);
+
+	B->mTransform.mulB_43(rotation);
 }
 
-void player_hud::load(const shared_str& player_hud_sect)
+void player_hud::load(const shared_str& player_hud_sect, bool force)
 {
-	if(player_hud_sect ==m_sect_name)	return;
-	bool b_reload = (m_model!=NULL);
+	if (!force && player_hud_sect == m_sect_name) return;
+
+	m_sect_name = player_hud_sect;
+
+	if (script_override_arms) return;
+
 	if(m_model)
@@ -437,6 +614,37 @@
 	}
+	if (m_model_2)
+	{
+		IRenderVisual* v = m_model_2->dcast_RenderVisual();
+		::Render->model_Delete(v);
+	}
 
-	m_sect_name					= player_hud_sect;
 	const shared_str& model_name= pSettings->r_string(player_hud_sect, "visual");
+	::Render->hud_loading = true;
 	m_model						= smart_cast<IKinematicsAnimated*>(::Render->model_Create(model_name.c_str()));
+	m_model_2 = smart_cast<IKinematicsAnimated*>(::Render->model_Create(pSettings->line_exist(player_hud_sect, "visual_2") ? pSettings->r_string(player_hud_sect, "visual_2") : model_name.c_str()));
+	bool b_reload = (m_attached_items[0] != nullptr || m_attached_items[1] != nullptr);
+
+	::Render->hud_loading = false;
+	u16 l_arm = m_model->dcast_PKinematics()->LL_BoneID("l_clavicle");
+	u16 r_arm = m_model_2->dcast_PKinematics()->LL_BoneID("r_clavicle");
+
+	u16 bone_r_finger0 = m_model->dcast_PKinematics()->LL_BoneID("r_finger0");
+	u16 bone_r_finger01 = m_model->dcast_PKinematics()->LL_BoneID("r_finger01");
+	u16 bone_r_finger02 = m_model->dcast_PKinematics()->LL_BoneID("r_finger02");
+
+	//u16 bone_r_triggerfinger0 = m_model->dcast_PKinematics()->LL_BoneID("bip01_r_finger1");
+	//u16 bone_r_triggerfinger01 = m_model->dcast_PKinematics()->LL_BoneID("bip01_r_finger11");
+	//u16 bone_r_triggerfinger02 = m_model->dcast_PKinematics()->LL_BoneID("bip01_r_finger12");
+
+	m_model->dcast_PKinematics()->LL_GetBoneInstance(bone_r_finger0).set_callback(bctCustom, FingerCallback, m_bone_callback_params[r_finger0]);
+	m_model->dcast_PKinematics()->LL_GetBoneInstance(bone_r_finger01).set_callback(bctCustom, FingerCallback, m_bone_callback_params[r_finger01]);
+	m_model->dcast_PKinematics()->LL_GetBoneInstance(bone_r_finger02).set_callback(bctCustom, FingerCallback, m_bone_callback_params[r_finger02]);
+
+	//m_model->dcast_PKinematics()->LL_GetBoneInstance(bone_r_triggerfinger0).set_callback(bctCustom, FingerCallback, m_bone_callback_params[bip01_r_finger1]);
+	//m_model->dcast_PKinematics()->LL_GetBoneInstance(bone_r_triggerfinger01).set_callback(bctCustom, FingerCallback, m_bone_callback_params[bip01_r_finger11]);
+	//m_model->dcast_PKinematics()->LL_GetBoneInstance(bone_r_triggerfinger02).set_callback(bctCustom, FingerCallback, m_bone_callback_params[bip01_r_finger12]);
+
+	// hides the unused arm meshes
+	m_model->dcast_PKinematics()->LL_SetBoneVisible(l_arm, FALSE, TRUE);
+	m_model_2->dcast_PKinematics()->LL_SetBoneVisible(r_arm, FALSE, TRUE);
 
@@ -454,4 +662,2 @@
 	
-//	Msg("hands visual changed to[%s] [%s] [%s]", model_name.c_str(), b_reload?"R":"", m_attached_items[0]?"Y":"");
-
 	if(!b_reload)
@@ -459,9 +665,11 @@
 		m_model->PlayCycle("hand_idle_doun");
-	}else
+		m_model_2->PlayCycle("hand_idle_doun");
+	}
+	else
 	{
 		if(m_attached_items[1])
-			m_attached_items[1]->m_parent_hud_item->on_a_hud_attach();
+			m_attached_items[1]->m_parent_hud_item->on_outfit_changed();
 
 		if(m_attached_items[0])
-			m_attached_items[0]->m_parent_hud_item->on_a_hud_attach();
+			m_attached_items[0]->m_parent_hud_item->on_outfit_changed();
 	}
@@ -467,4 +675,19 @@
 	}
+
 	m_model->dcast_PKinematics()->CalculateBones_Invalidate	();
 	m_model->dcast_PKinematics()->CalculateBones(TRUE);
+	m_model_2->dcast_PKinematics()->CalculateBones_Invalidate();
+	m_model_2->dcast_PKinematics()->CalculateBones(TRUE);
+
+	//--DSR-- HeatVision_start
+	m_model->dcast_RenderVisual()->MarkAsHot(true);
+	m_model_2->dcast_RenderVisual()->MarkAsHot(true);
+	//--DSR-- HeatVision_end
+}
+
+void player_hud::load_script(LPCSTR section)
+{
+	script_override_arms = false;
+	load(section, true);
+	script_override_arms = true;
 }
@@ -485,2 +708,6 @@
 {
+	IUIRender::ePointType bk = UI().m_currentPointType;
+	UI().m_currentPointType = IUIRender::pttLIT;
+	UIRender->CacheSetCullMode(IUIRender::cmNONE);
+
 	if(m_attached_items[0])
@@ -490,2 +717,5 @@
 		m_attached_items[1]->render_item_ui();
+
+	UIRender->CacheSetCullMode(IUIRender::cmCCW);
+	UI().m_currentPointType = bk;
 }
@@ -494,6 +724,4 @@
 {
-	if(!m_attached_items[0] && !m_attached_items[1])	return;
-
-	bool b_r0 = (m_attached_items[0] && m_attached_items[0]->need_renderable());
-	bool b_r1 = (m_attached_items[1] && m_attached_items[1]->need_renderable());
+	bool b_r0 = ((m_attached_items[0] && m_attached_items[0]->need_renderable()) || script_anim_part == 0 || script_anim_part == 2);
+	bool b_r1 = ((m_attached_items[1] && m_attached_items[1]->need_renderable()) || script_anim_part == 1 || script_anim_part == 2);
 
@@ -503,2 +731,4 @@
 	::Render->add_Visual		(m_model->dcast_RenderVisual());
+	::Render->set_Transform(&m_transform_2);
+	::Render->add_Visual(m_model_2->dcast_RenderVisual());
 	
@@ -509,2 +739,8 @@
 		m_attached_items[1]->render();
+
+	if (script_anim_item_model)
+	{
+		::Render->set_Transform(&m_item_pos);
+		::Render->add_Visual(script_anim_item_model->dcast_RenderVisual());
+	}
 }
@@ -514,5 +750,27 @@
 
+u32 player_hud::motion_length_script(LPCSTR section, LPCSTR anm_name, float speed)
+{
+	if (!pSettings->section_exist(section))
+	{
+		Msg("!script motion section [%s] does not exist", section);
+		return 0;
+	}
+
+	player_hud_motion_container* pm = get_hand_motions(section);
+	if (!pm)
+		return 0;
+
+	player_hud_motion* phm = pm->find_motion(anm_name);
+	if (!phm)
+	{
+		Msg("!script motion [%s] not found in section [%s]", anm_name, section);
+		return 0;
+	}
+
+	const CMotionDef* temp;
+	return motion_length(phm->m_animations[0].mid, temp, speed);
+}
+
 u32 player_hud::motion_length(const shared_str& anim_name, const shared_str& hud_name, const CMotionDef*& md)
 {
-	float speed						= CalcMotionSpeed(anim_name);
 	attachable_hud_item* pi			= create_hud_item(hud_name);
@@ -522,5 +780,6 @@
 	R_ASSERT2						(pm, 
-		make_string	("hudItem model [%s] has no motion with alias [%s]", hud_name.c_str(), anim_name.c_str() ).c_str() 
+	          make_string ("hudItem model [%s] has no motion with alias [%s]", hud_name.c_str(), anim_name.c_str() ).
+	          c_str()
 		);
-	return motion_length			(pm->m_animations[0].mid, md, speed);
+	return motion_length(pm->m_animations[0].mid, md, 1.f);
 }
@@ -538,24 +797,28 @@
 }
-const Fvector& player_hud::attach_rot() const
+
+const Fvector& player_hud::attach_rot(u8 part) const
 {
-	if(m_attached_items[0])
-		return m_attached_items[0]->hands_attach_rot();
-	else
-	if(m_attached_items[1])
-		return m_attached_items[1]->hands_attach_rot();
-	else
-		return Fvector().set(0,0,0);
+	if (m_attached_items[part])
+		return m_attached_items[part]->hands_attach_rot();
+	else if (m_attached_items[!part])
+		return m_attached_items[!part]->hands_attach_rot();
+
+	return Fvector().set(0.f, 0.f, 0.f);
 }
 
-const Fvector& player_hud::attach_pos() const
+const Fvector& player_hud::attach_pos(u8 part) const
 {
-	if(m_attached_items[0])
-		return m_attached_items[0]->hands_attach_pos();
-	else
-	if(m_attached_items[1])
-		return m_attached_items[1]->hands_attach_pos();
-	else
-		return Fvector().set(0,0,0);
+	if (m_attached_items[part])
+		return m_attached_items[part]->hands_attach_pos();
+	else if (m_attached_items[!part])
+		return m_attached_items[!part]->hands_attach_pos();
+
+	return Fvector().set(0.f, 0.f, 0.f);
 }
 
+#include "../xrEngine/CameraBase.h"
+#include "Inventory.h"
+extern float g_freelook_z_offset;
+extern float psHUD_FOV;
+
 void player_hud::update(const Fmatrix& cam_trans)
@@ -563,11 +826,128 @@
 	Fmatrix	trans					= cam_trans;
-	update_inertion					(trans);
-	update_additional				(trans);
+	Fmatrix trans_b = cam_trans;
+	CWeapon* wep = smart_cast<CWeapon*>(Actor()->inventory().ActiveItem());
+
+	float& control_factor = Actor()->freelook_cam_control;
+	u8 cam_freelook = Actor()->cam_freelook;
+	float sub_z = 0.f;
+
+	if (control_factor > 0)
+	{
+		Fvector new_k;
+		float old_pitch = trans.k.getP();
+		float new_pitch = old_pitch > 0.f ? old_pitch * (1.f - psHUD_FOV) : old_pitch * (1.f - (psHUD_FOV / 2.f));
+		float final_pitch = angle_lerp(old_pitch, new_pitch, control_factor);
+
+		float body_yaw = -angle_normalize_signed(Actor()->old_torso_yaw);
+		float cam_yaw = -angle_normalize_signed(Actor()->cam_FirstEye()->yaw);
+		float diff_yaw = angle_difference_signed(body_yaw, cam_yaw);
+		
+		if (final_pitch < 0.f)
+			sub_z += final_pitch * .35f;
+
+		sub_z -= abs(diff_yaw) * .1f;
+		clamp(sub_z, -.2f, 0.f);
+
+		float new_yaw = trans.k.getH() + diff_yaw * psHUD_FOV;
+		float final_yaw = angle_lerp(body_yaw, new_yaw, control_factor);
+
+		new_k.setHP(final_yaw, final_pitch);
+		trans.k.lerp(trans.k, new_k, control_factor);
+		Fvector::generate_orthonormal_basis_normalized(trans.k, trans.j, trans.i);
+	}
+
+	if (cam_freelook == eflEnabling || cam_freelook == eflEnabled)
+		control_factor += Device.fTimeDelta / .3f;
+	else
+		control_factor -= Device.fTimeDelta / .3f;
+
+	clamp(control_factor, 0.f, 1.f);
+
+	Fvector m1pos = attach_pos(0);
+	Fvector m2pos = attach_pos(1);
+
+	Fvector m1rot = attach_rot(0);
+	Fvector m2rot = attach_rot(1);
+
+	// freelook pitch compensation (avoid seeing missing arm parts or weapon parts that are not meant to be visible)
+	if ((m_attached_items[0] || m_attached_items[1]) && control_factor > 0 && sub_z < 0)
+	{
+		float z1, z2, z_factor;
+		z_factor = (sub_z * control_factor);
+		z1 = (g_freelook_z_offset ? g_freelook_z_offset : m_attached_items[m_attached_items[0] ? 0 : 1]->m_measures.m_fFreelookZOffset);
+		z2 = (g_freelook_z_offset ? g_freelook_z_offset : m_attached_items[m_attached_items[1] ? 1 : 0]->m_measures.m_fFreelookZOffset);
+
+		if (Actor()->is_safemode())
+		{
+			z1 = fmaxf(z1, .5f);
+			if (!m_attached_items[1])
+				z2 = fmaxf(z2, .5f);
+		}
+
+		z1 *= z_factor;
+		z2 *= z_factor;
+
+		m1pos.z += z1;
+		m2pos.z += z2;
+		m1pos.y += z1 / 2.f;
+		m2pos.y += z2 / 2.f;
+	}
+
+	Fmatrix trans_2 = trans;
+
+	if (m_attached_items[0])
+		m_attached_items[0]->m_parent_hud_item->UpdateHudAdditional(trans);
+		
+	if (m_attached_items[1])
+	{
+		m_attached_items[1]->m_parent_hud_item->UpdateHudAdditional(trans_2);
+		if (wep && wep->IsZoomed())
+			trans_2.mulB_43(wep->m_shoot_shake_mat);
+	}
+	
+	if (m_attached_items[0] && !m_attached_items[1])
+		trans_2 = trans;
+	else if (m_attached_items[1] && !m_attached_items[0])
+		trans = trans_2;
+	
+	// override hand offset for single hand animation
+	if (script_anim_part == 2 || (script_anim_part && !m_attached_items[0] && !m_attached_items[1]))
+	{
+		m1pos = script_anim_offset[0];
+		m2pos = script_anim_offset[0];
+		m1rot = script_anim_offset[1];
+		m2rot = script_anim_offset[1];
+		trans = trans_b;
+		trans_2 = trans_b;
+	}
+	else if (script_anim_offset_factor != 0.f)
+	{
+		Fvector& hand_pos = script_anim_part == 0 ? m1pos : m2pos;
+		Fvector& hand_rot = script_anim_part == 0 ? m1rot : m2rot;
+
+		hand_pos.lerp(script_anim_part == 0 ? m1pos : m2pos, script_anim_offset[0], script_anim_offset_factor);
+		hand_rot.lerp(script_anim_part == 0 ? m1rot : m2rot, script_anim_offset[1], script_anim_offset_factor);
+
+		if (script_anim_part == 0)
+		{
+			trans_b.inertion(trans, script_anim_offset_factor);
+			trans = trans_b;
+		}
+		else
+		{
+			trans_b.inertion(trans_2, script_anim_offset_factor);
+			trans_2 = trans_b;
+		}
+	}
+
+	m1rot.mul(PI / 180.f);
+	m_attach_offset.setHPB(m1rot.x, m1rot.y, m1rot.z);
+	m_attach_offset.translate_over(m1pos);
+
+	m2rot.mul(PI / 180.f);
+	m_attach_offset_2.setHPB(m2rot.x, m2rot.y, m2rot.z);
+	m_attach_offset_2.translate_over(m2pos);
 
-	Fvector ypr						= attach_rot();
-	ypr.mul							(PI/180.f);
-	m_attach_offset.setHPB			(ypr.x,ypr.y,ypr.z);
-	m_attach_offset.translate_over	(attach_pos());
 	m_transform.mul					(trans, m_attach_offset);
-	// insert inertion here
+	m_transform_2.mul(trans_2, m_attach_offset_2);
 
@@ -577,2 +957,104 @@
 
+	m_model_2->UpdateTracks();
+	m_model_2->dcast_PKinematics()->CalculateBones_Invalidate();
+	m_model_2->dcast_PKinematics()->CalculateBones(TRUE);
+
+	for (script_layer* anm : m_script_layers)
+	{
+		if (!anm || !anm->anm || (!anm->active && anm->blend_amount == 0.f))
+			continue;
+
+		if (anm->active)
+			anm->blend_amount += Device.fTimeDelta / .4f;
+		else
+			anm->blend_amount -= Device.fTimeDelta / .4f;
+
+		clamp(anm->blend_amount, 0.f, 1.f);
+
+		if (anm->blend_amount > 0.f)
+		{
+			if (anm->anm->bLoop || anm->anm->anim_param().t_current < anm->anm->anim_param().max_t)
+				anm->anm->Update(Device.fTimeDelta);
+			else
+				anm->Stop(false);
+		}
+		else
+		{
+			anm->Stop(true);
+			continue;
+		}
+
+		Fmatrix blend = anm->XFORM();
+
+		if (anm->m_part == 0 || anm->m_part == 2)
+			m_transform.mulB_43(blend);
+
+		if (anm->m_part == 1 || anm->m_part == 2)
+			m_transform_2.mulB_43(blend);
+	}
+
+	bool need_blend[2];
+	need_blend[0] = ((script_anim_part == 0 || script_anim_part == 2) || (m_attached_items[0] && m_attached_items[0]->m_parent_hud_item->NeedBlendAnm()));
+	need_blend[1] = ((script_anim_part == 1 || script_anim_part == 2) || (m_attached_items[1] && m_attached_items[1]->m_parent_hud_item->NeedBlendAnm()));
+
+	for (movement_layer* anm : m_movement_layers)
+	{
+		if (!anm || !anm->anm || (!anm->active && anm->blend_amount[0] == 0.f && anm->blend_amount[1] == 0.f))
+			continue;
+
+		if (anm->active && (need_blend[0] || need_blend[1]))
+		{
+			if (need_blend[0])
+			{
+				anm->blend_amount[0] += Device.fTimeDelta / .4f;
+
+				if (!m_attached_items[1])
+					anm->blend_amount[1] += Device.fTimeDelta / .4f;
+				else if (!need_blend[1])
+					anm->blend_amount[1] -= Device.fTimeDelta / .4f;
+			}
+
+			if (need_blend[1])
+			{
+				anm->blend_amount[1] += Device.fTimeDelta / .4f;
+
+				if (!m_attached_items[0])
+					anm->blend_amount[0] += Device.fTimeDelta / .4f;
+				else if (!need_blend[0])
+					anm->blend_amount[0] -= Device.fTimeDelta / .4f;
+			}
+		}
+		else
+		{
+			anm->blend_amount[0] -= Device.fTimeDelta / .4f;
+			anm->blend_amount[1] -= Device.fTimeDelta / .4f;
+		}
+
+		clamp(anm->blend_amount[0], 0.f, 1.f);
+		clamp(anm->blend_amount[1], 0.f, 1.f);
+
+		if (anm->blend_amount[0] == 0.f && anm->blend_amount[1] == 0.f)
+		{
+			anm->Stop(true);
+			continue;
+		}
+
+		anm->anm->Update(Device.fTimeDelta);
+
+		if (anm->blend_amount[0] == anm->blend_amount[1])
+		{
+			Fmatrix blend = anm->XFORM(0);
+			m_transform.mulB_43(blend);
+			m_transform_2.mulB_43(blend);
+		}
+		else
+		{
+			if (anm->blend_amount[0] > 0.f)
+				m_transform.mulB_43(anm->XFORM(0));
+			
+			if (anm->blend_amount[1] > 0.f)
+				m_transform_2.mulB_43(anm->XFORM(1));
+		}
+	}
+
 	if(m_attached_items[0])
@@ -582,81 +1064,350 @@
 		m_attached_items[1]->update(true);
+
+	if (script_anim_item_attached && script_anim_item_model)
+		update_script_item();
+
+	// single hand offset smoothing + syncing back to other hand animation on end
+	if (script_anim_part != u8(-1))
+	{
+		script_anim_offset_factor += Device.fTimeDelta * 2.5f;
+
+		if (m_bStopAtEndAnimIsRunning && Device.dwTimeGlobal >= script_anim_end)
+			StopScriptAnim();
+	}
+	else
+		script_anim_offset_factor -= Device.fTimeDelta * 5.f;
+
+	clamp(script_anim_offset_factor, 0.f, 1.f);
+}
+
+void player_hud::updateMovementLayerState()
+{
+	CActor* pActor = Actor();
+
+	if (!pActor)
+		return;
+
+	for (movement_layer* anm : m_movement_layers)
+	{
+		anm->Stop(false);
 }
 
-u32 player_hud::anim_play(u16 part, const MotionID& M, BOOL bMixIn, const CMotionDef*& md, float speed)
+	bool need_blend = (script_anim_part != u8(-1) || (m_attached_items[0] && m_attached_items[0]->m_parent_hud_item->NeedBlendAnm()) || (m_attached_items[1] && m_attached_items[1]->m_parent_hud_item->NeedBlendAnm()));
+
+	if (pActor->AnyMove() && need_blend)
 {
+		CEntity::SEntityState state;
+		pActor->g_State(state);
+
+		CWeapon* wep = nullptr;
+
+		if (m_attached_items[0] && m_attached_items[0]->m_parent_hud_item->object().cast_weapon())
+			wep = m_attached_items[0]->m_parent_hud_item->object().cast_weapon();
 
+		if (wep && wep->IsZoomed())
+			state.bCrouch ? m_movement_layers[eAimCrouch]->Play() : m_movement_layers[eAimWalk]->Play();
+		else if (state.bCrouch)
+			m_movement_layers[eCrouch]->Play();
+		else if (state.bSprint)
+			m_movement_layers[eSprint]->Play();
+		else if (!isActorAccelerated(pActor->MovingState(), false))
+			m_movement_layers[eWalk]->Play();
+		else
+			m_movement_layers[eRun]->Play();
+	}
+}
+
+void player_hud::PlayBlendAnm(LPCSTR name, u8 part, float speed, float power, bool bLooped, bool no_restart)
+{
+	for (script_layer* anm : m_script_layers)
+	{
+		if (!xr_strcmp(*anm->m_name, name))
+		{
+			if (!no_restart)
+			{
+				anm->anm->Stop();
+				anm->blend_amount = 0.f;
+				anm->blend.identity();
+			}
+
+			if (!anm->anm->IsPlaying())
+				anm->anm->Play(bLooped);
+				
+			anm->anm->bLoop = bLooped;
+			anm->m_part = part;
+			anm->anm->Speed() = speed;
+			anm->m_power = power;
+			anm->active = true;
+			return;
+		}
+	}
+
+	script_layer* anm = xr_new<script_layer>(name, part, speed, power, bLooped);
+	m_script_layers.push_back(anm);
+}
+
+void player_hud::StopBlendAnm(LPCSTR name, bool bForce)
+{
+	for (script_layer* anm : m_script_layers)
+	{
+		if (!xr_strcmp(*anm->m_name, name))
+		{
+			anm->Stop(bForce);
+			return;
+		}
+	}
+}
+
+void player_hud::StopAllBlendAnms(bool bForce)
+{
+	for (script_layer* anm : m_script_layers)
+	{
+		anm->Stop(bForce);
+	}
+}
+
+float player_hud::SetBlendAnmTime(LPCSTR name, float time)
+{
+	for (script_layer* anm : m_script_layers)
+	{
+		if (!xr_strcmp(*anm->m_name, name))
+		{
+			if (!anm->anm->IsPlaying())
+				return 0;
+
+			float speed = (anm->anm->anim_param().max_t - anm->anm->anim_param().t_current) / time;
+			anm->anm->Speed() = speed;
+			return speed;
+		}
+	}
+	
+	return 0;
+}
+
+//0 = both, 1 = left, 2 = right
+void play_blend(player_hud* hud, u8 pid, const MotionID& M, BOOL bMixIn, float speed, bool script_anim = false)
+{
+	switch (pid)
+	{
+	case 0:
+	{
+		if (!script_anim && hud->script_anim_part == 2) return;
+		play_blend(hud, 1, M, bMixIn, speed);
+		play_blend(hud, 2, M, bMixIn, speed);
+		break;
+	}
+	case 1:
+		if (!script_anim && hud->script_anim_part == 1) return;
+		hud->m_model_2->PlayCycle(0, M, bMixIn, 0, 0, 0, speed);
+		hud->m_model_2->PlayCycle(1, M, bMixIn, 0, 0, 0, speed);
+		hud->m_model_2->PlayCycle(2, M, bMixIn, 0, 0, 0, speed);
+		hud->m_model_2->dcast_PKinematics()->CalculateBones_Invalidate();
+		break;
+	case 2:
+		if (!script_anim && hud->script_anim_part == 0) return;
+		hud->m_model->PlayCycle(0, M, bMixIn, 0, 0, 0, speed);
+		hud->m_model->PlayCycle(2, M, bMixIn, 0, 0, 0, speed);
+		hud->m_model->dcast_PKinematics()->CalculateBones_Invalidate();
+		break;
+	}
+}
+
+void player_hud::StopScriptAnim()
+{
+	u8 part = script_anim_part;
+	script_anim_part = u8(-1);
+	script_anim_item_model = nullptr;
+	script_anim_lead_gun = false;
+
+	updateMovementLayerState();
+
+	if (part != 2 && !m_attached_items[part])
+		re_sync_anim(part + 1);
+	else
+		OnMovementChanged((ACTOR_DEFS::EMoveCommand) 0);
+}
+
+//part: 0 = right arm; 1 = left arm
+u32 player_hud::anim_play(u16 part, const MotionID& M, BOOL bMixIn, const CMotionDef*& md, float speed, u16 override_part)
+{
 	u16 part_id							= u16(-1);
 	if(attached_item(0) && attached_item(1))
-		part_id = m_model->partitions().part_id((part==0)?"right_hand":"left_hand");
+		part_id = ((part == 0) ? 2 : 1);
+	else
+		part_id = 0;
 
-	u16 pc					= m_model->partitions().count();
-	for(u16 pid=0; pid<pc; ++pid)
+	if (override_part != u16(-1))
+		part_id = override_part;
+	
+	play_blend(this, part_id, M, bMixIn, speed);
+
+	return motion_length(M, md, speed);
+}
+
+player_hud_motion_container* player_hud::get_hand_motions(LPCSTR section)
 	{
-		if(pid==0 || pid==part_id || part_id==u16(-1))
+	for (hand_motions* phm : m_hand_motions)
 		{
-			CBlend* B	= m_model->PlayCycle(pid, M, bMixIn);
-			R_ASSERT	(B);
-			B->speed	*= speed;
+		if (phm->section == section)
+			return &phm->pm;
 		}
+	
+	hand_motions* res = xr_new<hand_motions>();
+	res->section = section;
+	res->pm.load(m_model, section);
+	m_hand_motions.push_back(res);
+
+	return &res->pm;
 	}
-	m_model->dcast_PKinematics()->CalculateBones_Invalidate	();
 
-	return				motion_length(M, md, speed);
+void player_hud::update_script_item()
+{
+	Fvector ypr = item_pos[1];
+	ypr.mul(PI / 180.f);
+	m_attach_offset.setHPB(ypr.x, ypr.y, ypr.z);
+	m_attach_offset.translate_over(item_pos[0]);
+
+	calc_transform(m_attach_idx, m_attach_offset, m_item_pos, script_anim_lead_gun);
+
+	if (script_anim_item_model)
+	{
+		script_anim_item_model->UpdateTracks();
+		script_anim_item_model->dcast_PKinematics()->CalculateBones_Invalidate();
+		script_anim_item_model->dcast_PKinematics()->CalculateBones(TRUE);
+	}
 }
 
-void player_hud::update_additional	(Fmatrix& trans)
+// 0 = right arm + hand, 1 = left arm + hand, 2 = both
+u32 player_hud::script_anim_play(u8 hand, LPCSTR section, LPCSTR anm_name, bool bMixIn, float speed)
 {
-	if(m_attached_items[0])
-		m_attached_items[0]->update_hud_additional(trans);
+	if (!pSettings->section_exist(section))
+	{
+		Msg("!script motion section [%s] does not exist", section);
+		m_bStopAtEndAnimIsRunning = true;
+		script_anim_end = Device.dwTimeGlobal;
 
-	if(m_attached_items[1])
-		m_attached_items[1]->update_hud_additional(trans);
+		return 0;
+	}
+
+	xr_string pos = "hands_position";
+	xr_string rot = "hands_orientation";
+
+	if (UI().is_widescreen())
+	{
+		pos.append("_16x9");
+		rot.append("_16x9");
+	}
+	
+	Fvector def = { 0.f, 0.f, 0.f };
+	Fvector offs = READ_IF_EXISTS(pSettings, r_fvector3, section, pos.c_str(), def);
+	Fvector rrot = READ_IF_EXISTS(pSettings, r_fvector3, section, rot.c_str(), def);
+
+	if (pSettings->line_exist(section, "item_visual"))
+	{
+		::Render->hud_loading = true;
+		script_anim_item_model = ::Render->model_Create(pSettings->r_string(section, "item_visual"))->dcast_PKinematicsAnimated();
+		::Render->hud_loading = false;
+		item_pos[0] = READ_IF_EXISTS(pSettings, r_fvector3, section, "item_position", def);
+		item_pos[1] = READ_IF_EXISTS(pSettings, r_fvector3, section, "item_orientation", def);
+		script_anim_item_attached = READ_IF_EXISTS(pSettings, r_bool, section, "item_attached", true);
+		m_attach_idx = READ_IF_EXISTS(pSettings, r_u8, section, "attach_place_idx", 0);
+		script_anim_lead_gun = READ_IF_EXISTS(pSettings, r_bool, section, "lh_lead_gun", false);
+
+		if (!script_anim_item_attached)
+		{
+			Fmatrix attach_offs;
+			Fvector ypr = item_pos[1];
+			ypr.mul(PI / 180.f);
+			attach_offs.setHPB(ypr.x, ypr.y, ypr.z);
+			attach_offs.translate_over(item_pos[0]);
+			m_item_pos = attach_offs;
+		}
 }
 
+	script_anim_offset[0] = offs;
+	script_anim_offset[1] = rrot;
+	script_anim_part = hand;
 
-static const float PITCH_OFFSET_R	= 0.017f;
-static const float PITCH_OFFSET_N	= 0.012f;
-static const float PITCH_OFFSET_D	= 0.02f;
-static const float ORIGIN_OFFSET	= -0.05f;
-static const float TENDTO_SPEED		= 5.f;
+	player_hud_motion_container* pm = get_hand_motions(section);
+	player_hud_motion* phm = pm->find_motion(anm_name);
 
-void player_hud::update_inertion(Fmatrix& trans)
+	if (!phm)
 {
-	if ( inertion_allowed() )
+		Msg("!script motion [%s] not found in section [%s]", anm_name, section);
+		m_bStopAtEndAnimIsRunning = true;
+		script_anim_end = Device.dwTimeGlobal;
+
+		return 0;
+	}
+	
+	const motion_descr& M = phm->m_animations[Random.randI(phm->m_animations.size())];
+
+	if (script_anim_item_model)
 	{
-		Fmatrix								xform;
-		Fvector& origin						= trans.c; 
-		xform								= trans;
+		shared_str item_anm_name;
+		if (phm->m_base_name != phm->m_additional_name)
+			item_anm_name = phm->m_additional_name;
+		else
+			item_anm_name = M.name;
+
+		MotionID M2 = script_anim_item_model->ID_Cycle_Safe(item_anm_name);
+		if (!M2.valid())
+			M2 = script_anim_item_model->ID_Cycle_Safe("idle");
 
-		static Fvector						st_last_dir={0,0,0};
+		R_ASSERT3(M2.valid(), "model %s has no motion [idle] ", pSettings->r_string(m_sect_name, "item_visual"));
 
-		// calc difference
-		Fvector								diff_dir;
-		diff_dir.sub						(xform.k, st_last_dir);
+		u16 root_id = script_anim_item_model->dcast_PKinematics()->LL_GetBoneRoot();
+		CBoneInstance& root_binst = script_anim_item_model->dcast_PKinematics()->LL_GetBoneInstance(root_id);
+		root_binst.set_callback_overwrite(TRUE);
+		root_binst.mTransform.identity();
+
+		u16 pc = script_anim_item_model->partitions().count();
+		for (u16 pid = 0; pid < pc; ++pid)
+			CBlend* B = script_anim_item_model->PlayCycle(pid, M2, bMixIn, 0, 0, 0, speed);
 
-		// clamp by PI_DIV_2
-		Fvector last;						last.normalize_safe(st_last_dir);
-		float dot							= last.dotproduct(xform.k);
-		if (dot<EPS){
-			Fvector v0;
-			v0.crossproduct					(st_last_dir,xform.k);
-			st_last_dir.crossproduct		(xform.k,v0);
-			diff_dir.sub					(xform.k, st_last_dir);
+		script_anim_item_model->dcast_PKinematics()->CalculateBones_Invalidate();
 		}
 
-		// tend to forward
-		st_last_dir.mad						(diff_dir,TENDTO_SPEED*Device.fTimeDelta);
-		origin.mad							(diff_dir,ORIGIN_OFFSET);
+	play_blend(this, (hand == 2 ? 0 : hand == 0 ? 2 : 1), M.mid, bMixIn, speed, true);
 
-		// pitch compensation
-		float pitch							= angle_normalize_signed(xform.k.getP());
-		origin.mad							(xform.k,	-pitch * PITCH_OFFSET_D);
-		origin.mad							(xform.i,	-pitch * PITCH_OFFSET_R);
-		origin.mad							(xform.j,	-pitch * PITCH_OFFSET_N);
+	const CMotionDef* md;
+	u32 length = motion_length(M.mid, md, speed);
+
+	if (length > 0)
+	{
+		m_bStopAtEndAnimIsRunning = true;
+		script_anim_end = Device.dwTimeGlobal + length;
 	}
+	else
+		m_bStopAtEndAnimIsRunning = false;
+
+	updateMovementLayerState();
+
+	return length;
 }
 
+void player_hud::remove_from_model_pool(LPCSTR sect)
+{
+	xr_vector<attachable_hud_item*>::iterator it = m_pool.begin();
+	xr_vector<attachable_hud_item*>::iterator it_e = m_pool.end();
+	for (; it != it_e; ++it)
+	{
+		attachable_hud_item* itm = *it;
+		if (itm->m_sect_name == sect)
+		{
+			if (m_attached_items[0] && m_attached_items[0] == itm)
+				detach_item_idx(0);
+			else if (m_attached_items[1] && m_attached_items[1] == itm)
+				detach_item_idx(1);
 
+			m_pool.erase(it);
+			break;
+		}
+	}
+}
+
+shared_str current_player_hud_sect;
 attachable_hud_item* player_hud::create_hud_item(const shared_str& sect)
 {
+	current_player_hud_sect = sect;
 	xr_vector<attachable_hud_item*>::iterator it = m_pool.begin();
@@ -679,3 +1430,5 @@
 {
-	if(m_attached_items[1])
+	if (script_anim_part != u8(-1))
+		return false;
+	else if (m_attached_items[1])
 		return m_attached_items[1]->m_parent_hud_item->CheckCompatibility(item);
@@ -702,2 +1455,4 @@
 		item->on_a_hud_attach();
+
+		updateMovementLayerState();
 	}
@@ -706,18 +1461,50 @@
 
-void player_hud::detach_item_idx(u16 idx)
+//sync anim of other part to selected part (1 = sync to left hand anim; 2 = sync to right hand anim)
+void player_hud::re_sync_anim(u8 part)
+{
+	u32 bc = part == 1 ? m_model_2->LL_PartBlendsCount(part) : m_model->LL_PartBlendsCount(part);
+	for (u32 bidx = 0; bidx < bc; ++bidx)
 {
-	if( NULL==attached_item(idx) )					return;
+		CBlend* BR = part == 1 ? m_model_2->LL_PartBlend(part, bidx) : m_model->LL_PartBlend(part, bidx);
+		if (!BR)
+			continue;
 
-	m_attached_items[idx]->m_parent_hud_item->on_b_hud_detach();
+		MotionID M = BR->motionID;
 
-	m_attached_items[idx]->m_parent_hud_item		= NULL;
-	m_attached_items[idx]							= NULL;
+		u16 pc = m_model->partitions().count(); //same on both armatures
+		for (u16 pid = 0; pid < pc; ++pid)
+		{
+			if (pid == 0)
+			{
+				CBlend* B = m_model->PlayCycle(0, M, TRUE);
+				B->timeCurrent = BR->timeCurrent;
+				B->speed = BR->speed;
+				B = m_model_2->PlayCycle(0, M, TRUE);
+				B->timeCurrent = BR->timeCurrent;
+				B->speed = BR->speed;
+			}
+			else if (pid != part)
+			{
+				CBlend* B = part == 1 ? m_model->PlayCycle(pid, M, TRUE) : m_model_2->PlayCycle(pid, M, TRUE);
+				B->timeCurrent = BR->timeCurrent;
+				B->speed = BR->speed;
+			}
+		}
+	}
+}
 
-	if(idx==1 && attached_item(0))
+//set cycle time (0...1) part: 0 = root; 1 = left hand; 2 = right hand
+void player_hud::set_part_cycle_time(u8 part, float time)
+{
+	if (part == 0)
 	{
-		u16 part_idR			= m_model->partitions().part_id("right_hand");
-		u32 bc					= m_model->LL_PartBlendsCount(part_idR);
+		set_part_cycle_time(1, time);
+		set_part_cycle_time(2, time);
+		return;
+	}
+
+	u32 bc = part == 1 ? m_model_2->LL_PartBlendsCount(part) : m_model->LL_PartBlendsCount(part);
 		for(u32 bidx=0; bidx<bc; ++bidx)
 		{
-			CBlend* BR			= m_model->LL_PartBlend(part_idR, bidx);
+		CBlend* BR = part == 1 ? m_model_2->LL_PartBlend(part, bidx) : m_model->LL_PartBlend(part, bidx);
 			if(!BR)
@@ -725,23 +1512,63 @@
 
-			MotionID M			= BR->motionID;
+		BR->timeCurrent = BR->timeTotal * time;
+	}
+}
 
-			u16 pc					= m_model->partitions().count();
-			for(u16 pid=0; pid<pc; ++pid)
+//part: 0 = root; 1 = left hand; 2 = right hand
+void player_hud::set_part_cycle_speed(u8 part, float speed)
 			{
-				if(pid!=part_idR)
+	if (part == 0)
+	{
+		set_part_cycle_speed(1, speed);
+		set_part_cycle_speed(2, speed);
+	}
+	u32 bc = part == 1 ? m_model_2->LL_PartBlendsCount(part) : m_model->LL_PartBlendsCount(part);
+	for (u32 bidx = 0; bidx < bc; ++bidx)
+	{
+		CBlend* BR = part == 1 ? m_model_2->LL_PartBlend(part, bidx) : m_model->LL_PartBlend(part, bidx);
+		if (!BR)
+			continue;
+
+		BR->speed = speed;
+	}
+}
+
+void player_hud::detach_item_idx(u16 idx)
+{
+	if (NULL == m_attached_items[idx]) return;
+
+	m_attached_items[idx]->m_parent_hud_item->on_b_hud_detach();
+
+	m_attached_items[idx]->m_parent_hud_item = NULL;
+	m_attached_items[idx] = NULL;
+
+	if (idx == 1)
 				{
-					CBlend* B			= m_model->PlayCycle(pid, M, TRUE);//this can destroy BR calling UpdateTracks !
-					if( BR->blend_state() != CBlend::eFREE_SLOT )
+		if (m_attached_items[0])
+			re_sync_anim(2);
+		else
 					{
-						u16 bop				= B->bone_or_part;
-						*B					= *BR;
-						B->bone_or_part		= bop;
+			m_model_2->PlayCycle("hand_idle_doun");
 					}
 				}
+	else if (idx == 0)
+	{
+		if (m_attached_items[1])
+		{
+			//fix for a rare case where the right hand stays visible on screen after detaching the right hand's attached item
+			player_hud_motion* pm = m_attached_items[1]->m_hand_motions.find_motion("anm_idle");
+			const motion_descr& M = pm->m_animations[0];
+			m_model->PlayCycle(0, M.mid, false);
+			m_model->PlayCycle(2, M.mid, false);
+		}
+		else
+		{
+			m_model->PlayCycle("hand_idle_doun");
 			}
 		}
-	}else
-	if(idx==0 && attached_item(1))
+
+	if (!m_attached_items[0] && !m_attached_items[1])
 	{
-		OnMovementChanged(mcAnyMove);
+		m_model->PlayCycle("hand_idle_doun");
+		m_model_2->PlayCycle("hand_idle_doun");
 	}
@@ -760,6 +1587,19 @@
 
-void player_hud::calc_transform(u16 attach_slot_idx, const Fmatrix& offset, Fmatrix& result)
+bool player_hud::allow_script_anim()
+{
+	if (m_attached_items[0] && (m_attached_items[0]->m_parent_hud_item->IsPending() || m_attached_items[0]->m_parent_hud_item->GetState() == CHudItem::EHudStates::eBore))
+		return false;
+	else if (m_attached_items[1] && (m_attached_items[1]->m_parent_hud_item->IsPending() || m_attached_items[1]->m_parent_hud_item->GetState() == CHudItem::EHudStates::eBore))
+		return false;
+	else if (script_anim_part != u8(-1))
+		return false;
+
+	return true;
+}
+
+void player_hud::calc_transform(u16 attach_slot_idx, const Fmatrix& offset, Fmatrix& result, bool leadGun)
 {
-	Fmatrix ancor_m			= m_model->dcast_PKinematics()->LL_GetTransform(m_ancors[attach_slot_idx]);
-	result.mul				(m_transform, ancor_m);
+	IKinematics* kin = (attach_slot_idx == 0) ? m_model->dcast_PKinematics() : m_model_2->dcast_PKinematics();
+	Fmatrix ancor_m =  kin->LL_GetTransform(m_ancors[(leadGun ? 0 : attach_slot_idx)]);
+	result.mul((attach_slot_idx == 0) ? m_transform : m_transform_2, ancor_m);
 	result.mulB_43			(offset);
@@ -800,2 +1641,10 @@
 	}
+
+	luabind::functor<void> func;
+	if (ai().script_engine().functor("_g.player_hud__OnMovementChanged", func))
+	{
+		func(cmd);
+	}
+
+	updateMovementLayerState();
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/player_hud.h xray-monolith/src/xrGame/player_hud.h
--- coc-1.4-xray-64/src/xrGame/player_hud.h	2023-10-20 20:54:51.206326900 +0100
+++ xray-monolith/src/xrGame/player_hud.h	2023-10-20 20:54:33.136035800 +0100
@@ -2,3 +2,3 @@
 #include "firedeps.h"
-
+#include "../xrEngine/ObjectAnimator.h"
 #include "../Include/xrRender/Kinematics.h"
@@ -22,2 +22,3 @@
 	shared_str				m_additional_name;
+	float m_anim_speed, m_anim_end = 0.f;
 	xr_vector<motion_descr>	m_animations;
@@ -32,2 +33,164 @@
 
+struct hand_motions
+{
+	shared_str section;
+	player_hud_motion_container pm;
+};
+
+enum eMovementLayers
+{
+	eAimWalk = 0,
+	eAimCrouch,
+	eCrouch,
+	eWalk,
+	eRun,
+	eSprint,
+	move_anms_end
+};
+
+struct movement_layer
+{
+	CObjectAnimator* anm;
+	float blend_amount[2];
+	bool active;
+	float m_power;
+	Fmatrix blend;
+	u8 m_part;
+
+	movement_layer()
+	{
+		blend.identity();
+		anm = xr_new<CObjectAnimator>();
+		blend_amount[0] = 0.f;
+		blend_amount[1] = 0.f;
+		active = false;
+		m_power = 1.f;
+	}
+
+	void Load(LPCSTR name)
+	{
+		if (xr_strcmp(name, anm->Name()))
+			anm->Load(name);
+	}
+
+	void Play(bool bLoop = true)
+	{
+		if (!anm->Name())
+			return;
+
+		if (IsPlaying())
+		{
+			active = true;
+			return;
+		}
+		
+		anm->Play(bLoop);
+		active = true;
+	}
+
+	bool IsPlaying()
+	{
+		return anm->IsPlaying();
+	}
+
+	void Stop(bool bForce)
+	{
+		if (bForce)
+		{
+			anm->Stop();
+			blend_amount[0] = 0.f;
+			blend_amount[1] = 0.f;
+			blend.identity();
+		}
+
+		active = false;
+	}
+
+	const Fmatrix& XFORM(u8 part)
+	{
+		blend.set(anm->XFORM());
+		blend.mul(blend_amount[part] * m_power);
+		blend.m[0][0] = 1.f;
+		blend.m[1][1] = 1.f;
+		blend.m[2][2] = 1.f;
+
+		return blend;
+	}
+};
+
+struct script_layer
+{
+	shared_str m_name;
+	CObjectAnimator* anm;
+	float blend_amount;
+	float m_power;
+	bool active;
+	Fmatrix blend;
+	u8 m_part;
+
+	script_layer(LPCSTR name, u8 part, float speed = 1.f, float power = 1.f, bool looped = true)
+	{
+		m_name = name;
+		m_part = part;
+		m_power = power;
+		blend.identity();
+		anm = xr_new<CObjectAnimator>();
+		anm->Load(name);
+		anm->Play(looped);
+		anm->Speed() = speed;
+		blend_amount = 0.f;
+		active = true;
+	}
+
+	bool IsPlaying()
+	{
+		return anm->IsPlaying();
+	}
+
+	void Stop(bool bForce)
+	{
+		if (bForce)
+		{
+			anm->Stop();
+			blend_amount = 0.f;
+			blend.identity();
+		}
+
+		active = false;
+	}
+
+	const Fmatrix& XFORM()
+	{
+		blend.set(anm->XFORM());
+		blend.mul(blend_amount * m_power);
+		blend.m[0][0] = 1.f;
+		blend.m[1][1] = 1.f;
+		blend.m[2][2] = 1.f;
+
+		return blend;
+	}
+};
+
+struct BoneCallbackParams
+{
+	Fvector m_current;
+	Fvector m_target;
+
+	BoneCallbackParams()
+	{
+		m_current = { 0,0,0 };
+		m_target = { 0,0,0 };
+	}
+};
+
+enum EBoneCallbackParam
+{
+	r_finger0 = 0,
+	r_finger01,
+	r_finger02,
+	//bip01_r_finger1,
+	//bip01_r_finger11,
+	//bip01_r_finger12,
+};
+
 struct hud_item_measures
@@ -38,4 +202,4 @@
 	Fvector							m_item_attach[2];//pos,rot
-
-	Fvector							m_hands_offset[2][3];//pos,rot/ normal,aim,GL
+	Fvector m_hands_offset[2][5]; // pos,rot/ normal,aim,GL,aim_alt,safemode --#SM+#--
+	Fvector m_strafe_offset[4][2]; // pos,rot,data1,data2/ normal,aim-GL	 --#SM+#--
 
@@ -45,2 +209,3 @@
 	Fvector							m_fire_point2_offset;
+	Fvector m_fire_direction;
 	u16								m_shell_bone;
@@ -51,2 +216,34 @@
 	void load						(const shared_str& sect_name, IKinematics* K);
+
+	struct inertion_params
+	{
+		float m_tendto_speed;
+		float m_tendto_speed_aim;
+		float m_tendto_ret_speed;
+		float m_tendto_ret_speed_aim;
+
+		float m_min_angle;
+		float m_min_angle_aim;
+
+		Fvector4 m_offset_LRUD;
+		Fvector4 m_offset_LRUD_aim;
+	};
+
+	inertion_params m_inertion_params; //--#SM+#--
+
+	struct shooting_params
+	{
+		bool bShootShake;
+		Fvector4 m_shot_max_offset_LRUD;
+		Fvector4 m_shot_max_offset_LRUD_aim;
+		Fvector2 m_shot_offset_BACKW;
+		float m_ret_speed;
+		float m_ret_speed_aim;
+		float m_min_LRUD_power;
+	};
+
+	shooting_params m_shooting_params; //--#SM+#--
+
+	float m_fFreelookZOffset;
+	bool m_bLeadGunLeftHand;
 };
@@ -68,3 +265,4 @@
 			
-			attachable_hud_item		(player_hud* pparent):m_parent(pparent),m_upd_firedeps_frame(u32(-1)),m_parent_hud_item(NULL),m_model(NULL),m_attach_place_idx(0){}
+	attachable_hud_item(player_hud* pparent): m_parent(pparent), m_upd_firedeps_frame(u32(-1)), m_parent_hud_item(nullptr),
+	                                          m_model(nullptr), m_attach_place_idx(0) {}
 			~attachable_hud_item	();
@@ -72,3 +270,2 @@
 	void update						(bool bForce);
-	void update_hud_additional		(Fmatrix& trans);
 	void setup_firedeps				(firedeps& fd);
@@ -80,3 +277,3 @@
 	void debug_draw_firedeps		();
-
+	player_hud_motion* find_motion(const shared_str& anm_name);
 	//hands bind position
@@ -92,4 +289,3 @@
 	void		tune				(Ivector values);
-	u32			anim_play			(const shared_str& anim_name, BOOL bMixIn, const CMotionDef*& md, u8& rnd);
-
+	u32 anim_play(const shared_str& anim_name, BOOL bMixIn, const CMotionDef*& md, u8& rnd, float speed = 0, bool bMixIn2 = true);
 };
@@ -101,5 +297,13 @@
 					~player_hud			();
-	void			load				(const shared_str& model_name);
+	void load(const shared_str& model_name, bool force = false);
+	void load_script(LPCSTR section);
+	void reset_model_script() { script_override_arms = false; load(m_sect_name, true); };
 	void			load_default		(){load("actor_hud_05");};
 	void			update				(const Fmatrix& trans);
+	void updateMovementLayerState();
+	void StopScriptAnim();
+	void PlayBlendAnm(LPCSTR name, u8 part = 0, float speed = 1.f, float power = 1.f, bool bLooped = true, bool no_restart = false);
+	void StopBlendAnm(LPCSTR name, bool bForce = false);
+	void StopAllBlendAnms(bool bForce);
+	float SetBlendAnmTime(LPCSTR name, float time);
 	void			render_hud			();	
@@ -107,4 +311,28 @@
 	bool			render_item_ui_query();
-	u32				anim_play			(u16 part, const MotionID& M, BOOL bMixIn, const CMotionDef*& md, float speed);
+	u32 anim_play(u16 part, const MotionID& M, BOOL bMixIn, const CMotionDef*& md, float speed, u16 override_part = u16(-1));
+	u32 script_anim_play(u8 hand, LPCSTR itm_name, LPCSTR anm_name, bool bMixIn = true, float speed = 1.f);
 	const shared_str& section_name		() const {return m_sect_name;}
+	void remove_from_model_pool(LPCSTR sect);
+
+	u8 script_anim_part;
+	Fvector script_anim_offset[2];
+	u32 script_anim_end;
+	float script_anim_offset_factor;
+	bool m_bStopAtEndAnimIsRunning;
+	bool script_anim_item_attached;
+	bool script_override_arms;
+	bool script_anim_lead_gun;
+	IKinematicsAnimated* script_anim_item_model;
+	Fvector item_pos[2];
+	Fmatrix m_item_pos;
+	u8 m_attach_idx;
+
+	//Movement animation layers: 0 = aim_walk, 1 = aim_crouch, 2 = crouch, 3 = walk, 4 = run, 5 = sprint
+	xr_vector<movement_layer*> m_movement_layers;
+	xr_vector<script_layer*> m_script_layers;
+
+	xr_vector<hand_motions*> m_hand_motions;
+	player_hud_motion_container* get_hand_motions(LPCSTR section);
+
+	void update_script_item();
 
@@ -113,2 +341,5 @@
 	void			attach_item			(CHudItem* item);
+	void re_sync_anim(u8 part);
+	void set_part_cycle_time(u8 part, float time);
+	void set_part_cycle_speed(u8 part, float speed);
 	bool			allow_activation	(CHudItem* item);
@@ -117,23 +348,29 @@
 	void			detach_item			(CHudItem* item);
-	void			detach_all_items	(){m_attached_items[0]=NULL; m_attached_items[1]=NULL;};
 
-	void			calc_transform		(u16 attach_slot_idx, const Fmatrix& offset, Fmatrix& result);
+	bool allow_script_anim();
+
+	void detach_all_items()
+	{
+		m_attached_items[0] = NULL;
+		m_attached_items[1] = NULL;
+	};
+
+	Fmatrix m_transform;
+	Fmatrix m_transform_2;
+
+	Fmatrix m_attach_offset;
+	Fmatrix m_attach_offset_2;
+
+	void calc_transform(u16 attach_slot_idx, const Fmatrix& offset, Fmatrix& result, bool leadGun = false);
 	void			tune				(Ivector values);
 	u32				motion_length		(const MotionID& M, const CMotionDef*& md, float speed);
+	u32 motion_length_script(LPCSTR section, LPCSTR anm_name, float speed);
 	u32				motion_length		(const shared_str& anim_name, const shared_str& hud_name, const CMotionDef*& md);
 	void			OnMovementChanged	(ACTOR_DEFS::EMoveCommand cmd)	;
-private:
-	void			update_inertion		(Fmatrix& trans);
-	void			update_additional	(Fmatrix& trans);
 	bool			inertion_allowed	();
 private:
-	const Fvector&	attach_rot			() const;
-	const Fvector&	attach_pos			() const;
+	const Fvector& attach_rot(u8 part) const;
+	const Fvector& attach_pos(u8 part) const;
 
 	shared_str							m_sect_name;
-
-	Fmatrix								m_attach_offset;
-
-	Fmatrix								m_transform;
-	IKinematicsAnimated*				m_model;
 	xr_vector<u16>						m_ancors;
@@ -141,5 +378,51 @@
 	xr_vector<attachable_hud_item*>		m_pool;
+	static void _BCL FingerCallback(CBoneInstance* B);
+public:
+	IKinematicsAnimated* m_model;
+	IKinematicsAnimated* m_model_2;
+	Fvector m_adjust_offset[2][5]; // pos,rot/ normal,aim,GL,aim_alt,safemode
+	Fvector m_adjust_obj[2]; // pos,rot; used for the item/weapon itself
+	Fvector m_adjust_ui_offset[2]; // pos,rot; used for custom device ui
+	Fvector m_adjust_firepoint_shell[2][2];
+	xr_map<EBoneCallbackParam, BoneCallbackParams*> m_bone_callback_params; // bonename,params
+	int m_edit_attachment;
+	float m_adjust_zoom_factor[3];
+	bool m_adjust_mode;
+	u16 m_edit_bone;
 
+	void reset_thumb(bool bForce)
+	{
+		if (bForce)
+		{
+			m_bone_callback_params[r_finger0]->m_current.set(0.f, 0.f, 0.f);
+			m_bone_callback_params[r_finger01]->m_current.set(0.f, 0.f, 0.f);
+			m_bone_callback_params[r_finger02]->m_current.set(0.f, 0.f, 0.f);
+		}
+		
+		m_bone_callback_params[r_finger0]->m_target.set(0.f, 0.f, 0.f);
+		m_bone_callback_params[r_finger01]->m_target.set(0.f, 0.f, 0.f);
+		m_bone_callback_params[r_finger02]->m_target.set(0.f, 0.f, 0.f);
+	}
+
+	/*void reset_triggerfinger(bool bForce)
+	{
+		if (bForce)
+		{
+			m_bone_callback_params[bip01_r_finger1]->m_current.set(0.f, 0.f, 0.f);
+			m_bone_callback_params[bip01_r_finger11]->m_current.set(0.f, 0.f, 0.f);
+			m_bone_callback_params[bip01_r_finger12]->m_current.set(0.f, 0.f, 0.f);
+		}
+
+		m_bone_callback_params[bip01_r_finger1]->m_target.set(0.f, 0.f, 0.f);
+		m_bone_callback_params[bip01_r_finger11]->m_target.set(0.f, 0.f, 0.f);
+		m_bone_callback_params[bip01_r_finger12]->m_target.set(0.f, 0.f, 0.f);
+	}*/
+
+	DECLARE_SCRIPT_REGISTER_FUNCTION
 };
 
+add_to_type_list(player_hud)
+#undef script_type_list
+#define script_type_list save_type_list(player_hud)
+
 extern player_hud* g_player_hud;
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/pp_effector_custom.cpp xray-monolith/src/xrGame/pp_effector_custom.cpp
--- coc-1.4-xray-64/src/xrGame/pp_effector_custom.cpp	2023-10-20 20:54:51.219326700 +0100
+++ xray-monolith/src/xrGame/pp_effector_custom.cpp	2023-10-20 20:54:33.150035600 +0100
@@ -78,8 +81,7 @@
 {
-	if (m_effector) {
+	if (m_effector)
+	{
 		if (check_completion())				deactivate();
-	} else if (check_start_conditions())	activate();
 }
-
-
-
+	else if (check_start_conditions()) activate();
+}
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/problem_solver_inline.h xray-monolith/src/xrGame/problem_solver_inline.h
--- coc-1.4-xray-64/src/xrGame/problem_solver_inline.h	2023-10-20 20:54:51.220327400 +0100
+++ xray-monolith/src/xrGame/problem_solver_inline.h	2023-10-20 20:54:33.151037200 +0100
@@ -225,7 +234,11 @@
 TEMPLATE_SPECIALIZATION
-IC	const typename CProblemSolverAbstract::_index_type &CProblemSolverAbstract::value(const _index_type &vertex_index, const_iterator &i, bool reverse_search) const
+IC const typename CProblemSolverAbstract::_index_type&CProblemSolverAbstract::value(
+	const _index_type& vertex_index, const_iterator& i, bool reverse_search) const
+{
+	if (reverse_search)
 {
-	if (reverse_search) {
-		if ((*i).m_operator->applicable_reverse((*i).m_operator->effects(),(*i).m_operator->conditions(),vertex_index))
-			m_applied			= (*i).m_operator->apply_reverse(vertex_index,(*i).m_operator->effects(),m_temp,(*i).m_operator->conditions());
+		if ((*i).m_operator->applicable_reverse((*i).m_operator->effects(), (*i).m_operator->conditions(), vertex_index)
+		)
+			m_applied = (*i).m_operator->apply_reverse(vertex_index, (*i).m_operator->effects(), m_temp,
+			                                           (*i).m_operator->conditions());
 		else
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/profile_store.cpp xray-monolith/src/xrGame/profile_store.cpp
--- coc-1.4-xray-64/src/xrGame/profile_store.cpp	2023-10-20 20:54:51.221326700 +0100
+++ xray-monolith/src/xrGame/profile_store.cpp	2023-10-20 20:54:33.153035500 +0100
@@ -2,4 +2,2 @@
 #include "profile_store.h"
-#include "GameSpy/GameSpy_Full.h"
-#include "GameSpy/GAmeSpy_SAKE.h"
 #include "MainMenu.h"
@@ -22,5 +18,5 @@
 {
-	VERIFY(fullgs_obj && fullgs_obj->GetGameSpySAKE());
-	m_fullgs_obj		= fullgs_obj;
-	m_sake_obj			= fullgs_obj->GetGameSpySAKE();
+		//VERIFY(fullgs_obj && fullgs_obj->GetGameSpySAKE());
+		//m_fullgs_obj		= fullgs_obj;
+		//m_sake_obj			= fullgs_obj->GetGameSpySAKE();
 
@@ -58,3 +54,3 @@
 #endif
-	m_fullgs_obj->CoreThink(10);	//10 milliseconds on update
+		//m_fullgs_obj->CoreThink(10);	//10 milliseconds on update
 }
@@ -64,3 +60,3 @@
 	VERIFY(m_sake_obj);
-	m_sake_obj->SetProfile(profileId, loginTicket);
+		//m_sake_obj->SetProfile(profileId, loginTicket);
 }
@@ -70,21 +66,21 @@
 {
-	if (!complete_cb)
-	{
-		complete_cb.bind(this, &profile_store::onlylog_completion);
-	}
-	gamespy_gp::login_manager*	tmp_lmngr		= MainMenu()->GetLoginMngr();
-	R_ASSERT(tmp_lmngr);
-	gamespy_gp::profile const * tmp_curr_prof	= tmp_lmngr->get_current_profile();
-	if (!tmp_curr_prof)
-	{
-		complete_cb(false, "mp_first_need_to_login");
-		return;
-	}
-	set_current_profile				(
-		tmp_curr_prof->m_profile_id,
-		tmp_curr_prof->m_login_ticket.c_str()
-	);
+		//if (!complete_cb)
+		//{
+		//	complete_cb.bind(this, &profile_store::onlylog_completion);
+		//}
+		//gamespy_gp::login_manager*	tmp_lmngr		= MainMenu()->GetLoginMngr();
+		//R_ASSERT(tmp_lmngr);
+		//gamespy_gp::profile const * tmp_curr_prof	= tmp_lmngr->get_current_profile();
+		//if (!tmp_curr_prof)
+		//{
+		//	complete_cb(false, "mp_first_need_to_login");
+		//	return;
+		//}
+		//set_current_profile				(
+		//	tmp_curr_prof->m_profile_id,
+		//	tmp_curr_prof->m_login_ticket.c_str()
+		//);
 
-	load_prof_params_t	tmp_args(progress_indicator_cb);
-	m_load_current_profile_qam.execute(this, tmp_args, complete_cb);
+		//load_prof_params_t	tmp_args(progress_indicator_cb);
+		//m_load_current_profile_qam.execute(this, tmp_args, complete_cb);
 }
@@ -154,10 +151,10 @@
 	{
-		s32 tmp_profile_id = m_dsigned_reader.get_ltx().r_s32(
-			profile_data_section, profile_id_line
-		);
-		gamespy_gp::login_manager*	tmp_lmngr		= MainMenu()->GetLoginMngr();
-		R_ASSERT(tmp_lmngr);
-		gamespy_gp::profile const * tmp_curr_prof	= tmp_lmngr->get_current_profile();
-		R_ASSERT(tmp_curr_prof);
-		m_valid_ltx = (tmp_profile_id == tmp_curr_prof->m_profile_id);
+			//s32 tmp_profile_id = m_dsigned_reader.get_ltx().r_s32(
+			//	profile_data_section, profile_id_line
+			//);
+			//gamespy_gp::login_manager*	tmp_lmngr		= MainMenu()->GetLoginMngr();
+			//R_ASSERT(tmp_lmngr);
+			//gamespy_gp::profile const * tmp_curr_prof	= tmp_lmngr->get_current_profile();
+			//R_ASSERT(tmp_curr_prof);
+			//m_valid_ltx = (tmp_profile_id == tmp_curr_prof->m_profile_id);
 	}
@@ -193,5 +190,5 @@
 	VERIFY(i == merged_fields_count);
-	m_get_records_input.mNumFields	= i; 
-	m_get_records_input.mFieldNames = m_field_names_store;
-	m_get_records_input.mTableId	= profile_table_name;
+		//m_get_records_input.mNumFields	= i; 
+		//m_get_records_input.mFieldNames = m_field_names_store;
+		//m_get_records_input.mTableId	= profile_table_name;
 }
@@ -200,36 +197,36 @@
 {
-	SAKERequest reqres = m_sake_obj->GetMyRecords(
-		&m_get_records_input,
-		&profile_store::get_my_fields_cb,
-		this
-	);
-	
-	if (!reqres)
-	{
-		SAKEStartRequestResult tmp_result	= m_sake_obj->GetRequestResult();
-		loaded_fields(false, CGameSpy_SAKE::TryToTranslate(tmp_result).c_str());
-	}
-}
-
-void __cdecl profile_store::get_my_fields_cb(SAKE sake,
-											 SAKERequest request,
-											 SAKERequestResult result,
-											 void * inputData,
-											 void * outputData,
-											 void * userData)
-{
-	profile_store* my_inst = static_cast<profile_store*>(userData);
-	if (result != SAKERequestResult_SUCCESS)
-	{
-		my_inst->loaded_fields(false, CGameSpy_SAKE::TryToTranslate(result).c_str());
-		return;
-	}
-	SAKEGetMyRecordsOutput*	tmp_out		= static_cast<SAKEGetMyRecordsOutput*>(
-		outputData
-	);
-	VERIFY(tmp_out);
-	my_inst->m_awards_store->process_aw_out_response(tmp_out, merged_fields_count);
-	my_inst->m_best_scores_store->process_scores_out_response(tmp_out, merged_fields_count);
-	my_inst->loaded_fields(true, "");
-}
+		//SAKERequest reqres = m_sake_obj->GetMyRecords(
+		//	&m_get_records_input,
+		//	&profile_store::get_my_fields_cb,
+		//	this
+		//);
+		//
+		//if (!reqres)
+		//{
+		//	SAKEStartRequestResult tmp_result	= m_sake_obj->GetRequestResult();
+		//	loaded_fields(false, CGameSpy_SAKE::TryToTranslate(tmp_result).c_str());
+		//}
+	}
+
+	//void __cdecl profile_store::get_my_fields_cb(SAKE sake,
+	//											 SAKERequest request,
+	//											 SAKERequestResult result,
+	//											 void * inputData,
+	//											 void * outputData,
+	//											 void * userData)
+	//{
+	//	profile_store* my_inst = static_cast<profile_store*>(userData);
+	//	if (result != SAKERequestResult_SUCCESS)
+	//	{
+	//		my_inst->loaded_fields(false, CGameSpy_SAKE::TryToTranslate(result).c_str());
+	//		return;
+	//	}
+	//	SAKEGetMyRecordsOutput*	tmp_out		= static_cast<SAKEGetMyRecordsOutput*>(
+	//		outputData
+	//	);
+	//	VERIFY(tmp_out);
+	//	my_inst->m_awards_store->process_aw_out_response(tmp_out, merged_fields_count);
+	//	my_inst->m_best_scores_store->process_scores_out_response(tmp_out, merged_fields_count);
+	//	my_inst->loaded_fields(true, "");
+	//}
 
@@ -310,5 +307,5 @@
 		{
-			atlas_submit_queue* tmp_submit_queue = MainMenu()->GetSubmitQueue();
-			VERIFY(tmp_submit_queue);
-			tmp_submit_queue->submit_all();
+				//atlas_submit_queue* tmp_submit_queue = MainMenu()->GetSubmitQueue();
+				//VERIFY(tmp_submit_queue);
+				//tmp_submit_queue->submit_all();
 		}
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/profile_store.h xray-monolith/src/xrGame/profile_store.h
--- coc-1.4-xray-64/src/xrGame/profile_store.h	2023-10-20 20:54:51.222326500 +0100
+++ xray-monolith/src/xrGame/profile_store.h	2023-10-20 20:54:33.153035500 +0100
@@ -81,3 +80,3 @@
 	merged_fields_names_t	m_field_names_store;
-	SAKEGetMyRecordsInput	m_get_records_input;
+		//SAKEGetMyRecordsInput	m_get_records_input;
 	
@@ -93,8 +91,8 @@
 
-	static void __cdecl	get_my_fields_cb			(SAKE sake,
-													 SAKERequest request,
-													 SAKERequestResult result,
-													 void * inputData,
-													 void * outputData,
-													 void * userData);
+		//static void __cdecl	get_my_fields_cb			(SAKE sake,
+		//												 SAKERequest request,
+		//												 SAKERequestResult result,
+		//												 void * inputData,
+		//												 void * outputData,
+		//												 void * userData);
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/purchase_list.cpp xray-monolith/src/xrGame/purchase_list.cpp
--- coc-1.4-xray-64/src/xrGame/purchase_list.cpp	2023-10-20 20:54:51.227326800 +0100
+++ xray-monolith/src/xrGame/purchase_list.cpp	2023-10-20 20:54:33.158036500 +0100
@@ -58,5 +60,6 @@
 	const ALife::_OBJECT_ID	&id = owner.ID();
-	CRandom					random((u32)(CPU::QPC() & u32(-1)));
-	for (u32 i=0, j=0; i<count; ++i) {
-		if (random.randF() > probability)
+	u32 j = 0;
+	for (u32 i = 0; i < count; ++i)
+	{
+		if (::Random.randF(0.f, 1.f) > probability)
 			continue;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/raypick.h xray-monolith/src/xrGame/raypick.h
--- coc-1.4-xray-64/src/xrGame/raypick.h	2023-10-20 20:54:51.232326800 +0100
+++ xray-monolith/src/xrGame/raypick.h	2023-10-20 20:54:33.163035800 +0100
@@ -4,2 +4,3 @@
 #include "../xrcdb/xr_collide_defs.h"
+#include "material_manager.h"
 
@@ -11,3 +12,29 @@
 
-	script_rq_result() {O = 0; range = 0; element = 0;};
+	// Material of tri of ray query result
+	str_c pMaterialName;
+	u32 pMaterialFlags;
+
+	// physics part
+	float fPHFriction; // ?
+	float fPHDamping; // ?
+	float fPHSpring; // ?
+	float fPHBounceStartVelocity; // ?
+	float fPHBouncing; // ?
+					   // shoot&bounce&visibility&flotation
+	float fFlotationFactor; // 0.f - 1.f (1.f-ïîëíîñòüþ ïðîõîäèìûé)
+	float fShootFactor; // 0.f - 1.f (1.f-ïîëíîñòüþ ïðîñòðåëèâàåìûé)
+	float fShootFactorMP; // 0.f - 1.f (1.f-ïîëíîñòüþ ïðîñòðåëèâàåìûé)
+	float fBounceDamageFactor; // 0.f - 100.f
+	float fInjuriousSpeed; // 0.f - ... (0.f-íå îòáèðàåò çäîðîâüå (ñêîðîñòü óìåíüøåíèÿ çäîðîâüÿ))
+	float fVisTransparencyFactor; // 0.f - 1.f (1.f-ïîëíîñòüþ ïðîçðà÷íûé)
+	float fSndOcclusionFactor; // 0.f - 1.f (1.f-ïîëíîñòüþ ñëûøåí)
+	float fDensityFactor;
+
+	script_rq_result()
+	{
+		O = 0;
+		range = 0;
+		element = 0;
+	};
+
 	void set(collide::rq_result& R) 
@@ -22,2 +49,26 @@
 		element = R.element;
+
+		// demonized: set material params of ray pick result
+		//Msg("no object, check material");
+		auto pTri = Level().ObjectSpace.GetStaticTris() + R.element;
+		auto pMaterial = GMLib.GetMaterialByIdx(pTri->material);
+		auto pMaterialFlagsRQ = pMaterial->Flags;
+		//pTri = pTri;
+		//pMaterial = pMaterial;
+		pMaterialFlags = pMaterialFlagsRQ.flags;
+		pMaterialName = pMaterial->m_Name.c_str();
+
+		fPHFriction = pMaterial->fPHFriction;
+		fPHDamping = pMaterial->fPHDamping;
+		fPHSpring = pMaterial->fPHSpring;
+		fPHBounceStartVelocity = pMaterial->fPHBounceStartVelocity;
+		fPHBouncing = pMaterial->fPHBouncing;
+		fFlotationFactor = pMaterial->fFlotationFactor;
+		fShootFactor = pMaterial->fShootFactor;
+		fShootFactorMP = pMaterial->fShootFactorMP;
+		fBounceDamageFactor = pMaterial->fBounceDamageFactor;
+		fInjuriousSpeed = pMaterial->fInjuriousSpeed;
+		fVisTransparencyFactor = pMaterial->fVisTransparencyFactor;
+		fSndOcclusionFactor = pMaterial->fSndOcclusionFactor;
+		fDensityFactor = pMaterial->fDensityFactor;
 	};
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/RegistryFuncs.cpp xray-monolith/src/xrGame/RegistryFuncs.cpp
--- coc-1.4-xray-64/src/xrGame/RegistryFuncs.cpp	2023-10-20 20:54:50.696326700 +0100
+++ xray-monolith/src/xrGame/RegistryFuncs.cpp	2023-10-20 20:54:32.649035500 +0100
@@ -2,5 +2,5 @@
 #include "RegistryFuncs.h"
-#include "../xrGameSpy/xrGameSpy_MainDefs.h"
 
 #define REGISTRY_BASE	HKEY_LOCAL_MACHINE
+#define REGISTRY_PATH	"Software\\GSC Game World\\STALKER-Anomaly\\"
 
@@ -14,3 +14,3 @@
 	{
-		Msg ("! Unable to find %s in registry", REGISTRY_PATH);
+		//Msg ("! Unable to find %s in registry", REGISTRY_PATH);
 		return false;
@@ -65,3 +68,3 @@
 	{
-		Msg ("! Unable to find %s in registry", REGISTRY_PATH);
+		//Msg ("! Unable to find %s in registry", REGISTRY_PATH);
 		return false;
@@ -71,3 +74,3 @@
 	{
-		Msg ("! Unable to find %s entry in registry", REGISTRY_PATH); 
+		//Msg ("! Unable to find %s entry in registry", REGISTRY_PATH); 
 		return false;
@@ -125,3 +132,3 @@
 	{
-		Msg ("! Unable to find %s in registry", REGISTRY_PATH);
+		//Msg ("! Unable to find %s in registry", REGISTRY_PATH);
 		return 0;
@@ -157,3 +164,3 @@
 	{
-		Msg ("! Unable to find %s in registry", REGISTRY_PATH);
+		//Msg ("! Unable to find %s in registry", REGISTRY_PATH);
 		return;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/relation_registry_fights.cpp xray-monolith/src/xrGame/relation_registry_fights.cpp
--- coc-1.4-xray-64/src/xrGame/relation_registry_fights.cpp	2023-10-20 20:54:51.234326600 +0100
+++ xray-monolith/src/xrGame/relation_registry_fights.cpp	2023-10-20 20:54:33.165035900 +0100
@@ -29,3 +30,4 @@
 	FIGHT_VECTOR& fights = fight_registry();
-	for(FIGHT_VECTOR_IT it = fights.begin(); it != fights.end(); it++)
+	FIGHT_VECTOR_IT it = fights.begin();
+	for (; it != fights.end(); it++)
 	{
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/restricted_object.cpp xray-monolith/src/xrGame/restricted_object.cpp
--- coc-1.4-xray-64/src/xrGame/restricted_object.cpp	2023-10-20 20:54:51.235326900 +0100
+++ xray-monolith/src/xrGame/restricted_object.cpp	2023-10-20 20:54:33.166039200 +0100
@@ -33,4 +33,8 @@
 	xr_vector<ALife::_OBJECT_ID>::const_iterator	E = restrictions.end();
-	for ( ; I != E; ++I) {
+	for (; I != E; ++I)
+	{
 		CSE_ALifeDynamicObject	*object = ai().alife().objects().object(*I);
+		if (!object)
+			continue;
+			
 		if (ai().game_graph().vertex(object->m_tGraphID)->level_id() != ai().level_graph().level_id())
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/reward_event_generator.cpp xray-monolith/src/xrGame/reward_event_generator.cpp
--- coc-1.4-xray-64/src/xrGame/reward_event_generator.cpp	2023-10-20 20:54:51.236327400 +0100
+++ xray-monolith/src/xrGame/reward_event_generator.cpp	2023-10-20 20:54:33.168035600 +0100
@@ -34,4 +33,4 @@
 	m_event_handlers->init		();
-	m_submit_queue				= MainMenu()->GetSubmitQueue();
-	VERIFY(m_submit_queue);
+		//m_submit_queue				= MainMenu()->GetSubmitQueue();
+		//VERIFY(m_submit_queue);
 }
@@ -60,3 +59,3 @@
 	m_state_accum->update	();
-	m_submit_queue->update	();
+		//m_submit_queue->update	();
 }
@@ -164,32 +167,32 @@
 
-	gamespy_profile::enum_awards_t tmp_award_type = static_cast<gamespy_profile::enum_awards_t>(award_id);
-	VERIFY(award_id < gamespy_profile::at_awards_count);
+		//gamespy_profile::enum_awards_t tmp_award_type = static_cast<gamespy_profile::enum_awards_t>(award_id);
+		//VERIFY(award_id < gamespy_profile::at_awards_count);
 
-	gamespy_gp::login_manager* tmp_lmngr			= MainMenu()->GetLoginMngr();
-	VERIFY(tmp_lmngr);
-	gamespy_gp::profile const * tmp_curr_prof		= tmp_lmngr->get_current_profile();
-	if (!tmp_curr_prof)
-	{
-		Msg("! ERROR: can't reward player - not logged in");
-		return;
-	}
-	if ((m_rewarded >= m_max_rewards) && (m_max_rewards != u32(-1)))
-	{
-		Msg("! You have been rewarded by award [%s], but maximum rewards per game reached... sorry :(",
-			gamespy_profile::get_award_name(tmp_award_type));
-		return;
-	}
-
-	game_cl_mp*	tmp_mp_game		= smart_cast<game_cl_mp*>(&Game());
-	VERIFY(tmp_mp_game);
-	tmp_mp_game->AddRewardTask	(award_id);
-	++m_rewarded;
-
-	if (!tmp_curr_prof->online())
-	{
-		Msg("* An offline player has been rewarded by [%s] award",
-			get_award_name(tmp_award_type));
-		return;
-	}
-	m_submit_queue->submit_reward(tmp_award_type);
+		//gamespy_gp::login_manager* tmp_lmngr			= MainMenu()->GetLoginMngr();
+		//VERIFY(tmp_lmngr);
+		//gamespy_gp::profile const * tmp_curr_prof		= tmp_lmngr->get_current_profile();
+		//if (!tmp_curr_prof)
+		//{
+		//	Msg("! ERROR: can't reward player - not logged in");
+		//	return;
+		//}
+		//if ((m_rewarded >= m_max_rewards) && (m_max_rewards != u32(-1)))
+		//{
+		//	Msg("! You have been rewarded by award [%s], but maximum rewards per game reached... sorry :(",
+		//		gamespy_profile::get_award_name(tmp_award_type));
+		//	return;
+		//}
+
+		//game_cl_mp*	tmp_mp_game		= smart_cast<game_cl_mp*>(&Game());
+		//VERIFY(tmp_mp_game);
+		//tmp_mp_game->AddRewardTask	(award_id);
+		//++m_rewarded;
+
+		//if (!tmp_curr_prof->online())
+		//{
+		//	Msg("* An offline player has been rewarded by [%s] award",
+		//		get_award_name(tmp_award_type));
+		//	return;
+		//}
+		//m_submit_queue->submit_reward(tmp_award_type);
 }
@@ -201,20 +204,20 @@
 
-	gamespy_gp::login_manager* tmp_lmngr			= MainMenu()->GetLoginMngr();
-	VERIFY(tmp_lmngr);
-	gamespy_gp::profile const * tmp_curr_prof		= tmp_lmngr->get_current_profile();
-	if (!tmp_curr_prof)
-	{
-		Msg("! ERROR: can't submit best scores - not logged in");
-		return;
-	}
-	if (!tmp_curr_prof->online())
-	{
-		return;
-	}
-
-	VERIFY(m_best_scores_helper);
-	m_best_scores_helper->fill_best_results(
-		m_submit_queue->get_best_results_store()
-	);
-	m_submit_queue->submit_best_results();
+		//gamespy_gp::login_manager* tmp_lmngr			= MainMenu()->GetLoginMngr();
+		//VERIFY(tmp_lmngr);
+		//gamespy_gp::profile const * tmp_curr_prof		= tmp_lmngr->get_current_profile();
+		//if (!tmp_curr_prof)
+		//{
+		//	Msg("! ERROR: can't submit best scores - not logged in");
+		//	return;
+		//}
+		//if (!tmp_curr_prof->online())
+		//{
+		//	return;
+		//}
+
+		//VERIFY(m_best_scores_helper);
+		//m_best_scores_helper->fill_best_results(
+		//	m_submit_queue->get_best_results_store()
+		//);
+		//m_submit_queue->submit_best_results();
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/reward_event_generator.h xray-monolith/src/xrGame/reward_event_generator.h
--- coc-1.4-xray-64/src/xrGame/reward_event_generator.h	2023-10-20 20:54:51.237327100 +0100
+++ xray-monolith/src/xrGame/reward_event_generator.h	2023-10-20 20:54:33.168035600 +0100
@@ -50,3 +51,3 @@
 	rewarding_event_handlers*				m_event_handlers;
-	atlas_submit_queue*						m_submit_queue;
+		//atlas_submit_queue*						m_submit_queue;
 	
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/safe_map_iterator_inline.h xray-monolith/src/xrGame/safe_map_iterator_inline.h
--- coc-1.4-xray-64/src/xrGame/safe_map_iterator_inline.h	2023-10-20 20:54:51.240326600 +0100
+++ xray-monolith/src/xrGame/safe_map_iterator_inline.h	2023-10-20 20:54:33.171035700 +0100
@@ -40,4 +40,7 @@
 	_const_iterator			I = m_objects.find(id);
-	if (I != m_objects.end()) {
+	if (I != m_objects.end())
+	{
+#ifdef DEBUG
 		THROW2				(no_assert,"Specified object has been already found in the registry!");
+#endif
 		return;
@@ -57,4 +60,7 @@
 	_iterator				I = m_objects.find(id);
-	if (I == m_objects.end()) {
+	if (I == m_objects.end())
+	{
+#ifdef DEBUG
 		THROW2				(no_assert,"Specified object hasn't been found in the registry!");
+#endif
 		return;
@@ -124,3 +131,5 @@
 	VERIFY				(I != m_objects.end());
-	for (u32 i=0; (I != m_objects.end()) && !time_over() && predicate(I,m_cycle_count,true); ++i) {
+	u32 i = 0;
+	for (; (I != m_objects.end()) && !time_over() && predicate(I, m_cycle_count, true); ++i)
+	{
 		update_next		();
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/script_bind_macroses.h xray-monolith/src/xrGame/script_bind_macroses.h
--- coc-1.4-xray-64/src/xrGame/script_bind_macroses.h	2023-10-20 20:54:51.250327000 +0100
+++ xray-monolith/src/xrGame/script_bind_macroses.h	2023-10-20 20:54:33.182035300 +0100
@@ -14,2 +14,3 @@
 #define _DECLARE_FUNCTION13(A,D,F,G,H)	D A (F f, G g, H h)
+#define _DECLARE_FUNCTION14(A,D)		D* A ()
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/script_entity.cpp xray-monolith/src/xrGame/script_entity.cpp
--- coc-1.4-xray-64/src/xrGame/script_entity.cpp	2023-10-20 20:54:51.257326700 +0100
+++ xray-monolith/src/xrGame/script_entity.cpp	2023-10-20 20:54:33.188035500 +0100
@@ -285,3 +298,10 @@
 
-	try {
+	if (!l_tpEntityAction)
+	{
+		ResetScriptData();
+		return;
+	}
+
+	try
+	{
 		bool			l_bCompleted;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/script_game_object.cpp xray-monolith/src/xrGame/script_game_object.cpp
--- coc-1.4-xray-64/src/xrGame/script_game_object.cpp	2023-10-20 20:54:51.259326600 +0100
+++ xray-monolith/src/xrGame/script_game_object.cpp	2023-10-20 20:54:33.191035500 +0100
@@ -43,2 +43,3 @@
 
+#include "UIGameSP.h"
 #include "uigamecustom.h"
@@ -46,2 +47,4 @@
 #include "InventoryBox.h"
+#include "Pda.h"
+#include "player_hud.h"
 
@@ -76,17 +79,32 @@
 BIND_FUNCTION10(&object(), CScriptGameObject::GetRange, CEntityAlive, ffGetRange, float, -1);
+
 BIND_FUNCTION10(&object(), CScriptGameObject::GetHealth, CEntityAlive, conditions().GetHealth, float, -1);
+BIND_FUNCTION01(&object(), CScriptGameObject::SetHealth, CEntityAlive, conditions().SetHealth, float, float);
+BIND_FUNCTION01(&object(), CScriptGameObject::ChangeHealth, CEntityAlive, conditions().ChangeHealth, float, float);
+
 BIND_FUNCTION10(&object(), CScriptGameObject::GetPsyHealth, CEntityAlive, conditions().GetPsyHealth, float, -1);
+BIND_FUNCTION01(&object(), CScriptGameObject::SetPsyHealth, CEntityAlive, conditions().SetPsyHealth, float, float);
+BIND_FUNCTION01(&object(), CScriptGameObject::ChangePsyHealth, CEntityAlive, conditions().ChangePsyHealth, float, float);
+
 BIND_FUNCTION10(&object(), CScriptGameObject::GetPower, CEntityAlive, conditions().GetPower, float, -1);
+BIND_FUNCTION01(&object(), CScriptGameObject::SetPower, CEntityAlive, conditions().SetPower, float, float);
+BIND_FUNCTION01(&object(), CScriptGameObject::ChangePower, CEntityAlive, conditions().ChangePower, float, float);
+
 BIND_FUNCTION10(&object(), CScriptGameObject::GetSatiety, CEntityAlive, conditions().GetSatiety, float, -1);
+BIND_FUNCTION01(&object(), CScriptGameObject::SetSatiety, CEntityAlive, conditions().SetSatiety, float, float);
+BIND_FUNCTION01(&object(), CScriptGameObject::ChangeSatiety, CEntityAlive, conditions().ChangeSatiety, float, float);
+
 BIND_FUNCTION10(&object(), CScriptGameObject::GetRadiation, CEntityAlive, conditions().GetRadiation, float, -1);
-BIND_FUNCTION10(&object(), CScriptGameObject::GetBleeding, CEntityAlive, conditions().BleedingSpeed, float, -1);
+BIND_FUNCTION01(&object(), CScriptGameObject::SetRadiation, CEntityAlive, conditions().SetRadiation, float, float);
+BIND_FUNCTION01(&object(), CScriptGameObject::ChangeRadiation, CEntityAlive, conditions().ChangeRadiation, float, float);
+
 BIND_FUNCTION10(&object(), CScriptGameObject::GetMorale, CEntityAlive, conditions().GetEntityMorale, float, -1);
-BIND_FUNCTION01(&object(), CScriptGameObject::SetHealth, CEntityAlive, conditions().ChangeHealth, float, float);
-BIND_FUNCTION01(&object(), CScriptGameObject::SetPsyHealth, CEntityAlive, conditions().ChangePsyHealth, float, float);
-BIND_FUNCTION01(&object(), CScriptGameObject::SetPower, CEntityAlive, conditions().ChangePower, float, float);
-BIND_FUNCTION01(&object(), CScriptGameObject::ChangeSatiety, CEntityAlive, conditions().ChangeSatiety, float, float);
-BIND_FUNCTION01(&object(), CScriptGameObject::SetRadiation, CEntityAlive, conditions().ChangeRadiation, float, float);
-BIND_FUNCTION01(&object(), CScriptGameObject::SetBleeding, CEntityAlive, conditions().ChangeBleeding, float, float);
-BIND_FUNCTION01(&object(), CScriptGameObject::SetCircumspection, CEntityAlive, conditions().ChangeCircumspection, float, float);
-BIND_FUNCTION01(&object(), CScriptGameObject::SetMorale, CEntityAlive, conditions().ChangeEntityMorale, float, float);
+BIND_FUNCTION01(&object(), CScriptGameObject::SetMorale, CEntityAlive, conditions().SetEntityMorale, float, float);
+BIND_FUNCTION01(&object(), CScriptGameObject::ChangeMorale, CEntityAlive, conditions().ChangeEntityMorale, float, float);
+
+BIND_FUNCTION10(&object(), CScriptGameObject::GetBleeding, CEntityAlive, conditions().BleedingSpeed, float, -1);
+BIND_FUNCTION01(&object(), CScriptGameObject::ChangeBleeding, CEntityAlive, conditions().ChangeBleeding, float, float);
+
+BIND_FUNCTION01(&object(), CScriptGameObject::ChangeCircumspection, CEntityAlive, conditions().ChangeCircumspection, float, float);
+
 BIND_FUNCTION02(&object(), CScriptGameObject::SetScriptControl, CScriptEntity, SetScriptControl, bool, LPCSTR, bool, shared_str);
@@ -162,7 +183,2 @@
 
-u16 CScriptGameObject::get_bone_id(LPCSTR bone_name) const
-{
-    return object().Visual()->dcast_PKinematics()->LL_BoneID(bone_name);
-}
-
 cphysics_shell_scripted* CScriptGameObject::get_physics_shell() const
@@ -312,12 +340,66 @@
 
-Fvector	CScriptGameObject::bone_position(LPCSTR bone_name) const
+u16 CScriptGameObject::bone_id(LPCSTR bone_name, bool bHud)
 {
-    u16					bone_id;
+	IKinematics* k = nullptr;
+
+	if (bHud)
+	{
+		CActor* act = smart_cast<CActor*>(&object());
+		CHudItem* itm = smart_cast<CHudItem*>(&object());
+		if (itm && itm->HudItemData())
+			k = itm->HudItemData()->m_model;
+		else if (act)
+			k = g_player_hud->m_model->dcast_PKinematics();
+	} else {
+		k = object().Visual()->dcast_PKinematics();
+	}
+
+	if (!k) return BI_NONE;
+
+	u16 bone_id = BI_NONE;
     if (xr_strlen(bone_name))
-        bone_id = smart_cast<IKinematics*>(object().Visual())->LL_BoneID(bone_name);
-    else
-        bone_id = smart_cast<IKinematics*>(object().Visual())->LL_GetBoneRoot();
+		bone_id = k->LL_BoneID(bone_name);
+
+	return bone_id;
+}
+
+Fvector CScriptGameObject::bone_position(u16 bone_id, bool bHud)
+{
+	//if (bone_id == BI_NONE) return Fvector().set(0, 0, 0);
+
+	IKinematics* k = nullptr;
+	Fmatrix* xform = nullptr;
+
+	if (bHud)
+	{
+		CActor* act = smart_cast<CActor*>(&object());
+		CHudItem* itm = smart_cast<CHudItem*>(&object());
+		if (itm && itm->HudItemData())
+		{
+			k = itm->HudItemData()->m_model;
+			xform = &itm->HudItemData()->m_item_transform;
+		}
+		else if (act)
+		{
+			k = (bone_id > 20) ? g_player_hud->m_model->dcast_PKinematics() : g_player_hud->m_model_2->dcast_PKinematics();
+			xform = (bone_id > 20) ? &g_player_hud->m_transform : &g_player_hud->m_transform_2;
+		}
+	} else {
+		k = object().Visual()->dcast_PKinematics();
+		xform = &object().XFORM();
+	}
+
+	if (!k) return Fvector().set(0, 0, 0);
+
+	// demonized: backwards compatibility with scripts, get root bone if bone_id is BI_NONE
+	if (bone_id == BI_NONE) {
+		if (strstr(Core.Params, "-dbg")) {
+			Msg("![bone_position] Incorrect bone_id provided for %s (%d), fallback to root bone", object().cNameSect_str(), object().ID());
+			ai().script_engine().print_stack();
+		}
+		bone_id = k->LL_GetBoneRoot();
+	}
 
     Fmatrix				matrix;
-    matrix.mul_43(object().XFORM(), smart_cast<IKinematics*>(object().Visual())->LL_GetBoneInstance(bone_id).mTransform);
+	matrix.mul_43(*xform, k->LL_GetTransform(bone_id));
     return				(matrix.c);
@@ -325,2 +407,140 @@
 
+Fvector CScriptGameObject::bone_direction(u16 bone_id, bool bHud)
+{
+	//if (bone_id == BI_NONE) return Fvector().set(0, 0, 0);
+
+	IKinematics* k = nullptr;
+	Fmatrix* xform = nullptr;
+
+	if (bHud)
+	{
+		CActor* act = smart_cast<CActor*>(&object());
+		CHudItem* itm = smart_cast<CHudItem*>(&object());
+		if (itm && itm->HudItemData())
+		{
+			k = itm->HudItemData()->m_model;
+			xform = &itm->HudItemData()->m_item_transform;
+		}
+		else if (act)
+		{
+			k = (bone_id > 20) ? g_player_hud->m_model->dcast_PKinematics() : g_player_hud->m_model_2->dcast_PKinematics();
+			xform = (bone_id > 20) ? &g_player_hud->m_transform : &g_player_hud->m_transform_2;
+		}
+	} else {
+		k = object().Visual()->dcast_PKinematics();
+		xform = &object().XFORM();
+	}
+
+	if (!k) return Fvector().set(0, 0, 0);
+
+	// demonized: backwards compatibility with scripts, get root bone if bone_id is BI_NONE
+	if (bone_id == BI_NONE) {
+		if (strstr(Core.Params, "-dbg")) {
+			Msg("![bone_direction] Incorrect bone_id provided for %s (%d), fallback to root bone", object().cNameSect_str(), object().ID());
+			ai().script_engine().print_stack();
+		}
+		bone_id = k->LL_GetBoneRoot();
+	}
+
+	Fmatrix matrix;
+	Fvector res;
+	matrix.mul_43(*xform, k->LL_GetTransform(bone_id));
+	matrix.getHPB(res);
+	return (res);
+}
+
+u16 CScriptGameObject::bone_parent(u16 bone_id, bool bHud)
+{
+	IKinematics* k = nullptr;
+
+	if (bHud)
+	{
+		CActor* act = smart_cast<CActor*>(&object());
+		CHudItem* itm = smart_cast<CHudItem*>(&object());
+		if (itm && itm->HudItemData())
+			k = itm->HudItemData()->m_model;
+		else if (act)
+			k = g_player_hud->m_model->dcast_PKinematics();
+	} else {
+		k = object().Visual()->dcast_PKinematics();
+	}
+
+	if (!k || bone_id == k->LL_GetBoneRoot() || bone_id >= k->LL_BoneCount()) return BI_NONE;
+
+	CBoneData* data = &k->LL_GetData(bone_id);
+	u16 ParentID = data->GetParentID();
+	return ParentID;
+}
+
+LPCSTR CScriptGameObject::bone_name(u16 bone_id, bool bHud)
+{
+	if (bone_id == BI_NONE) return "";
+
+	IKinematics* k = nullptr;
+
+	if (bHud)
+	{
+		CActor* act = smart_cast<CActor*>(&object());
+		CHudItem* itm = smart_cast<CHudItem*>(&object());
+		if (itm && itm->HudItemData())
+			k = itm->HudItemData()->m_model;
+		else if (act)
+			k = g_player_hud->m_model->dcast_PKinematics();
+	} else {
+		k = object().Visual()->dcast_PKinematics();
+	}
+
+	if (!k) return "";
+
+	return (k->LL_BoneName_dbg(bone_id));
+}
+
+void CScriptGameObject::set_bone_visible(u16 bone_id, bool bVisibility, bool bRecursive, bool bHud)
+{
+	if (bone_id == BI_NONE) return;
+
+	IKinematics* k = nullptr;
+
+	if (bHud)
+	{
+		CActor* act = smart_cast<CActor*>(&object());
+		CHudItem* itm = smart_cast<CHudItem*>(&object());
+		if (itm && itm->HudItemData())
+			k = itm->HudItemData()->m_model;
+		else if (act)
+			k = (bone_id > 20) ? g_player_hud->m_model->dcast_PKinematics() : g_player_hud->m_model_2->dcast_PKinematics();
+	} else {
+		k = object().Visual()->dcast_PKinematics();
+	}
+
+	if (!k)
+		return;
+
+	if (bVisibility != !!k->LL_GetBoneVisible(bone_id))
+		k->LL_SetBoneVisible(bone_id, bVisibility, bRecursive);
+}
+
+bool CScriptGameObject::is_bone_visible(u16 bone_id, bool bHud)
+{
+	if (bone_id == BI_NONE) return false;
+
+	IKinematics* k = nullptr;
+
+	if (bHud)
+	{
+		CActor* act = smart_cast<CActor*>(&object());
+		CHudItem* itm = smart_cast<CHudItem*>(&object());
+		if (itm && itm->HudItemData())
+			k = itm->HudItemData()->m_model;
+		else if (act)
+			k = (bone_id > 20) ? g_player_hud->m_model->dcast_PKinematics() : g_player_hud->m_model_2->dcast_PKinematics();
+	} else {
+		k = object().Visual()->dcast_PKinematics();
+	}
+
+	if (!k) return false;
+
+	return !!k->LL_GetBoneVisible(bone_id);
+}
+
 //////////////////////////////////////////////////////////////////////////
@@ -482,2 +707,38 @@
 
+float CScriptGameObject::GetPowerCritical() const
+{
+	CInventoryItem* inventory_item = smart_cast<CInventoryItem*>(&object());
+	if (!inventory_item)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CSciptEntity : cannot access class member GetPowerCritical!");
+		return 0.f;
+	}
+	return (inventory_item->GetLowestBatteryCharge());
+}
+
+float CScriptGameObject::GetPsyFactor() const
+{
+	CPda* pda = smart_cast<CPda*>(&object());
+	if (!pda)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CSciptEntity : cannot access class member GetPsyFactor!");
+		return 0.f;
+	}
+	return (pda->m_psy_factor);
+}
+
+void CScriptGameObject::SetPsyFactor(float val)
+{
+	CPda* pda = smart_cast<CPda*>(&object());
+	if (!pda)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CSciptEntity : cannot access class member SetPsyFactor!");
+		return;
+	}
+	pda->m_psy_factor = val;
+}
+
 void CScriptGameObject::eat(CScriptGameObject *item)
@@ -685,3 +964,5 @@
 
-	CUIActorMenu& ActorMenu = CurrentGameUI()->GetActorMenu();
+	CUIGameSP* pGameSP = smart_cast<CUIGameSP*>(CurrentGameUI());
+	if (!pGameSP)
+		return ret;
 
@@ -690,29 +971,10 @@
 	{
-		ActorMenu.SetActor(pActorInv);
-		ActorMenu.SetInvBox(pBox);
-
-		ActorMenu.SetMenuMode(mmDeadBodySearch);
-		ActorMenu.ShowDialog(true);
-
-		return true;
-	} else {
-		CInventoryOwner* pOtherOwner = smart_cast<CInventoryOwner*>(&object());
-		if (!pOtherOwner)
-			return ret;
-
-		/*
-		CEntityAlive* e = smart_cast<CEntityAlive*>(pOtherOwner);
-		if (e && e->g_Alive())
-		{
-			actor->RunTalkDialog(pOtherOwner, false);
+		pGameSP->StartCarBody(pActorInv, pBox);
 			return true;
 		}
-		*/
-
-		ActorMenu.SetActor(pActorInv);
-		ActorMenu.SetPartner(pOtherOwner);
-
-		ActorMenu.SetMenuMode(mmDeadBodySearch);
-		ActorMenu.ShowDialog(true);
 
+	CInventoryOwner* pOtherOwner = smart_cast<CInventoryOwner*>(&object());
+	if (pOtherOwner)
+	{
+		pGameSP->StartCarBody(pActorInv, pOtherOwner);
 		return true;
@@ -737,9 +999,5 @@
 
-	CUIActorMenu& ActorMenu = CurrentGameUI()->GetActorMenu();
-
-	ActorMenu.SetActor(pActorInv);
-	ActorMenu.SetPartner(pOtherOwner);
-
-	ActorMenu.SetMenuMode(mmTrade);
-	ActorMenu.ShowDialog(true);
+	CUIGameSP* pGameSP = smart_cast<CUIGameSP*>(CurrentGameUI());
+	if (pGameSP)
+		pGameSP->StartTrade(pActorInv, pOtherOwner);
 }
@@ -760,9 +1018,23 @@
 
-	CUIActorMenu& ActorMenu = CurrentGameUI()->GetActorMenu();
-
-	ActorMenu.SetActor(pActorInv);
-	ActorMenu.SetPartner(pOtherOwner);
+	CUIGameSP* pGameSP = smart_cast<CUIGameSP*>(CurrentGameUI());
+	if (pGameSP)
+		pGameSP->StartUpgrade(pActorInv, pOtherOwner);
+}
+
+CGameObject& CScriptGameObject::object() const
+{
+#ifdef DEBUG
+    __try {
+        if (m_game_object && m_game_object->lua_game_object() == this)
+            return	(*m_game_object);
+    } __except (EXCEPTION_EXECUTE_HANDLER) {}
+
+    ai().script_engine().script_log(eLuaMessageTypeError, "you are trying to use a destroyed object [%x]", m_game_object);
+    THROW2(m_game_object && m_game_object->lua_game_object() == this, "Probably, you are trying to use a destroyed object!");
+#endif // #ifdef DEBUG
+	static CGameObject* m_game_object_dummy = NULL;
+	if (!m_game_object || m_game_object->lua_game_object() != this)
+		return (*m_game_object_dummy);
 
-	ActorMenu.SetMenuMode(mmUpgrade);
-	ActorMenu.ShowDialog(true);
+	return (*m_game_object);
 }
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/script_game_object.h xray-monolith/src/xrGame/script_game_object.h
--- coc-1.4-xray-64/src/xrGame/script_game_object.h	2023-10-20 20:54:51.260326500 +0100
+++ xray-monolith/src/xrGame/script_game_object.h	2023-10-20 20:54:33.192035500 +0100
@@ -17,2 +17,23 @@
 #include "game_location_selector.h"
+#include "Actor.h"
+#include "Car.h"
+#include "helicopter.h"
+#include "InventoryOwner.h"
+#include "InventoryBox.h"
+#include "CustomZone.h"
+#include "TorridZone.h"
+#include "MosquitoBald.h"
+#include "ZoneCampfire.h"
+#include "CustomOutfit.h"
+#include "ActorHelmet.h"
+#include "Artefact.h"
+#include "Weapon.h"
+#include "WeaponAmmo.h"
+#include "WeaponMagazined.h"
+#include "WeaponMagazinedWGrenade.h"
+#include "eatable_item.h"
+#include "FoodItem.h"
+#include "medkit.h"
+#include "antirad.h"
+#include "BottleItem.h"
 
@@ -146,3 +171,3 @@
 
-    IC		CGameObject			&object				() const;
+	CGameObject& object() const;
             CScriptGameObject	*Parent				() const;
@@ -168,2 +193,5 @@
             void				SetCondition		(float val);
+	float GetPowerCritical() const;
+	float GetPsyFactor() const;
+	void SetPsyFactor(float val);
 
@@ -182,18 +210,31 @@
     _DECLARE_FUNCTION10	(GetRange			,			float);
-    _DECLARE_FUNCTION10	(GetHealth			,			float);
-    _DECLARE_FUNCTION10	(GetPsyHealth		,			float);
-    _DECLARE_FUNCTION10	(GetPower			,			float);
-    _DECLARE_FUNCTION10	(GetRadiation		,			float);
-    _DECLARE_FUNCTION10	(GetSatiety			,			float);
-    _DECLARE_FUNCTION10	(GetBleeding		,			float);
-    _DECLARE_FUNCTION10	(GetMorale			,			float);
 
+	_DECLARE_FUNCTION10(GetHealth, float);
     _DECLARE_FUNCTION11	(SetHealth,			void, float);
+	_DECLARE_FUNCTION11(ChangeHealth, void, float);
+
+	_DECLARE_FUNCTION10(GetPsyHealth, float);
     _DECLARE_FUNCTION11	(SetPsyHealth,		void, float);
+	_DECLARE_FUNCTION11(ChangePsyHealth, void, float);
+
+	_DECLARE_FUNCTION10(GetPower, float);
     _DECLARE_FUNCTION11	(SetPower,			void, float);
+	_DECLARE_FUNCTION11(ChangePower, void, float);
+
+	_DECLARE_FUNCTION10(GetSatiety, float);
+	_DECLARE_FUNCTION11(SetSatiety, void, float);
     _DECLARE_FUNCTION11	(ChangeSatiety,		void, float);
+
+	_DECLARE_FUNCTION10(GetRadiation, float);
     _DECLARE_FUNCTION11	(SetRadiation,		void, float);
-    _DECLARE_FUNCTION11	(SetBleeding,		void, float);
-    _DECLARE_FUNCTION11	(SetCircumspection,	void, float);
+	_DECLARE_FUNCTION11(ChangeRadiation, void, float);
+
+	_DECLARE_FUNCTION10(GetMorale, float);
     _DECLARE_FUNCTION11	(SetMorale,			void, float);
+	_DECLARE_FUNCTION11(ChangeMorale, void, float);
+
+	_DECLARE_FUNCTION10(GetBleeding, float);
+	_DECLARE_FUNCTION11(ChangeBleeding, void, float);
+
+	_DECLARE_FUNCTION11(ChangeCircumspection, void, float);
 
@@ -217,4 +258,7 @@
     // Actor only
-            void				SetActorPosition	(Fvector pos);
+	void SetActorPosition(Fvector pos, bool bskip_collision_correct = false);
             void				SetActorDirection	(float dir);
+	void SetActorDirection(float dir, float pitch);
+	void SetActorDirection(float dir, float pitch, float roll);
+	void SetActorDirection(const Fvector& dir);
             void				SetNpcPosition		(Fvector pos);
@@ -256,2 +300,3 @@
             void				set_override_animation	(pcstr anim_name);
+	void set_override_animation(u32 AnimType, u32 AnimIndex);
             void				clear_override_animation();
@@ -339,7 +386,14 @@
             void				ActorLookAtPoint	(Fvector point);
+	void ActorStopLookAtPoint();
             void				IterateInventory	(luabind::functor<bool> functor, luabind::object object);
+	void IterateRuck(luabind::functor<bool> functor, luabind::object object);
+	void IterateBelt(luabind::functor<bool> functor, luabind::object object);
             void				IterateInventoryBox	(luabind::functor<bool> functor, luabind::object object);
-            void				MarkItemDropped		(CScriptGameObject *item);
+	void MarkItemDropped(CScriptGameObject* item, bool flag);
             bool				MarkedDropped		(CScriptGameObject *item);
-            void				UnloadMagazine		();
+	void UnloadMagazine(bool bKeepAmmo);
+	void ForceUnloadMagazine(bool bKeepAmmo);
+
+	void SetCanBeHarmed(bool state);
+	bool CanBeHarmed();
 
@@ -347,4 +401,5 @@
             void				DropItemAndTeleport	(CScriptGameObject* pItem, Fvector position);
-            void				ForEachInventoryItems(const luabind::functor<void> &functor);
+	void ForEachInventoryItems(const luabind::functor<bool>& functor);
             void				TransferItem		(CScriptGameObject* pItem, CScriptGameObject* pForWho);
+	void TakeItem(CScriptGameObject* pItem);
             void				TransferMoney		(int money, CScriptGameObject* pForWho);
@@ -353,2 +408,7 @@
             void				MakeItemActive		(CScriptGameObject* pItem);
+	void MoveItemToRuck(CScriptGameObject* pItem);
+	void MoveItemToSlot(CScriptGameObject* pItem, u16 slot_id);
+	void MoveItemToBelt(CScriptGameObject* pItem);
+	void ItemAllowTrade(CScriptGameObject* pItem);
+	void ItemDenyTrade(CScriptGameObject* pItem);
             
@@ -413,2 +473,3 @@
             CScriptGameObject	*GetObjectByIndex	(int iIndex) const;
+	CScriptGameObject * GetObjectById(u16 id) const;
 
@@ -585,2 +654,3 @@
             void				enable_night_vision		(bool value);			
+	void night_vision_allowed(bool value);
             bool				night_vision_enabled	() const;
@@ -593,4 +663,8 @@
             void				DisableAnomaly			();
+	void ChangeAnomalyIdlePart(LPCSTR name, bool bIdleLight);
             float				GetAnomalyPower			();
             void				SetAnomalyPower			(float p);
+	float GetAnomalyRadius();
+	void SetAnomalyRadius(float p);
+	void MoveAnomaly(Fvector pos);
     
@@ -602,2 +676,7 @@
             CHangingLamp*		get_hanging_lamp		();
+
+	//Torch
+	void set_color_animator(LPCSTR name, bool bFlicker, int flickerChance, float flickerDelay, int framerate);
+	void reset_color_animator();
+
             CHolderCustom*		get_custom_holder		();
@@ -608,6 +687,4 @@
 
-            Fvector				bone_position			(LPCSTR bone_name) const;
             bool				is_body_turning			() const;
     cphysics_shell_scripted*	get_physics_shell		() const;
-            u16					get_bone_id				(LPCSTR bone_name) const;					
             bool				weapon_strapped			() const;
@@ -637,3 +714,6 @@
             CScriptGameObject	*item_in_slot						(u32 slot_id) const;
-            CScriptGameObject	*active_detector					() const;
+	CScriptGameObject* active_device() const;
+	void show_device(bool bFast);
+	void hide_device(bool bFast);
+	void force_hide_device();
             u32					active_slot							();
@@ -676,5 +756,9 @@
             LPCSTR				get_smart_cover_description			() const;
-            void				set_visual_name						(LPCSTR visual);
+	void set_visual_name(LPCSTR visual, bool bForce);
+	float get_current_weight();
+	float get_max_weight();
             LPCSTR				get_visual_name						() const;
 
+	void reload_weapon();
+
             bool				can_throw_grenades					() const;
@@ -791,2 +875,3 @@
             _DECLARE_FUNCTION10(IsCustomOutfit, bool);
+	_DECLARE_FUNCTION10(IsHelmet, bool);
             _DECLARE_FUNCTION10(IsScope, bool);
@@ -817,2 +902,25 @@
 #ifdef GAME_OBJECT_EXTENDED_EXPORTS
+	_DECLARE_FUNCTION14(cast_Actor, CActor);
+	_DECLARE_FUNCTION14(cast_Car, CCar);
+	_DECLARE_FUNCTION14(cast_Heli, CHelicopter);
+	_DECLARE_FUNCTION14(cast_InventoryOwner, CInventoryOwner);
+	_DECLARE_FUNCTION14(cast_InventoryBox, CInventoryBox);
+	_DECLARE_FUNCTION14(cast_CustomZone, CCustomZone);
+	_DECLARE_FUNCTION14(cast_TorridZone, CTorridZone);
+	_DECLARE_FUNCTION14(cast_MosquitoBald, CMosquitoBald);
+	_DECLARE_FUNCTION14(cast_ZoneCampfire, CZoneCampfire);
+	_DECLARE_FUNCTION14(cast_InventoryItem, CInventoryItem);
+	_DECLARE_FUNCTION14(cast_CustomOutfit, CCustomOutfit);
+	_DECLARE_FUNCTION14(cast_Helmet, CHelmet);
+	_DECLARE_FUNCTION14(cast_Artefact, CArtefact);
+	_DECLARE_FUNCTION14(cast_Ammo, CWeaponAmmo);
+	_DECLARE_FUNCTION14(cast_Weapon, CWeapon);
+	_DECLARE_FUNCTION14(cast_WeaponMagazined, CWeaponMagazined);
+	_DECLARE_FUNCTION14(cast_WeaponMagazinedWGrenade, CWeaponMagazinedWGrenade);
+	_DECLARE_FUNCTION14(cast_EatableItem, CEatableItem);
+	_DECLARE_FUNCTION14(cast_Medkit, CMedkit);
+	_DECLARE_FUNCTION14(cast_Antirad, CAntirad);
+	_DECLARE_FUNCTION14(cast_FoodItem, CFoodItem);
+	_DECLARE_FUNCTION14(cast_BottleItem, CBottleItem);
+
             void SetHealthEx(float hp); //AVO
@@ -826,2 +934,3 @@
 			u32					GetSpatialType();
+	void DestroyObject();
 			void				SetSpatialType(u32 sptype);
@@ -830,5 +939,11 @@
 
+	// demonized: add getters and setters for pathfinding for npcs around anomalies and damage for npcs
+	bool get_enable_anomalies_pathfinding();
+	void set_enable_anomalies_pathfinding(bool v);
+	bool get_enable_anomalies_damage();
+	void set_enable_anomalies_damage(bool v);
+
 			//Weapon
 			void				Weapon_AddonAttach(CScriptGameObject* item);
-			void				Weapon_AddonDetach(LPCSTR item_section);
+	void Weapon_AddonDetach(LPCSTR item_section, bool b_spawn_item = true);
 			bool				HasAmmoType(u8 type);
@@ -843,2 +958,6 @@
 
+	//Scope
+	void Weapon_SetCurrentScope(u8 type);
+	u8 Weapon_GetCurrentScope();
+
 			//CWeaponAmmo
@@ -851,3 +970,3 @@
 			bool				HasUpgrade(LPCSTR upgrade);
-			void				IterateInstalledUpgrades(luabind::functor<void> functor);
+	void IterateInstalledUpgrades(const luabind::functor<bool>& functor);
 			bool				WeaponInGrenadeMode();
@@ -860,3 +979,3 @@
 			//Any class that is derived from CHudItem
-			u32					PlayHudMotion(LPCSTR M, bool bMixIn, u32 state);
+	u32 PlayHudMotion(LPCSTR M, bool bMixIn, u32 state, float speed = 0.f, float end = 0.f);
 			void				SwitchState(u32 state);
@@ -864,4 +983,31 @@
 			//Works for anything with visual
-			bool				IsBoneVisible(LPCSTR bone_name);
-			void				SetBoneVisible(LPCSTR bone_name, bool bVisibility, bool bRecursive = true);
+	u16 bone_id(LPCSTR bone_name, bool bHud);
+	u16 bone_id(LPCSTR bone_name) { return bone_id(bone_name, false); }
+	LPCSTR bone_name(u16 bone_id, bool bHud);
+	LPCSTR bone_name(u16 bone_id) { return bone_name(bone_id, false); }
+
+	bool is_bone_visible(u16 bone_id, bool bHud);
+	bool is_bone_visible(u16 bone_id) { return is_bone_visible(bone_id, false); }
+	bool is_bone_visible(LPCSTR bone_name, bool bHud) { return is_bone_visible(bone_id(bone_name, bHud), bHud); }
+	bool is_bone_visible(LPCSTR bone_name) { return is_bone_visible(bone_id(bone_name), false); }
+
+	void set_bone_visible(u16 bone_id, bool bVisibility, bool bRecursive, bool bHud);
+	void set_bone_visible(u16 bone_id, bool bVisibility, bool bRecursive) { set_bone_visible(bone_id, bVisibility, bRecursive, false); }
+	void set_bone_visible(LPCSTR bone_name, bool bVisibility, bool bRecursive, bool bHud) { set_bone_visible(bone_id(bone_name, bHud), bVisibility, bRecursive, bHud); }
+	void set_bone_visible(LPCSTR bone_name, bool bVisibility, bool bRecursive) { set_bone_visible(bone_id(bone_name), bVisibility, bRecursive, false); }
+
+	Fvector bone_position(u16 bone_id, bool bHud);
+	Fvector bone_position(u16 bone_id) { return bone_position(bone_id, false); }
+	Fvector bone_position(LPCSTR bone_name, bool bHud) { return bone_position(bone_id(bone_name, bHud), bHud); }
+	Fvector bone_position(LPCSTR bone_name) { return bone_position(bone_id(bone_name), false); }
+
+	Fvector bone_direction(u16 bone_id, bool bHud);
+	Fvector bone_direction(u16 bone_id) { return bone_direction(bone_id, false); }
+	Fvector bone_direction(LPCSTR bone_name, bool bHud) { return bone_direction(bone_id(bone_name, bHud), bHud); }
+	Fvector bone_direction(LPCSTR bone_name) { return bone_direction(bone_id(bone_name), false); }
+
+	u16 bone_parent(u16 bone_id, bool bHud);
+	u16 bone_parent(u16 bone_id) { return bone_parent(bone_id, false); }
+	u16 bone_parent(LPCSTR bone_name, bool bHud) { return bone_parent(bone_id(bone_name, bHud), bHud); }
+	u16 bone_parent(LPCSTR bone_name) { return bone_parent(bone_id(bone_name), false); }
 
@@ -871,2 +1017,4 @@
 			void				ForceSetPosition(Fvector pos, bool bActivate = false);
+	void ForceSetAngle(Fvector ang, bool bActivate);
+	Fvector Angle();
 
@@ -878,2 +1026,3 @@
 			float				GetArtefactBleedingRestoreSpeed();
+	float GetArtefactImmunity(ALife::EHitType hit_type);
 
@@ -884,2 +1033,6 @@
 			void				SetArtefactBleedingRestoreSpeed(float value);
+	void SetArtefactImmunity(ALife::EHitType hit_type, float value);
+
+	float GetArtefactAdditionalInventoryWeight();
+	void SetArtefactAdditionalInventoryWeight(float value);
 
@@ -914,2 +1067,10 @@
 		    void        SetActorRunBackCoef   (float run_back_coef);
+	float GetActorWalkAccel() const;
+	void SetActorWalkAccel(float val);
+	float GetActorWalkBackCoef() const;
+	void SetActorWalkBackCoef(float val);
+
+	// demonized: Adjust Lookout coeff
+	float GetActorLookoutCoef() const;
+	void SetActorLookoutCoef(float val);
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/script_game_object_impl.h xray-monolith/src/xrGame/script_game_object_impl.h
--- coc-1.4-xray-64/src/xrGame/script_game_object_impl.h	2023-10-20 20:54:51.262326300 +0100
+++ xray-monolith/src/xrGame/script_game_object_impl.h	2023-10-20 20:54:33.193035500 +0100
@@ -13,21 +13 @@
 #include "script_engine.h"
-
-IC	CGameObject &CScriptGameObject::object	() const
-{
-#ifdef DEBUG
-	__try {
-		if (m_game_object && m_game_object->lua_game_object() == this)
-			return	(*m_game_object);
-	}
-	__except(EXCEPTION_EXECUTE_HANDLER) {
-	}
-
-	ai().script_engine().script_log(eLuaMessageTypeError,"you are trying to use a destroyed object [%x]",m_game_object);
-	THROW2			(m_game_object && m_game_object->lua_game_object() == this,"Probably, you are trying to use a destroyed object!");
-#endif // #ifdef DEBUG
-    static CGameObject *m_game_object_dummy = NULL;
-    if (!m_game_object || m_game_object->lua_game_object() != this)
-        return	(*m_game_object_dummy);
-
-	return			(*m_game_object);
-}
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/script_game_object_inventory_owner.cpp xray-monolith/src/xrGame/script_game_object_inventory_owner.cpp
--- coc-1.4-xray-64/src/xrGame/script_game_object_inventory_owner.cpp	2023-10-20 20:54:51.262326300 +0100
+++ xray-monolith/src/xrGame/script_game_object_inventory_owner.cpp	2023-10-20 20:54:33.194035100 +0100
@@ -24,2 +24,3 @@
 #include "custommonster.h"
+#include "entitycondition.h"
 #include "actorcondition.h"
@@ -50,2 +51,3 @@
 #include "customoutfit.h"
+#include "InventoryBox.h"
 //Alundaio
@@ -54,4 +56,14 @@
 #include "inventory_item.h"
+#include "inventory_item_impl.h"
+#include "xrserver_objects_alife_items.h"
+#include "./xrServerEntities/inventory_space.h"
+#include "ai_space.h"
+#include "ActorBackpack.h"
+
+//using namespace luabind;
 //-Alundaio
 
+#include "Flashlight.h"
+#include "CharacterPhysicsSupport.h"
+
 bool CScriptGameObject::GiveInfoPortion(LPCSTR info_id)
@@ -208,3 +228,3 @@
 
-void CScriptGameObject::ForEachInventoryItems(const luabind::functor<void> &functor)
+void CScriptGameObject::ForEachInventoryItems(const luabind::functor<bool>& functor)
 {
@@ -219,3 +240,3 @@
     TIItemContainer item_list;
-    pInv->AddAvailableItems(item_list, true);
+	pInv->AddAvailableItems(item_list, false);
 
@@ -227,3 +248,4 @@
         {
-            functor(inv_go->lua_game_object(), this);
+			if (functor(inv_go->lua_game_object(), this) == true)
+				return;
         }
@@ -249,3 +272,36 @@
 
-#include "InventoryBox.h"
+void CScriptGameObject::IterateRuck(luabind::functor<bool> functor, luabind::object object)
+{
+	CInventoryOwner* inventory_owner = smart_cast<CInventoryOwner*>(&this->object());
+	if (!inventory_owner)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+		                                "CScriptGameObject::IterateRuck non-CInventoryOwner object !!!");
+		return;
+	}
+
+	TIItemContainer::iterator I = inventory_owner->inventory().m_ruck.begin();
+	TIItemContainer::iterator E = inventory_owner->inventory().m_ruck.end();
+	for (; I != E; ++I)
+		if (functor(object, (*I)->object().lua_game_object()) == true)
+			return;
+}
+
+void CScriptGameObject::IterateBelt(luabind::functor<bool> functor, luabind::object object)
+{
+	CInventoryOwner* inventory_owner = smart_cast<CInventoryOwner*>(&this->object());
+	if (!inventory_owner)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+		                                "CScriptGameObject::IterateBelt non-CInventoryOwner object !!!");
+		return;
+	}
+
+	TIItemContainer::iterator I = inventory_owner->inventory().m_belt.begin();
+	TIItemContainer::iterator E = inventory_owner->inventory().m_belt.end();
+	for (; I != E; ++I)
+		if (functor(object, (*I)->object().lua_game_object()) == true)
+			return;
+}
+
 void CScriptGameObject::IterateInventoryBox(luabind::functor<bool> functor, luabind::object object)
@@ -270,3 +327,3 @@
 
-void CScriptGameObject::MarkItemDropped(CScriptGameObject *item)
+void CScriptGameObject::MarkItemDropped(CScriptGameObject* item, bool flag)
 {
@@ -286,3 +345,3 @@
 
-    inventory_item->SetDropManual(TRUE);
+	inventory_item->SetDropManual(flag ? TRUE : FALSE);
 }
@@ -308,3 +369,3 @@
 
-void CScriptGameObject::UnloadMagazine()
+void CScriptGameObject::UnloadMagazine(bool bKeepAmmo)
 {
@@ -321,3 +383,16 @@
 
-    weapon_magazined->UnloadMagazine(false);
+	weapon_magazined->UnloadMagazine(bKeepAmmo);
+}
+
+void CScriptGameObject::ForceUnloadMagazine(bool bKeepAmmo)
+{
+	CWeaponMagazined* weapon_magazined = smart_cast<CWeaponMagazined*>(&object());
+	if (!weapon_magazined)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+		                                "CScriptGameObject::UnloadMagazine non-CWeaponMagazined object !!!");
+		return;
+	}
+
+	weapon_magazined->UnloadMagazine(bKeepAmmo);
 }
@@ -323,4 +398,31 @@
 }
+
 //
 
+void CScriptGameObject::SetCanBeHarmed(bool state)
+{
+	CEntityAlive* ent = smart_cast<CEntityAlive*>(&object());
+	if (!ent)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CEntityAlive : cannot access class member set_can_be_harmed!");
+		return;
+	}
+
+	ent->conditions().SetCanBeHarmedState(state);
+}
+
+bool CScriptGameObject::CanBeHarmed()
+{
+	CEntityAlive* ent = smart_cast<CEntityAlive*>(&object());
+	if (!ent)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CEntityAlive : cannot access class member can_be_harmed!");
+		return false;
+	}
+
+	return ent->conditions().CanBeHarmed();
+}
+
 void CScriptGameObject::DropItem(CScriptGameObject* pItem)
@@ -376,2 +479,105 @@
 
+void CScriptGameObject::MoveItemToRuck(CScriptGameObject* pItem)
+{
+	CInventoryOwner* owner = smart_cast<CInventoryOwner*>(&object());
+	CInventoryItem* item = smart_cast<CInventoryItem*>(&pItem->object());
+	if (!owner)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CScriptGameObject::MoveItemToRuck non-CInventoryOwner object !!!");
+		return;
+	}
+	
+	if (!owner->inventory().CanPutInRuck(item))
+		return;
+	
+	NET_Packet P;
+	CGameObject::u_EventGen(P, GEG_PLAYER_ITEM2RUCK, owner->object_id());
+	P.w_u16(item->object().ID());
+	CGameObject::u_EventSend(P);
+}
+
+void CScriptGameObject::MoveItemToSlot(CScriptGameObject* pItem, u16 slot_id)
+{
+	CInventoryOwner* owner = smart_cast<CInventoryOwner*>(&object());
+	CInventoryItem* item = smart_cast<CInventoryItem*>(&pItem->object());
+	if (!owner)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CScriptGameObject::MoveItemToSlot non-CInventoryOwner object !!!");
+		return;
+	}
+	
+	// Have a crash if you want
+	/*
+	if (!owner->inventory().CanPutInSlot(item, slot_id))
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CScriptGameObject::MoveItemToSlot can't put in slot !!!");
+		return;
+	}
+	*/
+	
+	CInventoryItem* item_in_slot = owner->inventory().ItemFromSlot(slot_id);
+
+	NET_Packet P;
+	if (item_in_slot)
+	{
+		CGameObject::u_EventGen(P, GEG_PLAYER_ITEM2RUCK, owner->object_id());
+		P.w_u16(item_in_slot->object().ID());
+		CGameObject::u_EventSend(P);
+	}
+	
+	CGameObject::u_EventGen(P, GEG_PLAYER_ITEM2SLOT, owner->object_id());
+	P.w_u16(item->object().ID());
+	P.w_u16(slot_id);
+	CGameObject::u_EventSend(P);
+}
+
+void CScriptGameObject::MoveItemToBelt(CScriptGameObject* pItem)
+{
+	CInventoryOwner* owner = smart_cast<CInventoryOwner*>(&object());
+	CInventoryItem* item = smart_cast<CInventoryItem*>(&pItem->object());
+	if (!owner)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CScriptGameObject::MoveItemToBelt non-CInventoryOwner object !!!");
+		return;
+	}
+	
+	if (!owner->inventory().CanPutInBelt(item))
+		return;
+	
+	NET_Packet P;
+	CGameObject::u_EventGen(P, GEG_PLAYER_ITEM2BELT, owner->object_id());
+	P.w_u16(item->object().ID());
+	CGameObject::u_EventSend(P);
+}
+
+void CScriptGameObject::ItemAllowTrade(CScriptGameObject* pItem)
+{
+	CInventoryOwner* owner = smart_cast<CInventoryOwner*>(&object());
+	CInventoryItem* item = smart_cast<CInventoryItem*>(&pItem->object());
+	if (!owner || !item)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CScriptGameObject::ItemAllowTrade non-CInventoryOwner object !!!");
+		return;
+	}
+	item->AllowTrade();
+}
+
+void CScriptGameObject::ItemDenyTrade(CScriptGameObject* pItem)
+{
+	CInventoryOwner* owner = smart_cast<CInventoryOwner*>(&object());
+	CInventoryItem* item = smart_cast<CInventoryItem*>(&pItem->object());
+	if (!owner || !item)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CScriptGameObject::ItemAllowTrade non-CInventoryOwner object !!!");
+		return;
+	}
+	item->DenyTrade();
+}
+
 //ïåðåäà÷å âåùè èç ñâîåãî èíâåíòàðÿ â èíâåíòàðü ïàðòíåðà
@@ -405,5 +611,51 @@
 
+void CScriptGameObject::TakeItem(CScriptGameObject* pItem)
+{
+	if (!pItem)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError, "!CScriptGameObject::TakeItem | cannot take NULL item");
+		return;
+	}
+
+	CInventoryItem* pIItem = smart_cast<CInventoryItem*>(&pItem->object());
+	if (!pIItem)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError, "!CScriptGameObject::TakeItem | Cannot take not CInventoryItem item");
+		return;
+	}
+
+	// In case of an existing parent, transfer item as usual
+	// probably doesn't work on NPC for now and needs fixing if needed in the future
+	if (pIItem->object().H_Parent())
+	{
+		const CInventoryOwner* inventory_owner = smart_cast<CInventoryOwner*>(pIItem->object().H_Parent());
+		const CInventoryBox* inventory_box = smart_cast<CInventoryBox*>(pIItem->object().H_Parent());
+		const CGameObject* parentGO = smart_cast<CGameObject*>(pIItem->object().H_Parent());
+		if ((inventory_owner || inventory_box) && parentGO)
+		{
+			NET_Packet P;
+			CGameObject::u_EventGen(P, GE_TRADE_SELL, parentGO->ID());
+			P.w_u16(pIItem->object().ID());
+			CGameObject::u_EventSend(P);
+
+			CGameObject::u_EventGen(P, GE_TRADE_BUY, object().ID());
+			P.w_u16(pIItem->object().ID());
+			CGameObject::u_EventSend(P);
+		}
+		else
+		{
+			ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError, "!CScriptGameObject::TakeItem | Unknown parent type found?");
+		}
+
+		return; // added return here just in case parent isn't identified as inventory owner or a box
+	}
+
+	// In case of no parent, do a take action
+	Game().SendPickUpEvent(object().ID(), pIItem->object().ID());
+}
+
 u32 CScriptGameObject::Money()
 {
-    CInventoryOwner* pOurOwner = smart_cast<CInventoryOwner*>(&object()); VERIFY(pOurOwner);
+	CInventoryOwner* pOurOwner = smart_cast<CInventoryOwner*>(&object());
+	VERIFY(pOurOwner);
     return pOurOwner->get_money();
@@ -714,4 +995,8 @@
     community.set(comm);
-    if (community.index() >= 0)
+	if (community.index() < 0)
     {
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError, "SetCharacterCommunity failed for '%'",
+		                                comm);
+		return;
+	}
         pInventoryOwner->SetCommunity(community.index());
@@ -719,7 +1004,2 @@
     }
-    else
-    {
-        ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeInfo, "SetCharacterCommunity can't set %s for %s", comm, Name());
-    }
-}
 
@@ -819,2 +1104,9 @@
 
+void CScriptGameObject::ActorStopLookAtPoint()
+{
+	CCameraBase* c = Actor()->cam_FirstEye();
+	CCameraFirstEye* cf = smart_cast<CCameraFirstEye*>(c);
+	cf->StopLookAtPoint();
+}
+
 //////////////////////////////////////////////////////////////////////////
@@ -981,11 +1287,24 @@
 
+void CScriptGameObject::night_vision_allowed(bool value)
+{
+	CActor* pActor = smart_cast<CActor*>(&object());
+	if (!pActor)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+		                                "CActor : cannot access class member enable_night_vision!");
+		return;
+	}
+	pActor->SetNightVisionAllowed(value);
+}
+
 void CScriptGameObject::enable_night_vision(bool value)
 {
-    CTorch									*torch = smart_cast<CTorch*>(&object());
-    if (!torch)
+	CActor* pActor = smart_cast<CActor*>(&object());
+	if (!pActor)
     {
-        ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError, "CTorch : cannot access class member enable_night_vision!");
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+		                                "CActor : cannot access class member enable_night_vision!");
         return;
     }
-    torch->SwitchNightVision(value);
+	pActor->SwitchNightVision(value);
 }
@@ -994,9 +1313,10 @@
 {
-    CTorch									*torch = smart_cast<CTorch*>(&object());
-    if (!torch)
+	CActor* pActor = smart_cast<CActor*>(&object());
+	if (!pActor)
     {
-        ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError, "CTorch : cannot access class member enable_night_vision!");
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+		                                "CActor : cannot access class member enable_night_vision!");
         return								(false);
     }
-    return									(torch->GetNightVisionStatus());
+	return (pActor->GetNightVisionStatus());
 }
@@ -1143,3 +1474,3 @@
 
-CScriptGameObject *CScriptGameObject::active_detector() const
+CScriptGameObject* CScriptGameObject::active_device() const
 {
@@ -1155,5 +1487,6 @@
     {
-        CCustomDetector *detector = smart_cast<CCustomDetector*>(result);
-        VERIFY(detector);
-        return			(detector->IsWorking() ? result->object().lua_game_object() : 0);
+		CCustomDevice* device = smart_cast<CCustomDevice*>(result);
+
+		if (device && device->GetState() != CHUDState::eHidden)
+			return result->object().lua_game_object();
     }
@@ -1162,2 +1495,59 @@
 
+void CScriptGameObject::show_device(bool bFast)
+{
+	CInventoryOwner* inventory_owner = smart_cast<CInventoryOwner*>(&object());
+	if (!inventory_owner)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+		                                "CInventoryOwner : cannot access class member show_device!");
+		return;
+	}
+
+	CInventoryItem* result = inventory_owner->inventory().ItemFromSlot(DETECTOR_SLOT);
+	if (result)
+	{
+		CCustomDevice* device = smart_cast<CCustomDevice*>(result);
+		if (device && device->GetState() == CHUDState::eHidden)
+			device->ShowDevice(bFast);
+	}
+}
+
+void CScriptGameObject::hide_device(bool bFast)
+{
+	CInventoryOwner* inventory_owner = smart_cast<CInventoryOwner*>(&object());
+	if (!inventory_owner)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+		                                "CInventoryOwner : cannot access class member hide_device!");
+		return;
+	}
+
+	CInventoryItem* result = inventory_owner->inventory().ItemFromSlot(DETECTOR_SLOT);
+	if (result)
+	{
+		CCustomDevice* device = smart_cast<CCustomDevice*>(result);
+		if (device && device->GetState() != CHUDState::eHidden)
+			device->HideDevice(bFast);
+	}
+}
+
+void CScriptGameObject::force_hide_device()
+{
+	CInventoryOwner* inventory_owner = smart_cast<CInventoryOwner*>(&object());
+	if (!inventory_owner)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CInventoryOwner : cannot access class member force_hide_device!");
+		return;
+	}
+
+	CInventoryItem* result = inventory_owner->inventory().ItemFromSlot(DETECTOR_SLOT);
+	if (result)
+	{
+		CCustomDevice* device = smart_cast<CCustomDevice*>(result);
+		if (device)
+			device->ForceHide();
+	}
+}
+
 CScriptGameObject *CScriptGameObject::item_in_slot(u32 slot_id) const
@@ -1171,3 +1562,3 @@
 
-    CInventoryItem	*result = inventory_owner->inventory().ItemFromSlot((u16) slot_id);
+	CInventoryItem* result = slot_id != NO_ACTIVE_SLOT ? inventory_owner->inventory().ItemFromSlot((u16)slot_id) : (0);
     return			(result ? result->object().lua_game_object() : 0);
@@ -1583,3 +2007,4 @@
 {
-    VERIFY2(!m_door, make_string("object %s has been registered as a door already", m_game_object->cName().c_str()));
+	//VERIFY2(!m_door, make_string("object %s has been registered as a door already", m_game_object->cName().c_str()));
+	if (!m_door)
     m_door = ai().doors().register_door(*smart_cast<CPhysicObject*>(m_game_object));
@@ -1590,4 +2015,6 @@
 {
-    VERIFY2(m_door, make_string("object %s is not a door", m_game_object->cName().c_str()));
+	//VERIFY2(m_door, make_string("object %s is not a door", m_game_object->cName().c_str()));
     //	Msg									( "UNregistering door 0x%-08x", m_door );
+	if (m_door)
+	{
     ai().doors().unregister_door(m_door);
@@ -1595,2 +2022,3 @@
 }
+}
 
@@ -1598,3 +2026,4 @@
 {
-    VERIFY2(m_door, make_string("object %s hasn't been registered as a door already", m_game_object->cName().c_str()));
+	// VERIFY2(m_door, make_string("object %s hasn't been registered as a door already", m_game_object->cName().c_str()));
+	if (m_door)
     ai().doors().on_door_is_open(m_door);
@@ -1604,3 +2033,4 @@
 {
-    VERIFY2(m_door, make_string("object %s hasn't been registered as a door already", m_game_object->cName().c_str()));
+	//VERIFY2(m_door, make_string("object %s hasn't been registered as a door already", m_game_object->cName().c_str()));
+	if (m_door)
     ai().doors().on_door_is_closed(m_door);
@@ -1610,3 +2040,5 @@
 {
-    VERIFY2(m_door, make_string("object %s hasn't been registered as a door already", m_game_object->cName().c_str()));
+	//VERIFY2(m_door, make_string("object %s hasn't been registered as a door already", m_game_object->cName().c_str()));
+	if (!m_door)
+		return false;
     return								ai().doors().is_door_locked(m_door);
@@ -1616,3 +2048,4 @@
 {
-    VERIFY2(m_door, make_string("object %s hasn't been registered as a door already", m_game_object->cName().c_str()));
+	//VERIFY2(m_door, make_string("object %s hasn't been registered as a door already", m_game_object->cName().c_str()));
+	if (m_door)
     ai().doors().lock_door(m_door);
@@ -1622,3 +2055,4 @@
 {
-    VERIFY2(m_door, make_string("object %s hasn't been registered as a door already", m_game_object->cName().c_str()));
+	//VERIFY2(m_door, make_string("object %s hasn't been registered as a door already", m_game_object->cName().c_str()));
+	if (m_door)
     ai().doors().unlock_door(m_door);
@@ -1628,3 +2062,5 @@
 {
-    VERIFY2(m_door, make_string("object %s hasn't been registered as a door already", m_game_object->cName().c_str()));
+	//VERIFY2(m_door, make_string("object %s hasn't been registered as a door already", m_game_object->cName().c_str()));
+	if (!m_door)
+		return false;
     return								ai().doors().is_door_blocked(m_door);
@@ -1654,3 +2092,3 @@
 
-void CScriptGameObject::Weapon_AddonDetach(LPCSTR item_section)
+void CScriptGameObject::Weapon_AddonDetach(LPCSTR item_section, bool b_spawn_item)
 {
@@ -1665,4 +2104,29 @@
 	{
-		weapon->Detach(item_section, true);
+		weapon->Detach(item_section, b_spawn_item);
+	}
+}
+
+void CScriptGameObject::Weapon_SetCurrentScope(u8 type)
+{
+	CWeaponMagazined* weapon = smart_cast<CWeaponMagazined*>(&object());
+	if (!weapon)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+		                                "CWeaponMagazined : cannot access class member Weapon_SetCurrentScope!");
+		return;
+	}
+
+	weapon->m_cur_scope = type;
+}
+
+u8 CScriptGameObject::Weapon_GetCurrentScope()
+{
+	CWeaponMagazined* weapon = smart_cast<CWeaponMagazined*>(&object());
+	if (!weapon)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+		                                "CWeaponMagazined : cannot access class member Weapon_GetCurrentScope!");
+		return 255;
 	}
+	return weapon->m_cur_scope;
 }
@@ -1681,3 +2146,3 @@
 
-	return item->install_upgrade(upgrade);
+	return ai().alife().inventory_upgrade_manager().upgrade_install(*item, upgrade, false);
 }
@@ -1699,3 +2165,3 @@
 
-void CScriptGameObject::IterateInstalledUpgrades(luabind::functor<void> functor)
+void CScriptGameObject::IterateInstalledUpgrades(const luabind::functor<bool>& functor)
 {
@@ -1710,3 +2176,4 @@
 	{
-		functor((*ib).c_str(), object().lua_game_object());
+		if (functor((*ib).c_str(), object().lua_game_object()) == true)
+			return;
 	}
@@ -1715,7 +2182,2 @@
 
-#include "inventory_item_impl.h"
-#include "inventory_item.h"
-#include "inventory.h"
-#include "xrserver_objects_alife_items.h"
-#include "./xrServerEntities/inventory_space.h"
 CScriptGameObject *CScriptGameObject::ItemOnBelt	(u32 item_id) const
@@ -1789,7 +2266,9 @@
 	CActor* pActor = smart_cast<CActor*>(&object());
-	if(!pActor) {
-		ai().script_engine().script_log			(ScriptStorage::eLuaMessageTypeError,"CActor : cannot access class member GetActorMaxWalkWeight!");
+	if (!pActor)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+		                                "CActor : cannot access class member GetActorMaxWalkWeight!");
 		return			(false);
 	}
-	return				(pActor->conditions().m_MaxWalkWeight);
+	return (pActor->conditions().MaxWalkWeight());
 }
@@ -1798,7 +2278,9 @@
 	CActor* pActor = smart_cast<CActor*>(&object());
-	if(!pActor) {
-		ai().script_engine().script_log			(ScriptStorage::eLuaMessageTypeError,"CActor : cannot access class member SetActorMaxWalkWeight!");
+	if (!pActor)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+		                                "CActor : cannot access class member SetActorMaxWalkWeight!");
 		return;
 	}
-	pActor->conditions().m_MaxWalkWeight = max_walk_weight;
+	pActor->conditions().SetMaxWalkWeight(max_walk_weight);
 }
@@ -1809,7 +2292,14 @@
 	CCustomOutfit* outfit = smart_cast<CCustomOutfit*>(&object());
-	if(!outfit) {
-		ai().script_engine().script_log			(ScriptStorage::eLuaMessageTypeError,"CCustomOutfit : cannot access class member GetAdditionalMaxWeight!");
+	CBackpack* pBackpack = smart_cast<CBackpack*>(&object());
+	if (!outfit && !pBackpack)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+		                                "CCustomOutfit : cannot access class member GetAdditionalMaxWeight!");
 		return			(false);
 	}
+
+	if (outfit)
 	return				(outfit->m_additional_weight2);
+
+	return (pBackpack->m_additional_weight2);
 }
@@ -1818,7 +2309,13 @@
 	CCustomOutfit* outfit = smart_cast<CCustomOutfit*>(&object());
-	if(!outfit) {
-		ai().script_engine().script_log			(ScriptStorage::eLuaMessageTypeError,"CCustomOutfit : cannot access class member GetAdditionalMaxWalkWeight!");
+	CBackpack* pBackpack = smart_cast<CBackpack*>(&object());
+	if (!outfit && !pBackpack)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+		                                "CCustomOutfit : cannot access class member GetAdditionalMaxWalkWeight!");
 		return			(false);
 	}
+	if (outfit)
 	return				(outfit->m_additional_weight);
+
+	return (pBackpack->m_additional_weight);
 }
@@ -1827,7 +2325,14 @@
 	CCustomOutfit* outfit = smart_cast<CCustomOutfit*>(&object());
-	if(!outfit) {
-		ai().script_engine().script_log			(ScriptStorage::eLuaMessageTypeError,"CCustomOutfit : cannot access class member SetAdditionalMaxWeight!");
+	CBackpack* pBackpack = smart_cast<CBackpack*>(&object());
+	if (!outfit && !pBackpack)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+		                                "CCustomOutfit : cannot access class member SetAdditionalMaxWeight!");
 		return;
 	}
+	if (outfit)
 	outfit->m_additional_weight2 = add_max_weight;
+
+	if (pBackpack)
+		pBackpack->m_additional_weight2 = add_max_weight;
 }
@@ -1836,7 +2342,15 @@
 	CCustomOutfit* outfit = smart_cast<CCustomOutfit*>(&object());
-	if(!outfit) {
-		ai().script_engine().script_log			(ScriptStorage::eLuaMessageTypeError,"CCustomOutfit : cannot access class member SetAdditionalMaxWalkWeight!");
+	CBackpack* pBackpack = smart_cast<CBackpack*>(&object());
+	if (!outfit && !pBackpack)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+		                                "CCustomOutfit : cannot access class member SetAdditionalMaxWalkWeight!");
 		return;
 	}
+
+	if (outfit)
 	outfit->m_additional_weight = add_max_walk_weight;
+
+	if (pBackpack)
+		pBackpack->m_additional_weight = add_max_walk_weight;
 }
@@ -1891,3 +2418,3 @@
 	pActor->m_fJumpSpeed = jump_speed;
-  //character_physics_support()->movement()->SetJumpUpVelocity(m_fJumpSpeed);  
+	pActor->character_physics_support()->movement()->SetJumpUpVelocity(pActor->m_fJumpSpeed);
 }
@@ -1951,2 +2493,51 @@
 
+
+float CScriptGameObject::GetActorWalkAccel() const
+{
+	CActor* pActor = smart_cast<CActor*>(&object());
+	if (!pActor)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CActor : cannot access class member GetActorWalkAccel!");
+		return (false);
+	}
+	return (pActor->m_fWalkAccel);
+}
+void CScriptGameObject::SetActorWalkAccel(float val)
+{
+	CActor* pActor = smart_cast<CActor*>(&object());
+	if (!pActor)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CActor : cannot access class member SetActorWalkAccel!");
+		return;
+	}
+	pActor->m_fWalkAccel = val;
+}
+
+
+float CScriptGameObject::GetActorWalkBackCoef() const
+{
+	CActor* pActor = smart_cast<CActor*>(&object());
+	if (!pActor)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CActor : cannot access class member GetActorWalkBackCoef!");
+		return (false);
+	}
+	return (pActor->m_fWalkBackFactor);
+}
+void CScriptGameObject::SetActorWalkBackCoef(float val)
+{
+	CActor* pActor = smart_cast<CActor*>(&object());
+	if (!pActor)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CActor : cannot access class member SetActorWalkBackCoef!");
+		return;
+	}
+	pActor->m_fWalkBackFactor = val;
+}
+
+
 void CScriptGameObject::SetCharacterIcon(LPCSTR iconName)
@@ -1962,2 +2554,27 @@
 }
+
+// demonized: Adjust Lookout factor
+float CScriptGameObject::GetActorLookoutCoef() const
+{
+	CActor* pActor = smart_cast<CActor*>(&object());
+	if (!pActor)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CActor : cannot access class member GetActorLookoutCoef!");
+		return (false);
+	}
+	return (pActor->m_fLookoutFactor);
+}
+void CScriptGameObject::SetActorLookoutCoef(float val)
+{
+	CActor* pActor = smart_cast<CActor*>(&object());
+	if (!pActor)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CActor : cannot access class member SetActorLookoutCoef!");
+		return;
+	}
+	pActor->m_fLookoutFactor = val;
+}
+
 #endif
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/script_game_object_script.cpp xray-monolith/src/xrGame/script_game_object_script.cpp
--- coc-1.4-xray-64/src/xrGame/script_game_object_script.cpp	2023-10-20 20:54:51.263326500 +0100
+++ xray-monolith/src/xrGame/script_game_object_script.cpp	2023-10-20 20:54:33.194035100 +0100
@@ -119,2 +119,3 @@
 				//weapon
+			value("weapon_fired", int(GameObject::eOnWeaponFired)),
 				value("weapon_jammed",				int(GameObject::eOnWeaponJammed)),
@@ -123,2 +124,4 @@
 				value("weapon_magazine_empty",		int(GameObject::eOnWeaponMagazineEmpty)),
+			value("weapon_lowered", int(GameObject::eOnWeaponLowered)),
+			value("weapon_raised", int(GameObject::eOnWeaponRaised)),
 #endif
@@ -131,2 +134,3 @@
 				//-AVO
+			value("on_foot_step", int(GameObject::eOnFootStep)),
                 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/script_game_object_script2.cpp xray-monolith/src/xrGame/script_game_object_script2.cpp
--- coc-1.4-xray-64/src/xrGame/script_game_object_script2.cpp	2023-10-20 20:54:51.263326500 +0100
+++ xray-monolith/src/xrGame/script_game_object_script2.cpp	2023-10-20 20:54:33.195036100 +0100
@@ -29,2 +29,4 @@
 #include "smart_cover_object.h"
+#include "detail_path_manager_space.h"
+#include "patrol_path_manager_space.h"
 
@@ -74,6 +76,14 @@
 		.property("power",					&CScriptGameObject::GetPower,			&CScriptGameObject::SetPower)
-		.property("satiety",				&CScriptGameObject::GetSatiety,			&CScriptGameObject::ChangeSatiety)
+		.property("satiety", &CScriptGameObject::GetSatiety, &CScriptGameObject::SetSatiety)
 		.property("radiation",				&CScriptGameObject::GetRadiation,		&CScriptGameObject::SetRadiation)
 		.property("morale",					&CScriptGameObject::GetMorale,			&CScriptGameObject::SetMorale)
-		.property("bleeding",				&CScriptGameObject::GetBleeding,		&CScriptGameObject::SetBleeding)
+
+		.property("bleeding", &CScriptGameObject::GetBleeding, &CScriptGameObject::ChangeBleeding)
+
+		.def("change_health", &CScriptGameObject::ChangeHealth)
+		.def("change_psy_health", &CScriptGameObject::ChangePsyHealth)
+		.def("change_power", &CScriptGameObject::ChangePower)
+		.def("change_satiety", &CScriptGameObject::ChangeSatiety)
+		.def("change_radiation", &CScriptGameObject::ChangeRadiation)
+		.def("change_morale", &CScriptGameObject::ChangeMorale)
 
@@ -93,2 +103,5 @@
 		.def("set_condition",				&CScriptGameObject::SetCondition)
+		.def("power_critical", &CScriptGameObject::GetPowerCritical)
+		.def("psy_factor", &CScriptGameObject::GetPsyFactor)
+		.def("set_psy_factor", &CScriptGameObject::SetPsyFactor)
 		.def("death_time",					&CScriptGameObject::DeathTime)
@@ -126,15 +139,28 @@
 		.def("object",						(CScriptGameObject *(CScriptGameObject::*)(int))(&CScriptGameObject::GetObjectByIndex))
+		.def("object_id", &CScriptGameObject::GetObjectById)
 		.def("active_item",					&CScriptGameObject::GetActiveItem)
 		
-		.def("set_callback",				(void (CScriptGameObject::*)(GameObject::ECallbackType, const luabind::functor<void> &))(&CScriptGameObject::SetCallback))
-		.def("set_callback",				(void (CScriptGameObject::*)(GameObject::ECallbackType, const luabind::functor<void> &, const luabind::object &))(&CScriptGameObject::SetCallback))
+		.def("set_callback",
+		     (void (CScriptGameObject::*)(GameObject::ECallbackType, const luabind::functor<void>&))(&CScriptGameObject
+			     ::SetCallback))
+		.def("set_callback",
+		     (void (CScriptGameObject::*)(GameObject::ECallbackType, const luabind::functor<void>&,
+		                                  const luabind::object&))(&CScriptGameObject::SetCallback))
 		.def("set_callback",				(void (CScriptGameObject::*)(GameObject::ECallbackType))(&CScriptGameObject::SetCallback))
 
-		.def("set_patrol_extrapolate_callback",	(void (CScriptGameObject::*)())(&CScriptGameObject::set_patrol_extrapolate_callback))
-		.def("set_patrol_extrapolate_callback",	(void (CScriptGameObject::*)(const luabind::functor<bool> &))(&CScriptGameObject::set_patrol_extrapolate_callback))
-		.def("set_patrol_extrapolate_callback",	(void (CScriptGameObject::*)(const luabind::functor<bool> &, const luabind::object &))(&CScriptGameObject::set_patrol_extrapolate_callback))
+		.def("set_patrol_extrapolate_callback",
+		     (void (CScriptGameObject::*)())(&CScriptGameObject::set_patrol_extrapolate_callback))
+		.def("set_patrol_extrapolate_callback",
+		     (void (CScriptGameObject::*)(const luabind::functor<bool>&))(&CScriptGameObject::
+			     set_patrol_extrapolate_callback))
+		.def("set_patrol_extrapolate_callback",
+		     (void (CScriptGameObject::*)(const luabind::functor<bool>&, const luabind::object&))(&CScriptGameObject::
+			     set_patrol_extrapolate_callback))
 
 		.def("set_enemy_callback",			(void (CScriptGameObject::*)())(&CScriptGameObject::set_enemy_callback))
-		.def("set_enemy_callback",			(void (CScriptGameObject::*)(const luabind::functor<bool> &))(&CScriptGameObject::set_enemy_callback))
-		.def("set_enemy_callback",			(void (CScriptGameObject::*)(const luabind::functor<bool> &, const luabind::object &))(&CScriptGameObject::set_enemy_callback))
+		.def("set_enemy_callback",
+		     (void (CScriptGameObject::*)(const luabind::functor<bool>&))(&CScriptGameObject::set_enemy_callback))
+		.def("set_enemy_callback",
+		     (void (CScriptGameObject::*)(const luabind::functor<bool>&, const luabind::object&))(&CScriptGameObject::
+			     set_enemy_callback))
 
@@ -189,3 +215,4 @@
 
-		.def("set_override_animation",		&CScriptGameObject::set_override_animation)
+		.def("set_override_animation", (void (CScriptGameObject::*)(pcstr))(&CScriptGameObject::set_override_animation))
+		.def("set_override_animation", (void (CScriptGameObject::*)(u32, u32))(&CScriptGameObject::set_override_animation))
 		.def("clear_override_animation",	&CScriptGameObject::clear_override_animation)
@@ -293,3 +323,7 @@
 		.def("set_actor_position",			&CScriptGameObject::SetActorPosition)
-		.def("set_actor_direction",			&CScriptGameObject::SetActorDirection)
+		.def("set_actor_direction", (void (CScriptGameObject::*)(float)) &CScriptGameObject::SetActorDirection)
+		.def("set_actor_direction", (void (CScriptGameObject::*)(float, float))& CScriptGameObject::SetActorDirection)
+		.def("set_actor_direction", (void (CScriptGameObject::*)(float, float, float))& CScriptGameObject::SetActorDirection)
+		.def("set_actor_direction", (void (CScriptGameObject::*)(const Fvector&))&CScriptGameObject::SetActorDirection)
+
 		.def("disable_hit_marks",			(void (CScriptGameObject::*)	(bool))&CScriptGameObject::DisableHitMarks)
@@ -303,3 +337,6 @@
 		.def("item_in_slot",				&CScriptGameObject::item_in_slot)
-		.def("active_detector",				&CScriptGameObject::active_detector)
+		.def("active_detector", &CScriptGameObject::active_device)
+		.def("hide_detector", &CScriptGameObject::hide_device)
+		.def("force_hide_detector", &CScriptGameObject::force_hide_device)
+		.def("show_detector", &CScriptGameObject::show_device)
 		.def("active_slot",					&CScriptGameObject::active_slot)
@@ -315,2 +352,4 @@
 		.def("set_visual_name",				&CScriptGameObject::set_visual_name)
+		.def("get_inv_weight", &CScriptGameObject::get_current_weight)
+		.def("get_inv_max_weight", &CScriptGameObject::get_max_weight)
 		.def("get_visual_name",				&CScriptGameObject::get_visual_name)
@@ -394,3 +443,4 @@
 
-	;return	(instance);
+		.def("reload_weapon", &CScriptGameObject::reload_weapon);
+	return (instance);
 }
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/script_game_object_script3.cpp xray-monolith/src/xrGame/script_game_object_script3.cpp
--- coc-1.4-xray-64/src/xrGame/script_game_object_script3.cpp	2023-10-20 20:54:51.263326500 +0100
+++ xray-monolith/src/xrGame/script_game_object_script3.cpp	2023-10-20 20:54:33.195036100 +0100
@@ -34,2 +34,3 @@
 #include "artefact.h"
+#include "sight_manager_space.h"
 
@@ -86,7 +107,11 @@
         .def("set_item",					(void (CScriptGameObject::*)(MonsterSpace::EObjectAction ))(&CScriptGameObject::set_item))
-        .def("set_item",					(void (CScriptGameObject::*)(MonsterSpace::EObjectAction, CScriptGameObject *))(&CScriptGameObject::set_item))
-        .def("set_item",					(void (CScriptGameObject::*)(MonsterSpace::EObjectAction, CScriptGameObject *, u32))(&CScriptGameObject::set_item))
-        .def("set_item",					(void (CScriptGameObject::*)(MonsterSpace::EObjectAction, CScriptGameObject *, u32, u32))(&CScriptGameObject::set_item))
-
-        .def("bone_position",				&CScriptGameObject::bone_position)
+		.def("set_item",
+		     (void (CScriptGameObject::*)(MonsterSpace::EObjectAction, CScriptGameObject*))(&CScriptGameObject::set_item
+		     ))
+		.def("set_item",
+		     (void (CScriptGameObject::*)(MonsterSpace::EObjectAction, CScriptGameObject*, u32))(&CScriptGameObject::
+			     set_item))
+		.def("set_item",
+		     (void (CScriptGameObject::*)(MonsterSpace::EObjectAction, CScriptGameObject*, u32, u32))(&CScriptGameObject
+			     ::set_item))
 
@@ -94,2 +119,37 @@
 
+		// Backwards compatibility
+		.def("get_bone_id", (u16(CScriptGameObject::*)(LPCSTR))(&CScriptGameObject::bone_id))
+		.def("get_bone_id", (u16(CScriptGameObject::*)(LPCSTR, bool))(&CScriptGameObject::bone_id))
+
+		.def("bone_id", (u16(CScriptGameObject::*)(LPCSTR))(&CScriptGameObject::bone_id))
+		.def("bone_id", (u16(CScriptGameObject::*)(LPCSTR, bool))(&CScriptGameObject::bone_id))
+
+		.def("bone_name", (LPCSTR(CScriptGameObject::*)(u16))(&CScriptGameObject::bone_name))
+		.def("bone_name", (LPCSTR(CScriptGameObject::*)(u16, bool))(&CScriptGameObject::bone_name))
+
+		.def("bone_position", (Fvector(CScriptGameObject::*)(u16))(&CScriptGameObject::bone_position))
+		.def("bone_position", (Fvector(CScriptGameObject::*)(u16, bool))(&CScriptGameObject::bone_position))
+		.def("bone_position", (Fvector(CScriptGameObject::*)(LPCSTR))(&CScriptGameObject::bone_position))
+		.def("bone_position", (Fvector(CScriptGameObject::*)(LPCSTR, bool))(&CScriptGameObject::bone_position))
+
+		.def("bone_direction", (Fvector(CScriptGameObject::*)(u16))(&CScriptGameObject::bone_direction))
+		.def("bone_direction", (Fvector(CScriptGameObject::*)(u16, bool))(&CScriptGameObject::bone_direction))
+		.def("bone_direction", (Fvector(CScriptGameObject::*)(LPCSTR))(&CScriptGameObject::bone_direction))
+		.def("bone_direction", (Fvector(CScriptGameObject::*)(LPCSTR, bool))(&CScriptGameObject::bone_direction))
+
+		.def("bone_parent", (u16(CScriptGameObject::*)(u16))(&CScriptGameObject::bone_parent))
+		.def("bone_parent", (u16(CScriptGameObject::*)(u16, bool))(&CScriptGameObject::bone_parent))
+		.def("bone_parent", (u16(CScriptGameObject::*)(LPCSTR))(&CScriptGameObject::bone_parent))
+		.def("bone_parent", (u16(CScriptGameObject::*)(LPCSTR, bool))(&CScriptGameObject::bone_parent))
+
+		.def("bone_visible", (bool (CScriptGameObject::*)(u16))(&CScriptGameObject::is_bone_visible))
+		.def("bone_visible", (bool (CScriptGameObject::*)(u16, bool))(&CScriptGameObject::is_bone_visible))
+		.def("bone_visible", (bool (CScriptGameObject::*)(LPCSTR))(&CScriptGameObject::is_bone_visible))
+		.def("bone_visible", (bool (CScriptGameObject::*)(LPCSTR, bool))(&CScriptGameObject::is_bone_visible))
+
+		.def("set_bone_visible", (void (CScriptGameObject::*)(u16, bool, bool))(&CScriptGameObject::set_bone_visible))
+		.def("set_bone_visible", (void (CScriptGameObject::*)(u16, bool, bool, bool))(&CScriptGameObject::set_bone_visible))
+		.def("set_bone_visible", (void (CScriptGameObject::*)(LPCSTR, bool, bool))(&CScriptGameObject::set_bone_visible))
+		.def("set_bone_visible", (void (CScriptGameObject::*)(LPCSTR, bool, bool, bool))(&CScriptGameObject::set_bone_visible))
+
         //////////////////////////////////////////////////////////////////////////
@@ -111,2 +171,3 @@
         .def("attachable_item_enabled",		&CScriptGameObject::attachable_item_enabled)
+		.def("night_vision_allowed", &CScriptGameObject::night_vision_allowed)
         .def("enable_night_vision",			&CScriptGameObject::enable_night_vision)
@@ -166,2 +232,3 @@
         .def("transfer_item",				&CScriptGameObject::TransferItem)
+		.def("take_item", &CScriptGameObject::TakeItem)
         .def("transfer_money",				&CScriptGameObject::TransferMoney)
@@ -169,3 +236,18 @@
         .def("money",						&CScriptGameObject::Money)
+
+		// Tronex
+		.def("iterate_inventory", &CScriptGameObject::IterateInventory)
+		.def("iterate_ruck", &CScriptGameObject::IterateRuck)
+		.def("iterate_belt", &CScriptGameObject::IterateBelt)
+		.def("iterate_inventory_box", &CScriptGameObject::IterateInventoryBox)
         .def("make_item_active",			&CScriptGameObject::MakeItemActive)
+		.def("move_to_ruck", &CScriptGameObject::MoveItemToRuck)
+		.def("move_to_slot", &CScriptGameObject::MoveItemToSlot)
+		.def("move_to_belt", &CScriptGameObject::MoveItemToBelt)
+		.def("is_on_belt", &CScriptGameObject::IsOnBelt)
+		.def("item_on_belt", &CScriptGameObject::ItemOnBelt)
+		.def("belt_count", &CScriptGameObject::BeltSize)
+
+		.def("item_allow_trade", &CScriptGameObject::ItemAllowTrade)
+		.def("item_deny_trade", &CScriptGameObject::ItemDenyTrade)
 
@@ -243,2 +325,3 @@
         .def("disable_anomaly",             &CScriptGameObject::DisableAnomaly)
+		.def("set_idle_particles", &CScriptGameObject::ChangeAnomalyIdlePart)
         .def("get_anomaly_power",			&CScriptGameObject::GetAnomalyPower)
@@ -246,2 +329,6 @@
 
+		.def("get_anomaly_radius", &CScriptGameObject::GetAnomalyRadius)
+		.def("set_anomaly_radius", &CScriptGameObject::SetAnomalyRadius)
+		.def("set_anomaly_position", &CScriptGameObject::MoveAnomaly)
+
         .def("get_artefact_health",			&CScriptGameObject::GetArtefactHealthRestoreSpeed)
@@ -251,2 +338,4 @@
         .def("get_artefact_bleeding",			&CScriptGameObject::GetArtefactBleedingRestoreSpeed)        
+		.def("get_artefact_immunity", &CScriptGameObject::GetArtefactImmunity)
+		.def("get_artefact_additional_inventory_weight", &CScriptGameObject::GetArtefactAdditionalInventoryWeight)
 
@@ -257,2 +346,4 @@
         .def("set_artefact_bleeding",			&CScriptGameObject::SetArtefactBleedingRestoreSpeed)
+		.def("set_artefact_immunity", &CScriptGameObject::SetArtefactImmunity)
+		.def("set_artefact_additional_inventory_weight", &CScriptGameObject::SetArtefactAdditionalInventoryWeight)
                                 
@@ -262,3 +353,2 @@
         .def("get_hanging_lamp",            &CScriptGameObject::get_hanging_lamp)
-        .def("get_bone_id",					&CScriptGameObject::get_bone_id)
         .def("get_physics_shell",			&CScriptGameObject::get_physics_shell)
@@ -311,4 +402,2 @@
 
-        .def("iterate_inventory",			&CScriptGameObject::IterateInventory)
-        .def("iterate_inventory_box",		&CScriptGameObject::IterateInventoryBox)
         .def("mark_item_dropped",			&CScriptGameObject::MarkItemDropped)
@@ -316,2 +405,3 @@
         .def("unload_magazine",				&CScriptGameObject::UnloadMagazine)
+		.def("force_unload_magazine", &CScriptGameObject::ForceUnloadMagazine)
 
@@ -342,2 +432,3 @@
         .def("actor_look_at_point",			&CScriptGameObject::ActorLookAtPoint)
+		.def("actor_stop_look_at_point", &CScriptGameObject::ActorStopLookAtPoint)
         .def("enable_level_changer",		&CScriptGameObject::enable_level_changer)
@@ -360,8 +451,9 @@
 		.def("get_luminocity", &CScriptGameObject::GetLuminocity)
-		.def("bone_visible", &CScriptGameObject::IsBoneVisible)
-		.def("set_bone_visible", &CScriptGameObject::SetBoneVisible)
 		.def("set_health_ex", &CScriptGameObject::SetHealthEx)
 		.def("force_set_position", &CScriptGameObject::ForceSetPosition)
+		.def("force_set_angle", &CScriptGameObject::ForceSetAngle)
+		.def("angle", &CScriptGameObject::Angle)
 		.def("set_spatial_type", &CScriptGameObject::SetSpatialType)
 		.def("get_spatial_type", &CScriptGameObject::GetSpatialType)
+		.def("destroy_object", &CScriptGameObject::DestroyObject)
 		//For Ammo
@@ -390,3 +482,30 @@
 		.def("set_character_icon", &CScriptGameObject::SetCharacterIcon)
+		//casting
+		.def("cast_Actor", &CScriptGameObject::cast_Actor)
+		.def("cast_Car", &CScriptGameObject::cast_Car)
+		.def("cast_Heli", &CScriptGameObject::cast_Heli)
+		.def("cast_InventoryOwner", &CScriptGameObject::cast_InventoryOwner)
+		.def("cast_InventoryBox", &CScriptGameObject::cast_InventoryBox)
+		.def("cast_CustomZone", &CScriptGameObject::cast_CustomZone)
+		.def("cast_TorridZone", &CScriptGameObject::cast_TorridZone)
+		.def("cast_MosquitoBald", &CScriptGameObject::cast_MosquitoBald)
+		.def("cast_ZoneCampfire", &CScriptGameObject::cast_ZoneCampfire)
+		.def("cast_InventoryItem", &CScriptGameObject::cast_InventoryItem)
+		.def("cast_CustomOutfit", &CScriptGameObject::cast_CustomOutfit)
+		.def("cast_Helmet", &CScriptGameObject::cast_Helmet)
+		.def("cast_Artefact", &CScriptGameObject::cast_Artefact)
+		.def("cast_Ammo", &CScriptGameObject::cast_Ammo)
+		.def("cast_Weapon", &CScriptGameObject::cast_Weapon)
+		.def("cast_WeaponMagazined", &CScriptGameObject::cast_WeaponMagazined)
+		.def("cast_WeaponMagazinedWGrenade", &CScriptGameObject::cast_WeaponMagazinedWGrenade)
+		.def("cast_EatableItem", &CScriptGameObject::cast_EatableItem)
+		.def("cast_Medkit", &CScriptGameObject::cast_Medkit)
+		.def("cast_Antirad", &CScriptGameObject::cast_Antirad)
+		.def("cast_FoodItem", &CScriptGameObject::cast_FoodItem)
+		.def("cast_BottleItem", &CScriptGameObject::cast_BottleItem)
 		//Alundaio: END
+
+		//Torch
+		.def("set_color_animator", &CScriptGameObject::set_color_animator)
+		.def("reset_color_animator", &CScriptGameObject::reset_color_animator)
 #endif
@@ -408,2 +527,3 @@
         .def("is_outfit", &CScriptGameObject::IsCustomOutfit)
+		.def("is_helmet", &CScriptGameObject::IsHelmet)
         .def("is_scope", &CScriptGameObject::IsScope)
@@ -431,6 +551,2 @@
         .def("is_inventory_box", &CScriptGameObject::IsInventoryBox)
-		.def("is_on_belt", &CScriptGameObject::IsOnBelt)
-		.def("item_on_belt",			&CScriptGameObject::ItemOnBelt) 
-		.def("belt_count",				&CScriptGameObject::BeltSize)  
-        
 
@@ -456,6 +572,24 @@
         //end AVO
-#endif
 
+		// demonized: Additional exports
+		.def("get_actor_walk_accel", &CScriptGameObject::GetActorWalkAccel)
+		.def("set_actor_walk_accel", &CScriptGameObject::SetActorWalkAccel)
+		.def("get_actor_walk_back_coef", &CScriptGameObject::GetActorWalkBackCoef)
+		.def("set_actor_walk_back_coef", &CScriptGameObject::SetActorWalkBackCoef)
+
+		// demonized: Adjust Lookout factor
+		.def("get_actor_lookout_coef", &CScriptGameObject::GetActorLookoutCoef)
+		.def("set_actor_lookout_coef", &CScriptGameObject::SetActorLookoutCoef)
+
+		// demonized: add getters and setters for pathfinding for npcs around anomalies and damage for npcs
+		.def("get_enable_anomalies_pathfinding", &CScriptGameObject::get_enable_anomalies_pathfinding)
+		.def("set_enable_anomalies_pathfinding", &CScriptGameObject::set_enable_anomalies_pathfinding)
+		.def("get_enable_anomalies_damage", &CScriptGameObject::get_enable_anomalies_damage)
+		.def("set_enable_anomalies_damage", &CScriptGameObject::set_enable_anomalies_damage)
+#endif
 
-    ;return	(instance);
+		.def("set_can_be_harmed", &CScriptGameObject::SetCanBeHarmed)
+		.def("can_be_harmed", &CScriptGameObject::CanBeHarmed)
+		;
+	return (instance);
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/script_game_object_use2.cpp xray-monolith/src/xrGame/script_game_object_use2.cpp
--- coc-1.4-xray-64/src/xrGame/script_game_object_use2.cpp	2023-10-20 20:54:51.265327600 +0100
+++ xray-monolith/src/xrGame/script_game_object_use2.cpp	2023-10-20 20:54:33.197036200 +0100
@@ -126,2 +137,14 @@
 
+void CScriptGameObject::set_override_animation(u32 AnimType, u32 AnimIndex)
+{
+	CBaseMonster* monster = smart_cast<CBaseMonster*>(&object());
+	if (!monster)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError, "object is not of CBaseMonster class!");
+		return;
+	}
+
+	monster->anim().set_override_animation_script((EMotionAnim)AnimType, AnimIndex);
+}
+
 void   CScriptGameObject::clear_override_animation ()
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/script_game_object2.cpp xray-monolith/src/xrGame/script_game_object2.cpp
--- coc-1.4-xray-64/src/xrGame/script_game_object2.cpp	2023-10-20 20:54:51.260326500 +0100
+++ xray-monolith/src/xrGame/script_game_object2.cpp	2023-10-20 20:54:33.192035500 +0100
@@ -39,2 +39,5 @@
 #include "detail_path_manager.h"
+#include "Inventory.h"
+#include "InventoryOwner.h"
+#include "CharacterPhysicsSupport.h"
 
@@ -152,17 +173,11 @@
 	SHit			HS;
-	HS.GenHeader(GE_HIT,object().ID());										//	object().u_EventGen(P,GE_HIT,object().ID());
-	THROW2			(tLuaHit.m_tpDraftsman,"Where is hit initiator??!");	//	THROW2			(tLuaHit.m_tpDraftsman,"Where is hit initiator??!");
-	HS.whoID  = u16(tLuaHit.m_tpDraftsman->ID());							//	P.w_u16			(u16(tLuaHit.m_tpDraftsman->ID()));
-	HS.weaponID = 0;														//	P.w_u16			(0);
-	HS.dir = tLuaHit.m_tDirection;											//	P.w_dir			(tLuaHit.m_tDirection);
-	HS.power = tLuaHit.m_fPower;											//	P.w_float		(tLuaHit.m_fPower);
-	IKinematics		*V = smart_cast<IKinematics*>(object().Visual());		//	IKinematics		*V = smart_cast<IKinematics*>(object().Visual());
-	VERIFY			(V);													//	VERIFY			(V);
-	if (xr_strlen	(tLuaHit.m_caBoneName))									//	if (xr_strlen	(tLuaHit.m_caBoneName))
-		HS.boneID = 		(V->LL_BoneID(tLuaHit.m_caBoneName));			//		P.w_s16		(V->LL_BoneID(tLuaHit.m_caBoneName));
-	else																	//	else
-		HS.boneID = 		(s16(0));										//		P.w_s16		(s16(0));
-	HS.p_in_bone_space = Fvector().set(0,0,0);								//	P.w_vec3		(Fvector().set(0,0,0));
-	HS.impulse = tLuaHit.m_fImpulse;										//	P.w_float		(tLuaHit.m_fImpulse);
-	HS.hit_type = (ALife::EHitType)(tLuaHit.m_tHitType);					//	P.w_u16			(u16(tLuaHit.m_tHitType));
+	HS.GenHeader(GE_HIT, object().ID());
+	HS.ApplyScriptHit(&tLuaHit);
+	if (xr_strlen(tLuaHit.m_caBoneName))
+	{
+		IKinematics* V = smart_cast<IKinematics*>(object().Visual());
+		if (V)
+			HS.boneID = (V->LL_BoneID(tLuaHit.m_caBoneName));
+	}
+	HS.p_in_bone_space = Fvector().set(0, 0, 0);
 	HS.Write_Packet(P);						
@@ -325,6 +358,20 @@
 
-void CScriptGameObject::SetActorPosition			(Fvector pos)
+void CScriptGameObject::SetActorPosition(Fvector pos, bool bskip_collision_correct)
 {
 	CActor* actor = smart_cast<CActor*>(&object());
-	if(actor){
+	if (actor)
+	{
+		if (bskip_collision_correct)
+		{
+			Fmatrix F = actor->XFORM();
+			F.c = pos;
+			actor->XFORM().set(F);
+			if (actor->character_physics_support()->movement()->CharacterExist())
+			{
+				actor->character_physics_support()->movement()->SetPosition(F.c);
+				actor->character_physics_support()->movement()->SetVelocity(0.f, 0.f, 0.f);
+			}
+		}
+		else
+		{
 		Fmatrix F = actor->XFORM();
@@ -332,6 +379,7 @@
 		actor->ForceTransform(F);
-//		actor->XFORM().c = pos;
-	}else
-		ai().script_engine().script_log		(ScriptStorage::eLuaMessageTypeError,"ScriptGameObject : attempt to call SetActorPosition method for non-actor object");
-
+		}
+	}
+	else
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+		                                "ScriptGameObject : attempt to call SetActorPosition method for non-actor object");
 }
@@ -349,15 +398,35 @@
 		//		actor->XFORM().c = pos;
-	}else
-		ai().script_engine().script_log		(ScriptStorage::eLuaMessageTypeError,"ScriptGameObject : attempt to call SetActorPosition method for non-CCustomMonster object");
-
+	}
+	else
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+		                                "ScriptGameObject : attempt to call SetActorPosition method for non-CCustomMonster object");
 }
 
-void CScriptGameObject::SetActorDirection		(float dir)
+// demonized: add pitch for set actor direction
+void CScriptGameObject::SetActorDirection(float dir, float pitch, float roll)
 {
 	CActor* actor = smart_cast<CActor*>(&object());
-	if(actor){
-		actor->cam_Active()->Set(dir,0,0);
+	if (actor)
+	{
+		actor->cam_Active()->Set(dir, pitch, roll);
 //		actor->XFORM().setXYZ(0,dir,0);
 	}else
-		ai().script_engine().script_log		(ScriptStorage::eLuaMessageTypeError,"ScriptGameObject : attempt to call SetActorDirection method for non-actor object");
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"ScriptGameObject : attempt to call SetActorDirection method for non-actor object");
+}
+
+void CScriptGameObject::SetActorDirection(float dir, float pitch)
+{
+	SetActorDirection(dir, pitch, 0);
+}
+
+void CScriptGameObject::SetActorDirection(float dir)
+{
+	SetActorDirection(dir, 0, 0);
+}
+
+// HPB vector input
+void CScriptGameObject::SetActorDirection(const Fvector& dir)
+{
+	SetActorDirection(dir.x, dir.y, dir.z);
 }
@@ -390,6 +461,8 @@
 	{
-		ai().script_engine().script_log		(ScriptStorage::eLuaMessageTypeError,"ScriptGameObject : attempt to call GetMovementSpeed method for non-actor object");
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+		                                "ScriptGameObject : attempt to call GetMovementSpeed method for non-actor object");
 		NODEFAULT;
 	}
-	return actor->GetMovementSpeed();
+	//return actor->GetMovementSpeed();
+	return actor->character_physics_support()->movement()->GetVelocity();
 }
@@ -526,13 +619,73 @@
 
-void CScriptGameObject::set_visual_name(LPCSTR visual)
+#include "stalker_animation_manager.h"
+#include "CharacterPhysicsSupport.h"
+#include "PhysicsShellHolder.h"
+
+void CScriptGameObject::set_visual_name(LPCSTR visual, bool bForce)
 {
-	object().cNameVisual_set(visual);
+	if (strcmp(visual, object().cNameVisual().c_str()) == 0)
+		return;
 
-	/*
-	CAI_Stalker* stalker = smart_cast<CAI_Stalker*>(&object());
-	if (!stalker)
+	NET_Packet P;
+	object().u_EventGen(P, GE_CHANGE_VISUAL, object().ID());
+	P.w_stringZ(visual);
+	object().u_EventSend(P);
+
+	CActor* actor = smart_cast<CActor*>(&object());
+	if (actor)
+	{
+		actor->ChangeVisual(visual);
 		return;
+	}
 
+	CAI_Stalker* stalker = smart_cast<CAI_Stalker*>(&object());
+	if (stalker)
+	{
+		stalker->ChangeVisual(visual);
+
+		IKinematicsAnimated* V = smart_cast<IKinematicsAnimated*>(stalker->Visual());
+		if (V)
+		{
+			if (!stalker->g_Alive())
+			{
+				stalker->m_pPhysics_support->in_Die(false);
+			}
+			else
+			{
+				stalker->CStepManager::reload(stalker->cNameSect().c_str());
+			}
+
+			stalker->CDamageManager::reload(*stalker->cNameSect(), "damage", pSettings);
 	stalker->ResetBoneProtections(NULL,NULL);
-	*/
+			stalker->reattach_items();
+			stalker->m_pPhysics_support->in_ChangeVisual();
+			stalker->animation().reload();
+		}
+
+		return;
+	}
+
+	object().cNameVisual_set(visual);
+	object().Visual()->dcast_PKinematics()->CalculateBones_Invalidate();
+	object().Visual()->dcast_PKinematics()->CalculateBones(TRUE);
+}
+
+float CScriptGameObject::get_current_weight()
+{
+	CInventoryOwner* inv_owner = smart_cast<CInventoryOwner*>(&object());
+
+	if (inv_owner)
+		return inv_owner->inventory().TotalWeight();
+
+	return 0;
+}
+
+float CScriptGameObject::get_max_weight()
+{
+	CInventoryOwner* inv_owner = smart_cast<CInventoryOwner*>(&object());
+
+	if (inv_owner)
+		return inv_owner->inventory().GetMaxWeight();
+
+	return 0;
 }
@@ -543 +696,20 @@
 }
\ No newline at end of file
+
+#include <Inventory.h>
+#include <Weapon.h>
+#include <xr_level_controller.h>
+
+void CScriptGameObject::reload_weapon()
+{
+	CActor* act = smart_cast<CActor*>(&object());
+	if (act)
+	{
+		PIItem it = act->inventory().ActiveItem();
+		if (it)
+		{
+			CWeapon* wpn = it->cast_weapon();
+			if (wpn)
+				wpn->Action(kWPN_RELOAD, CMD_START);
+		}
+	}
+}
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/script_game_object3.cpp xray-monolith/src/xrGame/script_game_object3.cpp
--- coc-1.4-xray-64/src/xrGame/script_game_object3.cpp	2023-10-20 20:54:51.261326500 +0100
+++ xray-monolith/src/xrGame/script_game_object3.cpp	2023-10-20 20:54:33.193035500 +0100
@@ -55,3 +55,7 @@
 
-namespace MemorySpace {
+#include "Torch.h"
+#include "Flashlight.h"
+
+namespace MemorySpace
+{
 	struct CVisibleObject;
@@ -815,4 +953,42 @@
 	}
-	else {
-		ai().script_engine().script_log			(ScriptStorage::eLuaMessageTypeError,"CScriptGameObject : cannot access class member object!");
+	else
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+		                                "CScriptGameObject : cannot access class member object!");
+		return (0);
+	}
+}
+
+CScriptGameObject* CScriptGameObject::GetObjectById(u16 id) const
+{
+	CInventoryOwner* l_tpInventoryOwner = smart_cast<CInventoryOwner*>(&object());
+	CInventoryBox* inventory_box = smart_cast<CInventoryBox*>(&this->object());
+	if (l_tpInventoryOwner)
+	{
+		CInventoryItem* l_tpInventoryItem = l_tpInventoryOwner->inventory().GetItemFromInventory(id);
+		CGameObject* l_tpGameObject = smart_cast<CGameObject*>(l_tpInventoryItem);
+		if (!l_tpGameObject)
+			return (0);
+		else
+			return (l_tpGameObject->lua_game_object());
+	}
+	else if (inventory_box)
+	{
+		xr_vector<u16>::const_iterator I = inventory_box->m_items.begin();
+		xr_vector<u16>::const_iterator E = inventory_box->m_items.end();
+		for (; I != E; ++I)
+		{
+			if (*I == id)
+			{
+				CGameObject* GO = smart_cast<CGameObject*>(Level().Objects.net_Find(*I));
+				if (GO) return (GO->lua_game_object());
+				return (0);
+			}
+		}
+		return (0);
+	}
+	else
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CScriptGameObject : cannot access class member object_id!");
 		return			(0);	
@@ -833,5 +1011,13 @@
 
+void CScriptGameObject::ChangeAnomalyIdlePart(LPCSTR name, bool bIdleLight)
+{
+	CCustomZone* zone = smart_cast<CCustomZone*>(&object());
+	THROW(zone);
+	zone->ChangeIdleParticles(name, bIdleLight);
+}
+
 float CScriptGameObject::GetAnomalyPower()
 {
-	CCustomZone		*zone = smart_cast<CCustomZone*>(&object()); THROW(zone);
+	CCustomZone* zone = smart_cast<CCustomZone*>(&object());
+	THROW(zone);
 	return zone->GetMaxPower();
@@ -845,2 +1032,52 @@
 
+float CScriptGameObject::GetAnomalyRadius()
+{
+	CCustomZone* zone = smart_cast<CCustomZone*>(&object());
+	THROW(zone);
+	return zone->GetEffectiveRadius();
+}
+
+void CScriptGameObject::SetAnomalyRadius(float p)
+{
+	CCustomZone* zone = smart_cast<CCustomZone*>(&object());
+	THROW(zone);
+	zone->SetEffectiveRadius(p);
+}
+
+void CScriptGameObject::MoveAnomaly(Fvector pos)
+{
+	CCustomZone* zone = smart_cast<CCustomZone*>(&object());
+	THROW(zone);
+	zone->MoveScript(pos);
+}
+
+void CScriptGameObject::set_color_animator(LPCSTR name, bool bFlicker, int flickerChance, float flickerDelay,
+                                           int framerate)
+{
+	CTorch* torch = smart_cast<CTorch*>(&object());
+	if (torch)
+	{
+		torch->SetLanim(name, bFlicker, flickerChance, flickerDelay, framerate);
+		return;
+	}
+
+	CFlashlight* flashlight = smart_cast<CFlashlight*>(&object());
+	if (flashlight)
+		flashlight->SetLanim(name, bFlicker, flickerChance, flickerDelay, framerate);
+}
+
+void CScriptGameObject::reset_color_animator()
+{
+	CTorch* torch = smart_cast<CTorch*>(&object());
+	if (torch)
+	{
+		torch->ResetLanim();
+		return;
+	}
+
+	CFlashlight* flashlight = smart_cast<CFlashlight*>(&object());
+	if (flashlight)
+		flashlight->ResetLanim();
+}
+
 bool CScriptGameObject::weapon_strapped	() const
@@ -1205,2 +1486,10 @@
 
+float CScriptGameObject::GetArtefactImmunity(ALife::EHitType hit_type)
+{
+	CArtefact* artefact = smart_cast<CArtefact*>(&object());
+	THROW(artefact);
+
+	return artefact->GetImmunity(hit_type);
+}
+
 void CScriptGameObject::SetArtefactHealthRestoreSpeed(float value)
@@ -1244,2 +1534,26 @@
 
+void CScriptGameObject::SetArtefactImmunity(ALife::EHitType hit_type, float value)
+{
+	CArtefact* artefact = smart_cast<CArtefact*>(&object());
+	THROW(artefact);
+
+	return artefact->SetImmunity(hit_type, value);
+}
+
+float CScriptGameObject::GetArtefactAdditionalInventoryWeight()
+{
+	CArtefact* artefact = smart_cast<CArtefact*>(&object());
+	THROW(artefact);
+
+	return artefact->m_additional_weight;
+}
+
+void CScriptGameObject::SetArtefactAdditionalInventoryWeight(float value)
+{
+	CArtefact* artefact = smart_cast<CArtefact*>(&object());
+	THROW(artefact);
+
+	artefact->m_additional_weight = value;
+}
+
 void CScriptGameObject::AttachVehicle(CScriptGameObject* veh, bool bForce)
@@ -1249,7 +1563,7 @@
 	{
-		CHolderCustom* vehicle = veh->object().cast_holder_custom();
+		CHolderCustom* vehicle = smart_cast<CHolderCustom*>(&veh->object());
 		if (vehicle)
-		{
 			actor->use_HolderEx(vehicle, bForce);
-		}
+		else
+			ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError, "CGameObject : cannot be cast to CHolderCustom!");
 	}
@@ -1283,6 +1597,7 @@
 
-u32 CScriptGameObject::PlayHudMotion(LPCSTR M, bool bMixIn, u32 state)
+u32 CScriptGameObject::PlayHudMotion(LPCSTR M, bool bMixIn, u32 state, float speed, float end)
 {
 	CWeapon* Weapon = object().cast_weapon();
-	if (Weapon){
+	if (Weapon)
+	{
 		if (!Weapon->HudAnimationExist(M))
@@ -1290,3 +1605,3 @@
 
-		return Weapon->PlayHUDMotion(M, bMixIn, Weapon, state);
+		return Weapon->PlayHUDMotion(M, bMixIn, Weapon, state, speed, end);
 	}
@@ -1300,3 +1615,3 @@
 
-	return itm->PlayHUDMotion(M, bMixIn, itm, state);
+	return itm->PlayHUDMotion(M, bMixIn, itm, state, speed, end);
 }
@@ -1349,33 +1664,2 @@
 
-void CScriptGameObject::SetBoneVisible(LPCSTR bone_name, bool bVisibility, bool bRecursive)
-{
-	IKinematics* k = object().Visual()->dcast_PKinematics();
-
-	if (!k)
-		return;
-
-	u16 bone_id = k->LL_BoneID(bone_name);
-	if (bone_id == BI_NONE)
-		return;
-
-	if (bVisibility == !k->LL_GetBoneVisible(bone_id))
-		k->LL_SetBoneVisible(bone_id, bVisibility, bRecursive);
-
-	return;
-}
-
-bool CScriptGameObject::IsBoneVisible(LPCSTR bone_name)
-{
-	IKinematics* k = object().Visual()->dcast_PKinematics();
-
-	if (!k)
-		return false;
-
-	u16 bone_id = k->LL_BoneID(bone_name);
-	if (bone_id == BI_NONE)
-		return false;
-
-	return k->LL_GetBoneVisible(bone_id)==TRUE?true:false;
-}
-
 float CScriptGameObject::GetLuminocityHemi()
@@ -1411,2 +1696,7 @@
 
+#if 1
+		Fmatrix M = Fmatrix().set(object().XFORM());
+		M.translate_over(pos);
+		object().XFORM().set(M);
+#else
 		Fmatrix	M = object().XFORM();
@@ -1414,2 +1704,3 @@
 		M.set(M);
+#endif
 
@@ -1420,3 +1711,39 @@
 	else
-		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError, "force_set_position: object %s has no physics shell!", *object().cName());
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+		                                "force_set_position: object %s has no physics shell!", *object().cName());
+}
+
+void CScriptGameObject::ForceSetAngle(Fvector ang, bool bActivate)
+{
+	CPhysicsShellHolder *sh = object().cast_physics_shell_holder();
+	if (!sh)
+		return;
+
+	if (bActivate)
+		sh->activate_physic_shell();
+
+	CPhysicsShell *shell = sh->PPhysicsShell();
+	if (shell)
+	{
+		Fmatrix M = Fmatrix().set(object().XFORM());
+		Fvector p = Fvector().set(object().XFORM().c);
+		M.setHPB(ang.x, ang.y, ang.z);
+		M.translate_over(p);
+		object().XFORM().set(M);
+		shell->SetGlTransformDynamic(M);
+		if (sh->character_physics_support())
+			sh->character_physics_support()->ForceTransform(M);
+	}
+	else
+	{
+		LPCSTR text = "force_set_angleHPB: object %s has no physics shell!";
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError, text, object().Name());
+	}
+}
+
+Fvector CScriptGameObject::Angle()
+{
+	Fvector ang;
+	object().XFORM().getHPB(ang.x, ang.y, ang.z);
+	return ang;
 }
@@ -1487,2 +1815,7 @@
 
+void CScriptGameObject::DestroyObject()
+{
+	object().DestroyObject();
+}
+
 u8 CScriptGameObject::GetRestrictionType()
@@ -1506,2 +1839,48 @@
 }
+
+// demonized: add getters and setters for pathfinding for npcs around anomalies and damage for npcs
+bool CScriptGameObject::get_enable_anomalies_pathfinding()
+{
+	auto stalker = smart_cast<CAI_Stalker*>(&object());
+	if (!stalker)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CGameObject : cannot access class member m_enable_anomalies_pathfinding!");
+		return false;
+	}
+	return stalker->m_enable_anomalies_pathfinding;
+}
+void CScriptGameObject::set_enable_anomalies_pathfinding(bool v)
+{
+	auto stalker = smart_cast<CAI_Stalker*>(&object());
+	if (!stalker)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CGameObject : cannot access class member m_enable_anomalies_pathfinding!");
+		return;
+	}
+	stalker->m_enable_anomalies_pathfinding = v;
+}
+bool CScriptGameObject::get_enable_anomalies_damage()
+{
+	auto stalker = smart_cast<CAI_Stalker*>(&object());
+	if (!stalker)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CGameObject : cannot access class member m_enable_anomalies_damage!");
+		return false;
+	}
+	return stalker->m_enable_anomalies_damage;
+}
+void CScriptGameObject::set_enable_anomalies_damage(bool v)
+{
+	auto stalker = smart_cast<CAI_Stalker*>(&object());
+	if (!stalker)
+	{
+		ai().script_engine().script_log(ScriptStorage::eLuaMessageTypeError,
+			"CGameObject : cannot access class member m_enable_anomalies_damage!");
+		return;
+	}
+	stalker->m_enable_anomalies_damage = v;
+}
 #endif
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/script_game_object4.cpp xray-monolith/src/xrGame/script_game_object4.cpp
--- coc-1.4-xray-64/src/xrGame/script_game_object4.cpp	2023-10-20 20:54:51.261326500 +0100
+++ xray-monolith/src/xrGame/script_game_object4.cpp	2023-10-20 20:54:33.193035500 +0100
@@ -20,4 +20,2 @@
 #include "sight_manager.h"
-#include "inventoryBox.h"
-#include "ZoneCampfire.h"
 #include "physicobject.h"
@@ -26,2 +24,31 @@
 
+#include "Actor.h"
+#include "Car.h"
+#include "helicopter.h"
+#include "InventoryOwner.h"
+#include "inventoryBox.h"
+#include "CustomZone.h"
+#include "TorridZone.h"
+#include "MosquitoBald.h"
+#include "ZoneCampfire.h"
+#include "CustomOutfit.h"
+#include "ActorHelmet.h"
+#include "Artefact.h"
+#include "Weapon.h"
+#include "WeaponAmmo.h"
+#include "WeaponMagazined.h"
+#include "WeaponMagazinedWGrenade.h"
+#include "ai\monsters\basemonster\base_monster.h"
+#include "scope.h"
+#include "silencer.h"
+#include "torch.h"
+#include "GrenadeLauncher.h"
+#include "searchlight.h"
+//#include "grenade.h"
+#include "eatable_item.h"
+#include "FoodItem.h"
+#include "medkit.h"
+#include "antirad.h"
+#include "BottleItem.h"
+
 class CWeapon;
@@ -382,25 +440,7 @@
 }
-//-AVO
 
-// AVO: functions for testing object class
-// Credits: KD
-//#include "car.h"
-//#include "helicopter.h"
-#include "actor.h"
-#include "customoutfit.h"
-//#include "customzone.h"
-#include "ai\monsters\basemonster\base_monster.h"
-//#include "Artifact.h"
-//#include "medkit.h"
-//#include "antirad.h"
-#include "scope.h"
-#include "silencer.h"
-#include "torch.h"
-#include "GrenadeLauncher.h"
-#include "searchlight.h"
-//#include "WeaponAmmo.h"
-//#include "grenade.h"
-//#include "BottleItem.h"
-#include "WeaponMagazinedWGrenade.h"
+//-AVO
 
+// AVO: Credits: KD
+// functions for testing object class 
 #define TEST_OBJECT_CLASS(A,B)\
@@ -413,4 +453,3 @@
         return true;\
-};\
-
+};
 //TEST_OBJECT_CLASS(CScriptGameObject::IsGameObject, CGameObject)
@@ -429,2 +468,3 @@
 TEST_OBJECT_CLASS(CScriptGameObject::IsCustomOutfit, CCustomOutfit)
+TEST_OBJECT_CLASS(CScriptGameObject::IsHelmet, CHelmet)
 TEST_OBJECT_CLASS(CScriptGameObject::IsScope, CScope)
@@ -453,2 +493,56 @@
 #endif
+
+// Casting
+#define SPECIFIC_CAST(A,B)\
+B* A ()\
+{\
+    B				*l_tpEntity = smart_cast<B*>(&object());\
+    if (!l_tpEntity)\
+        return (0);\
+                else\
+        return l_tpEntity;\
+};\
+
+SPECIFIC_CAST(CScriptGameObject::cast_Actor, CActor);
+SPECIFIC_CAST(CScriptGameObject::cast_Car, CCar);
+SPECIFIC_CAST(CScriptGameObject::cast_Heli, CHelicopter);
+SPECIFIC_CAST(CScriptGameObject::cast_InventoryOwner, CInventoryOwner);
+SPECIFIC_CAST(CScriptGameObject::cast_InventoryBox, CInventoryBox);
+SPECIFIC_CAST(CScriptGameObject::cast_CustomZone, CCustomZone);
+SPECIFIC_CAST(CScriptGameObject::cast_TorridZone, CTorridZone);
+SPECIFIC_CAST(CScriptGameObject::cast_MosquitoBald, CMosquitoBald);
+SPECIFIC_CAST(CScriptGameObject::cast_ZoneCampfire, CZoneCampfire);
+SPECIFIC_CAST(CScriptGameObject::cast_InventoryItem, CInventoryItem);
+SPECIFIC_CAST(CScriptGameObject::cast_CustomOutfit, CCustomOutfit);
+SPECIFIC_CAST(CScriptGameObject::cast_Helmet, CHelmet);
+SPECIFIC_CAST(CScriptGameObject::cast_Artefact, CArtefact);
+SPECIFIC_CAST(CScriptGameObject::cast_Ammo, CWeaponAmmo);
+SPECIFIC_CAST(CScriptGameObject::cast_Weapon, CWeapon);
+SPECIFIC_CAST(CScriptGameObject::cast_WeaponMagazined, CWeaponMagazined);
+SPECIFIC_CAST(CScriptGameObject::cast_WeaponMagazinedWGrenade, CWeaponMagazinedWGrenade);
+CMedkit* CScriptGameObject::cast_Medkit()
+{
+	CInventoryItem* ii = object().cast_inventory_item();
+	return ii ? smart_cast<CMedkit*>(ii) : (0);
+}
+CEatableItem* CScriptGameObject::cast_EatableItem()
+{
+	CInventoryItem* ii = object().cast_inventory_item();
+	return ii ? ii->cast_eatable_item() : (0);
+}
+CAntirad* CScriptGameObject::cast_Antirad()
+{
+	CInventoryItem* ii = object().cast_inventory_item();
+	return ii ? smart_cast<CAntirad*>(ii) : (0);
+}
+CFoodItem* CScriptGameObject::cast_FoodItem()
+{
+	CInventoryItem* ii = object().cast_inventory_item();
+	return ii ? ii->cast_food_item() : (0);
+}
+CBottleItem* CScriptGameObject::cast_BottleItem()
+{
+	CInventoryItem* ii = object().cast_inventory_item();
+	return ii ? smart_cast<CBottleItem*>(ii) : (0);
+}
 //end AVO
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/script_hit.h xray-monolith/src/xrGame/script_hit.h
--- coc-1.4-xray-64/src/xrGame/script_hit.h	2023-10-20 20:54:51.266326800 +0100
+++ xray-monolith/src/xrGame/script_hit.h	2023-10-20 20:54:33.197036200 +0100
@@ -13,5 +13,7 @@
 
+struct SHit;
 class CScriptGameObject;
 
-class CScriptHit {
+class CScriptHit
+{
 public:
@@ -23,2 +25,3 @@
 	int					m_tHitType;
+	u16 m_tpWeaponID;
 
@@ -27,2 +30,3 @@
 	IC					CScriptHit		(const CScriptHit *tpLuaHit);
+	IC CScriptHit(const SHit* tpHit);
 	virtual				~CScriptHit		();
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/script_hit_inline.h xray-monolith/src/xrGame/script_hit_inline.h
--- coc-1.4-xray-64/src/xrGame/script_hit_inline.h	2023-10-20 20:54:51.266326800 +0100
+++ xray-monolith/src/xrGame/script_hit_inline.h	2023-10-20 20:54:33.198035300 +0100
@@ -9,2 +9,4 @@
 #pragma once
+#include "Hit.h"
+#include "GameObject.h"
 
@@ -17,2 +19,3 @@
 	m_fImpulse			= 100;
+	m_tpWeaponID = 0;
 	m_tHitType			= ALife::eHitTypeWound;
@@ -25,2 +28,12 @@
 
+IC CScriptHit::CScriptHit(const SHit* tpHit)
+{
+	m_fPower = tpHit->power;
+	m_tDirection = tpHit->direction();
+	m_tpDraftsman = smart_cast<const CGameObject*>(tpHit->who)->lua_game_object();
+	m_fImpulse = tpHit->impulse;
+	m_tpWeaponID = tpHit->weaponID;
+	m_tHitType = tpHit->hit_type;
+}
+
 IC	void CScriptHit::set_bone_name	(LPCSTR bone_name)
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/script_hit_script.cpp xray-monolith/src/xrGame/script_hit_script.cpp
--- coc-1.4-xray-64/src/xrGame/script_hit_script.cpp	2023-10-20 20:54:51.266326800 +0100
+++ xray-monolith/src/xrGame/script_hit_script.cpp	2023-10-20 20:54:33.198035300 +0100
@@ -39,2 +39,3 @@
 			.def_readwrite("type",				&CScriptHit::m_tHitType)
+		.def_readwrite("weapon_id", &CScriptHit::m_tpWeaponID)
 			.def(								constructor<>())
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/script_particles.cpp xray-monolith/src/xrGame/script_particles.cpp
--- coc-1.4-xray-64/src/xrGame/script_particles.cpp	2023-10-20 20:54:51.274326800 +0100
+++ xray-monolith/src/xrGame/script_particles.cpp	2023-10-20 20:54:33.206036900 +0100
@@ -109,9 +115,9 @@
 
-void CScriptParticles::Play()
+void CScriptParticles::Play(bool bHudMode)
 {
 	VERIFY						(m_particles);
-	m_particles->Play			(false);
+	m_particles->Play(bHudMode);
 }
 
-void CScriptParticles::PlayAtPos(const Fvector &position)
+void CScriptParticles::PlayAtPos(const Fvector& position, bool bHudMode)
 {
@@ -121,3 +127,3 @@
 	m_particles->UpdateParent	(m_transform, zero_vel);	
-	m_particles->Play(false);	
+	m_particles->Play(bHudMode);
 	m_particles->UpdateParent	(m_transform, zero_vel);  
@@ -148,2 +154,9 @@
 
+void CScriptParticles::XFORMMoveTo(const Fvector& pos)
+{
+	VERIFY(m_particles);
+	m_transform.translate_over(pos);
+	m_particles->SetXFORM(m_transform);
+}
+
 void CScriptParticles::SetDirection (const Fvector &dir)
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/script_particles.h xray-monolith/src/xrGame/script_particles.h
--- coc-1.4-xray-64/src/xrGame/script_particles.h	2023-10-20 20:54:51.274326800 +0100
+++ xray-monolith/src/xrGame/script_particles.h	2023-10-20 20:54:33.206036900 +0100
@@ -42,4 +44,4 @@
 
-	void						Play				();
-	void						PlayAtPos			(const Fvector &pos);
+	void Play(bool bHudMode = false);
+	void PlayAtPos(const Fvector& pos, bool bHudMode = false);
 	void						Stop				();
@@ -51,2 +53,3 @@
 	void						MoveTo				(const Fvector &pos, const Fvector& vel);
+	void XFORMMoveTo(const Fvector & pos);
   void						SetDirection		(const Fvector &dir);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/script_particles_script.cpp xray-monolith/src/xrGame/script_particles_script.cpp
--- coc-1.4-xray-64/src/xrGame/script_particles_script.cpp	2023-10-20 20:54:51.274326800 +0100
+++ xray-monolith/src/xrGame/script_particles_script.cpp	2023-10-20 20:54:33.207035700 +0100
@@ -29,2 +29,3 @@
 			.def("move_to",						&CScriptParticles::MoveTo)
+		.def("set_position", &CScriptParticles::XFORMMoveTo)
       		.def("set_direction",				&CScriptParticles::SetDirection)
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/script_render_device_script.cpp xray-monolith/src/xrGame/script_render_device_script.cpp
--- coc-1.4-xray-64/src/xrGame/script_render_device_script.cpp	2023-10-20 20:54:51.276326700 +0100
+++ xray-monolith/src/xrGame/script_render_device_script.cpp	2023-10-20 20:54:33.208035600 +0100
@@ -35,2 +36,8 @@
 
+u32 time_continual(const CRenderDevice* self)
+{
+	THROW(self);
+	return (self->dwTimeContinual);
+}
+
 #pragma optimize("s",on)
@@ -55,2 +62,3 @@
 			.def("time_global",						&time_global)
+		.def("time_continual", &time_continual)
 			.def_readonly("precache_frame",			&CRenderDevice::dwPrecacheFrame)
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/script_sound.cpp xray-monolith/src/xrGame/script_sound.cpp
--- coc-1.4-xray-64/src/xrGame/script_sound.cpp	2023-10-20 20:54:51.276326700 +0100
+++ xray-monolith/src/xrGame/script_sound.cpp	2023-10-20 20:54:33.209035900 +0100
@@ -23,3 +23,6 @@
 	else
+	{
 		ai().script_engine().script_log	(ScriptStorage::eLuaMessageTypeError,"File not found \"%s\"!",l_caFileName);
+		m_sound.create("$no_sound.ogg", st_Effect, sound_type);
+	}
 }
@@ -28,3 +31,6 @@
 {
-	THROW3					(!m_sound._feedback(),"playing sound is not completed, but is destroying",m_sound._handle() ? m_sound._handle()->file_name() : "unknown");
+#ifdef DEBUG
+	THROW3(!m_sound._feedback(), "playing sound is not completed, but is destroying",
+	       m_sound._handle() ? m_sound._handle()->file_name() : "unknown");
+#endif
 	m_sound.destroy			();
@@ -58,6 +66,7 @@
 
-void CScriptSound::PlayNoFeedback	(CScriptGameObject *object,	u32 flags/*!< Looping */, float delay/*!< Delay */, Fvector pos, float vol)
+void CScriptSound::PlayNoFeedback(CScriptGameObject* object, u32 flags/*!< Looping */, float delay/*!< Delay */,
+                                  Fvector pos, float vol, float freq)
 {
 	THROW3						(m_sound._handle(),"There is no sound",*m_caSoundToPlay);
-	m_sound.play_no_feedback	((object) ? &object->object() : NULL, flags,delay,&pos,&vol);
+	m_sound.play_no_feedback((object) ? &object->object() : NULL, flags, delay, &pos, &vol, &freq);
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/script_sound.h xray-monolith/src/xrGame/script_sound.h
--- coc-1.4-xray-64/src/xrGame/script_sound.h	2023-10-20 20:54:51.276326700 +0100
+++ xray-monolith/src/xrGame/script_sound.h	2023-10-20 20:54:33.209035900 +0100
@@ -31,3 +32,4 @@
 			void				PlayAtPos			(CScriptGameObject *object, const Fvector &position, float delay, int flags);
-			void				PlayNoFeedback		(CScriptGameObject *object,	u32 flags/*!< Looping */, float delay/*!< Delay */, Fvector pos, float vol);
+	void PlayNoFeedback(CScriptGameObject* object, u32 flags/*!< Looping */, float delay/*!< Delay */, Fvector pos,
+	                    float vol, float freq);
 	IC		void				AttachTail			(LPCSTR caSoundName);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/script_sound_script.cpp xray-monolith/src/xrGame/script_sound_script.cpp
--- coc-1.4-xray-64/src/xrGame/script_sound_script.cpp	2023-10-20 20:54:51.279326900 +0100
+++ xray-monolith/src/xrGame/script_sound_script.cpp	2023-10-20 20:54:33.212035900 +0100
@@ -37,2 +37,3 @@
 			.property("volume",					&CScriptSound::GetVolume,		&CScriptSound::SetVolume)
+		.property("position", &CScriptSound::GetPosition, &CScriptSound::SetPosition)
 			.def(								constructor<LPCSTR>())
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ScriptXMLInit.cpp xray-monolith/src/xrGame/ScriptXMLInit.cpp
--- coc-1.4-xray-64/src/xrGame/ScriptXMLInit.cpp	2023-10-20 20:54:50.699326600 +0100
+++ xray-monolith/src/xrGame/ScriptXMLInit.cpp	2023-10-20 20:54:32.652035700 +0100
@@ -10,3 +10,3 @@
 #include "ui\UIFrameWindow.h"
-#include "ui\UILabel.h"
+//#include "ui\UILabel.h"
 #include "ui\ServerList.h"
@@ -39,2 +39,25 @@
 
+// demonized
+// Clear XML from BOM
+LPCSTR clearBOM(LPCSTR s) {
+	if (s[0] == (char)0xEF && s[1] == (char)0xBB && s[2] == (char)0xBF) {
+		LPCSTR new_s = s + 3;
+		return new_s;
+	}
+	return s;
+}
+
+// demonized
+// Send XML file contents to Lua for edit
+void XMLLuaCallback(CXml &m_xml, LPCSTR xml_string) {
+	xml_string = clearBOM(xml_string);
+	luabind::functor<LPCSTR> funct;
+	if (ai().script_engine().functor("_G.COnXmlRead", funct))
+	{
+		LPCSTR res = funct(m_xml.m_xml_file_name, xml_string);
+		//Msg("XMLLuaCallback, xml %s, contents %s", m_xml.m_xml_file_name, res);
+		m_xml.LoadFromString(res);
+	}
+}
+
 void CScriptXmlInit::ParseFile(LPCSTR xml_file)
@@ -44,2 +67,74 @@
 
+//------------------------------------------------------------
+// Tronex: useful exports to read XML files
+//------------------------------------------------------------
+void CScriptXmlInit::ParseDirFile(LPCSTR xml_dir, LPCSTR xml_file)
+{
+	m_xml.Load(CONFIG_PATH, xml_dir, xml_file);
+}
+
+bool CScriptXmlInit::NodeExist(LPCSTR path, int index)
+{
+	if (m_xml.NavigateToNode(path, index))
+	{
+		return true;
+	}
+	return false;
+}
+
+int CScriptXmlInit::GetNodesNum(LPCSTR path, int index, LPCSTR tag_name)
+{
+	return m_xml.GetNodesNum(path, index, tag_name);
+}
+
+bool CScriptXmlInit::NavigateToNode(LPCSTR path, int index)
+{
+	XML_NODE* node = m_xml.NavigateToNode(path, index);
+	if (node)
+	{
+		m_xml.SetLocalRoot(node);
+		return true;
+	}
+	return false;
+}
+
+bool CScriptXmlInit::NavigateToNode_ByAttribute(LPCSTR tag_name, LPCSTR attrib_name, LPCSTR attrib_value)
+{
+	XML_NODE* node = m_xml.NavigateToNodeWithAttribute(tag_name, attrib_name, attrib_value);
+	if (node)
+	{
+		m_xml.SetLocalRoot(node);
+		return true;
+	}
+	return false;
+}
+
+bool CScriptXmlInit::NavigateToNode_ByPath(LPCSTR path, int index, LPCSTR tag_name, LPCSTR attrib, LPCSTR attrib_value_pattern)
+{
+	XML_NODE* node = m_xml.SearchForAttribute(path, index, tag_name, attrib, attrib_value_pattern);
+	if (node)
+	{
+		m_xml.SetLocalRoot(node);
+		return true;
+	}
+	return false;
+}
+
+void CScriptXmlInit::NavigateToRoot()
+{
+	m_xml.SetLocalRoot(m_xml.GetRoot());
+}
+
+LPCSTR CScriptXmlInit::ReadValue(LPCSTR path, int index)
+{
+	return m_xml.Read(path, index, "");
+}
+
+LPCSTR CScriptXmlInit::ReadAttribute(LPCSTR path, int index, LPCSTR attrib)
+{
+	return m_xml.ReadAttrib(path, index, attrib, "");
+}
+
+//------------------------------------------------------------
+
 void CScriptXmlInit::InitWindow(LPCSTR path, int index, CUIWindow* pWnd)
@@ -265,2 +362,13 @@
 		.def("ParseFile",				&CScriptXmlInit::ParseFile)
+		.def("ParseDirFile", &CScriptXmlInit::ParseDirFile)
+		
+		.def("NodeExist", &CScriptXmlInit::NodeExist)
+		.def("GetNodesNum", &CScriptXmlInit::GetNodesNum)
+		.def("NavigateToNode", &CScriptXmlInit::NavigateToNode)
+		.def("NavigateToNode_ByAttribute", &CScriptXmlInit::NavigateToNode_ByAttribute)
+		.def("NavigateToNode_ByPath", &CScriptXmlInit::NavigateToNode_ByPath)
+		.def("NavigateToRoot", &CScriptXmlInit::NavigateToRoot)
+		.def("ReadValue", &CScriptXmlInit::ReadValue)
+		.def("ReadAttribute", &CScriptXmlInit::ReadAttribute)
+		
 		.def("InitWindow",				&CScriptXmlInit::InitWindow)
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ScriptXMLInit.h xray-monolith/src/xrGame/ScriptXMLInit.h
--- coc-1.4-xray-64/src/xrGame/ScriptXMLInit.h	2023-10-20 20:54:50.699326600 +0100
+++ xray-monolith/src/xrGame/ScriptXMLInit.h	2023-10-20 20:54:32.652035700 +0100
@@ -37,2 +37,13 @@
 	void ParseFile		(LPCSTR xml_file);
+	void ParseDirFile(LPCSTR xml_dir, LPCSTR xml_file);
+	
+	bool NodeExist(LPCSTR path, int index);
+	int GetNodesNum(LPCSTR path, int index, LPCSTR tag_name);
+	bool NavigateToNode(LPCSTR path, int index);
+	bool NavigateToNode_ByAttribute(LPCSTR tag_name, LPCSTR attrib_name, LPCSTR attrib_value);
+	bool NavigateToNode_ByPath(LPCSTR path, int index, LPCSTR tag_name, LPCSTR attrib, LPCSTR attrib_value_pattern);
+	void NavigateToRoot();
+	LPCSTR ReadValue(LPCSTR path, int index);
+	LPCSTR ReadAttribute(LPCSTR path, int index, LPCSTR attrib);
+	
 	void				InitWindow(LPCSTR path, int index, CUIWindow* pWnd);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ShootingObject.cpp xray-monolith/src/xrGame/ShootingObject.cpp
--- coc-1.4-xray-64/src/xrGame/ShootingObject.cpp	2023-10-20 20:54:50.699326600 +0100
+++ xray-monolith/src/xrGame/ShootingObject.cpp	2023-10-20 20:54:32.653035500 +0100
@@ -35,5 +35,5 @@
 
-	m_fPredBulletTime				= 0.0f;
-	m_bUseAimBullet					= false;
-	m_fTimeToAim					= 0.0f;
+	//m_fPredBulletTime = 0.0f;
+	//m_bUseAimBullet = false;
+	//m_fTimeToAim = 0.0f;
 
@@ -45,2 +45,3 @@
 	bWorking						= false;
+	bCycleDown = false;
 
@@ -159,3 +168,3 @@
 	m_fStartBulletSpeed = pSettings->r_float	(section, "bullet_speed" );
-	m_bUseAimBullet		= pSettings->r_bool		(section, "use_aim_bullet" );
+	/*m_bUseAimBullet = pSettings->r_bool(section, "use_aim_bullet");
 	if (m_bUseAimBullet)
@@ -163,3 +172,3 @@
 		m_fTimeToAim		= pSettings->r_float	(section, "time_to_aim" );
-	}
+	}*/
 }
@@ -202,4 +215,5 @@
 	light_render->set_position	(P);
-	light_render->set_color		(light_build_color.r*light_scale,light_build_color.g*light_scale,light_build_color.b*light_scale);
-	light_render->set_range		(light_build_range*light_scale);
+	light_render->set_color(light_build_color.r * light_scale, light_build_color.g * light_scale,
+	                        light_build_color.b * light_scale);
+	light_render->set_range(fmaxf(.1f, (light_build_range * light_scale)));
 
@@ -230,10 +244,3 @@
 	UpdateParticles(pParticles, pos, vel);
-	CSpectator* tmp_spectr = smart_cast<CSpectator*>(Level().CurrentControlEntity());
-	bool in_hud_mode = IsHudModeNow();
-	if (in_hud_mode && tmp_spectr &&
-		(tmp_spectr->GetActiveCam() != CSpectator::eacFirstEye))
-	{
-		in_hud_mode = false;
-	}
-	pParticles->Play(in_hud_mode);
+	pParticles->Play(false);
 }
@@ -468,4 +476,4 @@
 	
-	bool aim_bullet;
-	if (m_bUseAimBullet)
+	bool aim_bullet = false;
+	/*if (m_bUseAimBullet)
 	{
@@ -498,6 +506,6 @@
 	}
-	m_fPredBulletTime = Device.fTimeGlobal;
+	m_fPredBulletTime = Device.fTimeGlobal;*/
 
 	float l_fHitPower = 0.0f;
-	if (ParentIsActor())//åñëè èç îðóæèÿ ñòðåëÿåò àêò¸ð(èãðîê)
+	if (SOParentIsActor()) //åñëè èç îðóæèÿ ñòðåëÿåò àêò¸ð(èãðîê)
 	{
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ShootingObject.h xray-monolith/src/xrGame/ShootingObject.h
--- coc-1.4-xray-64/src/xrGame/ShootingObject.h	2023-10-20 20:54:50.700326600 +0100
+++ xray-monolith/src/xrGame/ShootingObject.h	2023-10-20 20:54:32.653035500 +0100
@@ -63,3 +66,3 @@
 	virtual BOOL			ParentMayHaveAimBullet()		{return FALSE;}
-	virtual BOOL			ParentIsActor()					{return FALSE;}
+	virtual bool SOParentIsActor() { return false; }
 
@@ -95,2 +98,8 @@
 		float	cam_disper_inc;
+		float pdm_base;
+		float pdm_accel;
+		float pdm_vel;
+		float crosshair_inertion;
+		float zoom_rotate_time;
+		float condition_shot_dec;
 
@@ -105,2 +114,8 @@
 			cam_disper_inc  = 1.0f;
+			pdm_base = 1.0f;
+			pdm_accel = 1.0f;
+			pdm_vel = 1.0f;
+			crosshair_inertion = 1.0f;
+			zoom_rotate_time = 1.0f;
+			condition_shot_dec = 1.0f;
 		}
@@ -112,2 +127,58 @@
 
+	struct ScopeKoeffs
+	{
+		float cam_dispersion;
+		float cam_disper_inc;
+		float pdm_base;
+		float pdm_accel;
+		float pdm_vel;
+		float crosshair_inertion;
+		float zoom_rotate_time;
+
+		ScopeKoeffs() { Reset(); }
+		IC void Reset()
+		{
+			cam_dispersion = 1.0f;
+			cam_disper_inc = 1.0f;
+			pdm_base = 1.0f;
+			pdm_accel = 1.0f;
+			pdm_vel = 1.0f;
+			crosshair_inertion = 1.0f;
+			zoom_rotate_time = 1.0f;
+		}
+	};
+
+	ScopeKoeffs m_scope_koef;
+
+public:
+	ScopeKoeffs cur_scope_koef;
+
+	struct LauncherKoeffs
+	{
+		float cam_dispersion;
+		float cam_disper_inc;
+		float pdm_base;
+		float pdm_accel;
+		float pdm_vel;
+		float crosshair_inertion;
+		float zoom_rotate_time;
+
+		LauncherKoeffs() { Reset(); }
+		IC void Reset()
+		{
+			cam_dispersion = 1.0f;
+			cam_disper_inc = 1.0f;
+			pdm_base = 1.0f;
+			pdm_accel = 1.0f;
+			pdm_vel = 1.0f;
+			crosshair_inertion = 1.0f;
+			zoom_rotate_time = 1.0f;
+		}
+	};
+
+	LauncherKoeffs m_launcher_koef;
+
+public:
+	LauncherKoeffs cur_launcher_koef;
+
 protected:
@@ -181,5 +256,5 @@
 	Fvector					vLoadedShellPoint;
-	float					m_fPredBulletTime;
-	float					m_fTimeToAim;
-	BOOL					m_bUseAimBullet;
+	//float m_fPredBulletTime;
+	//float m_fTimeToAim;
+	//BOOL m_bUseAimBullet;
 protected:
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/SimpleDetector.cpp xray-monolith/src/xrGame/SimpleDetector.cpp
--- coc-1.4-xray-64/src/xrGame/SimpleDetector.cpp	2023-10-20 20:54:50.701327300 +0100
+++ xray-monolith/src/xrGame/SimpleDetector.cpp	2023-10-20 20:54:32.654035500 +0100
@@ -17,3 +18,3 @@
 {
-	R_ASSERT(NULL==m_ui);
+	R_ASSERT(nullptr==m_ui);
 	m_ui				= xr_new<CUIArtefactDetectorSimple>();
@@ -104,3 +105,3 @@
 	if(!m_parent->HudItemData())	return;
-
+	if (m_flash_bone == BI_NONE) return;
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/SimpleDetector.h xray-monolith/src/xrGame/SimpleDetector.h
--- coc-1.4-xray-64/src/xrGame/SimpleDetector.h	2023-10-20 20:54:50.701327300 +0100
+++ xray-monolith/src/xrGame/SimpleDetector.h	2023-10-20 20:54:32.654035500 +0100
@@ -13,3 +13,2 @@
 protected:
-//.	virtual void 	UpdateZones					();
 	virtual void 	UpdateAf					();
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/smart_cover.h xray-monolith/src/xrGame/smart_cover.h
--- coc-1.4-xray-64/src/xrGame/smart_cover.h	2023-10-20 20:54:51.292326500 +0100
+++ xray-monolith/src/xrGame/smart_cover.h	2023-10-20 20:54:33.225035700 +0100
@@ -89,5 +94,19 @@
 };
-
 } // namespace smart_cover
 
+struct loophole_id_predicate
+{
+	shared_str m_id;
+
+	IC loophole_id_predicate(shared_str const& id) :
+		m_id(id)
+	{
+	}
+
+	IC bool operator()(smart_cover::loophole* loophole) const
+	{
+		return (loophole->id()._get() == m_id._get());
+	}
+};
+
 #include "smart_cover_inline.h"
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/sound_player_inline.h xray-monolith/src/xrGame/sound_player_inline.h
--- coc-1.4-xray-64/src/xrGame/sound_player_inline.h	2023-10-20 20:54:51.311326600 +0100
+++ xray-monolith/src/xrGame/sound_player_inline.h	2023-10-20 20:54:33.243035600 +0100
@@ -51,3 +53,6 @@
 	if (!temp->_p)
+	{
+		xr_delete(temp);
 		return				(0);
+	}
 	return					(temp);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/space_restriction_bridge.h xray-monolith/src/xrGame/space_restriction_bridge.h
--- coc-1.4-xray-64/src/xrGame/space_restriction_bridge.h	2023-10-20 20:54:51.314326800 +0100
+++ xray-monolith/src/xrGame/space_restriction_bridge.h	2023-10-20 20:54:33.246035300 +0100
@@ -40,3 +41,3 @@
 	template <typename T>
-	IC		u32						accessible_nearest			(T &restriction, const Fvector &position, Fvector &result, bool out_restriction);
+	IC u32 accessible_nearest(T restriction, const Fvector& position, Fvector& result, bool out_restriction);
 	template <typename T>
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/space_restriction_bridge_inline.h xray-monolith/src/xrGame/space_restriction_bridge_inline.h
--- coc-1.4-xray-64/src/xrGame/space_restriction_bridge_inline.h	2023-10-20 20:54:51.315326400 +0100
+++ xray-monolith/src/xrGame/space_restriction_bridge_inline.h	2023-10-20 20:54:33.246035300 +0100
@@ -23,3 +23,4 @@
 template <typename T>
-IC	u32	CSpaceRestrictionBridge::accessible_nearest	(T &restriction, const Fvector &position, Fvector &result, bool out_restriction)
+IC u32 CSpaceRestrictionBridge::accessible_nearest(T restriction, const Fvector& position, Fvector& result,
+                                                   bool out_restriction)
 {
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/space_restriction_manager.cpp xray-monolith/src/xrGame/space_restriction_manager.cpp
--- coc-1.4-xray-64/src/xrGame/space_restriction_manager.cpp	2023-10-20 20:54:51.317326900 +0100
+++ xray-monolith/src/xrGame/space_restriction_manager.cpp	2023-10-20 20:54:33.249036100 +0100
@@ -95,3 +97,3 @@
 
-IC	CSpaceRestrictionManager::CRestrictionPtr CSpaceRestrictionManager::restriction	(ALife::_OBJECT_ID id)
+CSpaceRestrictionManager::CRestrictionPtr CSpaceRestrictionManager::restriction(ALife::_OBJECT_ID id)
 {
@@ -158,2 +163,4 @@
 {
+	if (level_vertex_id == (u32)-1)
+		return false;
 	CRestrictionPtr				client_restriction = restriction(id);
@@ -192,3 +200,3 @@
 
-IC	bool CSpaceRestrictionManager::restriction_presented	(shared_str restrictions, shared_str restriction) const
+bool CSpaceRestrictionManager::restriction_presented(shared_str restrictions, shared_str restriction) const
 {
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/space_restriction_manager.h xray-monolith/src/xrGame/space_restriction_manager.h
--- coc-1.4-xray-64/src/xrGame/space_restriction_manager.h	2023-10-20 20:54:51.318326700 +0100
+++ xray-monolith/src/xrGame/space_restriction_manager.h	2023-10-20 20:54:33.249036100 +0100
@@ -44,3 +47,3 @@
 	IC		void				difference_restrictions			(shared_str &restrictions, shared_str update);
-	IC		CRestrictionPtr		restriction						(ALife::_OBJECT_ID id);
+	CRestrictionPtr restriction(ALife::_OBJECT_ID id);
 			CRestrictionPtr		restriction						(shared_str out_restrictors, shared_str in_restrictors);
@@ -73,3 +77,3 @@
 
-	IC		bool				restriction_presented			(shared_str restrictions, shared_str restriction) const;
+	bool restriction_presented(shared_str restrictions, shared_str restriction) const;
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/space_restrictor.cpp xray-monolith/src/xrGame/space_restrictor.cpp
--- coc-1.4-xray-64/src/xrGame/space_restrictor.cpp	2023-10-20 20:54:51.319326400 +0100
+++ xray-monolith/src/xrGame/space_restrictor.cpp	2023-10-20 20:54:33.251035600 +0100
@@ -77,3 +81,4 @@
 	CCustomZone* zone = smart_cast<CCustomZone*>(this);
-	if (g_ai_die_in_anomaly == 0 || !zone || smart_cast<CRadioactiveZone*>(zone) || smart_cast<CZoneCampfire*>(zone))
+	//if (g_ai_die_in_anomaly == 0 || !zone || smart_cast<CRadioactiveZone*>(zone) || smart_cast<CZoneCampfire*>(zone))
+	if (!zone || smart_cast<CRadioactiveZone*>(zone) || smart_cast<CZoneCampfire*>(zone))
 		spatial.type					&= ~STYPE_VISIBLEFORAI;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Spectator.cpp xray-monolith/src/xrGame/Spectator.cpp
--- coc-1.4-xray-64/src/xrGame/Spectator.cpp	2023-10-20 20:54:50.702326800 +0100
+++ xray-monolith/src/xrGame/Spectator.cpp	2023-10-20 20:54:32.655035800 +0100
@@ -292,5 +312,7 @@
 			vmove.mad( right, -m_fTimeDelta*Accel_mul );
-			}break;
 		}
-		if (cam_active != eacFreeFly || (pMPGame->Is_Spectator_Camera_Allowed(eacFreeFly) || (PS && PS->testFlag(GAME_PLAYER_FLAG_SPECTATOR))))
+			break;
+		}
+		if (cam_active != eacFreeFly || (pMPGame->Is_Spectator_Camera_Allowed(eacFreeFly) || (PS && PS->testFlag(
+			GAME_PLAYER_FLAG_SPECTATOR))))
 			XFORM().c.add( vmove );
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/stalker_animation_callbacks.cpp xray-monolith/src/xrGame/stalker_animation_callbacks.cpp
--- coc-1.4-xray-64/src/xrGame/stalker_animation_callbacks.cpp	2023-10-20 20:54:51.325326700 +0100
+++ xray-monolith/src/xrGame/stalker_animation_callbacks.cpp	2023-10-20 20:54:33.256035400 +0100
@@ -20,2 +20,3 @@
 {
+	if (!_valid( bone->mTransform )) return;
 	R_ASSERT						( _valid( bone->mTransform ) );
@@ -26,2 +27,7 @@
 
+	if (!parameter || !_valid(*parameter->m_rotation))
+	{
+		return;
+	}
+
 	CAI_Stalker const*				object = parameter->m_object;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/stalker_animation_global.cpp xray-monolith/src/xrGame/stalker_animation_global.cpp
--- coc-1.4-xray-64/src/xrGame/stalker_animation_global.cpp	2023-10-20 20:54:51.327326500 +0100
+++ xray-monolith/src/xrGame/stalker_animation_global.cpp	2023-10-20 20:54:33.258035700 +0100
@@ -89,11 +89,8 @@
 
-	return						(
-		global().select(
-			m_data_storage->m_part_animations.A[
-				body_state()
-			].m_global.A[
-				1
-			].A
-		)
-	);
+	//Alun: Fix stalker sprint
+	EBodyState b_state = body_state();
+	if (eMovementTypeRun == object().movement().movement_type() && b_state == eBodyStateStand)
+		return (MotionID());
+
+	return global().select(m_data_storage->m_part_animations.A[b_state].m_global.A[1].A);
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/stalker_animation_legs.cpp xray-monolith/src/xrGame/stalker_animation_legs.cpp
--- coc-1.4-xray-64/src/xrGame/stalker_animation_legs.cpp	2023-10-20 20:54:51.327326500 +0100
+++ xray-monolith/src/xrGame/stalker_animation_legs.cpp	2023-10-20 20:54:33.259035400 +0100
@@ -156,12 +160,8 @@
 
-		return					(
-			m_data_storage->m_part_animations.A[
-				body_state()
-			].m_movement.A[
-				movement.movement_type()
-			].A[
-				eMovementDirectionForward
-			].A[
-				1
-			]
+		//Alun: Sprint stalker fix
+		if (movement.movement_type() == eMovementTypeRun && movement.mental_state() == eMentalStatePanic)
+			return (m_data_storage->m_part_animations.A[eBodyStateStand].m_movement.A[2].A[4].A[0]);
+
+		return (m_data_storage->m_part_animations.A[body_state()].m_movement.A[movement.movement_type()].A[
+				eMovementDirectionForward].A[1]
 		);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/stalker_animation_manager.cpp xray-monolith/src/xrGame/stalker_animation_manager.cpp
--- coc-1.4-xray-64/src/xrGame/stalker_animation_manager.cpp	2023-10-20 20:54:51.328326400 +0100
+++ xray-monolith/src/xrGame/stalker_animation_manager.cpp	2023-10-20 20:54:33.259035400 +0100
@@ -106,2 +106,8 @@
 #endif
+
+	m_global.reset();
+	m_head.reset();
+	m_torso.reset();
+	m_legs.reset();
+	m_script.reset();
 };
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/stalker_animation_manager_update.cpp xray-monolith/src/xrGame/stalker_animation_manager_update.cpp
--- coc-1.4-xray-64/src/xrGame/stalker_animation_manager_update.cpp	2023-10-20 20:54:51.329326200 +0100
+++ xray-monolith/src/xrGame/stalker_animation_manager_update.cpp	2023-10-20 20:54:33.261035500 +0100
@@ -16,3 +16,3 @@
 
-IC	void CStalkerAnimationManager::play_delayed_callbacks()
+void CStalkerAnimationManager::play_delayed_callbacks()
 {
@@ -251,2 +251,3 @@
         /* avo: prevent game from crashing */
+			global().reset();
         head().reset();
@@ -254,3 +255,2 @@
         legs().reset();
-        global().reset();
         return;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/stalker_animation_names.cpp xray-monolith/src/xrGame/stalker_animation_names.cpp
--- coc-1.4-xray-64/src/xrGame/stalker_animation_names.cpp	2023-10-20 20:54:51.329326200 +0100
+++ xray-monolith/src/xrGame/stalker_animation_names.cpp	2023-10-20 20:54:33.261035500 +0100
@@ -49,2 +49,3 @@
 	"look_beack_rs_",	// 14
+	"escape_", // 15 Alun sprint fix
 	0
@@ -55,2 +56,3 @@
 	"run_",
+	"escape_", //2 Alun sprint fix
 	0
@@ -63,2 +65,3 @@
 	"rs_",
+	"0", //4 Alun sprint fix
 	0
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/stalker_animation_torso.cpp xray-monolith/src/xrGame/stalker_animation_torso.cpp
--- coc-1.4-xray-64/src/xrGame/stalker_animation_torso.cpp	2023-10-20 20:54:51.334327400 +0100
+++ xray-monolith/src/xrGame/stalker_animation_torso.cpp	2023-10-20 20:54:33.265035500 +0100
@@ -179,5 +188,17 @@
 
-	switch (m_weapon->GetState()) {
-		case CWeapon::eReload : {
-			switch (m_weapon->GetReloadState()){
+	//Alun: Fix stalker sprint
+	if (eMentalStatePanic == object().movement().mental_state() && eMovementTypeRun == object()
+	                                                                                   .movement().movement_type() &&
+		body_state == eBodyStateStand && !fis_zero(
+			object().movement().speed(object().character_physics_support()->movement())))
+	{
+		return (animation[15].A[0]);
+	}
+
+	switch (m_weapon->GetState())
+	{
+	case CWeapon::eReload:
+		{
+			switch (m_weapon->GetReloadState())
+			{
 				case CWeapon::eSubstateReloadBegin:
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/stalker_combat_actions.cpp xray-monolith/src/xrGame/stalker_combat_actions.cpp
--- coc-1.4-xray-64/src/xrGame/stalker_combat_actions.cpp	2023-10-20 20:54:51.337326700 +0100
+++ xray-monolith/src/xrGame/stalker_combat_actions.cpp	2023-10-20 20:54:33.268035500 +0100
@@ -1192,5 +1309,7 @@
 
-	if (object().inventory().ActiveItem() && object().best_weapon() && (object().inventory().ActiveItem()->object().ID() == object().best_weapon()->object().ID()))
+	if (object().inventory().ActiveItem() && object().best_weapon() && (object().inventory().ActiveItem()->object().ID()
+		== object().best_weapon()->object().ID()))
+	{
+		if (object().memory().enemy().selected())
 	{
-		if (object().memory().enemy().selected()) {
 			u32									min_queue_size, max_queue_size, min_queue_interval, max_queue_interval;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/stalker_danger_in_direction_actions.cpp xray-monolith/src/xrGame/stalker_danger_in_direction_actions.cpp
--- coc-1.4-xray-64/src/xrGame/stalker_danger_in_direction_actions.cpp	2023-10-20 20:54:51.341326700 +0100
+++ xray-monolith/src/xrGame/stalker_danger_in_direction_actions.cpp	2023-10-20 20:54:33.272035600 +0100
@@ -289,11 +314,17 @@
 
-	if (object().movement().path_completed()) {
-		object().m_ce_angle->setup			(position,10.f,object().ffGetRange(),mem_object.m_object_params.m_level_vertex_id);
-		const CCoverPoint					*point = ai().cover_manager().best_cover(object().Position(),10.f,*object().m_ce_angle,CStalkerMovementRestrictor(m_object,true));
-		if (!point) {
+	if (object().movement().path_completed())
+	{
 			object().m_ce_angle->setup		(position,10.f,object().ffGetRange(),mem_object.m_object_params.m_level_vertex_id);
-			point							= ai().cover_manager().best_cover(object().Position(),30.f,*object().m_ce_angle,CStalkerMovementRestrictor(m_object,true));
+		const CCoverPoint* point = ai().cover_manager().best_cover(object().Position(), 10.f, *object().m_ce_angle,
+		                                                           CStalkerMovementRestrictor(m_object, true));
+		if (!point)
+		{
+			object().m_ce_angle->setup(position, 10.f, object().ffGetRange(),
+			                           mem_object.m_object_params.m_level_vertex_id);
+			point = ai().cover_manager().best_cover(object().Position(), 30.f, *object().m_ce_angle,
+			                                        CStalkerMovementRestrictor(m_object, true));
 		}
 
-		if (point) {
+		if (point)
+		{
 			object().movement().set_level_dest_vertex	(point->level_vertex_id());
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/stalker_movement_manager_base_inline.h xray-monolith/src/xrGame/stalker_movement_manager_base_inline.h
--- coc-1.4-xray-64/src/xrGame/stalker_movement_manager_base_inline.h	2023-10-20 20:54:51.352326600 +0100
+++ xray-monolith/src/xrGame/stalker_movement_manager_base_inline.h	2023-10-20 20:54:33.283035400 +0100
@@ -38,2 +39,3 @@
 {
+#ifdef DEBUG
 	THROW2						(
@@ -42,2 +44,3 @@
 	);
+#endif
 	m_target.m_body_state		= body_state;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/stalker_movement_manager_obstacles.cpp xray-monolith/src/xrGame/stalker_movement_manager_obstacles.cpp
--- coc-1.4-xray-64/src/xrGame/stalker_movement_manager_obstacles.cpp	2023-10-20 20:54:51.353326600 +0100
+++ xray-monolith/src/xrGame/stalker_movement_manager_obstacles.cpp	2023-10-20 20:54:33.283035400 +0100
@@ -48,3 +48,3 @@
 
-	level_path_builder().use_delay_after_fail	( false );
+	level_path_builder().use_delay_after_fail(true);
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/stalker_movement_manager_smart_cover_loopholes.cpp xray-monolith/src/xrGame/stalker_movement_manager_smart_cover_loopholes.cpp
--- coc-1.4-xray-64/src/xrGame/stalker_movement_manager_smart_cover_loopholes.cpp	2023-10-20 20:54:51.355327400 +0100
+++ xray-monolith/src/xrGame/stalker_movement_manager_smart_cover_loopholes.cpp	2023-10-20 20:54:33.286036200 +0100
@@ -644,17 +686,4 @@
 
-struct loophole_id_predicate {
-	shared_str				m_id;
-
-	IC			loophole_id_predicate		(shared_str const &id) :
-		m_id				(id)
-	{
-	}
-
-	IC	bool	operator()					(smart_cover::loophole *loophole) const
-	{
-		return				(loophole->id()._get() == m_id._get());
-	}
-};
-
-loophole const &stalker_movement_manager_smart_cover::loophole		(smart_cover::cover const &cover, shared_str const &loophole_id) const
+loophole const& stalker_movement_manager_smart_cover::loophole(smart_cover::cover const& cover,
+                                                               shared_str const& loophole_id) const
 {
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/stalker_movement_params.cpp xray-monolith/src/xrGame/stalker_movement_params.cpp
--- coc-1.4-xray-64/src/xrGame/stalker_movement_params.cpp	2023-10-20 20:54:51.356326700 +0100
+++ xray-monolith/src/xrGame/stalker_movement_params.cpp	2023-10-20 20:54:33.287035700 +0100
@@ -143,60 +146,8 @@
 
-struct loophole_id_predicate {
-	shared_str							m_id;
-
-	IC			loophole_id_predicate		(shared_str const &id) :
-		m_id							(id)
+void stalker_movement_params::actualize_loophole() const
 	{
-	}
-
-	IC	bool	operator()					(smart_cover::loophole *loophole) const
+	if (m_selected_loophole_actual)
 	{
-		return							(loophole->id()._get() == m_id._get());
-	}
-}; // struct loophole_id_predicate
-
-void stalker_movement_params::cover_loophole_id					(shared_str const& loophole_id)
+		if (!m_cover || !m_cover_selected_loophole || m_cover->description()->loophole(m_cover_selected_loophole->id()))
 {
-	cover_fire_object					(0);
-	cover_fire_position					(0);
-
-	if (m_cover_loophole_id == loophole_id)
-		return;
-
-	m_cover_loophole_id					= loophole_id;
-	m_selected_loophole_actual			= false;
-	m_cover_selected_loophole			= 0;
-
-	if (!loophole_id.size()) {
-		m_cover_loophole				= 0;
-		return;
-	}
-
-	VERIFY								(m_cover);
-
-	typedef smart_cover::cover::Loopholes	Loopholes;
-	Loopholes const						&loopholes = m_cover->description()->loopholes();
-	Loopholes::const_iterator			i =
-		std::find_if(
-			loopholes.begin(),
-			loopholes.end(),
-			loophole_id_predicate(loophole_id)
-		);
-
-	VERIFY2								(
-		i != loopholes.end(),
-		make_string			(
-			"loophole [%s] not present in smart_cover [%s]",
-			loophole_id.c_str(),
-			m_cover_id.c_str()
-		)
-	);
-	
-	m_cover_loophole					= *i;
-}
-
-void stalker_movement_params::actualize_loophole					() const
-{
-	if (m_selected_loophole_actual) {
-		if (!m_cover || !m_cover_selected_loophole || m_cover->description()->loophole(m_cover_selected_loophole->id())) {
 			if (m_last_selection_time + time_before_selection > Device.dwTimeGlobal)
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/stalker_movement_params_inline.h xray-monolith/src/xrGame/stalker_movement_params_inline.h
--- coc-1.4-xray-64/src/xrGame/stalker_movement_params_inline.h	2023-10-20 20:54:51.357326900 +0100
+++ xray-monolith/src/xrGame/stalker_movement_params_inline.h	2023-10-20 20:54:33.287035700 +0100
@@ -11,2 +11,4 @@
 
+#include "smart_cover.h"
+
 IC	void stalker_movement_params::construct								(stalker_movement_manager_smart_cover* manager)
@@ -100,2 +105,43 @@
 
+IC void stalker_movement_params::cover_loophole_id(shared_str const& loophole_id)
+{
+	cover_fire_object(0);
+	cover_fire_position(0);
+
+	if (m_cover_loophole_id == loophole_id)
+		return;
+
+	m_cover_loophole_id = loophole_id;
+	m_selected_loophole_actual = false;
+	m_cover_selected_loophole = 0;
+
+	if (!loophole_id.size())
+	{
+		m_cover_loophole = 0;
+		return;
+	}
+
+	VERIFY(m_cover);
+
+	typedef smart_cover::cover::Loopholes Loopholes;
+	Loopholes const& loopholes = m_cover->description()->loopholes();
+	Loopholes::const_iterator i =
+		std::find_if(
+			loopholes.begin(),
+			loopholes.end(),
+			loophole_id_predicate(loophole_id)
+		);
+
+	VERIFY2(
+		i != loopholes.end(),
+		make_string(
+			"loophole [%s] not present in smart_cover [%s]",
+			loophole_id.c_str(),
+			m_cover_id.c_str()
+		)
+	);
+
+	m_cover_loophole = *i;
+}
+
 #endif // #ifndef STALKER_MOVEMENT_PARAMS_INLINE_H_INCLUDED
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/StalkerOutfit.cpp xray-monolith/src/xrGame/StalkerOutfit.cpp
--- coc-1.4-xray-64/src/xrGame/StalkerOutfit.cpp	2023-10-20 20:54:50.703326700 +0100
+++ xray-monolith/src/xrGame/StalkerOutfit.cpp	2023-10-20 20:54:32.655035800 +0100
@@ -20,5 +20,2 @@
 		class_<CStalkerOutfit,CGameObject>("CStalkerOutfit")
-			.def(constructor<>()),
-
-		class_<CHelmet,CGameObject>("CHelmet")
 			.def(constructor<>())
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/static_obstacles_avoider.cpp xray-monolith/src/xrGame/static_obstacles_avoider.cpp
--- coc-1.4-xray-64/src/xrGame/static_obstacles_avoider.cpp	2023-10-20 20:54:51.366326500 +0100
+++ xray-monolith/src/xrGame/static_obstacles_avoider.cpp	2023-10-20 20:54:33.296035800 +0100
@@ -16,3 +16,3 @@
 
-IC	const CAI_Stalker &static_obstacles_avoider::object	() const
+const CAI_Stalker& static_obstacles_avoider::object() const
 {
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/static_obstacles_avoider.h xray-monolith/src/xrGame/static_obstacles_avoider.h
--- coc-1.4-xray-64/src/xrGame/static_obstacles_avoider.h	2023-10-20 20:54:51.366326500 +0100
+++ xray-monolith/src/xrGame/static_obstacles_avoider.h	2023-10-20 20:54:33.297035500 +0100
@@ -38,3 +39,3 @@
 	IC		const stalker_movement_manager_obstacles	&movement_manager		() const;
-	IC		const CAI_Stalker				&object					() const;
+	const CAI_Stalker& object() const;
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/stats_submitter.cpp xray-monolith/src/xrGame/stats_submitter.cpp
--- coc-1.4-xray-64/src/xrGame/stats_submitter.cpp	2023-10-20 20:54:51.367326500 +0100
+++ xray-monolith/src/xrGame/stats_submitter.cpp	2023-10-20 20:54:33.297035500 +0100
@@ -2,3 +2,2 @@
 #include "stats_submitter.h"
-#include "gamespy/GameSpy_Full.h"
 #include "login_manager.h"
@@ -21,10 +19,10 @@
 	shedule.t_max				= 1000;
-	VERIFY(fullgs);
-	m_fullgs_obj				= fullgs;
-	m_atlas_obj					= fullgs->GetGameSpyATLAS();
-	VERIFY(m_atlas_obj);
+		//VERIFY(fullgs);
+		//m_fullgs_obj				= fullgs;
+		//m_atlas_obj					= fullgs->GetGameSpyATLAS();
+		//VERIFY(m_atlas_obj);
 	m_last_operation_profile	= NULL;
-	m_atlas_report				= NULL;
+		//m_atlas_report				= NULL;
 	m_last_best_scores			= NULL;
-	ZeroMemory					(m_atlas_connection_id, sizeof(m_atlas_connection_id));
+		//ZeroMemory					(m_atlas_connection_id, sizeof(m_atlas_connection_id));
 }
@@ -99,3 +100,3 @@
 {
-	VERIFY(m_fullgs_obj && m_atlas_obj);
+		//VERIFY(m_fullgs_obj && m_atlas_obj);
 #ifdef DEBUG
@@ -103,4 +104,4 @@
 #endif
-	m_fullgs_obj->CoreThink(10);	//10 milliseconds on update
-	m_atlas_obj->Think();
+		//m_fullgs_obj->CoreThink(10);	//10 milliseconds on update
+		//m_atlas_obj->Think();
 }
@@ -121,142 +122,142 @@
 {
-	VERIFY(m_last_operation_profile && m_last_operation_cb);
-	SCResult tmp_result = m_atlas_obj->CreateSession(
-		&m_last_operation_profile->mCertificate,
-		&m_last_operation_profile->mPrivateData,
-		&stats_submitter::created_session_cb,
-		operation_timeout_value,
-		this
-	);
-	
-	if (tmp_result != SCResult_NO_ERROR)
-	{
-		m_last_operation_cb(false, CGameSpy_ATLAS::TryToTranslate(tmp_result).c_str());
-		terminate_session();
-		return;
-	}
-	
-	Engine.Sheduler.Register(this, FALSE);
-}
-
-void __cdecl stats_submitter::created_session_cb(const SCInterfacePtr theInterface,
-												 GHTTPResult          theHttpResult,
-												 SCResult             theResult,
-												 void *               theUserData)
-{
-	stats_submitter* my_inst = static_cast<stats_submitter*>(theUserData);
-	VERIFY(my_inst && my_inst->m_last_operation_profile);
-	if (theHttpResult != GHTTPSuccess)
-	{
-		my_inst->m_last_operation_cb	(false, CGameSpy_ATLAS::TryToTranslate(theHttpResult).c_str());
-		my_inst->terminate_session		();
-		Engine.Sheduler.Unregister		(my_inst);
-		return;
-	}
-	if (theResult != SCResult_NO_ERROR)
-	{
-		my_inst->m_last_operation_cb	(false, CGameSpy_ATLAS::TryToTranslate(theResult).c_str());
-		my_inst->terminate_session		();
-		Engine.Sheduler.Unregister		(my_inst);
-		return;
-	}
-	SCResult tmp_result = my_inst->m_atlas_obj->SetReportIntention(
-		NULL,
-		gsi_true,
-		&my_inst->m_last_operation_profile->mCertificate,
-		&my_inst->m_last_operation_profile->mPrivateData,
-		&stats_submitter::set_intension_cb,
-		stats_submitter::operation_timeout_value,
-		my_inst
-	);
-	
-	if (tmp_result != SCResult_NO_ERROR)
-	{
-		my_inst->m_last_operation_cb(false, CGameSpy_ATLAS::TryToTranslate(tmp_result).c_str());
-		my_inst->terminate_session();
-		Engine.Sheduler.Unregister(my_inst);
-		return;
-	}
-}
-
-void __cdecl stats_submitter::set_intension_cb(const SCInterfacePtr theInterface,
-											   GHTTPResult          theHttpResult,
-											   SCResult             theResult,
-											   void *               theUserData)
-{
-	stats_submitter* my_inst = static_cast<stats_submitter*>(theUserData);
-	VERIFY(my_inst && my_inst->m_last_operation_profile);
-	if (theHttpResult != GHTTPSuccess)
-	{
-		my_inst->m_last_operation_cb	(false, CGameSpy_ATLAS::TryToTranslate(theHttpResult).c_str());
-		my_inst->terminate_session		();
-		Engine.Sheduler.Unregister		(my_inst);
-		return;
-	}
-	if (theResult != SCResult_NO_ERROR)
-	{
-		my_inst->m_last_operation_cb	(false, CGameSpy_ATLAS::TryToTranslate(theResult).c_str());
-		my_inst->terminate_session		();
-		Engine.Sheduler.Unregister		(my_inst);
-		return;
-	}
-	char const * tmp_connection_id = my_inst->m_atlas_obj->GetConnectionId();
-	VERIFY(tmp_connection_id);
-	xr_strcpy(
-		static_cast<char*>((void*)my_inst->m_atlas_connection_id),
-		sizeof(my_inst->m_atlas_connection_id),
-		tmp_connection_id
-	);
-	
-	if (!my_inst->prepare_report())
-	{
-		my_inst->m_last_operation_cb	(false, "mp_failed_to_create_report");
-		my_inst->terminate_session		();
-		Engine.Sheduler.Unregister		(my_inst);
-		return;
-	}
-	
-	SCResult tmp_result = my_inst->m_atlas_obj->SubmitReport(
-		my_inst->m_atlas_report,
-		gsi_true,
-		&my_inst->m_last_operation_profile->mCertificate,
-		&my_inst->m_last_operation_profile->mPrivateData,
-		&stats_submitter::submitted_cb,
-		stats_submitter::operation_timeout_value,
-		my_inst
-	);
-	if (tmp_result != SCResult_NO_ERROR)
-	{
-		my_inst->m_last_operation_cb(false, CGameSpy_ATLAS::TryToTranslate(tmp_result).c_str());
-		my_inst->terminate_session();
-		Engine.Sheduler.Unregister(my_inst);
-		return;
-	}
-}
-
-void __cdecl stats_submitter::submitted_cb(const SCInterfacePtr theInterface,
-										   GHTTPResult          theHttpResult,
-										   SCResult             theResult,
-										   void *               theUserData)
-{
-	stats_submitter* my_inst = static_cast<stats_submitter*>(theUserData);
-	VERIFY(my_inst && my_inst->m_last_operation_profile);
-	if (theHttpResult != GHTTPSuccess)
-	{
-		my_inst->m_last_operation_cb	(false, CGameSpy_ATLAS::TryToTranslate(theHttpResult).c_str());
-		my_inst->terminate_session		();
-		Engine.Sheduler.Unregister		(my_inst);
-		return;
-	}
-	if (theResult != SCResult_NO_ERROR)
-	{
-		my_inst->m_last_operation_cb	(false, CGameSpy_ATLAS::TryToTranslate(theResult).c_str());
-		my_inst->terminate_session		();
-		Engine.Sheduler.Unregister		(my_inst);
-		return;
-	}
-	
-	my_inst->m_last_operation_cb	(true, "");
-	my_inst->terminate_session		();
-	Engine.Sheduler.Unregister		(my_inst);
-}
+		//VERIFY(m_last_operation_profile && m_last_operation_cb);
+		//SCResult tmp_result = m_atlas_obj->CreateSession(
+		//	&m_last_operation_profile->mCertificate,
+		//	&m_last_operation_profile->mPrivateData,
+		//	&stats_submitter::created_session_cb,
+		//	operation_timeout_value,
+		//	this
+		//);
+		//
+		//if (tmp_result != SCResult_NO_ERROR)
+		//{
+		//	m_last_operation_cb(false, CGameSpy_ATLAS::TryToTranslate(tmp_result).c_str());
+		//	terminate_session();
+		//	return;
+		//}
+		//
+		//Engine.Sheduler.Register(this, FALSE);
+	}
+
+	//void __cdecl stats_submitter::created_session_cb(const SCInterfacePtr theInterface,
+	//												 GHTTPResult          theHttpResult,
+	//												 SCResult             theResult,
+	//												 void *               theUserData)
+	//{
+	//	stats_submitter* my_inst = static_cast<stats_submitter*>(theUserData);
+	//	VERIFY(my_inst && my_inst->m_last_operation_profile);
+	//	if (theHttpResult != GHTTPSuccess)
+	//	{
+	//		my_inst->m_last_operation_cb	(false, CGameSpy_ATLAS::TryToTranslate(theHttpResult).c_str());
+	//		my_inst->terminate_session		();
+	//		Engine.Sheduler.Unregister		(my_inst);
+	//		return;
+	//	}
+	//	if (theResult != SCResult_NO_ERROR)
+	//	{
+	//		my_inst->m_last_operation_cb	(false, CGameSpy_ATLAS::TryToTranslate(theResult).c_str());
+	//		my_inst->terminate_session		();
+	//		Engine.Sheduler.Unregister		(my_inst);
+	//		return;
+	//	}
+	//	SCResult tmp_result = my_inst->m_atlas_obj->SetReportIntention(
+	//		NULL,
+	//		gsi_true,
+	//		&my_inst->m_last_operation_profile->mCertificate,
+	//		&my_inst->m_last_operation_profile->mPrivateData,
+	//		&stats_submitter::set_intension_cb,
+	//		stats_submitter::operation_timeout_value,
+	//		my_inst
+	//	);
+	//	
+	//	if (tmp_result != SCResult_NO_ERROR)
+	//	{
+	//		my_inst->m_last_operation_cb(false, CGameSpy_ATLAS::TryToTranslate(tmp_result).c_str());
+	//		my_inst->terminate_session();
+	//		Engine.Sheduler.Unregister(my_inst);
+	//		return;
+	//	}
+	//}
+
+	//void __cdecl stats_submitter::set_intension_cb(const SCInterfacePtr theInterface,
+	//											   GHTTPResult          theHttpResult,
+	//											   SCResult             theResult,
+	//											   void *               theUserData)
+	//{
+	//	stats_submitter* my_inst = static_cast<stats_submitter*>(theUserData);
+	//	VERIFY(my_inst && my_inst->m_last_operation_profile);
+	//	if (theHttpResult != GHTTPSuccess)
+	//	{
+	//		my_inst->m_last_operation_cb	(false, CGameSpy_ATLAS::TryToTranslate(theHttpResult).c_str());
+	//		my_inst->terminate_session		();
+	//		Engine.Sheduler.Unregister		(my_inst);
+	//		return;
+	//	}
+	//	if (theResult != SCResult_NO_ERROR)
+	//	{
+	//		my_inst->m_last_operation_cb	(false, CGameSpy_ATLAS::TryToTranslate(theResult).c_str());
+	//		my_inst->terminate_session		();
+	//		Engine.Sheduler.Unregister		(my_inst);
+	//		return;
+	//	}
+	//	char const * tmp_connection_id = my_inst->m_atlas_obj->GetConnectionId();
+	//	VERIFY(tmp_connection_id);
+	//	xr_strcpy(
+	//		static_cast<char*>((void*)my_inst->m_atlas_connection_id),
+	//		sizeof(my_inst->m_atlas_connection_id),
+	//		tmp_connection_id
+	//	);
+	//	
+	//	if (!my_inst->prepare_report())
+	//	{
+	//		my_inst->m_last_operation_cb	(false, "mp_failed_to_create_report");
+	//		my_inst->terminate_session		();
+	//		Engine.Sheduler.Unregister		(my_inst);
+	//		return;
+	//	}
+	//	
+	//	SCResult tmp_result = my_inst->m_atlas_obj->SubmitReport(
+	//		my_inst->m_atlas_report,
+	//		gsi_true,
+	//		&my_inst->m_last_operation_profile->mCertificate,
+	//		&my_inst->m_last_operation_profile->mPrivateData,
+	//		&stats_submitter::submitted_cb,
+	//		stats_submitter::operation_timeout_value,
+	//		my_inst
+	//	);
+	//	if (tmp_result != SCResult_NO_ERROR)
+	//	{
+	//		my_inst->m_last_operation_cb(false, CGameSpy_ATLAS::TryToTranslate(tmp_result).c_str());
+	//		my_inst->terminate_session();
+	//		Engine.Sheduler.Unregister(my_inst);
+	//		return;
+	//	}
+	//}
+
+	//void __cdecl stats_submitter::submitted_cb(const SCInterfacePtr theInterface,
+	//										   GHTTPResult          theHttpResult,
+	//										   SCResult             theResult,
+	//										   void *               theUserData)
+	//{
+	//	stats_submitter* my_inst = static_cast<stats_submitter*>(theUserData);
+	//	VERIFY(my_inst && my_inst->m_last_operation_profile);
+	//	if (theHttpResult != GHTTPSuccess)
+	//	{
+	//		my_inst->m_last_operation_cb	(false, CGameSpy_ATLAS::TryToTranslate(theHttpResult).c_str());
+	//		my_inst->terminate_session		();
+	//		Engine.Sheduler.Unregister		(my_inst);
+	//		return;
+	//	}
+	//	if (theResult != SCResult_NO_ERROR)
+	//	{
+	//		my_inst->m_last_operation_cb	(false, CGameSpy_ATLAS::TryToTranslate(theResult).c_str());
+	//		my_inst->terminate_session		();
+	//		Engine.Sheduler.Unregister		(my_inst);
+	//		return;
+	//	}
+	//	
+	//	my_inst->m_last_operation_cb	(true, "");
+	//	my_inst->terminate_session		();
+	//	Engine.Sheduler.Unregister		(my_inst);
+	//}
 
@@ -264,61 +265,61 @@
 {
-	VERIFY(!m_atlas_report);
-	SCResult tmp_res = m_atlas_obj->CreateReport(ATLAS_RULE_SET_VERSION, 1, 0, &m_atlas_report);
-	VERIFY2((tmp_res == SCResult_NO_ERROR) && (m_atlas_report), "failed to create atlas report");
-	if ((tmp_res != SCResult_NO_ERROR) || (!m_atlas_report))
-		return false;
-
-	tmp_res = m_atlas_obj->ReportBeginGlobalData(m_atlas_report);
-	VERIFY2(tmp_res == SCResult_NO_ERROR, "failed to begin global data");
-	if (tmp_res != SCResult_NO_ERROR)
-		return false;
-
-	tmp_res = m_atlas_obj->ReportBeginPlayerData(m_atlas_report);
-	VERIFY2(tmp_res == SCResult_NO_ERROR, "failed to begin player data");
-	if (tmp_res != SCResult_NO_ERROR)
-		return false;
-
-	tmp_res = m_atlas_obj->ReportBeginNewPlayer(m_atlas_report);
-	VERIFY2(tmp_res == SCResult_NO_ERROR, "failed to begin new player data");
-	if (tmp_res != SCResult_NO_ERROR)
-		return false;
-
-	tmp_res = m_atlas_obj->ReportSetPlayerData(
-		m_atlas_report,
-		0,
-		m_atlas_connection_id,
-		0,
-		SCGameResult_NONE,
-		m_last_operation_profile->m_profile_id,
-		&m_last_operation_profile->mCertificate
-	);
-	VERIFY2(tmp_res == SCResult_NO_ERROR, "failed to set player data");
-	if (tmp_res != SCResult_NO_ERROR)
-		return false;
-
-	bool	report_creation_result = false;	
-	switch (m_report_type)
-	{
-	case ert_set_award:
-		{
-			report_creation_result	= create_award_inc_report();
-		}break;
-	case ert_set_best_scores:
-		{
-			report_creation_result	= create_best_scores_report();
-		}break;
-	case ert_synchronize_profile:
-		{
-			report_creation_result	= create_all_awards_report();
-			report_creation_result	&= create_best_scores_report();
-		}break;
-	default:
-		NODEFAULT;
-	};//switch (m_report_type)
-	if (report_creation_result)
-	{
-		tmp_res = m_atlas_obj->ReportEnd(m_atlas_report, gsi_true, SCGameStatus_COMPLETE);
-		VERIFY(tmp_res == SCResult_NO_ERROR);
-		return (tmp_res == SCResult_NO_ERROR);
-	}
+		//VERIFY(!m_atlas_report);
+		//SCResult tmp_res = m_atlas_obj->CreateReport(ATLAS_RULE_SET_VERSION, 1, 0, &m_atlas_report);
+		//VERIFY2((tmp_res == SCResult_NO_ERROR) && (m_atlas_report), "failed to create atlas report");
+		//if ((tmp_res != SCResult_NO_ERROR) || (!m_atlas_report))
+		//	return false;
+
+		//tmp_res = m_atlas_obj->ReportBeginGlobalData(m_atlas_report);
+		//VERIFY2(tmp_res == SCResult_NO_ERROR, "failed to begin global data");
+		//if (tmp_res != SCResult_NO_ERROR)
+		//	return false;
+
+		//tmp_res = m_atlas_obj->ReportBeginPlayerData(m_atlas_report);
+		//VERIFY2(tmp_res == SCResult_NO_ERROR, "failed to begin player data");
+		//if (tmp_res != SCResult_NO_ERROR)
+		//	return false;
+
+		//tmp_res = m_atlas_obj->ReportBeginNewPlayer(m_atlas_report);
+		//VERIFY2(tmp_res == SCResult_NO_ERROR, "failed to begin new player data");
+		//if (tmp_res != SCResult_NO_ERROR)
+		//	return false;
+
+		//tmp_res = m_atlas_obj->ReportSetPlayerData(
+		//	m_atlas_report,
+		//	0,
+		//	m_atlas_connection_id,
+		//	0,
+		//	SCGameResult_NONE,
+		//	m_last_operation_profile->m_profile_id,
+		//	&m_last_operation_profile->mCertificate
+		//);
+		//VERIFY2(tmp_res == SCResult_NO_ERROR, "failed to set player data");
+		//if (tmp_res != SCResult_NO_ERROR)
+		//	return false;
+
+		//bool	report_creation_result = false;	
+		//switch (m_report_type)
+		//{
+		//case ert_set_award:
+		//	{
+		//		report_creation_result	= create_award_inc_report();
+		//	}break;
+		//case ert_set_best_scores:
+		//	{
+		//		report_creation_result	= create_best_scores_report();
+		//	}break;
+		//case ert_synchronize_profile:
+		//	{
+		//		report_creation_result	= create_all_awards_report();
+		//		report_creation_result	&= create_best_scores_report();
+		//	}break;
+		//default:
+		//	NODEFAULT;
+		//};//switch (m_report_type)
+		//if (report_creation_result)
+		//{
+		//	tmp_res = m_atlas_obj->ReportEnd(m_atlas_report, gsi_true, SCGameStatus_COMPLETE);
+		//	VERIFY(tmp_res == SCResult_NO_ERROR);
+		//	return (tmp_res == SCResult_NO_ERROR);
+		//}
 	return false;	
@@ -328,10 +329,10 @@
 {
-	SCResult tmp_res = m_atlas_obj->ReportAddStringValue(
-		m_atlas_report,
-		KEY_PlayerName,
-		m_last_operation_profile->unique_nick()
-	);
-	VERIFY(tmp_res == SCResult_NO_ERROR);
-	if (tmp_res != SCResult_NO_ERROR)
-			return false;
+		//SCResult tmp_res = m_atlas_obj->ReportAddStringValue(
+		//	m_atlas_report,
+		//	KEY_PlayerName,
+		//	m_last_operation_profile->unique_nick()
+		//);
+		//VERIFY(tmp_res == SCResult_NO_ERROR);
+		//if (tmp_res != SCResult_NO_ERROR)
+		//		return false;
 
@@ -345,19 +346,19 @@
 
-	SCResult tmp_res = m_atlas_obj->ReportAddIntValue(
-		m_atlas_report,
-		get_award_id_key(m_last_award_id),
-		static_cast<gsi_i32>(m_last_award_count)
-	);
-	VERIFY(tmp_res == SCResult_NO_ERROR);
-	if (tmp_res != SCResult_NO_ERROR)
-		return false;
-
-	tmp_res = m_atlas_obj->ReportAddIntValue(
-		m_atlas_report,
-		get_award_reward_date_key(m_last_award_id),
-		static_cast<gsi_i32>(tmp_time)
-	);
-	VERIFY(tmp_res == SCResult_NO_ERROR);
-	if (tmp_res != SCResult_NO_ERROR)
-			return false;
+		//SCResult tmp_res = m_atlas_obj->ReportAddIntValue(
+		//	m_atlas_report,
+		//	get_award_id_key(m_last_award_id),
+		//	static_cast<gsi_i32>(m_last_award_count)
+		//);
+		//VERIFY(tmp_res == SCResult_NO_ERROR);
+		//if (tmp_res != SCResult_NO_ERROR)
+		//	return false;
+
+		//tmp_res = m_atlas_obj->ReportAddIntValue(
+		//	m_atlas_report,
+		//	get_award_reward_date_key(m_last_award_id),
+		//	static_cast<gsi_i32>(tmp_time)
+		//);
+		//VERIFY(tmp_res == SCResult_NO_ERROR);
+		//if (tmp_res != SCResult_NO_ERROR)
+		//		return false;
 
@@ -368,16 +369,16 @@
 {
-	VERIFY(m_last_best_scores);
-	SCResult tmp_res;
-	for (all_best_scores_t::const_iterator si = m_last_best_scores->begin(),
-		sie = m_last_best_scores->end(); si != sie; ++si)
-	{
-		tmp_res = m_atlas_obj->ReportAddIntValue(
-			m_atlas_report,
-			get_best_score_id_key(static_cast<gamespy_profile::enum_best_score_type>(si->first)),
-			si->second
-		);
-		VERIFY(tmp_res == SCResult_NO_ERROR);
-		if (tmp_res != SCResult_NO_ERROR)
-			return false;
-	}
+		//VERIFY(m_last_best_scores);
+		//SCResult tmp_res;
+		//for (all_best_scores_t::const_iterator si = m_last_best_scores->begin(),
+		//	sie = m_last_best_scores->end(); si != sie; ++si)
+		//{
+		//	tmp_res = m_atlas_obj->ReportAddIntValue(
+		//		m_atlas_report,
+		//		get_best_score_id_key(static_cast<gamespy_profile::enum_best_score_type>(si->first)),
+		//		si->second
+		//	);
+		//	VERIFY(tmp_res == SCResult_NO_ERROR);
+		//	if (tmp_res != SCResult_NO_ERROR)
+		//		return false;
+		//}
 	return add_player_name_to_report();
@@ -387,24 +388,24 @@
 {
-	VERIFY(m_last_all_awards);
-	for (all_awards_t::const_iterator ai = m_last_all_awards->begin(),
-		aie = m_last_all_awards->end(); ai != aie; ++ai)
-	{
-		SCResult tmp_res = m_atlas_obj->ReportAddIntValue(
-			m_atlas_report,
-			get_award_id_key(ai->first),
-			static_cast<gsi_i32>(ai->second.m_count)
-		);
-		VERIFY(tmp_res == SCResult_NO_ERROR);
-		if (tmp_res != SCResult_NO_ERROR)
-			return false;
-
-		tmp_res = m_atlas_obj->ReportAddIntValue(
-			m_atlas_report,
-			get_award_reward_date_key(ai->first),
-			static_cast<gsi_i32>(ai->second.m_last_reward_date)
-		);
-		VERIFY(tmp_res == SCResult_NO_ERROR);
-		if (tmp_res != SCResult_NO_ERROR)
-			return false;
-	}
+		//VERIFY(m_last_all_awards);
+		//for (all_awards_t::const_iterator ai = m_last_all_awards->begin(),
+		//	aie = m_last_all_awards->end(); ai != aie; ++ai)
+		//{
+		//	SCResult tmp_res = m_atlas_obj->ReportAddIntValue(
+		//		m_atlas_report,
+		//		get_award_id_key(ai->first),
+		//		static_cast<gsi_i32>(ai->second.m_count)
+		//	);
+		//	VERIFY(tmp_res == SCResult_NO_ERROR);
+		//	if (tmp_res != SCResult_NO_ERROR)
+		//		return false;
+
+		//	tmp_res = m_atlas_obj->ReportAddIntValue(
+		//		m_atlas_report,
+		//		get_award_reward_date_key(ai->first),
+		//		static_cast<gsi_i32>(ai->second.m_last_reward_date)
+		//	);
+		//	VERIFY(tmp_res == SCResult_NO_ERROR);
+		//	if (tmp_res != SCResult_NO_ERROR)
+		//		return false;
+		//}
 	return add_player_name_to_report();
@@ -416,5 +417,5 @@
 	m_last_operation_profile	= NULL;
-	m_atlas_report				= NULL;
+		//m_atlas_report				= NULL;
 	m_last_best_scores			= NULL;
-	ZeroMemory					(m_atlas_connection_id, sizeof(m_atlas_connection_id));
+		//ZeroMemory					(m_atlas_connection_id, sizeof(m_atlas_connection_id));
 }
@@ -424,16 +425,16 @@
 {
-	profile_store*	tmp_prof_store = MainMenu()->GetProfileStore();
-	VERIFY(tmp_prof_store);
-	awards_store*	tmp_awards_store = tmp_prof_store->get_awards_store();
-	VERIFY(tmp_awards_store);
-	
-	all_awards_t&	tmp_awards = tmp_awards_store->get_player_awards();
-
-	all_awards_t::iterator award_iter = tmp_awards.find(award_id);
-	R_ASSERT(award_iter != tmp_awards.end());
-	++award_iter->second.m_count;
-	__time32_t tmp_time		= 0;
-	_time32					(&tmp_time);
-	award_iter->second.m_last_reward_date = static_cast<u32>(tmp_time);
-	save_file(profile);
+		//profile_store*	tmp_prof_store = MainMenu()->GetProfileStore();
+		//VERIFY(tmp_prof_store);
+		//awards_store*	tmp_awards_store = tmp_prof_store->get_awards_store();
+		//VERIFY(tmp_awards_store);
+		//
+		//all_awards_t&	tmp_awards = tmp_awards_store->get_player_awards();
+
+		//all_awards_t::iterator award_iter = tmp_awards.find(award_id);
+		//R_ASSERT(award_iter != tmp_awards.end());
+		//++award_iter->second.m_count;
+		//__time32_t tmp_time		= 0;
+		//_time32					(&tmp_time);
+		//award_iter->second.m_last_reward_date = static_cast<u32>(tmp_time);
+		//save_file(profile);
 }
@@ -442,19 +443,19 @@
 {
-	VERIFY(scores);
-	profile_store*		tmp_prof_store = MainMenu()->GetProfileStore();
-	VERIFY(tmp_prof_store);
-	best_scores_store*	tmp_bs_store = tmp_prof_store->get_best_scores_store();
-	VERIFY(tmp_bs_store);
-
-	all_best_scores_t&	tmp_best_scores = tmp_bs_store->get_player_best_scores();
-	
-	for (all_best_scores_t::iterator i = tmp_best_scores.begin(),
-		ie = tmp_best_scores.end(); i != ie; ++i)
-	{
-		all_best_scores_t::const_iterator tmp_iter = scores->find(i->first);
-		if (tmp_iter == scores->end())
-			continue;
-		i->second = std::max(i->second, tmp_iter->second);				
-	}
-	save_file(profile);
+		//VERIFY(scores);
+		//profile_store*		tmp_prof_store = MainMenu()->GetProfileStore();
+		//VERIFY(tmp_prof_store);
+		//best_scores_store*	tmp_bs_store = tmp_prof_store->get_best_scores_store();
+		//VERIFY(tmp_bs_store);
+
+		//all_best_scores_t&	tmp_best_scores = tmp_bs_store->get_player_best_scores();
+		//
+		//for (all_best_scores_t::iterator i = tmp_best_scores.begin(),
+		//	ie = tmp_best_scores.end(); i != ie; ++i)
+		//{
+		//	all_best_scores_t::const_iterator tmp_iter = scores->find(i->first);
+		//	if (tmp_iter == scores->end())
+		//		continue;
+		//	i->second = std::max(i->second, tmp_iter->second);				
+		//}
+		//save_file(profile);
 }
@@ -463,39 +464,39 @@
 {
-	profile_store*		tmp_prof_store = MainMenu()->GetProfileStore();
-	VERIFY(tmp_prof_store);
-	awards_store*		tmp_awards_store = tmp_prof_store->get_awards_store();
-	VERIFY(tmp_awards_store);
-	best_scores_store*	tmp_bs_store = tmp_prof_store->get_best_scores_store();
-	VERIFY(tmp_prof_store);
-
-	all_awards_t&		tmp_awards = tmp_awards_store->get_player_awards();
-	all_best_scores_t&	tmp_best_scores = tmp_bs_store->get_player_best_scores();
-	
-	CInifile& ltx_to_write = m_ltx_file.get_ltx();
-	ltx_to_write.sections().clear();
-	
-	for (all_awards_t::const_iterator i = tmp_awards.begin(),
-		ie = tmp_awards.end(); i != ie; ++i)
-	{
-		LPCSTR tmp_award_name = get_award_name(i->first);
-		ltx_to_write.w_u16(tmp_award_name, award_count_line, i->second.m_count);
-		ltx_to_write.w_u32(tmp_award_name, award_rdate_line, i->second.m_last_reward_date);
-	}
-	
-	for (all_best_scores_t::const_iterator i = tmp_best_scores.begin(),
-		ie = tmp_best_scores.end(); i != ie; ++i)
-	{
-		LPCSTR tmp_bs_name = get_best_score_name(i->first);
-		ltx_to_write.w_u32(tmp_bs_name, best_score_value_line, i->second);
-	}
-
-	__time32_t tmp_time	= 0;
-	_time32				(&tmp_time);
-	
-	ltx_to_write.w_s32(profile_data_section, profile_id_line, profile->m_profile_id);
-	ltx_to_write.w_u32(profile_data_section, profile_last_submit_time, static_cast<u32>(tmp_time));
-
-	IWriter* tmp_writer = FS.w_open("$app_data_root$", profile_store_file_name);
-	m_ltx_file.sign_and_save(*tmp_writer);
-	FS.w_close(tmp_writer);
+		//profile_store*		tmp_prof_store = MainMenu()->GetProfileStore();
+		//VERIFY(tmp_prof_store);
+		//awards_store*		tmp_awards_store = tmp_prof_store->get_awards_store();
+		//VERIFY(tmp_awards_store);
+		//best_scores_store*	tmp_bs_store = tmp_prof_store->get_best_scores_store();
+		//VERIFY(tmp_prof_store);
+
+		//all_awards_t&		tmp_awards = tmp_awards_store->get_player_awards();
+		//all_best_scores_t&	tmp_best_scores = tmp_bs_store->get_player_best_scores();
+		//
+		//CInifile& ltx_to_write = m_ltx_file.get_ltx();
+		//ltx_to_write.sections().clear();
+		//
+		//for (all_awards_t::const_iterator i = tmp_awards.begin(),
+		//	ie = tmp_awards.end(); i != ie; ++i)
+		//{
+		//	LPCSTR tmp_award_name = get_award_name(i->first);
+		//	ltx_to_write.w_u16(tmp_award_name, award_count_line, i->second.m_count);
+		//	ltx_to_write.w_u32(tmp_award_name, award_rdate_line, i->second.m_last_reward_date);
+		//}
+		//
+		//for (all_best_scores_t::const_iterator i = tmp_best_scores.begin(),
+		//	ie = tmp_best_scores.end(); i != ie; ++i)
+		//{
+		//	LPCSTR tmp_bs_name = get_best_score_name(i->first);
+		//	ltx_to_write.w_u32(tmp_bs_name, best_score_value_line, i->second);
+		//}
+
+		//__time32_t tmp_time	= 0;
+		//_time32				(&tmp_time);
+		//
+		//ltx_to_write.w_s32(profile_data_section, profile_id_line, profile->m_profile_id);
+		//ltx_to_write.w_u32(profile_data_section, profile_last_submit_time, static_cast<u32>(tmp_time));
+
+		//IWriter* tmp_writer = FS.w_open("$app_data_root$", profile_store_file_name);
+		//m_ltx_file.sign_and_save(*tmp_writer);
+		//FS.w_close(tmp_writer);
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/stats_submitter.h xray-monolith/src/xrGame/stats_submitter.h
--- coc-1.4-xray-64/src/xrGame/stats_submitter.h	2023-10-20 20:54:51.367326500 +0100
+++ xray-monolith/src/xrGame/stats_submitter.h	2023-10-20 20:54:33.298035800 +0100
@@ -4,3 +4,2 @@
 #include <boost/noncopyable.hpp>
-#include "gamespy/GameSpy_ATLAS.h"
 #include "profile_data_types.h"
@@ -54,3 +53,3 @@
 	CGameSpy_Full*			m_fullgs_obj;
-	CGameSpy_ATLAS*			m_atlas_obj;
+		//CGameSpy_ATLAS*			m_atlas_obj;
 	gsc_dsigned_ltx_writer	m_ltx_file;
@@ -58,4 +57,5 @@
 	gamespy_gp::profile const *	m_last_operation_profile;
-	gsi_u8						m_atlas_connection_id[SC_CONNECTION_GUID_SIZE];
-	SCReportPtr					m_atlas_report;
+
+		//gsi_u8						m_atlas_connection_id[SC_CONNECTION_GUID_SIZE];
+		//SCReportPtr					m_atlas_report;
 
@@ -94,15 +94,14 @@
 	static u32 const		operation_timeout_value;
-	static void __cdecl		created_session_cb		(const SCInterfacePtr theInterface,
-													 GHTTPResult          theHttpResult,
-													 SCResult             theResult,
-													 void *               theUserData);
-	static void __cdecl		set_intension_cb		(const SCInterfacePtr theInterface,
-													 GHTTPResult          theHttpResult,
-													 SCResult             theResult,
-													 void *               theUserData);
-	static void __cdecl		submitted_cb			(const SCInterfacePtr theInterface,
-													 GHTTPResult          theHttpResult,
-													 SCResult             theResult,
-													 void *               theUserData);
-
+		//static void __cdecl		created_session_cb		(const SCInterfacePtr theInterface,
+		//												 GHTTPResult          theHttpResult,
+		//												 SCResult             theResult,
+		//												 void *               theUserData);
+		//static void __cdecl		set_intension_cb		(const SCInterfacePtr theInterface,
+		//												 GHTTPResult          theHttpResult,
+		//												 SCResult             theResult,
+		//												 void *               theUserData);
+		//static void __cdecl		submitted_cb			(const SCInterfacePtr theInterface,
+		//												 GHTTPResult          theHttpResult,
+		//												 SCResult             theResult,
+		//												 void *               theUserData);
 };
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/StdAfx.h xray-monolith/src/xrGame/StdAfx.h
--- coc-1.4-xray-64/src/xrGame/StdAfx.h	2023-10-20 20:54:50.704327200 +0100
+++ xray-monolith/src/xrGame/StdAfx.h	2023-10-20 20:54:32.656035600 +0100
@@ -2,2 +2,10 @@
 
+/**/
+#define GP_EMAIL_LEN 128
+#define GP_NICK_LEN 32
+#define GP_UNIQUENICK_LEN 32
+#define GP_PASSWORD_LEN 32
+/**/
+
+
 #pragma warning(push)
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/step_manager.cpp xray-monolith/src/xrGame/step_manager.cpp
--- coc-1.4-xray-64/src/xrGame/step_manager.cpp	2023-10-20 20:54:51.371326800 +0100
+++ xray-monolith/src/xrGame/step_manager.cpp	2023-10-20 20:54:33.301035600 +0100
@@ -9,2 +9,4 @@
 #include "IKLimbsController.h"
+#include "GameObject.h"
+#include "../../xrServerEntities/script_engine.h"
 
@@ -157,4 +164,4 @@
 
-	float dist_sqr = m_object->Position().distance_to_sqr(Device.vCameraPosition);
-	bool b_play = dist_sqr < 400.0f; //20m
+		float dist = m_object->Position().distance_to(Device.vCameraPosition);
+		bool b_play = dist < 50.0f; //meters
 
@@ -193,5 +199,24 @@
 
-			// Èãðàòü çâóê
-			if(b_play && is_on_ground() )
+				CGameObject* object = smart_cast<CGameObject*>(m_object);
+				if (b_play && is_on_ground() && object)
+				{
+					if (object->ID() == 0)
+					{
+						SGameMtl* mt = GMLib.GetMaterialByID(mtl_pair->GetMtl1());
+						if (mt)
+						{
+							luabind::functor<bool>	funct;
+							if (ai().script_engine().functor("_G.CActor__FootstepCallback", funct))
+							{
+								if (funct(*mt->m_Name, m_step_info.params.step[i].power, b_hud_view))
+									m_step_sound.play_next(mtl_pair, m_object, m_step_info.params.step[i].power, b_hud_view);
+							}
+						}
+					}
+					else
+					{
 				m_step_sound.play_next(mtl_pair, m_object, m_step_info.params.step[i].power, b_hud_view);
+						object->FootStepCallback(m_step_info.params.step[i].power, b_play, is_on_ground(), b_hud_view);
+					}	
+				}
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/string_table.cpp xray-monolith/src/xrGame/string_table.cpp
--- coc-1.4-xray-64/src/xrGame/string_table.cpp	2023-10-20 20:54:51.372326800 +0100
+++ xray-monolith/src/xrGame/string_table.cpp	2023-10-20 20:54:33.302036300 +0100
@@ -5,2 +5,6 @@
 #include "xr_level_controller.h"
+#include "..\..\xrEngine\x_ray.h"
+#include "MainMenu.h"
+#include "UIGameCustom.h"
+#include <regex>
 
@@ -25,2 +30,6 @@
 
+extern void refresh_npc_names();
+
+// demonized: use english text if locale text string is missing
+BOOL use_english_text_for_missing_translations = TRUE;
 void CStringTable::Init		()
@@ -32,4 +41,22 @@
 	//èìÿ ÿçûêà, åñëè íå çàäàíî (NULL), òî ïåðâûé <text> â <string> â XML
-	pData->m_sLanguage	= pSettings->r_string("string_table", "language");
+	pData->m_sLanguage = READ_IF_EXISTS(pSettings, r_string, "string_table", "language", "eng");
+
+	// demonized: parse english files first, then they will be replaced by current locale
+	if (use_english_text_for_missing_translations && xr_strcmp(pData->m_sLanguage, "eng") != 0) {
+		FS_FileSet fset;
+		string_path files_mask;
+		xr_sprintf(files_mask, "text\\%s\\*.xml", "eng");
+		FS.file_list(fset, "$game_config$", FS_ListFiles, files_mask);
+		FS_FileSetIt fit = fset.begin();
+		FS_FileSetIt fit_e = fset.end();
 
+		for (; fit != fit_e; ++fit)
+		{
+			string_path fn, ext;
+			_splitpath((*fit).name.c_str(), 0, 0, fn, ext);
+			xr_strcat(fn, ext);
+
+			Load(fn, "eng");
+		}
+	}
 
@@ -56,9 +83,24 @@
 	ReparseKeyBindings();
+
+	//Discord
+	snprintf(discord_strings.mainmenu, 128, xr_ToUTF8(*CStringTable().translate("st_main_menu")));
+	snprintf(discord_strings.paused, 128, xr_ToUTF8(*CStringTable().translate("st_pause_menu")));
+	snprintf(discord_strings.loading, 128, xr_ToUTF8(*CStringTable().translate("st_loading")));
+	snprintf(discord_strings.health, 128, xr_ToUTF8(*CStringTable().translate("st_ui_health_sensor")));
+	snprintf(discord_strings.dead, 128, xr_ToUTF8(*CStringTable().translate("st_player_dead")));
+	snprintf(discord_strings.livesleft, 128, xr_ToUTF8(*CStringTable().translate("st_hardcore_lives_left")));
+	snprintf(discord_strings.livesleftsingle, 128, xr_ToUTF8(*CStringTable().translate("st_hardcore_lives_left_single")));
+	snprintf(discord_strings.livespossessed, 128, xr_ToUTF8(*CStringTable().translate("st_azazel_lives_possessed")));
+	snprintf(discord_strings.livespossessedsingle, 128, xr_ToUTF8(*CStringTable().translate("st_azazel_lives_possessed_single")));
+	snprintf(discord_strings.godmode, 128, xr_ToUTF8(*CStringTable().translate("st_godmode")));
+
+	discord_gameinfo.ex_update = true;
 }
 
-void CStringTable::Load	(LPCSTR xml_file_full)
+void CStringTable::Load(LPCSTR xml_file_full, LPCSTR lang_in)
 {
+	LPCSTR lang = lang_in ? lang_in : pData->m_sLanguage.c_str();
 	CUIXml						uiXml;
 	string_path					_s;
-	strconcat					(sizeof(_s),_s, "text\\", pData->m_sLanguage.c_str() );
+	strconcat(sizeof(_s), _s, "text\\", lang);
 
@@ -78,5 +121,5 @@
 		if(m_bWriteErrorsToLog && string_text)
-			Msg("[string table] '%s' no translation in '%s'", string_name, pData->m_sLanguage.c_str() );
+			Msg("[string table] '%s' no translation in '%s'", string_name, lang);
 		
-		VERIFY3						(string_text, "string table entry does not has a text", string_name);
+		R_ASSERT3(string_text, "string table entry does not have a text", string_name);
 		
@@ -100,2 +143,27 @@
 
+void CStringTable::ReloadLanguage()
+{
+	if (0 == xr_strcmp(READ_IF_EXISTS(pSettings, r_string, "string_table", "language", "eng"), *(pData->m_sLanguage)))
+		return;
+
+	//reload language
+	Destroy();
+	Init();
+
+	//reload language in menu
+	if (MainMenu()->IsActive())
+	{
+		MainMenu()->Activate(FALSE);
+		MainMenu()->Activate(TRUE);
+	}
+
+	if (!g_pGameLevel)
+		return;
+
+	//refresh npc names
+	refresh_npc_names();
+
+	//reload language in other UIs
+	g_hud->OnScreenResolutionChanged();
+}
 
@@ -143,2 +212,7 @@
 
+	if (Core.april1)
+	{
+		res = std::regex_replace(res, std::regex("Anomal"), "Amomaw");
+		res = std::regex_replace(res, std::regex("anomal"), "amomaw");
+	}
 	return STRING_VALUE(res.c_str());
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/string_table.h xray-monolith/src/xrGame/string_table.h
--- coc-1.4-xray-64/src/xrGame/string_table.h	2023-10-20 20:54:51.372326800 +0100
+++ xray-monolith/src/xrGame/string_table.h	2023-10-20 20:54:33.302036300 +0100
@@ -32,5 +32,6 @@
 	static	void				ReparseKeyBindings		();
+	void ReloadLanguage();
 private:
 			void				Init					();
-			void				Load					(LPCSTR xml_file);
+	void Load(LPCSTR xml_file, LPCSTR lang = 0);
 	static STRING_VALUE			ParseLine				(LPCSTR str, LPCSTR key, bool bFirst);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/TeleWhirlwind.cpp xray-monolith/src/xrGame/TeleWhirlwind.cpp
--- coc-1.4-xray-64/src/xrGame/TeleWhirlwind.cpp	2023-10-20 20:54:50.705327100 +0100
+++ xray-monolith/src/xrGame/TeleWhirlwind.cpp	2023-10-20 20:54:32.656035600 +0100
@@ -10,2 +10,3 @@
 #include "../Include/xrRender/KinematicsAnimated.h"
+#include "entity_alive.h"
 //#include "PHWorld.h"
@@ -153,3 +154,3 @@
 		dir_inv.random_dir();
-		impulse=throw_power*100.f;
+		impulse = throw_power * 10.f;
 	}
@@ -159,3 +160,3 @@
 	{
-		b_destroyed=destroy_object(dir_inv,throw_power*100.f);
+		b_destroyed = destroy_object(dir_inv, impulse);
 	}
@@ -171,3 +171,3 @@
 	CPHDestroyable* D=object->ph_destroyable();
-	if(D)
+	if (D && D->CanDestroy())
 	{
@@ -188,6 +188,7 @@
 		CParticlesPlayer* PP = smart_cast<CParticlesPlayer*>(object);
-		if(PP)
+		if (PP && smart_cast<CEntityAlive*>(object))
 		{
 			u16 root=(smart_cast<IKinematics*>(object->Visual()))->LL_GetBoneRoot();
-			PP->StartParticles(m_telekinesis->destroing_particles(),root, Fvector().set(0,1,0),m_telekinesis->OwnerObject()->ID());
+			PP->StartParticles(m_telekinesis->destroing_particles(), root, Fvector().set(0, 1, 0),
+			                   m_telekinesis->OwnerObject()->ID());
 		}
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Torch.cpp xray-monolith/src/xrGame/Torch.cpp
--- coc-1.4-xray-64/src/xrGame/Torch.cpp	2023-10-20 20:54:50.706326500 +0100
+++ xray-monolith/src/xrGame/Torch.cpp	2023-10-20 20:54:32.658035400 +0100
@@ -17,3 +17,2 @@
 #include "UIGameCustom.h"
-#include "actorEffector.h"
 #include "CustomOutfit.h"
@@ -30,3 +29,3 @@
 
-ENGINE_API int g_current_renderer;
+extern ENGINE_API int g_current_renderer;
 
@@ -48,11 +47,20 @@
 	m_delta_h					= 0;
-	m_night_vision				= NULL;
 
-	// Disabling shift by x and z axes for 1st render, 
-	// because we don't have dynamic lighting in it. 
-	if( g_current_renderer == 1 )
-	{
-		TORCH_OFFSET.x = 0;
-		TORCH_OFFSET.z = 0;
-	}
+	m_torch_offset = TORCH_OFFSET;
+	m_omni_offset = OMNI_OFFSET;
+	m_torch_inertion_speed_max = TORCH_INERTION_SPEED_MAX;
+	m_torch_inertion_speed_min = TORCH_INERTION_SPEED_MIN;
+	m_torch_inertion_clamp = TORCH_INERTION_CLAMP;
+
+	m_bUseInertion = false;
+
+	guid_bone = 0;
+	light_trace_bone = "";
+	m_light_section = "";
+
+	isFlickering = false;
+	lightRenderState = false;
+	lastFlicker = 0.0f;
+	l_flickerChance = 0;
+	l_flickerDelay = 0.0f;
 }
@@ -64,3 +72,19 @@
 	glow_render.destroy		();
-	xr_delete				(m_night_vision);
+}
+
+void CTorch::OnMoveToSlot(const SInvItemPlace& prev)
+{
+	CInventoryOwner* owner = smart_cast<CInventoryOwner*>(H_Parent());
+	if (owner && !owner->attached(this))
+	{
+		owner->attach(this->cast_inventory_item());
+	}
+}
+
+void CTorch::OnMoveToRuck(const SInvItemPlace& prev)
+{
+	if (prev.type == eItemPlaceSlot)
+	{
+		Switch(false);
+	}
 }
@@ -84,79 +108,42 @@
 
+	m_light_section = READ_IF_EXISTS(pSettings, r_string, section, "light_section", "torch_definition");
+	if (pSettings->line_exist(section, "snd_turn_on"))
+		m_sounds.LoadSound(section, "snd_turn_on", "sndTurnOn", false, SOUND_TYPE_ITEM_USING);
+	if (pSettings->line_exist(section, "snd_turn_off"))
+		m_sounds.LoadSound(section, "snd_turn_off", "sndTurnOff", false, SOUND_TYPE_ITEM_USING);
+
+	m_torch_offset = READ_IF_EXISTS(pSettings, r_fvector3, section, "torch_offset", TORCH_OFFSET);
+	m_omni_offset = READ_IF_EXISTS(pSettings, r_fvector3, section, "omni_offset", OMNI_OFFSET);
+	m_torch_inertion_speed_max = READ_IF_EXISTS(pSettings, r_float, section, "torch_inertion_speed_max",
+	                                            TORCH_INERTION_SPEED_MAX);
+	m_torch_inertion_speed_min = READ_IF_EXISTS(pSettings, r_float, section, "torch_inertion_speed_min",
+	                                            TORCH_INERTION_SPEED_MIN);
+	m_torch_inertion_clamp = READ_IF_EXISTS(pSettings, r_float, section, "torch_inertion_clamp",
+		TORCH_INERTION_CLAMP);
 
-	m_bNightVisionEnabled = !!pSettings->r_bool(section,"night_vision");
+	m_bUseInertion = READ_IF_EXISTS(pSettings, r_bool, section, "torch_inertion",
+		true);
 }
 
-void CTorch::SwitchNightVision()
+void CTorch::Switch()
 {
 	if (OnClient()) return;
-	SwitchNightVision(!m_bNightVisionOn);	
-}
-
-void CTorch::SwitchNightVision(bool vision_on, bool use_sounds)
-{
-	if(!m_bNightVisionEnabled) return;
-	
-	m_bNightVisionOn			= vision_on;
-
-	CActor *pA = smart_cast<CActor *>(H_Parent());
-	if(!pA)						
-	{
-		return;
-	}
-	if(!m_night_vision)
-		m_night_vision			= xr_new<CNightVisionEffector>(cNameSect());
-
-
-	LPCSTR disabled_names	= pSettings->r_string(cNameSect(),"disabled_maps");
-	LPCSTR curr_map			= *Level().name();
-	u32 cnt					= _GetItemCount(disabled_names);
-	bool b_allow			= true;
-	string512				tmp;
-	for(u32 i=0; i<cnt;++i){
-		_GetItem(disabled_names, i, tmp);
-		if(0==stricmp(tmp, curr_map)){
-			b_allow = false;
-			break;
-		}
-	}
-
-	CHelmet* pHelmet	= smart_cast<CHelmet*>(pA->inventory().ItemFromSlot(HELMET_SLOT));
-	CCustomOutfit* pOutfit	= smart_cast<CCustomOutfit*>(pA->inventory().ItemFromSlot(OUTFIT_SLOT));
-
-	if(pHelmet && pHelmet->m_NightVisionSect.size() && !b_allow)
-	{
-		m_night_vision->OnDisabled(pA, use_sounds);
-		return;
-	}
-	else if(pOutfit && pOutfit->m_NightVisionSect.size() && !b_allow)
-	{
-		m_night_vision->OnDisabled(pA, use_sounds);
-		return;
+	bool bActive = !m_switched_on;
+	Switch(bActive);
 	}
 
-	bool bIsActiveNow = m_night_vision->IsActive();
-
-	if(m_bNightVisionOn)
-	{
-
-		if(!bIsActiveNow)
+void CTorch::Switch(bool light_on)
 		{
-			if(pHelmet && pHelmet->m_NightVisionSect.size())
+	CActor* pActor = smart_cast<CActor*>(H_Parent());
+	if (pActor)
 			{
-				m_night_vision->Start(pHelmet->m_NightVisionSect, pA, use_sounds);
-				return;
-			}
-			else if(pOutfit && pOutfit->m_NightVisionSect.size())
+		if (light_on && !m_switched_on)
 			{
-				m_night_vision->Start(pOutfit->m_NightVisionSect, pA, use_sounds);
-				return;
+			if (m_sounds.FindSoundItem("SndTurnOn", false))
+				m_sounds.PlaySound("SndTurnOn", pActor->Position(), NULL, !!pActor->HUDview());
 			}
-			m_bNightVisionOn = false; // in case if there is no nightvision in helmet and outfit
-		}
-	}else
-	{
-		if(bIsActiveNow)
+		else if (!light_on && m_switched_on)
 		{
-			m_night_vision->Stop(100000.0f, use_sounds);
-		}
+			if (m_sounds.FindSoundItem("SndTurnOff", false))
+				m_sounds.PlaySound("SndTurnOff", pActor->Position(), NULL, !!pActor->HUDview());
 	}
@@ -164,12 +151,4 @@
 
-void CTorch::Switch()
-{
-	if (OnClient())			return;
-	bool bActive			= !m_switched_on;
-	Switch					(bActive);
-}
-
-void CTorch::Switch(bool light_on)
-{
 	m_switched_on			= light_on;
+	lightRenderState = light_on;
 	if (can_use_dynamic_lights())
@@ -212,2 +193,12 @@
 	
+	LoadLightParams();
+
+	Switch(torch->m_active);
+	VERIFY(!torch->m_active || (torch->ID_Parent != 0xffff));
+
+	return (TRUE);
+}
+
+void CTorch::LoadLightParams()
+{
 	bool b_r2				= !!psDeviceFlags.test(rsR2);
@@ -216,11 +207,26 @@
 
+	xr_string light_definition = *m_light_section;
+
+	if (parent_id() == g_actor->ID())
+	{
+		light_definition += "_actor";
+
+		if (!pSettings->section_exist(light_definition.c_str()))
+			light_definition = *m_light_section;
+	}
+
 	IKinematics* K			= smart_cast<IKinematics*>(Visual());
-	CInifile* pUserData		= K->LL_UserData(); 
+	/*CInifile* pUserData = K->LL_UserData();
 	R_ASSERT3				(pUserData,"Empty Torch user data!",torch->get_visual());
-	lanim					= LALib.FindItem(pUserData->r_string("torch_definition","color_animator"));
-	guid_bone				= K->LL_BoneID	(pUserData->r_string("torch_definition","guide_bone"));	VERIFY(guid_bone!=BI_NONE);
+	R_ASSERT2(pUserData->section_exist(light_definition.c_str()),
+	"Section not found in torch user data! Check 'light_section' field in config");*/
+	def_lanim = pSettings->r_string(light_definition.c_str(), "color_animator");
+	lanim = LALib.FindItem(def_lanim);
+	guid_bone = K->LL_BoneID(pSettings->r_string(light_definition.c_str(), "guide_bone"));
+	VERIFY(guid_bone != BI_NONE);
 
-	Fcolor clr				= pUserData->r_fcolor				("torch_definition",(b_r2)?"color_r2":"color");
+	Fcolor clr = pSettings->r_fcolor(light_definition.c_str(), (b_r2) ? "color_r2" : "color");
+	def_clr = clr;
 	fBrightness				= clr.intensity();
-	float range				= pUserData->r_float				("torch_definition",(b_r2)?"range_r2":"range");
+	float range = pSettings->r_float(light_definition.c_str(), (b_r2) ? "range_r2" : "range");
 	light_render->set_color	(clr);
@@ -228,4 +234,4 @@
 
-	Fcolor clr_o			= pUserData->r_fcolor				("torch_definition",(b_r2)?"omni_color_r2":"omni_color");
-	float range_o			= pUserData->r_float				("torch_definition",(b_r2)?"omni_range_r2":"omni_range");
+	Fcolor clr_o = pSettings->r_fcolor(light_definition.c_str(), (b_r2) ? "omni_color_r2" : "omni_color");
+	float range_o = pSettings->r_float(light_definition.c_str(), (b_r2) ? "omni_range_r2" : "omni_range");
 	light_omni->set_color	(clr_o);
@@ -233,21 +239,21 @@
 
-	light_render->set_cone	(deg2rad(pUserData->r_float			("torch_definition","spot_angle")));
-	light_render->set_texture(pUserData->r_string				("torch_definition","spot_texture"));
+	light_render->set_cone(deg2rad(pSettings->r_float(light_definition.c_str(), "spot_angle")));
+	light_render->set_texture(READ_IF_EXISTS(pSettings, r_string, light_definition.c_str(), "spot_texture", (0)));
 
-	glow_render->set_texture(pUserData->r_string				("torch_definition","glow_texture"));
+	glow_render->set_texture(pSettings->r_string(light_definition.c_str(), "glow_texture"));
 	glow_render->set_color	(clr);
-	glow_render->set_radius	(pUserData->r_float					("torch_definition","glow_radius"));
+	glow_render->set_radius(pSettings->r_float(light_definition.c_str(), "glow_radius"));
 
-	//âêëþ÷èòü/âûêëþ÷èòü ôîíàðèê
-	Switch					(torch->m_active);
-	VERIFY					(!torch->m_active || (torch->ID_Parent != 0xffff));
-	
-	if(torch->ID_Parent == 0)		
-		SwitchNightVision	(torch->m_nightvision_active, false);
-	//else
-	//	SwitchNightVision	(false, false);
+	light_render->set_volumetric(!!READ_IF_EXISTS(pSettings, r_bool, light_definition.c_str(), "volumetric", 0));
+	light_render->
+		set_volumetric_quality(READ_IF_EXISTS(pSettings, r_float, light_definition.c_str(), "volumetric_quality", 1.f));
+	light_render->set_volumetric_intensity(READ_IF_EXISTS(pSettings, r_float, light_definition.c_str(), "volumetric_intensity",
+		1.f));
+	light_render->set_volumetric_distance(READ_IF_EXISTS(pSettings, r_float, light_definition.c_str(), "volumetric_distance",
+		1.f));
 
-	m_delta_h				= PI_DIV_2-atan((range*0.5f)/_abs(TORCH_OFFSET.x));
+	light_render->set_type((IRender_Light::LT)(READ_IF_EXISTS(pSettings, r_u8, light_definition.c_str(), "type", 2)));
+	light_omni->set_type((IRender_Light::LT)(READ_IF_EXISTS(pSettings, r_u8, light_definition.c_str(), "omni_type", 1)));
 
-	return					(TRUE);
+	m_delta_h = PI_DIV_2 - atan((range * 0.5f) / _abs(m_torch_offset.x));
 }
@@ -257,3 +263,2 @@
 	Switch					(false);
-	SwitchNightVision		(false);
 
@@ -265,3 +270,2 @@
 	inherited::OnH_A_Chield			();
-	m_focus.set						(Position());
 }
@@ -273,5 +277,26 @@
 	Switch						(false);
-	SwitchNightVision			(false);
+}
 
-	m_sounds.StopAllSounds		();
+//Switch light render on/off without touching torch state
+void CTorch::SwitchLightOnly()
+{
+	lightRenderState = !lightRenderState;
+
+	if (can_use_dynamic_lights())
+	{
+		light_render->set_active(lightRenderState);
+		light_omni->set_active(lightRenderState);
+	}
+
+	glow_render->set_active(lightRenderState);
+
+	if (*light_trace_bone)
+	{
+		IKinematics* pVisual = smart_cast<IKinematics*>(Visual());
+		VERIFY(pVisual);
+		u16 bi = pVisual->LL_BoneID(light_trace_bone);
+
+		pVisual->LL_SetBoneVisible(bi, lightRenderState, TRUE);
+		pVisual->CalculateBones(TRUE);
+	}
 }
@@ -284,2 +309,15 @@
 
+	if (isFlickering)
+	{
+		float tg = Device.fTimeGlobal;
+		if (lastFlicker == NULL) lastFlicker = tg;
+		if (tg - lastFlicker >= l_flickerDelay)
+		{
+			int rando = rand() % 100 + 1;
+			if (rando <= l_flickerChance)
+				SwitchLightOnly();
+			lastFlicker = tg;
+		}
+	}
+
 	CBoneInstance			&BI = smart_cast<IKinematics*>(Visual())->LL_GetBoneInstance(guid_bone);
@@ -305,4 +347,16 @@
 		{
-			m_prev_hp.x		= angle_inertion_var(m_prev_hp.x,-actor->cam_FirstEye()->yaw,TORCH_INERTION_SPEED_MIN,TORCH_INERTION_SPEED_MAX,TORCH_INERTION_CLAMP,Device.fTimeDelta);
-			m_prev_hp.y		= angle_inertion_var(m_prev_hp.y,-actor->cam_FirstEye()->pitch,TORCH_INERTION_SPEED_MIN,TORCH_INERTION_SPEED_MAX,TORCH_INERTION_CLAMP,Device.fTimeDelta);
+			if (actor->active_cam() == eacLookAt)
+			{
+				m_prev_hp.x = angle_inertion_var(m_prev_hp.x, -actor->cam_Active()->yaw, m_torch_inertion_speed_min,
+				                                 m_torch_inertion_speed_max, m_torch_inertion_clamp, Device.fTimeDelta);
+				m_prev_hp.y = angle_inertion_var(m_prev_hp.y, -actor->cam_Active()->pitch, m_torch_inertion_speed_min,
+				                                 m_torch_inertion_speed_max, m_torch_inertion_clamp, Device.fTimeDelta);
+			}
+			else
+			{
+				m_prev_hp.x = angle_inertion_var(m_prev_hp.x, -actor->cam_FirstEye()->yaw, m_torch_inertion_speed_min,
+				                                 m_torch_inertion_speed_max, m_torch_inertion_clamp, Device.fTimeDelta);
+				m_prev_hp.y = angle_inertion_var(m_prev_hp.y, -actor->cam_FirstEye()->pitch, m_torch_inertion_speed_min,
+				                                 m_torch_inertion_speed_max, m_torch_inertion_clamp, Device.fTimeDelta);
+			}
 
@@ -312,33 +366,29 @@
 
-
-			if (true)
+			if (!m_bUseInertion && actor->active_cam() == eacFirstEye)
 			{
-				Fvector offset				= M.c; 
-				offset.mad					(M.i,TORCH_OFFSET.x);
-				offset.mad					(M.j,TORCH_OFFSET.y);
-				offset.mad					(M.k,TORCH_OFFSET.z);
+				CCameraBase* actorcam = actor->cam_FirstEye();
+				Fvector offset = actorcam->vPosition;
+				offset.mad(actorcam->Right(), m_torch_offset.x);
+				offset.mad(actorcam->Up(), m_torch_offset.y);
+				offset.mad(actorcam->Direction(), m_torch_offset.z);
 				light_render->set_position	(offset);
-
-				if(true /*false*/)
-				{
-					offset						= M.c; 
-					offset.mad					(M.i,OMNI_OFFSET.x);
-					offset.mad					(M.j,OMNI_OFFSET.y);
-					offset.mad					(M.k,OMNI_OFFSET.z);
 					light_omni->set_position	(offset);
+				glow_render->set_position(actorcam->vPosition);
+				light_render->set_rotation(actorcam->Direction(), actorcam->Right());
+				light_omni->set_rotation(actorcam->Direction(), actorcam->Right());
+				glow_render->set_direction(actorcam->Direction());
 				}
-			}//if (true)
-			glow_render->set_position	(M.c);
-
-			if (true)
+			else
 			{
+				Fvector offset = M.c;
+				offset.mad(M.i, m_torch_offset.x);
+				offset.mad(M.j, m_torch_offset.y);
+				offset.mad(M.k, m_torch_offset.z);
+				light_render->set_position(offset);
+				glow_render->set_position(M.c);
 				light_render->set_rotation	(dir, right);
-				
-				if(true /*false*/)
-				{
+				light_omni->set_position(M.c);
 					light_omni->set_rotation	(dir, right);
-				}
-			}//if (true)
 			glow_render->set_direction	(dir);
-
+			}
 		}// if(actor)
@@ -352,5 +402,5 @@
 				Fvector offset				= M.c; 
-				offset.mad					(M.i,OMNI_OFFSET.x);
-				offset.mad					(M.j,OMNI_OFFSET.y);
-				offset.mad					(M.k,OMNI_OFFSET.z);
+				offset.mad(M.i, m_omni_offset.x);
+				offset.mad(M.j, m_omni_offset.y);
+				offset.mad(M.k, m_omni_offset.z);
 				light_omni->set_position	(M.c);
@@ -396,2 +446,34 @@
 
+void CTorch::SetLanim(LPCSTR name, bool bFlicker, int flickerChance, float flickerDelay, float framerate)
+{
+	lanim = LALib.FindItem(name);
+	if (lanim && framerate)
+		lanim->SetFramerate(framerate);
+	isFlickering = bFlicker;
+	if (isFlickering)
+	{
+		l_flickerChance = flickerChance;
+		l_flickerDelay = flickerDelay;
+	}
+}
+
+void CTorch::ResetLanim()
+{
+	if (lanim)
+	{
+		lanim->ResetFramerate();
+		if (lanim->cName != def_lanim)
+			lanim = LALib.FindItem(def_lanim);
+	}
+
+	if (can_use_dynamic_lights())
+	{
+		light_render->set_color(def_clr);
+		light_omni->set_color(def_clr);
+	}
+	glow_render->set_color(def_clr);
+
+	isFlickering = false;
+}
+
 
@@ -420,3 +502,2 @@
 	F |= (m_switched_on ? eTorchActive : 0);
-	F |= (m_bNightVisionOn ? eNightVisionActive : 0);
 	const CActor *pA = smart_cast<const CActor *>(H_Parent());
@@ -428,3 +509,2 @@
 	P.w_u8(F);
-//	Msg("CTorch::net_export - NV[%d]", m_bNightVisionOn);
 }
@@ -437,15 +517,4 @@
 	bool new_m_switched_on				= !!(F & eTorchActive);
-	bool new_m_bNightVisionOn			= !!(F & eNightVisionActive);
 
 	if (new_m_switched_on != m_switched_on)			Switch						(new_m_switched_on);
-	if (new_m_bNightVisionOn != m_bNightVisionOn)	
-	{
-//		Msg("CTorch::net_Import - NV[%d]", new_m_bNightVisionOn);
-
-		const CActor *pA = smart_cast<const CActor *>(H_Parent());
-		if (pA)
-		{
-			SwitchNightVision			(new_m_bNightVisionOn);
-		}
-	}
 }
@@ -460,2 +530,7 @@
 
+void CTorch::afterAttach()
+{
+	LoadLightParams();
+}
+
 void CTorch::afterDetach			()
@@ -476,79 +552,2 @@
 		Switch				(false);
-
-}
-
-CNightVisionEffector::CNightVisionEffector(const shared_str& section)
-:m_pActor(NULL)
-{
-	m_sounds.LoadSound(section.c_str(),"snd_night_vision_on", "NightVisionOnSnd", false, SOUND_TYPE_ITEM_USING);
-	m_sounds.LoadSound(section.c_str(),"snd_night_vision_off", "NightVisionOffSnd", false, SOUND_TYPE_ITEM_USING);
-	m_sounds.LoadSound(section.c_str(),"snd_night_vision_idle", "NightVisionIdleSnd", false, SOUND_TYPE_ITEM_USING);
-	m_sounds.LoadSound(section.c_str(),"snd_night_vision_broken", "NightVisionBrokenSnd", false, SOUND_TYPE_ITEM_USING);
-}
-
-void CNightVisionEffector::Start(const shared_str& sect, CActor* pA, bool play_sound)
-{
-	m_pActor			= pA;
-	AddEffector			(m_pActor, effNightvision, sect);
-	if(play_sound)
-	{
-		PlaySounds(eStartSound);
-		PlaySounds(eIdleSound);
-	}
-}
-
-void CNightVisionEffector::Stop(const float factor, bool play_sound)
-{
-	if(!m_pActor)		return;
-	CEffectorPP* pp		= m_pActor->Cameras().GetPPEffector((EEffectorPPType)effNightvision);
-	if(pp)
-	{
-		pp->Stop			(factor);
-		if(play_sound)
-			PlaySounds(eStopSound);
-
-		m_sounds.StopSound("NightVisionIdleSnd");
-	}
-}
-
-bool CNightVisionEffector::IsActive()
-{
-	if(!m_pActor)	return false;
-	CEffectorPP* pp = m_pActor->Cameras().GetPPEffector((EEffectorPPType)effNightvision);
-	return (pp!=NULL);
-}
-
-void CNightVisionEffector::OnDisabled(CActor* pA, bool play_sound)
-{
-	m_pActor					= pA;
-	if(play_sound)
-		PlaySounds(eBrokeSound);
-}
-
-void CNightVisionEffector::PlaySounds(EPlaySounds which)
-{
-	if(!m_pActor)
-		return;
-
-	bool bPlaySoundFirstPerson = !!m_pActor->HUDview();
-	switch(which)
-	{
-	case eStartSound:
-		{
-			m_sounds.PlaySound("NightVisionOnSnd", m_pActor->Position(), NULL, bPlaySoundFirstPerson);
-		}break;
-	case eStopSound:
-		{
-			m_sounds.PlaySound("NightVisionOffSnd", m_pActor->Position(), NULL, bPlaySoundFirstPerson);
-		}break;
-	case eIdleSound:
-		{
-			m_sounds.PlaySound("NightVisionIdleSnd", m_pActor->Position(), NULL, bPlaySoundFirstPerson, true);
-		}break;
-	case eBrokeSound:
-		{
-			m_sounds.PlaySound("NightVisionBrokenSnd", m_pActor->Position(), NULL, bPlaySoundFirstPerson);
-		}break;
-	default: NODEFAULT;
-	}
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Torch.h xray-monolith/src/xrGame/Torch.h
--- coc-1.4-xray-64/src/xrGame/Torch.h	2023-10-20 20:54:50.706326500 +0100
+++ xray-monolith/src/xrGame/Torch.h	2023-10-20 20:54:32.658035400 +0100
@@ -16,2 +17,4 @@
 	CLAItem*		lanim;
+	LPCSTR def_lanim;
+	Fcolor def_clr;
 
@@ -26,6 +29,16 @@
 	ref_glow		glow_render;
-	Fvector			m_focus;
+	shared_str m_light_section;
+	Fvector m_torch_offset;
+	Fvector m_omni_offset;
+	float m_torch_inertion_speed_max;
+	float m_torch_inertion_speed_min;
+	float m_torch_inertion_clamp;
+	bool m_bUseInertion;
 private:
 	inline	bool	can_use_dynamic_lights	();
-
+	bool isFlickering;
+	bool lightRenderState;
+	float lastFlicker;
+	int l_flickerChance;
+	float l_flickerDelay;
 public:
@@ -43,2 +57,4 @@
 
+	virtual void OnMoveToSlot(const SInvItemPlace& prev);
+	virtual void OnMoveToRuck(const SInvItemPlace& prev);
 	virtual void	UpdateCL				();
@@ -47,2 +63,6 @@
 			void	Switch					(bool light_on);
+	void SwitchLightOnly();
+	void SetLanim(LPCSTR name, bool bFlicker, int flickerChance, float flickerDelay, float framerate);
+	void ResetLanim();
+	void LoadLightParams();
 			bool	torch_active			() const;
@@ -53,17 +73,7 @@
 	virtual	void	enable					(bool value);
- 
-public:
-			void	SwitchNightVision		();
-			void	SwitchNightVision		(bool light_on, bool use_sounds=true);
-
-			bool	GetNightVisionStatus	() { return m_bNightVisionOn; }
-CNightVisionEffector* GetNightVision		() { return m_night_vision; }
 protected:
-	bool					m_bNightVisionEnabled;
-	bool					m_bNightVisionOn;
-
-	CNightVisionEffector*	m_night_vision;
-	HUD_SOUND_COLLECTION	m_sounds;
+	HUD_SOUND_COLLECTION_LAYERED m_sounds;
 
-	enum EStats{
+	enum EStats
+	{
 		eTorchActive				= (1<<0),
@@ -83,2 +94,3 @@
 
+	virtual void afterAttach();
 	virtual void	afterDetach				();
@@ -89,21 +101,2 @@
 
-class CNightVisionEffector
-{
-	CActor*					m_pActor;
-	HUD_SOUND_COLLECTION	m_sounds;
-public:
-	enum EPlaySounds{
-		eStartSound	= 0,
-		eStopSound,
-		eIdleSound,
-		eBrokeSound
-	};
-				CNightVisionEffector(const shared_str& sect);
-	void		Start		(const shared_str& sect, CActor* pA, bool play_sound=true);
-	void		Stop		(const float factor, bool play_sound=true);
-	bool		IsActive	();
-	void		OnDisabled	(CActor* pA, bool play_sound=true);
-	void		PlaySounds	(EPlaySounds which);
-};
-
 add_to_type_list(CTorch)
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/trade2.cpp xray-monolith/src/xrGame/trade2.cpp
--- coc-1.4-xray-64/src/xrGame/trade2.cpp	2023-10-20 20:54:51.375328300 +0100
+++ xray-monolith/src/xrGame/trade2.cpp	2023-10-20 20:54:33.305035900 +0100
@@ -15,2 +15,3 @@
 #include "trade_parameters.h"
+#include "eatable_item.h"
 
@@ -268,2 +283,11 @@
 
+	CEatableItem* eatable_item = pItem->cast_eatable_item();
+	if (eatable_item && eatable_item->GetMaxUses())
+	{
+		u8 max_uses = eatable_item->GetMaxUses();
+		u8 remaining_uses = eatable_item->GetRemainingUses();
+		result = result * remaining_uses / max_uses;
+		if (result < 1) result = 1;
+	}
+
 	clamp<u32>					(result, 1, 1000000);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/ArtefactDetectorUI.h xray-monolith/src/xrGame/ui/ArtefactDetectorUI.h
--- coc-1.4-xray-64/src/xrGame/ui/ArtefactDetectorUI.h	2023-10-20 20:54:51.387326400 +0100
+++ xray-monolith/src/xrGame/ui/ArtefactDetectorUI.h	2023-10-20 20:54:33.311035400 +0100
@@ -12,7 +12,12 @@
 
-class CUIArtefactDetectorBase
+class CUICustomDeviceBase
 {
 public:
-	virtual			~CUIArtefactDetectorBase	()	{};
-	virtual void	update						()	{};
+	virtual ~CUICustomDeviceBase()
+	{
+	};
+
+	virtual void update()
+	{
+	};
 };
@@ -32,5 +39,5 @@
 
-class CUIArtefactDetectorSimple :public CUIArtefactDetectorBase
+class CUIArtefactDetectorSimple : public CUICustomDeviceBase
 {
-	typedef CUIArtefactDetectorBase	inherited;
+	typedef CUICustomDeviceBase inherited;
 
@@ -54,5 +61,5 @@
 
-class CUIArtefactDetectorElite :public CUIArtefactDetectorBase, public CUIWindow
+class CUIArtefactDetectorElite : public CUICustomDeviceBase, public CUIWindow
 {
-	typedef CUIArtefactDetectorBase	inherited;
+	typedef CUICustomDeviceBase inherited;
 
@@ -83,5 +95,5 @@
 
-class CUIArtefactDetectorAdv :public CUIArtefactDetectorBase
+class CUIArtefactDetectorAdv : public CUICustomDeviceBase
 {
-	typedef CUIArtefactDetectorBase	inherited;
+	typedef CUICustomDeviceBase inherited;
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/ServerList.cpp xray-monolith/src/xrGame/ui/ServerList.cpp
--- coc-1.4-xray-64/src/xrGame/ui/ServerList.cpp	2023-10-20 20:54:51.393326800 +0100
+++ xray-monolith/src/xrGame/ui/ServerList.cpp	2023-10-20 20:54:33.313035600 +0100
@@ -11,4 +11,2 @@
 #include "../login_manager.h"
-#include "../GameSpy/GameSpy_Full.h"
-#include "../GameSpy/GameSpy_Browser.h"
 
@@ -20,4 +18,4 @@
 {
-	m_GSBrowser	= MainMenu()->GetGS()->GetGameSpyBrowser();
-	browser().Init(this);
+	//m_GSBrowser	= MainMenu()->GetGS()->GetGameSpyBrowser();
+	//browser().Init(this);
 
@@ -59,4 +57,4 @@
 	xr_delete			(m_message_box);
-	if (m_GSBrowser)
-		m_GSBrowser->Clear	();
+	//if (m_GSBrowser)
+	//	m_GSBrowser->Clear	();
 
@@ -104,10 +102,12 @@
 {
-	CUIListItemServer* pItem = (CUIListItemServer*)m_list[LST_SERVER].GetSelectedItem();
-	if(!pItem)
+	//CUIListItemServer* pItem = (CUIListItemServer*)m_list[LST_SERVER].GetSelectedItem();
+	//if(!pItem)
 		return false;
-	return browser().HasAllKeys(pItem->GetInfo()->info.Index) == false;
+	//return browser().HasAllKeys(pItem->GetInfo()->info.Index) == false;
 };
 
-void CServerList::SendMessage(CUIWindow* pWnd, s16 msg, void* pData){
-	if (m_bShowServerInfo && LIST_ITEM_CLICKED == msg && &m_list[LST_SERVER] == pWnd){
+void CServerList::SendMessage(CUIWindow* pWnd, s16 msg, void* pData)
+{
+	if (m_bShowServerInfo && LIST_ITEM_CLICKED == msg && &m_list[LST_SERVER] == pWnd)
+	{
 		if (NeedToRefreshCurServer())
@@ -192,153 +201,153 @@
 	CUIListItemServer* pItem = (CUIListItemServer*)m_list[LST_SERVER].GetSelectedItem();
-	if(pItem)
-	{
-		ServerInfo srvInfo;
-		browser().GetServerInfoByIndex(&srvInfo, pItem->GetInfo()->info.Index);
-		u32 teams = srvInfo.m_aTeams.size();
-
-		if (2 == teams)
-		{
-			LPSTR _buff = NULL;
-
-			CUIListBoxItem* pItemAdv;
-
-			// TEAM 1
-			xr_vector<PlayerInfo>::iterator it;
-			for (it = srvInfo.m_aPlayers.begin(); it != srvInfo.m_aPlayers.end(); ++it)
-			{
-				PlayerInfo pf = *it;
-				if (1 != pf.Team)
-					continue;
-				if (pf.Spectator)
-					continue;
-
-				if (!t1)		// add header
-				{
-					STRCONCAT(_buff, CStringTable().translate("ui_st_team").c_str(),
-						"\"", CTeamInfo::GetTeam1_name().c_str(), "\"");
-
-					pItemAdv					= m_list[LST_PLAYERS].AddItem();
-					pItemAdv->SetTextColor		(m_list[LST_PLAYERS].GetTextColor());
-					pItemAdv->SetFont			(m_list[LST_PLAYERS].GetFont());
-					pItemAdv->SetText			(_buff);
-					pItemAdv->GetTextItem()->SetWidth(m_list[LST_PLAYERS].GetDesiredChildWidth());
-					t1 = true;
-				}
-
-
- 				pItemAdv						= m_list[LST_PLAYERS].AddItem();
-
-				char buf[16];
-				pItemAdv->SetTextColor			(m_list[LST_PLAYERS].GetTextColor());
-				pItemAdv->SetFont				(m_list[LST_PLAYERS].GetFont());
-				pItemAdv->SetText	(pf.Name);
-				pItemAdv->GetTextItem()->SetWidth(m_header2[1].GetWidth());
-
-				xr_sprintf						(buf,sizeof(buf),"%d",pf.Frags);
-				pItemAdv->AddTextField			(buf, m_header2[2].GetWidth());
-
-				xr_sprintf						(buf,sizeof(buf),"%d",pf.Deaths);
-				pItemAdv->AddTextField			(buf, m_header2[3].GetWidth());
-			}
-
-			
-			// TEAM 2
-			for (it = srvInfo.m_aPlayers.begin(); it != srvInfo.m_aPlayers.end(); it++)
-			{
-				PlayerInfo pf = *it;
-				if (2 != pf.Team)
-					continue;
-				if (pf.Spectator)
-					continue;
-
-				if (!t2)
-				{
-					STRCONCAT(_buff, CStringTable().translate("ui_st_team").c_str(),
-						"\"", CTeamInfo::GetTeam2_name().c_str(), "\"");
-
-					m_list[LST_PLAYERS].AddTextItem	(_buff);
-
-					t2 = true;
-				}
-
-				pItemAdv						= m_list[LST_PLAYERS].AddItem();
-
-				char buf[16];
-				pItemAdv->SetTextColor			(m_list[LST_PLAYERS].GetTextColor());
-				pItemAdv->SetFont				(m_list[LST_PLAYERS].GetFont());
-				pItemAdv->SetText				(pf.Name);
-				pItemAdv->GetTextItem()->SetWidth(m_header2[1].GetWidth());
-				
-				xr_sprintf						(buf,sizeof(buf),"%d",pf.Frags);
-				pItemAdv->AddTextField			(buf, m_header2[2].GetWidth());
-
-				xr_sprintf						(buf,sizeof(buf),"%d",pf.Deaths);
-				pItemAdv->AddTextField			(buf, m_header2[3].GetWidth());
-			}
-
-			// SPECTATORS
-			for (it = srvInfo.m_aPlayers.begin(); it != srvInfo.m_aPlayers.end();++it)
-			{
-				PlayerInfo pf = *it;
-				if (!pf.Spectator)
-					continue;
-
-				if (!spect)
-				{
-					pItemAdv					= m_list[LST_PLAYERS].AddTextItem(CStringTable().translate("mp_spectator").c_str());
-					spect = true;
-				}
-
-				pItemAdv						= m_list[LST_PLAYERS].AddItem();
-
-				char buf[16];
-				pItemAdv->SetFont				(m_list[LST_PLAYERS].GetFont());
-				pItemAdv->SetTextColor			(m_list[LST_PLAYERS].GetTextColor());
-				pItemAdv->SetText				(pf.Name);
-				pItemAdv->GetTextItem()->SetWidth(m_header2[1].GetWidth());
-
-				xr_sprintf						(buf,sizeof(buf),"%d",pf.Frags);
-				pItemAdv->AddTextField			(buf, m_header2[2].GetWidth());
-
-				xr_sprintf						(buf,sizeof(buf),"%d",pf.Deaths);
-				pItemAdv->AddTextField			(buf, m_header2[3].GetWidth());
-			}
-
-		}
-		else
-		{
-			xr_vector<PlayerInfo>::iterator it;
-			for (it = srvInfo.m_aPlayers.begin(); it != srvInfo.m_aPlayers.end(); ++it)
-			{
-				PlayerInfo pf = *it;
-				CUIListBoxItem* pItemAdv		= m_list[LST_PLAYERS].AddItem();
-
-				char buf[16];
-
-				pItemAdv->SetTextColor			(m_list[LST_PLAYERS].GetTextColor());
-				pItemAdv->SetFont				(m_list[LST_PLAYERS].GetFont());
-				pItemAdv->SetText				(pf.Name);
-				pItemAdv->GetTextItem()->SetWidth(m_header2[1].GetWidth());
-
-				xr_sprintf						(buf,sizeof(buf),"%d",pf.Frags);
-				pItemAdv->AddTextField			(buf, m_header2[2].GetWidth());
-
-				xr_sprintf						(buf,sizeof(buf),"%d",pf.Deaths);
-				pItemAdv->AddTextField			(buf, m_header2[3].GetWidth());
-			}
-		}
-
-		xr_vector<GameInfo>::iterator it;
-		for (it = srvInfo.m_aInfos.begin(); it != srvInfo.m_aInfos.end(); ++it)
-		{
-			GameInfo gi							= *it;
-			CUIListBoxItem* pItemAdv			= m_list[LST_SRV_PROP].AddItem();
-
-			pItemAdv->SetText					(gi.InfoName.c_str());
-			pItemAdv->GetTextItem()->SetWidth	(m_list[LST_SRV_PROP].GetWidth()/2);
-
-			pItemAdv->AddTextField				(gi.InfoData.c_str(), m_list[LST_SRV_PROP].GetWidth()/2);
-		}
-	}
-	else
+	//if(pItem)
+	//{
+	//	ServerInfo srvInfo;
+	//	browser().GetServerInfoByIndex(&srvInfo, pItem->GetInfo()->info.Index);
+	//	u32 teams = srvInfo.m_aTeams.size();
+
+	//	if (2 == teams)
+	//	{
+	//		LPSTR _buff = NULL;
+
+	//		CUIListBoxItem* pItemAdv;
+
+	//		// TEAM 1
+	//		xr_vector<PlayerInfo>::iterator it;
+	//		for (it = srvInfo.m_aPlayers.begin(); it != srvInfo.m_aPlayers.end(); ++it)
+	//		{
+	//			PlayerInfo pf = *it;
+	//			if (1 != pf.Team)
+	//				continue;
+	//			if (pf.Spectator)
+	//				continue;
+
+	//			if (!t1)		// add header
+	//			{
+	//				STRCONCAT(_buff, CStringTable().translate("ui_st_team").c_str(),
+	//					"\"", CTeamInfo::GetTeam1_name().c_str(), "\"");
+
+	//				pItemAdv					= m_list[LST_PLAYERS].AddItem();
+	//				pItemAdv->SetTextColor		(m_list[LST_PLAYERS].GetTextColor());
+	//				pItemAdv->SetFont			(m_list[LST_PLAYERS].GetFont());
+	//				pItemAdv->SetText			(_buff);
+	//				pItemAdv->GetTextItem()->SetWidth(m_list[LST_PLAYERS].GetDesiredChildWidth());
+	//				t1 = true;
+	//			}
+
+
+	//				pItemAdv						= m_list[LST_PLAYERS].AddItem();
+
+	//			char buf[16];
+	//			pItemAdv->SetTextColor			(m_list[LST_PLAYERS].GetTextColor());
+	//			pItemAdv->SetFont				(m_list[LST_PLAYERS].GetFont());
+	//			pItemAdv->SetText	(pf.Name);
+	//			pItemAdv->GetTextItem()->SetWidth(m_header2[1].GetWidth());
+
+	//			xr_sprintf						(buf,sizeof(buf),"%d",pf.Frags);
+	//			pItemAdv->AddTextField			(buf, m_header2[2].GetWidth());
+
+	//			xr_sprintf						(buf,sizeof(buf),"%d",pf.Deaths);
+	//			pItemAdv->AddTextField			(buf, m_header2[3].GetWidth());
+	//		}
+
+	//		
+	//		// TEAM 2
+	//		for (it = srvInfo.m_aPlayers.begin(); it != srvInfo.m_aPlayers.end(); it++)
+	//		{
+	//			PlayerInfo pf = *it;
+	//			if (2 != pf.Team)
+	//				continue;
+	//			if (pf.Spectator)
+	//				continue;
+
+	//			if (!t2)
+	//			{
+	//				STRCONCAT(_buff, CStringTable().translate("ui_st_team").c_str(),
+	//					"\"", CTeamInfo::GetTeam2_name().c_str(), "\"");
+
+	//				m_list[LST_PLAYERS].AddTextItem	(_buff);
+
+	//				t2 = true;
+	//			}
+
+	//			pItemAdv						= m_list[LST_PLAYERS].AddItem();
+
+	//			char buf[16];
+	//			pItemAdv->SetTextColor			(m_list[LST_PLAYERS].GetTextColor());
+	//			pItemAdv->SetFont				(m_list[LST_PLAYERS].GetFont());
+	//			pItemAdv->SetText				(pf.Name);
+	//			pItemAdv->GetTextItem()->SetWidth(m_header2[1].GetWidth());
+	//			
+	//			xr_sprintf						(buf,sizeof(buf),"%d",pf.Frags);
+	//			pItemAdv->AddTextField			(buf, m_header2[2].GetWidth());
+
+	//			xr_sprintf						(buf,sizeof(buf),"%d",pf.Deaths);
+	//			pItemAdv->AddTextField			(buf, m_header2[3].GetWidth());
+	//		}
+
+	//		// SPECTATORS
+	//		for (it = srvInfo.m_aPlayers.begin(); it != srvInfo.m_aPlayers.end();++it)
+	//		{
+	//			PlayerInfo pf = *it;
+	//			if (!pf.Spectator)
+	//				continue;
+
+	//			if (!spect)
+	//			{
+	//				pItemAdv					= m_list[LST_PLAYERS].AddTextItem(CStringTable().translate("mp_spectator").c_str());
+	//				spect = true;
+	//			}
+
+	//			pItemAdv						= m_list[LST_PLAYERS].AddItem();
+
+	//			char buf[16];
+	//			pItemAdv->SetFont				(m_list[LST_PLAYERS].GetFont());
+	//			pItemAdv->SetTextColor			(m_list[LST_PLAYERS].GetTextColor());
+	//			pItemAdv->SetText				(pf.Name);
+	//			pItemAdv->GetTextItem()->SetWidth(m_header2[1].GetWidth());
+
+	//			xr_sprintf						(buf,sizeof(buf),"%d",pf.Frags);
+	//			pItemAdv->AddTextField			(buf, m_header2[2].GetWidth());
+
+	//			xr_sprintf						(buf,sizeof(buf),"%d",pf.Deaths);
+	//			pItemAdv->AddTextField			(buf, m_header2[3].GetWidth());
+	//		}
+
+	//	}
+	//	else
+	//	{
+	//		xr_vector<PlayerInfo>::iterator it;
+	//		for (it = srvInfo.m_aPlayers.begin(); it != srvInfo.m_aPlayers.end(); ++it)
+	//		{
+	//			PlayerInfo pf = *it;
+	//			CUIListBoxItem* pItemAdv		= m_list[LST_PLAYERS].AddItem();
+
+	//			char buf[16];
+
+	//			pItemAdv->SetTextColor			(m_list[LST_PLAYERS].GetTextColor());
+	//			pItemAdv->SetFont				(m_list[LST_PLAYERS].GetFont());
+	//			pItemAdv->SetText				(pf.Name);
+	//			pItemAdv->GetTextItem()->SetWidth(m_header2[1].GetWidth());
+
+	//			xr_sprintf						(buf,sizeof(buf),"%d",pf.Frags);
+	//			pItemAdv->AddTextField			(buf, m_header2[2].GetWidth());
+
+	//			xr_sprintf						(buf,sizeof(buf),"%d",pf.Deaths);
+	//			pItemAdv->AddTextField			(buf, m_header2[3].GetWidth());
+	//		}
+	//	}
+
+	//	xr_vector<GameInfo>::iterator it;
+	//	for (it = srvInfo.m_aInfos.begin(); it != srvInfo.m_aInfos.end(); ++it)
+	//	{
+	//		GameInfo gi							= *it;
+	//		CUIListBoxItem* pItemAdv			= m_list[LST_SRV_PROP].AddItem();
+
+	//		pItemAdv->SetText					(gi.InfoName.c_str());
+	//		pItemAdv->GetTextItem()->SetWidth	(m_list[LST_SRV_PROP].GetWidth()/2);
+
+	//		pItemAdv->AddTextField				(gi.InfoData.c_str(), m_list[LST_SRV_PROP].GetWidth()/2);
+	//	}
+	//}
+	//else
 		ClearDetailedServerInfo		();
@@ -406,8 +415,8 @@
 
-	result &= !m_sf.empty ? (m_sf.empty == (item.m_ServerNumPlayers == 0))						: true;
-	result &= !m_sf.full ? (m_sf.full == (item.m_ServerNumPlayers == item.m_ServerMaxPlayers))	: true;
-	result &= !m_sf.with_pass ? (m_sf.with_pass == item.m_bPassword)							: true;
-	result &= !m_sf.without_pass ? (m_sf.without_pass != item.m_bPassword)						: true;
-	result &= !m_sf.without_ff ? (m_sf.without_ff != item.m_bFFire)								: true;
-	result &= !m_sf.listen_servers ? (m_sf.listen_servers != item.m_bDedicated)					: true;
+	//result &= !m_sf.empty ? (m_sf.empty == (item.m_ServerNumPlayers == 0))						: true;
+	//result &= !m_sf.full ? (m_sf.full == (item.m_ServerNumPlayers == item.m_ServerMaxPlayers))	: true;
+	//result &= !m_sf.with_pass ? (m_sf.with_pass == item.m_bPassword)							: true;
+	//result &= !m_sf.without_pass ? (m_sf.without_pass != item.m_bPassword)						: true;
+	//result &= !m_sf.without_ff ? (m_sf.without_ff != item.m_bFFire)								: true;
+	//result &= !m_sf.listen_servers ? (m_sf.listen_servers != item.m_bDedicated)					: true;
 
@@ -459,56 +472,56 @@
 {
-	gamespy_gp::login_manager const * lmngr = MainMenu()->GetLoginMngr();
-	R_ASSERT(lmngr);
-	gamespy_gp::profile const * tmp_profile = lmngr->get_current_profile(); 
-	R_ASSERT2(tmp_profile, "need first to log in");
-	if (tmp_profile->online())
-	{
-		if (!MainMenu()->ValidateCDKey())
-			return;
-
-		if (!xr_strcmp(tmp_profile->unique_nick(), "@unregistered"))
-		{
-			if (m_connect_cb)
-				m_connect_cb(ece_unique_nick_not_registred, "mp_gp_unique_nick_not_registred");
-			return;
-		}
-		if (!xr_strcmp(tmp_profile->unique_nick(), "@expired"))
-		{
-			if (m_connect_cb)
-				m_connect_cb(ece_unique_nick_expired, "mp_gp_unique_nick_has_expired");
-			return;
-		}
-	}
-
-
-	CUIListItemServer* item = smart_cast<CUIListItemServer*>(m_list[LST_SERVER].GetSelectedItem());
-	if(!item)
-		return;
-	if (!browser().CheckDirectConnection(item->GetInfo()->info.Index))
-	{
-		Msg("! Direct connection to this server is not available -> its behind firewall");
-		return;
-	}
-
-	if (xr_strcmp(item->GetInfo()->info.version, MainMenu()->GetGSVer()))
-	{
-		MainMenu()->SetErrorDialog(CMainMenu::ErrDifferentVersion);
-		return;
-	}
+	//gamespy_gp::login_manager const * lmngr = MainMenu()->GetLoginMngr();
+	//R_ASSERT(lmngr);
+	//gamespy_gp::profile const * tmp_profile = lmngr->get_current_profile(); 
+	//R_ASSERT2(tmp_profile, "need first to log in");
+	//if (tmp_profile->online())
+	//{
+	//	if (!MainMenu()->ValidateCDKey())
+	//		return;
+
+	//	if (!xr_strcmp(tmp_profile->unique_nick(), "@unregistered"))
+	//	{
+	//		if (m_connect_cb)
+	//			m_connect_cb(ece_unique_nick_not_registred, "mp_gp_unique_nick_not_registred");
+	//		return;
+	//	}
+	//	if (!xr_strcmp(tmp_profile->unique_nick(), "@expired"))
+	//	{
+	//		if (m_connect_cb)
+	//			m_connect_cb(ece_unique_nick_expired, "mp_gp_unique_nick_has_expired");
+	//		return;
+	//	}
+	//}
+
+
+	//CUIListItemServer* item = smart_cast<CUIListItemServer*>(m_list[LST_SERVER].GetSelectedItem());
+	//if(!item)
+	//	return;
+	//if (!browser().CheckDirectConnection(item->GetInfo()->info.Index))
+	//{
+	//	Msg("! Direct connection to this server is not available -> its behind firewall");
+	//	return;
+	//}
+
+	//if (xr_strcmp(item->GetInfo()->info.version, MainMenu()->GetGSVer()))
+	//{
+	//	MainMenu()->SetErrorDialog(CMainMenu::ErrDifferentVersion);
+	//	return;
+	//}
+
+
+	//if (item->GetInfo()->info.icons.pass || item->GetInfo()->info.icons.user_pass)
+	//{
+	//	m_message_box->m_pMessageBox->SetUserPasswordMode	(item->GetInfo()->info.icons.user_pass);
+	//	m_message_box->m_pMessageBox->SetPasswordMode		(item->GetInfo()->info.icons.pass);
+	//	m_message_box->ShowDialog(true);
+	//}
+	//else
+	//{
+	//	xr_string command;
 
+	//	item->CreateConsoleCommand(command, m_playerName.c_str(), "", "" );
 
-	if (item->GetInfo()->info.icons.pass || item->GetInfo()->info.icons.user_pass)
-	{
-		m_message_box->m_pMessageBox->SetUserPasswordMode	(item->GetInfo()->info.icons.user_pass);
-		m_message_box->m_pMessageBox->SetPasswordMode		(item->GetInfo()->info.icons.pass);
-		m_message_box->ShowDialog(true);
-	}
-	else
-	{
-		xr_string command;
-
-		item->CreateConsoleCommand(command, m_playerName.c_str(), "", "" );
-
-		Console->Execute(command.c_str());
-	}
+	//	Console->Execute(command.c_str());
+	//}
 }
@@ -566,3 +579,3 @@
 	SetSortFunc			("ping",	false);
-	browser().RefreshList_Full(Local, m_edit_gs_filter.GetText());
+	//browser().RefreshList_Full(Local, m_edit_gs_filter.GetText());
 
@@ -624,9 +636,9 @@
 
-	u32 NumServersFound				= browser().GetServersCount();
-	g_gs_browser					= m_GSBrowser;
-	m_tmp_srv_lst.resize			(NumServersFound);
-
-	
-	for (u32 i=0; i<NumServersFound; i++)
-		m_tmp_srv_lst[i] = i;
+	//u32 NumServersFound				= browser().GetServersCount();
+	//g_gs_browser					= m_GSBrowser;
+	//m_tmp_srv_lst.resize			(NumServersFound);
+
+	//
+	//for (u32 i=0; i<NumServersFound; i++)
+	//	m_tmp_srv_lst[i] = i;
 
@@ -650,9 +662,9 @@
 
-	for (u32 i=0; i<NumServersFound; i++)
-	{
-		ServerInfo							NewServerInfo;
-		browser().GetServerInfoByIndex		(&NewServerInfo, m_tmp_srv_lst[i]);
+	//for (u32 i=0; i<NumServersFound; i++)
+	//{
+	//	ServerInfo							NewServerInfo;
+	//	browser().GetServerInfoByIndex		(&NewServerInfo, m_tmp_srv_lst[i]);
 
-		AddServerToList						(&NewServerInfo);
-	}
+	//	AddServerToList						(&NewServerInfo);
+	//}
 	UpdateSizes();
@@ -666,3 +678,3 @@
 		return;
-	browser().RefreshQuick(pItem->GetInfo()->info.Index);
+	//browser().RefreshQuick(pItem->GetInfo()->info.Index);
 	
@@ -695,19 +708,19 @@
 {
-	m_itemInfo.info.server			= pServerInfo->m_ServerName;
-	xr_string address				= pServerInfo->m_HostName;
-	char							port[8];
-	address							+= "/port=";	
-	address							+= itoa(pServerInfo->m_Port, port, 10);
-	m_itemInfo.info.address			= address.c_str();
-	m_itemInfo.info.map				= pServerInfo->m_SessionName;
-	m_itemInfo.info.game			= GameTypeToString( (EGameIDs)pServerInfo->m_GameType, true);
-	m_itemInfo.info.players.printf	("%d/%d", pServerInfo->m_ServerNumPlayers, pServerInfo->m_ServerMaxPlayers);
-	m_itemInfo.info.ping.printf		("%d", pServerInfo->m_Ping);
-	m_itemInfo.info.version			= pServerInfo->m_ServerVersion;
-	m_itemInfo.info.icons.pass		= pServerInfo->m_bPassword;
-	m_itemInfo.info.icons.dedicated	= pServerInfo->m_bDedicated;
-	m_itemInfo.info.icons.punkbuster= false;//	= pServerInfo->m_bPunkBuster;
-	m_itemInfo.info.icons.user_pass	= pServerInfo->m_bUserPass;
+	//m_itemInfo.info.server			= pServerInfo->m_ServerName;
+	//xr_string address				= pServerInfo->m_HostName;
+	//char							port[8];
+	//address							+= "/port=";	
+	//address							+= itoa(pServerInfo->m_Port, port, 10);
+	//m_itemInfo.info.address			= address.c_str();
+	//m_itemInfo.info.map				= pServerInfo->m_SessionName;
+	//m_itemInfo.info.game			= GameTypeToString( (EGameIDs)pServerInfo->m_GameType, true);
+	//m_itemInfo.info.players.printf	("%d/%d", pServerInfo->m_ServerNumPlayers, pServerInfo->m_ServerMaxPlayers);
+	//m_itemInfo.info.ping.printf		("%d", pServerInfo->m_Ping);
+	//m_itemInfo.info.version			= pServerInfo->m_ServerVersion;
+	//m_itemInfo.info.icons.pass		= pServerInfo->m_bPassword;
+	//m_itemInfo.info.icons.dedicated	= pServerInfo->m_bDedicated;
+	//m_itemInfo.info.icons.punkbuster= false;//	= pServerInfo->m_bPunkBuster;
+	//m_itemInfo.info.icons.user_pass	= pServerInfo->m_bUserPass;
 
-	m_itemInfo.info.Index			= pServerInfo->Index;   
+	//m_itemInfo.info.Index			= pServerInfo->Index;   
 }
@@ -717,10 +730,11 @@
 {
-	CGameSpy_Browser& gs_browser = *g_gs_browser;
-	ServerInfo info1,info2;
+	//CGameSpy_Browser& gs_browser = *g_gs_browser;
+	//ServerInfo info1,info2;
 
-	gs_browser.GetServerInfoByIndex(&info1, p1);
-    gs_browser.GetServerInfoByIndex(&info2, p2);
+	//gs_browser.GetServerInfoByIndex(&info1, p1);
+	//   gs_browser.GetServerInfoByIndex(&info2, p2);
 
-	int res = xr_strcmp(info1.m_ServerName, info2.m_ServerName);
-	return (g_bSort_Ascending) ? (-1 == res) : (1 == res);
+	//int res = xr_strcmp(info1.m_ServerName, info2.m_ServerName);
+	//return (g_bSort_Ascending) ? (-1 == res) : (1 == res);
+	return p1 < p2;
 }
@@ -729,10 +743,11 @@
 {
-	CGameSpy_Browser& gs_browser = *g_gs_browser;
-	ServerInfo info1,info2;
+	//CGameSpy_Browser& gs_browser = *g_gs_browser;
+	//ServerInfo info1,info2;
 
-	gs_browser.GetServerInfoByIndex(&info1, p1);
-    gs_browser.GetServerInfoByIndex(&info2, p2);
+	//gs_browser.GetServerInfoByIndex(&info1, p1);
+	//   gs_browser.GetServerInfoByIndex(&info2, p2);
 
-	int res = xr_strcmp(info1.m_SessionName, info2.m_SessionName);
-	return (g_bSort_Ascending) ? (-1 == res) : (1 == res);
+	//int res = xr_strcmp(info1.m_SessionName, info2.m_SessionName);
+	//return (g_bSort_Ascending) ? (-1 == res) : (1 == res);
+	return p1 < p2;
 }
@@ -741,10 +756,11 @@
 {
-	CGameSpy_Browser& gs_browser = *g_gs_browser;
-	ServerInfo info1,info2;
+	//CGameSpy_Browser& gs_browser = *g_gs_browser;
+	//ServerInfo info1,info2;
 
-	gs_browser.GetServerInfoByIndex(&info1, p1);
-    gs_browser.GetServerInfoByIndex(&info2, p2);
+	//gs_browser.GetServerInfoByIndex(&info1, p1);
+	//   gs_browser.GetServerInfoByIndex(&info2, p2);
 
-	int res = xr_strcmp(info1.m_ServerGameType, info2.m_ServerGameType);
-	return (g_bSort_Ascending) ? (-1 == res) : (1 == res);
+	//int res = xr_strcmp(info1.m_ServerGameType, info2.m_ServerGameType);
+	//return (g_bSort_Ascending) ? (-1 == res) : (1 == res);
+	return p1 < p2;
 }
@@ -753,9 +769,10 @@
 {
-	CGameSpy_Browser& gs_browser = *g_gs_browser;
-	ServerInfo info1,info2;
+	//CGameSpy_Browser& gs_browser = *g_gs_browser;
+	//ServerInfo info1,info2;
 
-	gs_browser.GetServerInfoByIndex(&info1, p1);
-    gs_browser.GetServerInfoByIndex(&info2, p2);
+	//gs_browser.GetServerInfoByIndex(&info1, p1);
+	//   gs_browser.GetServerInfoByIndex(&info2, p2);
 
-	return (g_bSort_Ascending) ? (info1.m_ServerNumPlayers < info2.m_ServerNumPlayers) : (info1.m_ServerNumPlayers > info2.m_ServerNumPlayers);
+	//return (g_bSort_Ascending) ? (info1.m_ServerNumPlayers < info2.m_ServerNumPlayers) : (info1.m_ServerNumPlayers > info2.m_ServerNumPlayers);
+	return p1 < p2;
 }
@@ -764,9 +781,10 @@
 {
-	CGameSpy_Browser& gs_browser = *g_gs_browser;
-	ServerInfo info1,info2;
+	//CGameSpy_Browser& gs_browser = *g_gs_browser;
+	//ServerInfo info1,info2;
 
-	gs_browser.GetServerInfoByIndex(&info1, p1);
-    gs_browser.GetServerInfoByIndex(&info2, p2);
+	//gs_browser.GetServerInfoByIndex(&info1, p1);
+	//   gs_browser.GetServerInfoByIndex(&info2, p2);
 
-	return (g_bSort_Ascending) ? (info1.m_Ping < info2.m_Ping) : (info1.m_Ping > info2.m_Ping);
+	//return (g_bSort_Ascending) ? (info1.m_Ping < info2.m_Ping) : (info1.m_Ping > info2.m_Ping);
+	return p1 < p2;
 }
@@ -775,10 +793,11 @@
 {
-	CGameSpy_Browser& gs_browser = *g_gs_browser;
-	ServerInfo info1,info2;
+	//CGameSpy_Browser& gs_browser = *g_gs_browser;
+	//ServerInfo info1,info2;
 
-	gs_browser.GetServerInfoByIndex(&info1, p1);
-	gs_browser.GetServerInfoByIndex(&info2, p2);
+	//gs_browser.GetServerInfoByIndex(&info1, p1);
+	//gs_browser.GetServerInfoByIndex(&info2, p2);
 
-	int res = xr_strcmp(info1.m_ServerVersion, info2.m_ServerVersion);
-	return (g_bSort_Ascending) ? (-1 == res) : (1 == res);
+	//int res = xr_strcmp(info1.m_ServerVersion, info2.m_ServerVersion);
+	//return (g_bSort_Ascending) ? (-1 == res) : (1 == res);
+	return p1 < p2;
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/ui_af_params.cpp xray-monolith/src/xrGame/ui/ui_af_params.cpp
--- coc-1.4-xray-64/src/xrGame/ui/ui_af_params.cpp	2023-10-20 20:54:51.510326400 +0100
+++ xray-monolith/src/xrGame/ui/ui_af_params.cpp	2023-10-20 20:54:33.407036400 +0100
@@ -301,2 +301,5 @@
 	string32	buf;
+	if (value > -1.f && value < 1.f)
+		xr_sprintf(buf, "%+.3f", value);
+	else
 	xr_sprintf( buf, "%+.0f", value );
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/uiabstract.h xray-monolith/src/xrGame/ui/uiabstract.h
--- coc-1.4-xray-64/src/xrGame/ui/uiabstract.h	2023-10-20 20:54:51.511326400 +0100
+++ xray-monolith/src/xrGame/ui/uiabstract.h	2023-10-20 20:54:33.408036200 +0100
@@ -48,5 +60,11 @@
 	IC const Fvector2&		GetWndSize			()						const				{return m_wndSize;}
-	virtual void			SetWndRect			(const Frect& rect)							{m_wndPos.set(rect.lt); rect.getsize(m_wndSize);}
+
+	virtual void SetWndRect(const Frect& rect)
+	{
+		m_wndPos.set(rect.lt);
+		rect.getsize(m_wndSize);
+	}
 
 	virtual void			SetHeight			(float height)								{m_wndSize.y = height;}
+	virtual bool StopAnyMove() { return true; }
 	IC		float			GetHeight			()						const				{return m_wndSize.y;}
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIActorMenu.cpp xray-monolith/src/xrGame/ui/UIActorMenu.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIActorMenu.cpp	2023-10-20 20:54:51.396328600 +0100
+++ xray-monolith/src/xrGame/ui/UIActorMenu.cpp	2023-10-20 20:54:33.316036300 +0100
@@ -24,2 +24,5 @@
 #include "../eatable_item.h"
+#include "../WeaponBinoculars.h"
+#include "../WeaponKnife.h"
+#include "../WeaponPistol.h"
 
@@ -241,2 +248,3 @@
 	inherited::Update();
+	if (m_ItemInfo->CurrentItem())
 	m_ItemInfo->Update();
@@ -292,7 +300,7 @@
 
-	if(l==m_pInventoryAutomaticList)	return iActorSlot;
-	if(l==m_pInventoryPistolList)		return iActorSlot;
-	if(l==m_pInventoryOutfitList)		return iActorSlot;
-	if(l==m_pInventoryHelmetList)		return iActorSlot;
-	if(l==m_pInventoryDetectorList)		return iActorSlot;
+	for (u8 i = 1; i <= m_slot_count; ++i)
+	{
+		if (m_pInvList[i] && m_pInvList[i] == l)
+			return iActorSlot;
+	}
 	
@@ -367,3 +379,3 @@
 {
-	if ( !cell_item )
+	if (!cell_item || !cell_item->m_pData)
 	{
@@ -393,3 +405,3 @@
 
-		CWeaponAmmo* ammo = smart_cast<CWeaponAmmo*>(current_item);
+		/* CWeaponAmmo* ammo = smart_cast<CWeaponAmmo*>(current_item);
 		if(ammo)
@@ -411,6 +423,12 @@
 			}
-		}
+		} //*/
 
-		if (!current_item->CanTrade() ||	(!m_pPartnerInvOwner->trade_parameters().enabled(CTradeParameters::action_buy(0), current_item->object().cNameSect()) && item_owner && item_owner==m_pActorInvOwner))
+		CEatableItem* eatable_item = current_item->cast_eatable_item();
+		if (!current_item->CanTrade() || (!m_pPartnerInvOwner->trade_parameters().enabled(
+				CTradeParameters::action_buy(0),
+				current_item->object().cNameSect()) && item_owner &&
+			item_owner == m_pActorInvOwner))
 			m_ItemInfo->InitItem	( cell_item, compare_item, u32(-1), "st_no_trade_tip_1" );
+		else if (eatable_item && eatable_item->GetMaxUses())
+			m_ItemInfo->InitItem(cell_item, compare_item, item_price);
 		else if(current_item->GetCondition()<m_pPartnerInvOwner->trade_parameters().buy_item_condition_factor)
@@ -462,7 +480,8 @@
 {
-	m_InvSlot2Highlight->Show(false);
-	m_InvSlot3Highlight->Show(false);
-	m_HelmetSlotHighlight->Show(false);
-	m_OutfitSlotHighlight->Show(false);
-	m_DetectorSlotHighlight->Show(false);
+	for (u8 i = 1; i <= m_slot_count; ++i)
+	{
+		if (m_pInvSlotHighlight[i])
+			m_pInvSlotHighlight[i]->Show(false);
+	}
+
 	for(u8 i=0; i<4; i++)
@@ -503,32 +523,34 @@
 
-	CWeapon* weapon = smart_cast<CWeapon*>(item);
-	CHelmet* helmet = smart_cast<CHelmet*>(item);
-	CCustomOutfit* outfit = smart_cast<CCustomOutfit*>(item);
-	CCustomDetector* detector = smart_cast<CCustomDetector*>(item);
-	CEatableItem* eatable = smart_cast<CEatableItem*>(item);
-	CArtefact* artefact = smart_cast<CArtefact*>(item);
-
 	u16 slot_id = item->BaseSlot();
-
-	if (weapon && (slot_id == INV_SLOT_2 || slot_id == INV_SLOT_3))
+	if (slot_id == INV_SLOT_2 || slot_id == INV_SLOT_3)
 	{
-		m_InvSlot2Highlight->Show(true);
-		m_InvSlot3Highlight->Show(true);
+		if (slot_id == INV_SLOT_2 && m_pInvSlotHighlight[KNIFE_SLOT])
+			m_pInvSlotHighlight[KNIFE_SLOT]->Show(true);
+
+		if (m_pInvSlotHighlight[INV_SLOT_2])
+			m_pInvSlotHighlight[INV_SLOT_2]->Show(true);
+
+		if (m_pInvSlotHighlight[INV_SLOT_3])
+			m_pInvSlotHighlight[INV_SLOT_3]->Show(true);
 		return;
 	}
-	if(helmet && slot_id == HELMET_SLOT)
+
+	if (slot_id == HELMET_SLOT || slot_id == BACKPACK_SLOT)
 	{
-		m_HelmetSlotHighlight->Show(true);
-		return;
-	}
-	if(outfit && slot_id == OUTFIT_SLOT)
+		CCustomOutfit* outfit = Actor()->GetOutfit();
+		if (outfit)
 	{
-		m_OutfitSlotHighlight->Show(true);
+			if (slot_id == HELMET_SLOT && !outfit->bIsHelmetAvaliable || slot_id == BACKPACK_SLOT && !outfit->
+				bIsBackpackAvaliable)
 		return;
 	}
-	if(detector && slot_id == DETECTOR_SLOT)
+	}
+
+	if (m_pInvSlotHighlight[slot_id])
 	{
-		m_DetectorSlotHighlight->Show(true);
+		m_pInvSlotHighlight[slot_id]->Show(true);
 		return;
 	}
+
+	CEatableItem* eatable = smart_cast<CEatableItem*>(item);
 	if(eatable)
@@ -542,2 +564,3 @@
 	}
+	CArtefact* artefact = smart_cast<CArtefact*>(item);
 	if(artefact)
@@ -798,9 +819,10 @@
 	m_pInventoryBagList->ClearAll				(true);
-	
 	m_pInventoryBeltList->ClearAll				(true);
-	m_pInventoryOutfitList->ClearAll			(true);
-	m_pInventoryHelmetList->ClearAll			(true);
-	m_pInventoryDetectorList->ClearAll			(true);
-	m_pInventoryPistolList->ClearAll			(true);
-	m_pInventoryAutomaticList->ClearAll			(true);
+
+	for (u8 i = 1; i <= m_slot_count; ++i)
+	{
+		if (m_pInvList[i])
+			m_pInvList[i]->ClearAll(true);
+	}
+
 	m_pQuickSlot->ClearAll						(true);
@@ -864,11 +885,20 @@
 
-	if(item_slot==INV_SLOT_3 && l==m_pInventoryPistolList)
+	if (item_slot == INV_SLOT_2)
 	{
-		ret_slot	= INV_SLOT_2;
+		if (l == m_pInvList[INV_SLOT_3])
+		{
+			ret_slot = INV_SLOT_3;
+			return true;
+		}
+		if (l == m_pInvList[KNIFE_SLOT])
+		{
+			ret_slot = KNIFE_SLOT;
 		return		true;
 	}
+	}
 
-	if(item_slot==INV_SLOT_2 && l==m_pInventoryAutomaticList)
+	if (item_slot == INV_SLOT_3)
+		if (l == m_pInvList[INV_SLOT_2])
 	{
-		ret_slot	= INV_SLOT_3;
+			ret_slot = INV_SLOT_2;
 		return		true;
@@ -878,29 +908,11 @@
 }
+
 void CUIActorMenu::UpdateConditionProgressBars()
 {
-	PIItem itm = m_pActorInvOwner->inventory().ItemFromSlot(INV_SLOT_2);
-	if(itm)
+	for (u8 i = 1; i <= m_slot_count; ++i)
 	{
-		m_WeaponSlot1_progress->SetProgressPos(iCeil(itm->GetCondition()*15.0f)/15.0f);
+		PIItem itm = m_pActorInvOwner->inventory().ItemFromSlot(i);
+		if (m_pInvSlotProgress[i])
+			m_pInvSlotProgress[i]->SetProgressPos(itm ? iCeil(itm->GetCondition() * 10.f) / 10.f : 0);
 	}
-	else
-		m_WeaponSlot1_progress->SetProgressPos(0);
-
-	itm = m_pActorInvOwner->inventory().ItemFromSlot(INV_SLOT_3);
-	if(itm)
-		m_WeaponSlot2_progress->SetProgressPos(iCeil(itm->GetCondition()*15.0f)/15.0f);
-	else
-		m_WeaponSlot2_progress->SetProgressPos(0);
-
-	itm = m_pActorInvOwner->inventory().ItemFromSlot(OUTFIT_SLOT);
-	if(itm)
-		m_Outfit_progress->SetProgressPos(iCeil(itm->GetCondition()*15.0f)/15.0f);
-	else
-		m_Outfit_progress->SetProgressPos(0);
-
-	itm = m_pActorInvOwner->inventory().ItemFromSlot(HELMET_SLOT);
-	if(itm)
-		m_Helmet_progress->SetProgressPos(iCeil(itm->GetCondition()*15.0f)/15.0f);
-	else
-		m_Helmet_progress->SetProgressPos(0);
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIActorMenu.h xray-monolith/src/xrGame/ui/UIActorMenu.h
--- coc-1.4-xray-64/src/xrGame/ui/UIActorMenu.h	2023-10-20 20:54:51.397327100 +0100
+++ xray-monolith/src/xrGame/ui/UIActorMenu.h	2023-10-20 20:54:33.317035500 +0100
@@ -95,7 +104,2 @@
 	CUIDragDropListEx*			m_pInventoryBeltList;
-	CUIDragDropListEx*			m_pInventoryPistolList;
-	CUIDragDropListEx*			m_pInventoryAutomaticList;
-	CUIDragDropListEx*			m_pInventoryOutfitList;
-	CUIDragDropListEx*			m_pInventoryHelmetList;
-	CUIDragDropListEx*			m_pInventoryDetectorList;
 	CUIDragDropListEx*			m_pInventoryBagList;
@@ -110,10 +114,12 @@
 	enum						{e_af_count = 5};
+
 	CUIStatic*					m_belt_list_over[e_af_count];
 	CUIStatic*					m_HelmetOver;
+	CUIStatic* m_BackpackOver;
+
+	u8 m_slot_count;
+	CUIStatic* m_pInvSlotHighlight[LAST_SLOT + 1];
+	CUIProgressBar* m_pInvSlotProgress[LAST_SLOT + 1];
+	CUIDragDropListEx* m_pInvList[LAST_SLOT + 1];
 
-	CUIStatic*					m_InvSlot2Highlight;
-	CUIStatic*					m_InvSlot3Highlight;
-	CUIStatic*					m_HelmetSlotHighlight;
-	CUIStatic*					m_OutfitSlotHighlight;
-	CUIStatic*					m_DetectorSlotHighlight;
 	CUIStatic*					m_QuickSlotsHighlight[4];
@@ -140,6 +146,2 @@
 	
-	CUIProgressBar*				m_WeaponSlot1_progress;
-	CUIProgressBar*				m_WeaponSlot2_progress;
-	CUIProgressBar*				m_Helmet_progress;
-	CUIProgressBar*				m_Outfit_progress;
 	// bottom ---------------------------------
@@ -171,2 +173,3 @@
 	CUI3tButton*				m_takeall_button;
+	CUI3tButton* m_putall_button;
 	CUI3tButton*				m_exit_button;
@@ -190,2 +193,4 @@
 	CInventoryBox*				GetInvBox					() {return m_pInvBox;};
+	bool b_sort_hotkeys;
+	void SelectInventoryTab(int tab);
 private:
@@ -213,5 +218,13 @@
 	void						InitCallbacks				();
-
+	void FilterActorBagList(int mode);
 	void						InitCellForSlot				(u16 slot_idx);
 	void						InitInventoryContents		(CUIDragDropListEx* pBagList);
+public:
+	//Item Sorting Tabs
+	xr_vector<CUI3tButton*> m_sort_buttons;
+	xr_vector<LPCSTR> m_sort_kinds;
+	int current_sort_mode();
+protected:
+	void xr_stdcall sort_button_callback(CUIWindow* w, void* d);
+
 	void						ClearAllLists				();
@@ -220,3 +233,2 @@
 	EDDListType					GetListType					(CUIDragDropListEx* l);
-	CUIDragDropListEx*			GetListByType				(EDDListType t);
 	CUIDragDropListEx*			GetSlotList					(u16 slot_idx);
@@ -245,2 +257,3 @@
 	void						DeInitUpgradeMode			();
+	void FilterDeadBodyList(int mode);
 	void						InitDeadBodySearchMode		();
@@ -304,2 +317,4 @@
 	void						InitPartnerInventoryContents();
+	void FilterTraderList(int mode);
+	void FilterActorTradeBagList(int mode);
 	void						ColorizeItem				(CUICellItem* itm, bool colorize);
@@ -315,2 +330,4 @@
 
+	CUIDragDropListEx* GetListByType(EDDListType t);
+
 	virtual bool				StopAnyMove					();
@@ -345,2 +362,4 @@
 	void						TakeAllFromInventoryBox		();
+	void xr_stdcall PutAllToPartner(CUIWindow* w, void* d);
+	void PutAllToInventoryBox();
 	void						UpdateConditionProgressBars	();
@@ -355,4 +374,6 @@
 	CScriptGameObject* GetCurrentItemAsGameObject();
+	bool CanRepairItem(PIItem itm);
+	LPCSTR RepairQuestion(PIItem item, bool can_repair);
 	void HighlightSectionInSlot(LPCSTR section, u8 type, u16 slot_id = 0);
-	void HighlightForEachInSlot(luabind::functor<bool> functor, u8 type, u16 slot_id);
+	void HighlightForEachInSlot(const luabind::functor<bool>& functor, u8 type, u16 slot_id);
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIActorMenu_script.cpp xray-monolith/src/xrGame/ui/UIActorMenu_script.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIActorMenu_script.cpp	2023-10-20 20:54:51.399326700 +0100
+++ xray-monolith/src/xrGame/ui/UIActorMenu_script.cpp	2023-10-20 20:54:33.319035600 +0100
@@ -25,2 +25,8 @@
 #include "UIPdaWnd.h"
+#include "UITabControl.h"
+
+#include "UIMainIngameWnd.h"
+#include "UIZoneMap.h"
+#include "UIMotionIcon.h"
+#include "UIHudStatesWnd.h"
 
@@ -38,2 +44,7 @@
 
+CUIMainIngameWnd* GetMainGameMenu()
+{
+	return CurrentGameUI()->UIMainIngameWnd;
+}
+
 u8 GrabMenuMode()
@@ -52,12 +63,7 @@
 
-void CUIActorMenu::TryRepairItem(CUIWindow* w, void* d)
-{
-	PIItem item = get_upgrade_item();
-	if ( !item )
+bool CUIActorMenu::CanRepairItem(PIItem item)
 	{
-		return;
-	}
 	if ( item->GetCondition() > 0.99f )
 	{
-		return;
+		return false;
 	}
@@ -70,3 +76,3 @@
 		if (!allow_repair)
-			return;
+			return false;
 	}
@@ -83,2 +88,9 @@
 
+	return can_repair;
+}
+
+LPCSTR CUIActorMenu::RepairQuestion(PIItem item, bool can_repair)
+{
+	LPCSTR partner = m_pPartnerInvOwner->CharacterInfo().Profile().c_str();
+	LPCSTR item_name = item->m_section_id.c_str();
 	luabind::functor<LPCSTR> funct2;
@@ -88,3 +100,25 @@
 		);
-	LPCSTR question = funct2( item_name, item->GetCondition(), can_repair, partner );
+	LPCSTR question = funct2(item->m_section_id.c_str(), item->GetCondition(), can_repair, partner);
+
+	return question;
+}
+
+void CUIActorMenu::TryRepairItem(CUIWindow* w, void* d)
+{
+	PIItem item = get_upgrade_item();
+	if (!item)
+	{
+		return;
+	}
+
+	LPCSTR item_name = item->m_section_id.c_str();
+
+	bool can_repair = CanRepairItem(item);
+
+	luabind::functor<bool> funct;
+	R_ASSERT2(
+		ai().script_engine().functor("inventory_upgrades.can_afford_repair_item", funct),
+		make_string("Failed to get functor <inventory_upgrades.can_afford_repair_item>, item = %s", item_name)
+	);
+	bool enough_money = funct(item_name, item->GetCondition());
 
@@ -92,7 +126,10 @@
 	{
+		if (enough_money)
+		{
 		m_repair_mode = true;
-		CallMessageBoxYesNo( question );
+			CallMessageBoxYesNo(RepairQuestion(item, true));
 	} 
 	else
-		CallMessageBoxOK( question );
+			CallMessageBoxOK(RepairQuestion(item, true));
+	}
 }
@@ -199,3 +236,3 @@
 
-void CUIActorMenu::HighlightForEachInSlot(luabind::functor<bool> functor, u8 type, u16 slot_id)
+void CUIActorMenu::HighlightForEachInSlot(const luabind::functor<bool>& functor, u8 type, u16 slot_id)
 {
@@ -297,2 +334,58 @@
 				.def("GetActiveSection", &CUIPdaWnd::GetActiveSection)
+		.def("GetTabControl", &CUIPdaWnd::GetTabControl),
+
+		class_<CUIMainIngameWnd, CUIWindow>("CUIMainIngameWnd")
+		.def(constructor<>())
+		.def_readonly("UIStaticDiskIO", &CUIMainIngameWnd::UIStaticDiskIO)
+		.def_readonly("UIStaticQuickHelp", &CUIMainIngameWnd::UIStaticQuickHelp)
+		.def_readonly("UIMotionIcon", &CUIMainIngameWnd::UIMotionIcon)
+		.def_readonly("UIZoneMap", &CUIMainIngameWnd::UIZoneMap)
+		.def_readonly("m_ui_hud_states", &CUIMainIngameWnd::m_ui_hud_states)
+		.def_readonly("m_ind_bleeding", &CUIMainIngameWnd::m_ind_bleeding)
+		.def_readonly("m_ind_radiation", &CUIMainIngameWnd::m_ind_radiation)
+		.def_readonly("m_ind_starvation", &CUIMainIngameWnd::m_ind_starvation)
+		.def_readonly("m_ind_weapon_broken", &CUIMainIngameWnd::m_ind_weapon_broken)
+		.def_readonly("m_ind_helmet_broken", &CUIMainIngameWnd::m_ind_helmet_broken)
+		.def_readonly("m_ind_outfit_broken", &CUIMainIngameWnd::m_ind_outfit_broken)
+		.def_readonly("m_ind_overweight", &CUIMainIngameWnd::m_ind_overweight)
+		.def_readonly("m_ind_boost_psy", &CUIMainIngameWnd::m_ind_boost_psy)
+		.def_readonly("m_ind_boost_radia", &CUIMainIngameWnd::m_ind_boost_radia)
+		.def_readonly("m_ind_boost_chem", &CUIMainIngameWnd::m_ind_boost_chem)
+		.def_readonly("m_ind_boost_wound", &CUIMainIngameWnd::m_ind_boost_wound)
+		.def_readonly("m_ind_boost_weight", &CUIMainIngameWnd::m_ind_boost_weight)
+		.def_readonly("m_ind_boost_health", &CUIMainIngameWnd::m_ind_boost_health)
+		.def_readonly("m_ind_boost_power", &CUIMainIngameWnd::m_ind_boost_power)
+		.def_readonly("m_ind_boost_rad", &CUIMainIngameWnd::m_ind_boost_rad),
+
+		class_<CUIZoneMap>("CUIZoneMap")
+		.def(constructor<>())
+		.def_readwrite("disabled", &CUIZoneMap::disabled)
+		.def_readonly("visible", &CUIZoneMap::visible)
+		.def("MapFrame", &CUIZoneMap::MapFrame)
+		.def("Background", &CUIZoneMap::Background),
+
+		class_<CUIMotionIcon, CUIWindow>("CUIMotionIcon")
+		.def(constructor<>()),
+
+		class_<CUIHudStatesWnd, CUIWindow>("CUIHudStatesWnd")
+		.def(constructor<>())
+		.def_readonly("m_back", &CUIHudStatesWnd::m_back)
+		.def_readonly("m_ui_weapon_ammo_color_active", &CUIHudStatesWnd::m_ui_weapon_ammo_color_active)
+		.def_readonly("m_ui_weapon_ammo_color_inactive", &CUIHudStatesWnd::m_ui_weapon_ammo_color_inactive)
+		.def_readonly("m_ui_weapon_cur_ammo", &CUIHudStatesWnd::m_ui_weapon_cur_ammo)
+		.def_readonly("m_ui_weapon_fmj_ammo", &CUIHudStatesWnd::m_ui_weapon_fmj_ammo)
+		.def_readonly("m_ui_weapon_ap_ammo", &CUIHudStatesWnd::m_ui_weapon_ap_ammo)
+		.def_readonly("m_ui_weapon_third_ammo", &CUIHudStatesWnd::m_ui_weapon_third_ammo)
+		.def_readonly("m_fire_mode", &CUIHudStatesWnd::m_fire_mode)
+		.def_readonly("m_ui_grenade", &CUIHudStatesWnd::m_ui_grenade)
+		.def_readonly("m_ui_weapon_icon", &CUIHudStatesWnd::m_ui_weapon_icon)
+		.def_readonly("m_ui_health_bar", &CUIHudStatesWnd::m_ui_health_bar)
+		.def_readonly("m_ui_stamina_bar", &CUIHudStatesWnd::m_ui_stamina_bar)
+		.def_readonly("m_ui_psy_bar", &CUIHudStatesWnd::m_ui_psy_bar)
+		.def_readonly("m_radia_damage", &CUIHudStatesWnd::m_radia_damage)
+
+		// Tronex
+		.def_readwrite("m_ui_health_bar_show", &CUIHudStatesWnd::m_ui_health_bar_show)
+		.def_readwrite("m_ui_stamina_bar_show", &CUIHudStatesWnd::m_ui_stamina_bar_show)
+		.def_readwrite("m_ui_psy_bar_show", &CUIHudStatesWnd::m_ui_psy_bar_show)
 	];
@@ -303,3 +396,4 @@
 		def("get_actor_menu", &GetActorMenu),
-		def("get_menu_mode", &GrabMenuMode)
+		def("get_menu_mode", &GrabMenuMode),
+		def("get_maingame", &GetMainGameMenu)
 	];
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIActorMenuDeadBodySearch.cpp xray-monolith/src/xrGame/ui/UIActorMenuDeadBodySearch.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIActorMenuDeadBodySearch.cpp	2023-10-20 20:54:51.397327100 +0100
+++ xray-monolith/src/xrGame/ui/UIActorMenuDeadBodySearch.cpp	2023-10-20 20:54:33.317035500 +0100
@@ -51,2 +51,52 @@
 
+void CUIActorMenu::FilterDeadBodyList(int mode)
+{
+	m_pDeadBodyBagList->ClearAll(true);
+
+	TIItemContainer items_list;
+	if (m_pPartnerInvOwner)
+	{
+		m_pPartnerInvOwner->inventory().AddAvailableItems(items_list, false, m_pPartnerInvOwner->is_alive()); //true
+		UpdatePartnerBag();
+	}
+	else
+	{
+		VERIFY(m_pInvBox);
+		m_pInvBox->set_in_use(true);
+		m_pInvBox->AddAvailableItems(items_list);
+	}
+
+	std::sort(items_list.begin(), items_list.end(), InventoryUtilities::GreaterRoomInRuck);
+
+	TIItemContainer::iterator it = items_list.begin();
+	TIItemContainer::iterator it_e = items_list.end();
+	for (; it != it_e; ++it)
+	{
+		PIItem iitm = *it;
+		int kinds = _GetItemCount(m_sort_kinds[mode]);
+
+		if (0 == xr_strcmp(m_sort_kinds[mode], "s_all"))
+		{
+			CUICellItem* itm = create_cell_item(*it);
+			m_pDeadBodyBagList->SetItem(itm);
+		}
+		else
+		{
+			for (int i = 0; i < kinds; i++)
+			{
+				string256 kind;
+				_GetItem(m_sort_kinds[mode], i, kind);
+
+				if (iitm->m_kind != NULL && iitm->m_kind.equal(kind))
+				{
+					CUICellItem* itm = create_cell_item(*it);
+					m_pDeadBodyBagList->SetItem(itm);
+				}
+			}
+		}
+	}
+
+	UpdateDeadBodyBag();
+}
+
 void CUIActorMenu::InitDeadBodySearchMode()
@@ -58,2 +108,3 @@
 	m_takeall_button->Show			(true);
+	m_putall_button->Show(true);
 
@@ -125,2 +176,3 @@
 	m_takeall_button->Show			(false);
+	m_putall_button->Show(false);
 
@@ -189,3 +242,28 @@
 	LPCSTR kg_str = CStringTable().translate( "st_kg" ).c_str();
-	float total	= CalcItemsWeight( m_pDeadBodyBagList );
+	float total = 0.f;
+
+	if (xr_strcmp(m_sort_kinds[current_sort_mode()], "s_all"))
+	{
+		TIItemContainer items_list;
+
+		if (m_pPartnerInvOwner)
+			m_pPartnerInvOwner->inventory().AddAvailableItems(items_list, false, m_pPartnerInvOwner->is_alive());
+		else
+			m_pInvBox->AddAvailableItems(items_list);
+
+		if (!items_list.empty())
+		{
+			TIItemContainer::iterator it = items_list.begin();
+			TIItemContainer::iterator it_e = items_list.end();
+
+			for (; it != it_e; it++)
+			{
+				PIItem itm = *it;
+				total += itm->Weight();
+			}
+		}
+	}
+	else
+		total = CalcItemsWeight(m_pDeadBodyBagList);
+
 	xr_sprintf( buf, "%.1f %s", total, kg_str );
@@ -224,4 +302,5 @@
 		move_item_check( item, m_pPartnerInvOwner, m_pActorInvOwner, false );
-	}//for i
-	m_pDeadBodyBagList->ClearAll( true ); // false
+	}
+
+	m_pDeadBodyBagList->ClearAll(true);
 }
@@ -244,4 +323,58 @@
 		move_item_from_to( m_pInvBox->ID(), actor_id, item->object_id() );
-	}//for i
-	m_pDeadBodyBagList->ClearAll( true ); // false
+	}
+
+	m_pDeadBodyBagList->ClearAll(true);
+}
+
+void CUIActorMenu::PutAllToPartner(CUIWindow* w, void* d)
+{
+	VERIFY(m_pActorInvOwner);
+	if (!m_pPartnerInvOwner)
+	{
+		if (m_pInvBox)
+		{
+			PutAllToInventoryBox();
+		}
+		return;
+	}
+
+	u32 const cnt = m_pInventoryBagList->ItemsCount();
+	for (u32 i = 0; i < cnt; ++i)
+	{
+		CUICellItem* ci = m_pInventoryBagList->GetItemIdx(i);
+		for (u32 j = 0; j < ci->ChildsCount(); ++j)
+		{
+			PIItem j_item = (PIItem)(ci->Child(j)->m_pData);
+			if (j_item->IsQuestItem()) continue;
+			move_item_check(j_item, m_pActorInvOwner, m_pPartnerInvOwner, false);
+		}
+		PIItem item = (PIItem)(ci->m_pData);
+		if (item->IsQuestItem()) continue;
+		move_item_check(item, m_pActorInvOwner, m_pPartnerInvOwner, false);
+	}
+
+	FilterActorBagList(current_sort_mode());
+}
+
+void CUIActorMenu::PutAllToInventoryBox()
+{
+	u16 actor_id = m_pActorInvOwner->object_id();
+
+	u32 const cnt = m_pInventoryBagList->ItemsCount();
+	for (u32 i = 0; i < cnt; ++i)
+	{
+		CUICellItem* ci = m_pInventoryBagList->GetItemIdx(i);
+		for (u32 j = 0; j < ci->ChildsCount(); ++j)
+		{
+			PIItem j_item = (PIItem)(ci->Child(j)->m_pData);
+			if (j_item->IsQuestItem()) continue;
+			move_item_from_to(actor_id, m_pInvBox->ID(), j_item->object_id());
+		}
+
+		PIItem item = (PIItem)(ci->m_pData);
+		if (item->IsQuestItem()) continue;
+		move_item_from_to(actor_id, m_pInvBox->ID(), item->object_id());
+	}
+
+	FilterActorBagList(current_sort_mode());
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIActorMenuInitialize.cpp xray-monolith/src/xrGame/ui/UIActorMenuInitialize.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIActorMenuInitialize.cpp	2023-10-20 20:54:51.397327100 +0100
+++ xray-monolith/src/xrGame/ui/UIActorMenuInitialize.cpp	2023-10-20 20:54:33.317035500 +0100
@@ -96,12 +96,2 @@
 
-	m_InvSlot2Highlight			= UIHelper::CreateStatic(uiXml, "inv_slot2_highlight", this);
-	m_InvSlot2Highlight			->Show(false);
-	m_InvSlot3Highlight			= UIHelper::CreateStatic(uiXml, "inv_slot3_highlight", this);
-	m_InvSlot3Highlight			->Show(false);
-	m_HelmetSlotHighlight		= UIHelper::CreateStatic(uiXml, "helmet_slot_highlight", this);
-	m_HelmetSlotHighlight		->Show(false);
-	m_OutfitSlotHighlight		= UIHelper::CreateStatic(uiXml, "outfit_slot_highlight", this);
-	m_OutfitSlotHighlight		->Show(false);
-	m_DetectorSlotHighlight		= UIHelper::CreateStatic(uiXml, "detector_slot_highlight", this);
-	m_DetectorSlotHighlight		->Show(false);
 	m_QuickSlotsHighlight[0]	= UIHelper::CreateStatic(uiXml, "quick_slot_highlight", this);
@@ -133,7 +123,2 @@
 	m_pInventoryBeltList		= UIHelper::CreateDragDropListEx(uiXml, "dragdrop_belt", this);
-	m_pInventoryOutfitList		= UIHelper::CreateDragDropListEx(uiXml, "dragdrop_outfit", this);
-	m_pInventoryHelmetList		= UIHelper::CreateDragDropListEx(uiXml, "dragdrop_helmet", this);
-	m_pInventoryDetectorList	= UIHelper::CreateDragDropListEx(uiXml, "dragdrop_detector", this);
-	m_pInventoryPistolList		= UIHelper::CreateDragDropListEx(uiXml, "dragdrop_pistol", this);
-	m_pInventoryAutomaticList	= UIHelper::CreateDragDropListEx(uiXml, "dragdrop_automatic", this);
 	m_pTradeActorBagList		= UIHelper::CreateDragDropListEx(uiXml, "dragdrop_actor_trade_bag", this);
@@ -162,2 +147,5 @@
 
+	m_BackpackOver = UIHelper::CreateStatic(uiXml, "backpack_over", this);
+	m_BackpackOver->Show(false);
+
 	m_ActorMoney	= UIHelper::CreateTextWnd(uiXml, "actor_money_static", this);
@@ -169,7 +157,2 @@
 
-	m_WeaponSlot1_progress	= UIHelper::CreateProgressBar(uiXml, "progess_bar_weapon1", this);
-	m_WeaponSlot2_progress	= UIHelper::CreateProgressBar(uiXml, "progess_bar_weapon2", this);
-	m_Helmet_progress		= UIHelper::CreateProgressBar(uiXml, "progess_bar_helmet", this);
-	m_Outfit_progress		= UIHelper::CreateProgressBar(uiXml, "progess_bar_outfit", this);
-
 	m_trade_buy_button	= UIHelper::Create3tButton(uiXml, "trade_buy_button", this);
@@ -177,12 +160,51 @@
 	m_takeall_button	= UIHelper::Create3tButton(uiXml, "takeall_button", this);
+	m_putall_button = UIHelper::Create3tButton(uiXml, "putall_button", this);
 	m_exit_button		= UIHelper::Create3tButton(uiXml, "exit_button", this);
 
-//	m_clock_value						= UIHelper::CreateStatic(uiXml, "clock_value", this);
+	//Alun: Dynamic UI slots bro
+	for (u8 i = 0; i <= LAST_SLOT; ++i)
+	{
+		m_pInvList[i] = NULL;
+		m_pInvSlotHighlight[i] = NULL;
+		m_pInvSlotProgress[i] = NULL;
+	}
+
+	XML_NODE* stored_root = uiXml.GetLocalRoot();
+	XML_NODE* node = uiXml.NavigateToNode("inventory_slot_wnd", 0);
+	uiXml.SetLocalRoot(node);
+
+	m_slot_count = (u8)uiXml.GetNodesNum(node, "slot");
+	for (u8 i = 1; i <= m_slot_count; ++i)
+	{
+		uiXml.SetLocalRoot(node);
+		XML_NODE* slot_node = uiXml.NavigateToNode("slot", i - 1);
+		uiXml.SetLocalRoot(slot_node);
+
+		if (uiXml.GetNodesNum(slot_node, "slot_dragdrop") == 0)
+			continue;
+
+		m_pInvList[i] = xr_new<CUIDragDropListEx>();
+		AttachChild(m_pInvList[i]);
+		CUIXmlInit::InitDragDropListEx(uiXml, "slot_dragdrop", 0, m_pInvList[i]);
+		m_pInvList[i]->SetAutoDelete(true);
+
+		BindDragDropListEvents(m_pInvList[i]);
+
+		m_pInvSlotHighlight[i] = xr_new<CUIStatic>();
+		AttachChild(m_pInvSlotHighlight[i]);
+		CUIXmlInit::InitStatic(uiXml, "slot_highlight", 0, m_pInvSlotHighlight[i]);
+		m_pInvSlotHighlight[i]->SetAutoDelete(true);
+		m_pInvSlotHighlight[i]->Show(false);
+
+		if (uiXml.GetNodesNum(slot_node, "slot_progress") == 0)
+			continue;
+
+		m_pInvSlotProgress[i] = xr_new<CUIProgressBar>();
+		AttachChild(m_pInvSlotProgress[i]);
+		CUIXmlInit::InitProgressBar(uiXml, "slot_progress", 0, m_pInvSlotProgress[i]);
+		m_pInvSlotProgress[i]->SetAutoDelete(true);
+	}
+	uiXml.SetLocalRoot(stored_root);
+	//-Alun
 
-/*
-	m_pDeadBodyBagList					= xr_new<CUIDragDropListEx>(); 
-	AttachChild							(m_pDeadBodyBagList);
-	m_pDeadBodyBagList->SetAutoDelete	(true);
-	xml_init.InitDragDropListEx			(uiXml, "dragdrop_deadbody_bag", 0, m_pDeadBodyBagList);
-*/
 	m_ActorStateInfo					= xr_new<ui_actor_state_wnd>();
@@ -192,3 +214,4 @@
 
-	XML_NODE* stored_root				= uiXml.GetLocalRoot	();
+	/*XML_NODE**/
+	stored_root = uiXml.GetLocalRoot();
 	uiXml.SetLocalRoot					(uiXml.NavigateToNode	("action_sounds",0));
@@ -236,2 +259,20 @@
 
+	b_sort_hotkeys = pSettings->r_bool("button_sort_settings", "hotkeys");
+	u16 buttons = pSettings->r_u16("button_sort_settings", "button_amount");
+
+	for (u16 i = 1; i <= buttons; i++)
+	{
+		xr_string buttonName = "button_sort_tab_";
+		buttonName.append(std::to_string(i).c_str());
+
+		CUI3tButton* newbutton = UIHelper::Create3tButton(uiXml, buttonName.c_str(), this);
+		m_sort_buttons.push_back(newbutton);
+		Register(m_sort_buttons.back());
+
+		AddCallback(m_sort_buttons.back(), BUTTON_CLICKED,
+			CUIWndCallback::void_function(this, &CUIActorMenu::sort_button_callback));
+
+		m_sort_kinds.push_back(pSettings->r_string(buttonName.c_str(), "kinds"));
+	}
+
 	InitCallbacks						();
@@ -239,7 +280,2 @@
 	BindDragDropListEvents				(m_pInventoryBeltList);		
-	BindDragDropListEvents				(m_pInventoryPistolList);		
-	BindDragDropListEvents				(m_pInventoryAutomaticList);	
-	BindDragDropListEvents				(m_pInventoryOutfitList);	
-	BindDragDropListEvents				(m_pInventoryHelmetList);	
-	BindDragDropListEvents				(m_pInventoryDetectorList);	
 	BindDragDropListEvents				(m_pInventoryBagList);
@@ -328,2 +364,3 @@
 	Register						(m_takeall_button);
+	Register(m_putall_button);
 	Register						(m_exit_button);
@@ -333,8 +370,15 @@
 
-	AddCallback(m_trade_buy_button,BUTTON_CLICKED,   CUIWndCallback::void_function(this, &CUIActorMenu::OnBtnPerformTradeBuy));
-	AddCallback(m_trade_sell_button,BUTTON_CLICKED,   CUIWndCallback::void_function(this, &CUIActorMenu::OnBtnPerformTradeSell));
-	AddCallback(m_takeall_button,  BUTTON_CLICKED,   CUIWndCallback::void_function(this, &CUIActorMenu::TakeAllFromPartner));
+	AddCallback(m_trade_buy_button, BUTTON_CLICKED,
+	            CUIWndCallback::void_function(this, &CUIActorMenu::OnBtnPerformTradeBuy));
+	AddCallback(m_trade_sell_button, BUTTON_CLICKED,
+	            CUIWndCallback::void_function(this, &CUIActorMenu::OnBtnPerformTradeSell));
+	AddCallback(m_takeall_button, BUTTON_CLICKED,
+	            CUIWndCallback::void_function(this, &CUIActorMenu::TakeAllFromPartner)); 
+	AddCallback(m_putall_button, BUTTON_CLICKED,
+				CUIWndCallback::void_function(this, &CUIActorMenu::PutAllToPartner));
 	AddCallback(m_exit_button,     BUTTON_CLICKED,   CUIWndCallback::void_function(this, &CUIActorMenu::OnBtnExitClicked));
-	AddCallback(m_UIPropertiesBox, PROPERTY_CLICKED, CUIWndCallback::void_function(this, &CUIActorMenu::ProcessPropertiesBoxClicked));
-	AddCallback(m_pUpgradeWnd->m_btn_repair, BUTTON_CLICKED,   CUIWndCallback::void_function(this, &CUIActorMenu::TryRepairItem));
+	AddCallback(m_UIPropertiesBox, PROPERTY_CLICKED,
+	            CUIWndCallback::void_function(this, &CUIActorMenu::ProcessPropertiesBoxClicked));
+	AddCallback(m_pUpgradeWnd->m_btn_repair, BUTTON_CLICKED,
+	            CUIWndCallback::void_function(this, &CUIActorMenu::TryRepairItem));
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIActorMenuInventory.cpp xray-monolith/src/xrGame/ui/UIActorMenuInventory.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIActorMenuInventory.cpp	2023-10-20 20:54:51.398326500 +0100
+++ xray-monolith/src/xrGame/ui/UIActorMenuInventory.cpp	2023-10-20 20:54:33.318036200 +0100
@@ -35,3 +35,3 @@
 #include "../PDA.h"
-
+#include "../ActorBackpack.h"
 #include "../actor_defs.h"
@@ -46,7 +46,9 @@
 	m_pInventoryBeltList->Show			(true);
-	m_pInventoryOutfitList->Show		(true);
-	m_pInventoryHelmetList->Show		(true);
-	m_pInventoryDetectorList->Show		(true);
-	m_pInventoryPistolList->Show		(true);
-	m_pInventoryAutomaticList->Show		(true);
+
+	for (u8 i = 1; i <= m_slot_count; ++i)
+	{
+		if (m_pInvList[i])
+			m_pInvList[i]->Show(true);
+	}
+
 	m_pQuickSlot->Show					(true);
@@ -239,7 +243,2 @@
 		m_pInventoryBeltList,
-		m_pInventoryPistolList,
-		m_pInventoryAutomaticList,
-		m_pInventoryOutfitList,
-		m_pInventoryHelmetList,
-		m_pInventoryDetectorList,
 		m_pInventoryBagList,
@@ -290,9 +288,5 @@
 						if ( lst_to_add != curr )
-						{
 							RemoveItemFromList(curr, pItem);
-						}
 						else
-						{
 							b_already = true;
-						}
 						//break;
@@ -301,2 +295,19 @@
 				}
+
+			for (u8 i = 1; i <= m_slot_count; ++i)
+			{
+				CUIDragDropListEx* curr = m_pInvList[i];
+				if (curr)
+				{
+					CUICellItem* ci = NULL;
+					if (FindItemInList(curr, pItem, ci))
+					{
+						if (lst_to_add != curr)
+							RemoveItemFromList(curr, pItem);
+						else
+							b_already = true;
+					}
+				}
+			}
+
 				CUICellItem*		ci   = NULL;
@@ -309,2 +320,19 @@
 					{
+					int mode = current_sort_mode();
+					int kinds = _GetItemCount(m_sort_kinds[mode]);
+
+					if (0 == xr_strcmp(m_sort_kinds[mode], "s_all"))
+					{
+						CUICellItem* itm = create_cell_item(pItem);
+						lst_to_add->SetItem(itm);
+					}
+					else
+					{
+						for (int i = 0; i < kinds; i++)
+						{
+							string256 kind;
+							_GetItem(m_sort_kinds[mode], i, kind);
+
+							if (pItem->m_kind != NULL && pItem->m_kind.equal(kind))
+							{
 						CUICellItem* itm	= create_cell_item(pItem);
@@ -313,5 +341,9 @@
 				}
+					}
+				}
+			}
 				if(m_pActorInvOwner)
 					m_pQuickSlot->ReloadReferences(m_pActorInvOwner);
-			}break;
+		}
+		break;
 		case GE_TRADE_SELL :
@@ -343,5 +376,16 @@
 				}
+
+			for (u8 i = 1; i <= m_slot_count; ++i)
+			{
+				CUIDragDropListEx* curr = m_pInvList[i];
+				if (curr)
+				{
+					if (RemoveItemFromList(curr, pItem))
+						break;
+				}
+			}
 				if(m_pActorInvOwner)
 					m_pQuickSlot->ReloadReferences(m_pActorInvOwner);
-			}break;
+		}
+		break;
 	}
@@ -390,10 +435,10 @@
 {
-	//VERIFY( KNIFE_SLOT <= slot_idx && slot_idx <= LAST_SLOT );
 	PIItem item	= m_pActorInvOwner->inventory().ItemFromSlot(slot_idx);
 	if ( !item )
-	{
 		return;
-	}
 
 	CUIDragDropListEx* curr_list	= GetSlotList( slot_idx );
+	if (!curr_list)
+		return;
+
 	CUICellItem* cell_item			= create_cell_item( item );
@@ -402,10 +447,2 @@
 		ColorizeItem( cell_item, !CanMoveToPartner( item ) );
-
-	//CCustomOutfit* outfit = smart_cast<CCustomOutfit*>(item);
-	//if(outfit)
-	//	outfit->ReloadBonesProtection();
-
-	//CHelmet* helmet = smart_cast<CHelmet*>(item);
-	//if(helmet)
-	//	helmet->ReloadBonesProtection();
 }
@@ -421,28 +458,12 @@
 	//Slots
-	InitCellForSlot				(INV_SLOT_2);
-	InitCellForSlot				(INV_SLOT_3);
-	InitCellForSlot				(OUTFIT_SLOT);
-	InitCellForSlot				(DETECTOR_SLOT);
-	InitCellForSlot				(GRENADE_SLOT);
-	InitCellForSlot				(HELMET_SLOT);
-
-	//Alundaio
-	if (!m_pActorInvOwner->inventory().SlotIsPersistent(KNIFE_SLOT))
-		InitCellForSlot(KNIFE_SLOT);
-	if (!m_pActorInvOwner->inventory().SlotIsPersistent(BINOCULAR_SLOT))
-		InitCellForSlot(BINOCULAR_SLOT);
-	if (!m_pActorInvOwner->inventory().SlotIsPersistent(ARTEFACT_SLOT))
-		InitCellForSlot(ARTEFACT_SLOT);
-	if (!m_pActorInvOwner->inventory().SlotIsPersistent(PDA_SLOT))
-		InitCellForSlot(PDA_SLOT);
-	//if (!m_pActorInvOwner->inventory().SlotIsPersistent(TORCH_SLOT)) //Alundaio: TODO find out why this crash when you unequip
-	//	InitCellForSlot(TORCH_SLOT);
-	
-	//for custom slots that exist past LAST_SLOT
-	for (u16 i = LAST_SLOT+1; i <= m_pActorInvOwner->inventory().LastSlot(); ++i)
+	for (u8 i = 1; i <= m_slot_count; ++i)
+	{
+		if (m_pInvList[i])
+			InitCellForSlot(i);
+		else
 	{
-		if (!m_pActorInvOwner->inventory().SlotIsPersistent(i))
+			if (i != BOLT_SLOT && i != PDA_SLOT && !m_pActorInvOwner->inventory().SlotIsPersistent(i))
 			InitCellForSlot(i);
 	}
-	//-Alundaio
+	}
 
@@ -477,10 +499,10 @@
 			ColorizeItem(itm, !CanMoveToPartner(*itb));
+	}
 
-		//CCustomOutfit* outfit = smart_cast<CCustomOutfit*>(*itb);
-		//if(outfit)
-		//	outfit->ReloadBonesProtection();
-
-		//CHelmet* helmet = smart_cast<CHelmet*>(*itb);
-		//if(helmet)
-		//	helmet->ReloadBonesProtection();
+	for (int i = 0; i < m_sort_kinds.size(); i++)
+	{
+		if (0 == xr_strcmp(m_sort_kinds[i], "s_all"))
+			m_sort_buttons.at(i)->Enable(false);
+		else
+			m_sort_buttons.at(i)->Enable(true);
 	}
@@ -489,2 +512,111 @@
 
+#include "ui\UI3tButton.h"
+
+void CUIActorMenu::FilterActorBagList(int mode)
+{
+	m_pInventoryBagList->ClearAll(true);
+
+	CUIDragDropListEx* templist = NULL;
+
+	TIItemContainer ruck_list;
+	ruck_list = m_pActorInvOwner->inventory().m_ruck;
+	std::sort(ruck_list.begin(), ruck_list.end(), InventoryUtilities::GreaterRoomInRuck);
+
+	TIItemContainer::iterator itb = ruck_list.begin();
+	TIItemContainer::iterator ite = ruck_list.end();
+	for (; itb != ite; ++itb)
+	{
+		CMPPlayersBag* bag = smart_cast<CMPPlayersBag*>(&(*itb)->object());
+		if (bag)
+			continue;
+
+		PIItem iitm = *itb;
+		int kinds = _GetItemCount(m_sort_kinds[mode]);
+
+		if (0 == xr_strcmp(m_sort_kinds[mode], "s_all"))
+		{
+			CUICellItem* itm = create_cell_item(iitm);
+			m_pInventoryBagList->SetItem(itm);
+			if (m_currMenuMode == mmTrade && m_pPartnerInvOwner)
+				ColorizeItem(itm, !CanMoveToPartner(iitm));
+		}
+		else
+		{
+			for (int i = 0; i < kinds; i++)
+			{
+				string256 kind;
+				_GetItem(m_sort_kinds[mode], i, kind);
+
+				if (iitm->m_kind != NULL && iitm->m_kind.equal(kind))
+				{
+					CUICellItem* itm = create_cell_item(iitm);
+					m_pInventoryBagList->SetItem(itm);
+					if (m_currMenuMode == mmTrade && m_pPartnerInvOwner)
+						ColorizeItem(itm, !CanMoveToPartner(iitm));
+				}
+			}
+		}
+	}
+}
+
+void CUIActorMenu::sort_button_callback(CUIWindow* w, void* d)
+{
+	if (!strstr(w->WindowName().c_str(), "button_sort_tab_"))
+		return;
+
+	xr_string buttonName = w->WindowName().c_str();
+	int buttonNum = atoi(buttonName.substr(16, 99).c_str());
+
+	if (buttonNum > m_sort_buttons.size())
+		return;
+
+	if (!m_sort_buttons.at(buttonNum - 1)->IsEnabled())
+		return;
+
+	SelectInventoryTab(buttonNum - 1);
+}
+
+int CUIActorMenu::current_sort_mode()
+{
+	for (int i = 0; i < m_sort_buttons.size(); i++)
+	{
+		if (!m_sort_buttons.at(i)->IsEnabled())
+		{
+			return i;
+		}
+	}
+}
+
+void CUIActorMenu::SelectInventoryTab(int tab)
+{
+	for (int i = 0; i < m_sort_buttons.size(); i++)
+	{
+		m_sort_buttons.at(i)->Enable(true);
+	}
+
+	m_sort_buttons.at(tab)->Enable(false);
+
+	switch (m_currMenuMode)
+	{
+	case mmInventory:
+	case mmUpgrade:
+	{
+		FilterActorBagList(tab);
+	}
+	break;
+	case mmTrade:
+	{
+		FilterActorTradeBagList(tab);
+		FilterTraderList(tab);
+	}
+	break;
+	case mmDeadBodySearch:
+	{
+		FilterActorBagList(tab);
+		FilterDeadBodyList(tab);
+	}
+	break;
+	}
+}
+
 bool CUIActorMenu::TryActiveSlot(CUICellItem* itm)
@@ -505,6 +637,2 @@
 	}
-	if ( slot == DETECTOR_SLOT )
-	{
-
-	}
 	return false;
@@ -549,2 +677,9 @@
 
+	if (slot_id == BACKPACK_SLOT)
+	{
+		CCustomOutfit* pOutfit = m_pActorInvOwner->GetOutfit();
+		if (pOutfit && !pOutfit->bIsBackpackAvaliable)
+			return false;
+	}
+
 	if(m_pActorInvOwner->inventory().CanPutInSlot(iitem, slot_id))
@@ -552,4 +687,2 @@
 		CUIDragDropListEx* new_owner		= GetSlotList(slot_id);
-
-		//Alundaio
 		if (!new_owner)
@@ -557,8 +690,3 @@
 		
-		/*
-		if ( slot_id == GRENADE_SLOT || !new_owner )
-		{
-			return true; //fake, sorry (((
-		} 
-		else*/ if(slot_id==OUTFIT_SLOT)
+		if (slot_id == OUTFIT_SLOT)
 		{
@@ -568,3 +696,3 @@
 				CUIDragDropListEx* helmet_list		= GetSlotList(HELMET_SLOT);
-				if(helmet_list->ItemsCount()==1)
+				if (helmet_list && helmet_list->ItemsCount() == 1)
 				{
@@ -574,2 +702,12 @@
 			}
+
+			if (pOutfit && !pOutfit->bIsBackpackAvaliable)
+			{
+				CUIDragDropListEx* backpack_list = GetSlotList(BACKPACK_SLOT);
+				if (backpack_list && backpack_list->ItemsCount() == 1)
+				{
+					CUICellItem* backpack_cell = backpack_list->GetItemIdx(0);
+					ToBag(backpack_cell, false);
+				}
+			}
 		}
@@ -587,2 +725,5 @@
 
+		if (!new_owner->CanSetItem(i))
+			return ToSlot(i, true, slot_id);
+
 		new_owner->SetItem					(i);
@@ -608,9 +750,26 @@
 
-		if ( slot_id == INV_SLOT_2 && m_pActorInvOwner->inventory().CanPutInSlot(iitem, INV_SLOT_3))
+		if (slot_id == INV_SLOT_2)
+		{
+			if (m_pActorInvOwner->inventory().CanPutInSlot(iitem, INV_SLOT_3) && iitem->BaseSlot() != KNIFE_SLOT)
 			return ToSlot(itm, force_place, INV_SLOT_3);
-
-		if ( slot_id == INV_SLOT_3 && m_pActorInvOwner->inventory().CanPutInSlot(iitem, INV_SLOT_2))
+			if (m_pActorInvOwner->inventory().CanPutInSlot(iitem, KNIFE_SLOT) && iitem->BaseSlot() != INV_SLOT_3)
+				return ToSlot(itm, force_place, KNIFE_SLOT);
+		}
+		else if (slot_id == INV_SLOT_3)
+		{
+			if (m_pActorInvOwner->inventory().CanPutInSlot(iitem, INV_SLOT_2))
 			return ToSlot(itm, force_place, INV_SLOT_2);
+		}
+		// else if (slot_id == KNIFE_SLOT)
+		// {
+		// 	if (m_pActorInvOwner->inventory().CanPutInSlot(iitem, INV_SLOT_2))
+		// 		return ToSlot(itm, force_place, INV_SLOT_2);
+		// }
+
+		CUIDragDropListEx* slot_list;
+		if (CUIDragDropListEx::m_drag_item && CUIDragDropListEx::m_drag_item->BackList())
+			slot_list = CUIDragDropListEx::m_drag_item->BackList();
+		else
+			slot_list = GetSlotList(slot_id);
 
-		CUIDragDropListEx* slot_list		= GetSlotList(slot_id);
 		if (!slot_list)
@@ -620,4 +779,3 @@
 
-		CUIDragDropListEx* invlist = GetListByType(iActorBag);
-		if (invlist != slot_list)
+		if (slot_list != GetListByType(iActorBag))
 		{
@@ -627,6 +785,9 @@
 			CUICellItem* slot_cell = slot_list->GetItemIdx(0);
-			if (!(slot_cell && ((PIItem)slot_cell->m_pData) == _iitem))
+			if (!slot_cell)
 				return false;
 
-			if (ToBag(slot_cell, false) == false)
+			if ((PIItem)slot_cell->m_pData != _iitem)
+				return false;
+
+			if (!ToBag(slot_cell, false))
 				return false;
@@ -657,10 +818,15 @@
 
-		bool result	= ToSlot(itm, false, slot_id);
-		if(b_own_item && result && slot_id==DETECTOR_SLOT)
+		if (b_own_item && slot_id == DETECTOR_SLOT)
+		{
+			if (ToSlot(itm, false, slot_id))
 		{
-			CCustomDetector* det			= smart_cast<CCustomDetector*>(iitem);
-			det->ToggleDetector				(g_player_hud->attached_item(0)!=NULL);
+				CCustomDevice* det = smart_cast<CCustomDevice*>(iitem);
+				if (det)
+					det->ToggleDevice(g_player_hud->attached_item(0) != NULL);
+				return true;
+			}
+			return false;
 		}
 
-		return result;
+		return ToSlot(itm, false, slot_id);
 	}
@@ -689,13 +856,36 @@
 		VERIFY								(result);
-		CUICellItem* i						= old_owner->RemoveItem(itm, (old_owner==new_owner) );
-		if(!i)
+
+		CUICellItem* citm = old_owner->RemoveItem(itm, (old_owner == new_owner));
+		if (!citm)
 			return false;
 
+		if (0 == xr_strcmp(m_sort_kinds[current_sort_mode()], "s_all"))
+		{
 		if(b_use_cursor_pos)
-			new_owner->SetItem				(i,old_owner->GetDragItemPosition());
+				new_owner->SetItem(citm, old_owner->GetDragItemPosition());
 		else
-			new_owner->SetItem				(i);
+				new_owner->SetItem(citm);
 
-		if (!b_already || !b_own_item)
-			SendEvent_Item2Ruck(iitem, m_pActorInvOwner->object_id());
+			if (m_currMenuMode == mmTrade && m_pPartnerInvOwner)
+			{
+				ColorizeItem(itm, !CanMoveToPartner(iitem));
+			}
+		}
+		else
+		{
+			PIItem iitm = (PIItem)citm->m_pData;
+
+			int kinds = _GetItemCount(m_sort_kinds[current_sort_mode()]);
+
+			for (int i = 0; i < kinds; i++)
+			{
+				string256 kind;
+				_GetItem(m_sort_kinds[current_sort_mode()], i, kind);
+
+				if (iitm->m_kind != NULL && iitm->m_kind.equal(kind))
+				{
+					if (b_use_cursor_pos)
+						new_owner->SetItem(citm, old_owner->GetDragItemPosition());
+					else
+						new_owner->SetItem(citm);
 
@@ -705,2 +895,8 @@
 		}
+				}
+			}
+		}
+
+		if (!b_already || !b_own_item)
+			SendEvent_Item2Ruck(iitem, m_pActorInvOwner->object_id());
 		return true;
@@ -797,33 +997,9 @@
 	}
-	switch ( slot_idx )
-	{
-		case INV_SLOT_2:
-			return m_pInventoryPistolList;
-			break;
-
-		case INV_SLOT_3:
-			return m_pInventoryAutomaticList;
-			break;
 
-		case OUTFIT_SLOT:
-			return m_pInventoryOutfitList;
-			break;
-
-		case HELMET_SLOT:
-			return m_pInventoryHelmetList;
-			break;
+	if (m_pInvList[slot_idx])
+		return m_pInvList[slot_idx];
 
-		case DETECTOR_SLOT:
-			return m_pInventoryDetectorList;
-			break;
-
-		default:
 			if ( m_currMenuMode == mmTrade )
-			{
 				return m_pTradeActorBagList;
-			}
 			return m_pInventoryBagList;
-			break;
-	};
-	return NULL;
 }
@@ -852,2 +1028,4 @@
 
+	cell_itm->UpdateConditionProgressBar(); //Alundaio
+
 	u16 recipient = m_pActorInvOwner->object_id();
@@ -872,6 +1050,7 @@
 
+	//Update: Should not be necessary now
 	//Alundaio: Fix deep recursion if placing icon greater then col/row set in actor_menu.xml
-	Ivector2 iWH = iitem->GetInvGridRect().rb;
+	/* 	Ivector2 iWH = iitem->GetInvGridRect().rb;
 	if (iWH.x > 1 || iWH.y > 1)
-		return false;
+			return false; */
 	//Alundaio: END
@@ -882,2 +1061,5 @@
 
+	if (!m_pQuickSlot->CanSetItem(itm))
+		return false;
+
 	m_pQuickSlot->SetItem(create_cell_item(iitem), GetUICursor().GetCursorPosition());
@@ -974,2 +1157,3 @@
 	CHelmet* pHelmet		= smart_cast<CHelmet*>		( item );
+	CBackpack* pBackpack = smart_cast<CBackpack*>(item);
 	CInventory&  inv		= m_pActorInvOwner->inventory();
@@ -980,5 +1164,6 @@
 
-	if (	!pOutfit && !pHelmet &&
+	if (!pOutfit && !pHelmet && !pBackpack &&
 			cur_slot != NO_ACTIVE_SLOT &&
-			!inv.SlotIsPersistent(cur_slot) && m_pActorInvOwner->inventory().ItemFromSlot(cur_slot) != item /*&& inv.CanPutInSlot(item, cur_slot)*/)
+		!inv.SlotIsPersistent(cur_slot) && m_pActorInvOwner->inventory().ItemFromSlot(cur_slot) != item
+			/*&& inv.CanPutInSlot(item, cur_slot)*/)
 	{
@@ -1000,2 +1185,4 @@
 			{
+				if (!pBackpack)
+				{
 				if (m_currMenuMode == mmDeadBodySearch)
@@ -1006,2 +1193,5 @@
 			else
+					m_UIPropertiesBox->AddItem("st_unequip_backpack", NULL, INVENTORY_TO_BAG_ACTION);
+			}
+			else
 				m_UIPropertiesBox->AddItem( "st_undress_helmet",  NULL, INVENTORY_TO_BAG_ACTION );
@@ -1026,2 +1216,8 @@
 	}
+
+	if (pBackpack && !bAlreadyDressed && (!outfit_in_slot || outfit_in_slot->bIsBackpackAvaliable))
+	{
+		m_UIPropertiesBox->AddItem("st_equip_backpack", NULL, INVENTORY_TO_SLOT_ACTION);
+		b_show = true;
+	}
 }
@@ -1284,2 +1482,98 @@
 	}
+
+	//5th Custom Use action
+	functor_name = READ_IF_EXISTS(pSettings, r_string, GO->cNameSect(), "use5_functor", 0);
+	if (functor_name)
+	{
+		luabind::functor<LPCSTR> funct1;
+		if (ai().script_engine().functor(functor_name, funct1))
+		{
+			act_str = funct1(GO->lua_game_object());
+			if (act_str)
+			{
+				m_UIPropertiesBox->AddItem(act_str, NULL, INVENTORY_EAT6_ACTION);
+				b_show = true;
+			}
+		}
+	}
+
+	//6th Custom Use action
+	functor_name = READ_IF_EXISTS(pSettings, r_string, GO->cNameSect(), "use6_functor", 0);
+	if (functor_name)
+	{
+		luabind::functor<LPCSTR> funct1;
+		if (ai().script_engine().functor(functor_name, funct1))
+		{
+			act_str = funct1(GO->lua_game_object());
+			if (act_str)
+			{
+				m_UIPropertiesBox->AddItem(act_str, NULL, INVENTORY_EAT7_ACTION);
+				b_show = true;
+			}
+		}
+	}
+
+	//7th Custom Use action
+	functor_name = READ_IF_EXISTS(pSettings, r_string, GO->cNameSect(), "use7_functor", 0);
+	if (functor_name)
+	{
+		luabind::functor<LPCSTR> funct1;
+		if (ai().script_engine().functor(functor_name, funct1))
+		{
+			act_str = funct1(GO->lua_game_object());
+			if (act_str)
+			{
+				m_UIPropertiesBox->AddItem(act_str, NULL, INVENTORY_EAT8_ACTION);
+				b_show = true;
+			}
+		}
+	}
+
+	//8th Custom Use action
+	functor_name = READ_IF_EXISTS(pSettings, r_string, GO->cNameSect(), "use8_functor", 0);
+	if (functor_name)
+	{
+		luabind::functor<LPCSTR> funct1;
+		if (ai().script_engine().functor(functor_name, funct1))
+		{
+			act_str = funct1(GO->lua_game_object());
+			if (act_str)
+			{
+				m_UIPropertiesBox->AddItem(act_str, NULL, INVENTORY_EAT9_ACTION);
+				b_show = true;
+			}
+		}
+	}
+
+	//9th Custom Use action
+	functor_name = READ_IF_EXISTS(pSettings, r_string, GO->cNameSect(), "use9_functor", 0);
+	if (functor_name)
+	{
+		luabind::functor<LPCSTR> funct1;
+		if (ai().script_engine().functor(functor_name, funct1))
+		{
+			act_str = funct1(GO->lua_game_object());
+			if (act_str)
+			{
+				m_UIPropertiesBox->AddItem(act_str, NULL, INVENTORY_EAT10_ACTION);
+				b_show = true;
+			}
+		}
+	}
+
+	//10th Custom Use action
+	functor_name = READ_IF_EXISTS(pSettings, r_string, GO->cNameSect(), "use10_functor", 0);
+	if (functor_name)
+	{
+		luabind::functor<LPCSTR> funct1;
+		if (ai().script_engine().functor(functor_name, funct1))
+		{
+			act_str = funct1(GO->lua_game_object());
+			if (act_str)
+			{
+				m_UIPropertiesBox->AddItem(act_str, NULL, INVENTORY_EAT11_ACTION);
+				b_show = true;
+			}
+		}
+	}
 }
@@ -1418,2 +1716,92 @@
 	}
+	case INVENTORY_EAT6_ACTION:
+		{
+			CGameObject* GO = smart_cast<CGameObject*>(item);
+			LPCSTR functor_name = READ_IF_EXISTS(pSettings, r_string, GO->cNameSect(), "use5_action_functor", 0);
+			if (functor_name)
+			{
+				luabind::functor<bool> funct5;
+				if (ai().script_engine().functor(functor_name, funct5))
+				{
+					if (funct5(GO->lua_game_object()))
+						TryUseItem(cell_item);
+				}
+			}
+			break;
+		}
+	case INVENTORY_EAT7_ACTION:
+		{
+			CGameObject* GO = smart_cast<CGameObject*>(item);
+			LPCSTR functor_name = READ_IF_EXISTS(pSettings, r_string, GO->cNameSect(), "use6_action_functor", 0);
+			if (functor_name)
+			{
+				luabind::functor<bool> funct6;
+				if (ai().script_engine().functor(functor_name, funct6))
+				{
+					if (funct6(GO->lua_game_object()))
+						TryUseItem(cell_item);
+				}
+			}
+			break;
+		}
+	case INVENTORY_EAT8_ACTION:
+		{
+			CGameObject* GO = smart_cast<CGameObject*>(item);
+			LPCSTR functor_name = READ_IF_EXISTS(pSettings, r_string, GO->cNameSect(), "use7_action_functor", 0);
+			if (functor_name)
+			{
+				luabind::functor<bool> funct7;
+				if (ai().script_engine().functor(functor_name, funct7))
+				{
+					if (funct7(GO->lua_game_object()))
+						TryUseItem(cell_item);
+				}
+			}
+			break;
+		}
+	case INVENTORY_EAT9_ACTION:
+		{
+			CGameObject* GO = smart_cast<CGameObject*>(item);
+			LPCSTR functor_name = READ_IF_EXISTS(pSettings, r_string, GO->cNameSect(), "use8_action_functor", 0);
+			if (functor_name)
+			{
+				luabind::functor<bool> funct8;
+				if (ai().script_engine().functor(functor_name, funct8))
+				{
+					if (funct8(GO->lua_game_object()))
+						TryUseItem(cell_item);
+				}
+			}
+			break;
+		}
+	case INVENTORY_EAT10_ACTION:
+		{
+			CGameObject* GO = smart_cast<CGameObject*>(item);
+			LPCSTR functor_name = READ_IF_EXISTS(pSettings, r_string, GO->cNameSect(), "use9_action_functor", 0);
+			if (functor_name)
+			{
+				luabind::functor<bool> funct9;
+				if (ai().script_engine().functor(functor_name, funct9))
+				{
+					if (funct9(GO->lua_game_object()))
+						TryUseItem(cell_item);
+				}
+			}
+			break;
+		}
+	case INVENTORY_EAT11_ACTION:
+		{
+			CGameObject* GO = smart_cast<CGameObject*>(item);
+			LPCSTR functor_name = READ_IF_EXISTS(pSettings, r_string, GO->cNameSect(), "use10_action_functor", 0);
+			if (functor_name)
+			{
+				luabind::functor<bool> funct10;
+				if (ai().script_engine().functor(functor_name, funct10))
+				{
+					if (funct10(GO->lua_game_object()))
+						TryUseItem(cell_item);
+				}
+			}
+			break;
+		}
 	case INVENTORY_DROP_ACTION:
@@ -1551,2 +1939,7 @@
 
+	if (outfit && !outfit->bIsBackpackAvaliable)
+		m_BackpackOver->Show(true);
+	else
+		m_BackpackOver->Show(false);
+
 	if ( !outfit )
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIActorMenuTrade.cpp xray-monolith/src/xrGame/ui/UIActorMenuTrade.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIActorMenuTrade.cpp	2023-10-20 20:54:51.398326500 +0100
+++ xray-monolith/src/xrGame/ui/UIActorMenuTrade.cpp	2023-10-20 20:54:33.318036200 +0100
@@ -26,2 +26,3 @@
 #include "UITalkWnd.h"
+#include "eatable_item.h"
 
@@ -82,2 +84,53 @@
 
+#include "../MPPlayersBag.h"
+
+void CUIActorMenu::FilterActorTradeBagList(int mode)
+{
+	m_pTradeActorBagList->ClearAll(true);
+
+	TIItemContainer ruck_list;
+	ruck_list = m_pActorInvOwner->inventory().m_ruck;
+	std::sort(ruck_list.begin(), ruck_list.end(), InventoryUtilities::GreaterRoomInRuck);
+
+	TIItemContainer::iterator itb = ruck_list.begin();
+	TIItemContainer::iterator ite = ruck_list.end();
+	for (; itb != ite; ++itb)
+	{
+		if (!is_item_in_list(m_pTradeActorList, *itb))
+		{
+			CMPPlayersBag* bag = smart_cast<CMPPlayersBag*>(&(*itb)->object());
+			if (bag)
+				continue;
+
+			PIItem iitm = *itb;
+
+			int kinds = _GetItemCount(m_sort_kinds[mode]);
+
+			if (0 == xr_strcmp(m_sort_kinds[mode], "s_all"))
+			{
+				CUICellItem* itm = create_cell_item(iitm);
+				m_pTradeActorBagList->SetItem(itm);
+				if (m_currMenuMode == mmTrade && m_pPartnerInvOwner)
+					ColorizeItem(itm, !CanMoveToPartner(iitm));
+			}
+			else
+			{
+				for (int i = 0; i < kinds; i++)
+				{
+					string256 kind;
+					_GetItem(m_sort_kinds[mode], i, kind);
+
+					if (iitm->m_kind != NULL && iitm->m_kind.equal(kind))
+					{
+						CUICellItem* itm = create_cell_item(iitm);
+						m_pTradeActorBagList->SetItem(itm);
+						if (m_currMenuMode == mmTrade && m_pPartnerInvOwner)
+							ColorizeItem(itm, !CanMoveToPartner(iitm));
+					}
+				}
+			}
+		}
+	}
+}
+
 void CUIActorMenu::InitPartnerInventoryContents()
@@ -103,2 +156,43 @@
 
+void CUIActorMenu::FilterTraderList(int mode)
+{
+	m_pTradePartnerBagList->ClearAll(true);
+
+	TIItemContainer items_list;
+	m_pPartnerInvOwner->inventory().AddAvailableItems(items_list, true);
+	std::sort(items_list.begin(), items_list.end(), InventoryUtilities::GreaterRoomInRuck);
+
+	TIItemContainer::iterator itb = items_list.begin();
+	TIItemContainer::iterator ite = items_list.end();
+	for (; itb != ite; ++itb)
+	{
+		if (!is_item_in_list(m_pTradePartnerList, *itb))
+		{
+			PIItem iitm = *itb;
+			int kinds = _GetItemCount(m_sort_kinds[mode]);
+
+			if (0 == xr_strcmp(m_sort_kinds[mode], "s_all"))
+			{
+				CUICellItem* itm = create_cell_item(*itb);
+				m_pTradePartnerBagList->SetItem(itm);
+			}
+			else
+			{
+				for (int i = 0; i < kinds; i++)
+				{
+					string256 kind;
+					_GetItem(m_sort_kinds[mode], i, kind);
+
+					if (iitm->m_kind != NULL && iitm->m_kind.equal(kind))
+					{
+						CUICellItem* itm = create_cell_item(*itb);
+						m_pTradePartnerBagList->SetItem(itm);
+					}
+				}
+			}
+		}
+	}
+	m_trade_partner_inventory_state = m_pPartnerInvOwner->inventory().ModifyFrame();
+}
+
 void CUIActorMenu::ColorizeItem(CUICellItem* itm, bool colorize)
@@ -242,11 +338,35 @@
 		VERIFY							(new_owner==m_pTradePartnerBagList);
-	}else
+	}
+	else
 		new_owner						= m_pTradePartnerBagList;
 	
-	CUICellItem* i						= old_owner->RemoveItem(itm, (old_owner==new_owner) );
+	CUICellItem* citm = old_owner->RemoveItem(itm, (old_owner == new_owner));
 
+	if (0 == xr_strcmp(m_sort_kinds[current_sort_mode()], "s_all"))
+	{
 	if(b_use_cursor_pos)
-		new_owner->SetItem				(i,old_owner->GetDragItemPosition());
+			new_owner->SetItem(citm, old_owner->GetDragItemPosition());
 	else
-		new_owner->SetItem				(i);
+			new_owner->SetItem(citm);
+	}
+	else
+	{
+		PIItem iitm = (PIItem)citm->m_pData;
+
+		int kinds = _GetItemCount(m_sort_kinds[current_sort_mode()]);
+
+		for (int i = 0; i < kinds; i++)
+		{
+			string256 kind;
+			_GetItem(m_sort_kinds[current_sort_mode()], i, kind);
+
+			if (iitm->m_kind != NULL && iitm->m_kind.equal(kind))
+			{
+				if (b_use_cursor_pos)
+					new_owner->SetItem(citm, old_owner->GetDragItemPosition());
+				else
+					new_owner->SetItem(citm);
+			}
+		}
+	}
 	
@@ -302,3 +422,4 @@
 
-	if(pItem->GetCondition()<m_pPartnerInvOwner->trade_parameters().buy_item_condition_factor)
+	bool has_max_uses = pItem->cast_eatable_item() && pItem->cast_eatable_item()->GetMaxUses();
+	if (!has_max_uses && (pItem->GetCondition() < m_pPartnerInvOwner->trade_parameters().buy_item_condition_factor))
 		return false;
@@ -458,2 +585,21 @@
 
+	if (xr_strcmp(m_sort_kinds[current_sort_mode()], "s_all"))
+	{
+		for (int i = 0; i < m_sort_buttons.size(); i++)
+		{
+			if (0 == xr_strcmp(m_sort_kinds[i], "s_all"))
+			{
+				for (int ii = 0; ii < m_sort_buttons.size(); ii++)
+				{
+					m_sort_buttons.at(ii)->Enable(true);
+				}
+
+				m_sort_buttons.at(i)->Enable(false);
+
+				FilterActorTradeBagList(i);
+			}
+				
+		}
+	}
+
 	UpdateItemsPlace				();
@@ -500,2 +648,20 @@
 
+	if (xr_strcmp(m_sort_kinds[current_sort_mode()], "s_all"))
+	{
+		for (int i = 0; i < m_sort_buttons.size(); i++)
+		{
+			if (0 == xr_strcmp(m_sort_kinds[i], "s_all"))
+			{
+				for (int ii = 0; ii < m_sort_buttons.size(); ii++)
+				{
+					m_sort_buttons.at(ii)->Enable(true);
+				}
+
+				m_sort_buttons.at(i)->Enable(false);
+
+				FilterActorTradeBagList(i);
+			}
+		}
+	}
+
 	UpdateItemsPlace				();
@@ -543,2 +710,11 @@
 
+	//Alundaio: 
+	luabind::functor<bool> funct;
+	if (ai().script_engine().functor("actor_menu_inventory.CUIActorMenu_DonateCurrentItem", funct))
+	{
+		if (funct(m_pPartnerInvOwner->cast_game_object()->lua_game_object(), item->object().lua_game_object()) == false)
+			return;
+	}
+	//-Alundaio
+
 	CUICellItem* itm = invlist->RemoveItem(cell_item, false);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIBoosterInfo.cpp xray-monolith/src/xrGame/ui/UIBoosterInfo.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIBoosterInfo.cpp	2023-10-20 20:54:51.401326500 +0100
+++ xray-monolith/src/xrGame/ui/UIBoosterInfo.cpp	2023-10-20 20:54:33.321035500 +0100
@@ -260,6 +260,6 @@
 	string32 buf;
-	if(m_show_sign)
-		xr_sprintf(buf, "%+.0f", value);
+	if (value > -1.f && value < 1.f)
+		xr_sprintf(buf, m_show_sign ? "%+.2f" : "%.2f", value);
 	else
-		xr_sprintf(buf, "%.0f", value);
+		xr_sprintf(buf, m_show_sign ? "%+.0f" : "%.0f", value);
 	
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIButton_script.cpp xray-monolith/src/xrGame/ui/UIButton_script.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIButton_script.cpp	2023-10-20 20:54:51.403326600 +0100
+++ xray-monolith/src/xrGame/ui/UIButton_script.cpp	2023-10-20 20:54:33.323035400 +0100
@@ -49,2 +49,7 @@
 		.def("GetFValue",				&CUITrackBar::GetFValue)
+		.def("SetIValue", &CUITrackBar::SetIValue)
+		.def("SetFValue", &CUITrackBar::SetFValue)
+		.def("SetStep", &CUITrackBar::SetStep)
+		.def("GetInvert", &CUITrackBar::GetInvert)
+		.def("SetInvert", &CUITrackBar::SetInvert)
 		.def("SetOptIBounds",			&CUITrackBar::SetOptIBounds)
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UICDkey.cpp xray-monolith/src/xrGame/ui/UICDkey.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UICDkey.cpp	2023-10-20 20:54:51.405326500 +0100
+++ xray-monolith/src/xrGame/ui/UICDkey.cpp	2023-10-20 20:54:33.324035300 +0100
@@ -9,7 +8,4 @@
 #include "../RegistryFuncs.h"
-#include "../../xrGameSpy/xrGameSpy_MainDefs.h"
 #include "player_name_modifyer.h"
 
-#include "gamespy/GameSpy_GP.h"
-
 #include <dinput.h>
@@ -17,3 +13,3 @@
 
-extern string64	gsCDKey;
+string64 gsCDKey;
 LPCSTR AddHyphens( LPCSTR c );
@@ -214,4 +213,4 @@
 {
-	ReadRegistry_StrValue(REGISTRY_VALUE_GSCDKEY, cdkey);
-	if ( xr_strlen(cdkey) > 64 )
+	//ReadRegistry_StrValue(REGISTRY_VALUE_GSCDKEY, cdkey);
+	//if ( xr_strlen(cdkey) > 64 )
 	{
@@ -223,7 +222,7 @@
 {
-	if ( xr_strlen(cdkey) > 64 )
-	{
-		cdkey[64] = 0;
-	}
-	WriteRegistry_StrValue(REGISTRY_VALUE_GSCDKEY, cdkey);
+	//if ( xr_strlen(cdkey) > 64 )
+	//{
+	//	cdkey[64] = 0;
+	//}
+	//WriteRegistry_StrValue(REGISTRY_VALUE_GSCDKEY, cdkey);
 }
@@ -232,20 +231,20 @@
 {
-	string256	new_name;
-	if (!ReadRegistry_StrValue(REGISTRY_VALUE_USERNAME, name))
+	//string256	new_name;
+	//if (!ReadRegistry_StrValue(REGISTRY_VALUE_USERNAME, name))
 	{
 		name[0] = 0;
-		Msg( "! Player name registry key (%s) not found !", REGISTRY_VALUE_USERNAME );
+		//Msg( "! Player name registry key (%s) not found !", REGISTRY_VALUE_USERNAME );
 		return;
 	}
-	u32 const max_name_length	=	GP_UNIQUENICK_LEN - 1;
-	if ( xr_strlen(name) > max_name_length )
-	{
-		name[max_name_length] = 0;
-	}
-	if ( xr_strlen(name) == 0 )
-	{
-		Msg( "! Player name in registry is empty! (%s)", REGISTRY_VALUE_USERNAME );
-	}
-	modify_player_name(name, new_name);
-	strncpy_s(name, name_size, new_name, max_name_length);
+	//u32 const max_name_length	=	GP_UNIQUENICK_LEN - 1;
+	//if ( xr_strlen(name) > max_name_length )
+	//{
+	//	name[max_name_length] = 0;
+	//}
+	//if ( xr_strlen(name) == 0 )
+	//{
+	//	//Msg( "! Player name in registry is empty! (%s)", REGISTRY_VALUE_USERNAME );
+	//}
+	//modify_player_name(name, new_name);
+	//strncpy_s(name, name_size, new_name, max_name_length);
 }
@@ -254,8 +253,8 @@
 {
-	u32 const max_name_length	=	GP_UNIQUENICK_LEN - 1;
-	if ( xr_strlen(name) > max_name_length )
-	{
-		name[max_name_length] = 0;
-	}
-	WriteRegistry_StrValue(REGISTRY_VALUE_USERNAME, name);
+	//u32 const max_name_length	=	GP_UNIQUENICK_LEN - 1;
+	//if ( xr_strlen(name) > max_name_length )
+	//{
+	//	name[max_name_length] = 0;
+	//}
+	//WriteRegistry_StrValue(REGISTRY_VALUE_USERNAME, name);
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UICellCustomItems.cpp xray-monolith/src/xrGame/ui/UICellCustomItems.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UICellCustomItems.cpp	2023-10-20 20:54:51.407326400 +0100
+++ xray-monolith/src/xrGame/ui/UICellCustomItems.cpp	2023-10-20 20:54:33.326035500 +0100
@@ -6,3 +6,3 @@
 #include "UIProgressBar.h"
-
+#include "UIXmlInit.h"
 #define INV_GRID_WIDTHF			50.0f
@@ -29,2 +25,8 @@
 
+	if (pSettings->line_exist(itm->m_section_id.c_str(), "icons_texture"))
+	{
+		LPCSTR icons_texture = pSettings->r_string(itm->m_section_id.c_str(), "icons_texture");
+		inherited::SetShader(InventoryUtilities::GetCustomIconTextureShader(icons_texture));
+	}
+	else
 	inherited::SetShader							(InventoryUtilities::GetEquipmentIconsShader());
@@ -70,2 +76,10 @@
 	//-Alundaio
+
+	LPCSTR condbar = READ_IF_EXISTS(pSettings, r_string, itm->m_section_id, "condition_bar", NULL);
+	if (condbar)
+	{
+		CUIXml uiXml;
+		uiXml.Load(CONFIG_PATH, UI_PATH, "actor_menu_item.xml");
+		CUIXmlInit::InitProgressBar(uiXml, condbar, 0, m_pConditionState);
+	}
 }
@@ -81,2 +95,3 @@
 
+#include <eatable_item.h>
 
@@ -101,2 +116,7 @@
 	}
+	CEatableItem* eatable_item_1 = object()->cast_eatable_item();
+	CEatableItem* eatable_item_2 = ci->object()->cast_eatable_item();
+	if (eatable_item_1 && eatable_item_2 && ((eatable_item_1->GetRemainingUses() != eatable_item_1->GetMaxUses()) || (
+		eatable_item_2->GetRemainingUses() != eatable_item_2->GetMaxUses())))
+		return false;
 	return true;
@@ -121,2 +141,9 @@
 		s->SetAutoDelete(true);
+
+		if (pSettings->line_exist((*it)->m_name, "icons_texture"))
+		{
+			LPCSTR icons_texture = pSettings->r_string((*it)->m_name, "icons_texture");
+			s->SetShader(InventoryUtilities::GetCustomIconTextureShader(icons_texture));
+		}
+		else
 		s->SetShader(InventoryUtilities::GetEquipmentIconsShader());
@@ -185,2 +213,9 @@
 		AttachChild(s);
+
+		if (pSettings->line_exist(section, "icons_texture"))
+		{
+			LPCSTR icons_texture = pSettings->r_string(section, "icons_texture");
+			s->SetShader(InventoryUtilities::GetCustomIconTextureShader(icons_texture));
+		}
+		else
 		s->SetShader(InventoryUtilities::GetEquipmentIconsShader());
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UICellItem.cpp xray-monolith/src/xrGame/ui/UICellItem.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UICellItem.cpp	2023-10-20 20:54:51.407326400 +0100
+++ xray-monolith/src/xrGame/ui/UICellItem.cpp	2023-10-20 20:54:33.326035500 +0100
@@ -55,4 +55,10 @@
 {
-	CUIXml	uiXml;
+	static CUIXml uiXml;
+	static bool is_xml_ready = false;
+
+	if (!is_xml_ready)
+	{
 	uiXml.Load( CONFIG_PATH, UI_PATH, "actor_menu_item.xml" );
+		is_xml_ready = true;
+	}
 	
@@ -226,3 +232,3 @@
 
-					if (max_uses < 8)
+					if (max_uses < 10)
 					{
@@ -235,3 +241,3 @@
 					}
-					else if ( max_uses > 8 )
+					else if (max_uses > 10)
 					{
@@ -241,3 +247,3 @@
 					{
-						cond = (( float )remaining_uses * 0.125f ) - 0.0625f;
+						cond = ((float)remaining_uses * 0.1f) - 0.05f;
 					}
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UICellItem.h xray-monolith/src/xrGame/ui/UICellItem.h
--- coc-1.4-xray-64/src/xrGame/ui/UICellItem.h	2023-10-20 20:54:51.408326500 +0100
+++ xray-monolith/src/xrGame/ui/UICellItem.h	2023-10-20 20:54:33.327035400 +0100
@@ -30,5 +34,3 @@
 	xr_vector<CUICellItem*> m_childs;
-
 	CUIDragDropListEx*		m_pParentList;
-	CUIProgressBar*			m_pConditionState;
 	Ivector2				m_grid_size;
@@ -62,2 +66,4 @@
 
+	CUIProgressBar* m_pConditionState;
+
 	virtual		CUIDragItem* CreateDragItem			();
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UICustomEdit.cpp xray-monolith/src/xrGame/ui/UICustomEdit.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UICustomEdit.cpp	2023-10-20 20:54:51.413326500 +0100
+++ xray-monolith/src/xrGame/ui/UICustomEdit.cpp	2023-10-20 20:54:33.331035300 +0100
@@ -131,2 +131,3 @@
 
+extern int mouse_button_2_key[];
 
@@ -139,2 +140,11 @@
 
+	if (dik == mouse_button_2_key[0] || dik == mouse_button_2_key[1]) // Mouse 1 + 2
+	{
+		if (!m_bCursorOverWindow)
+		{
+			press_commit();
+			return false;
+		}
+	}
+
 	if ( keyboard_action == WINDOW_KEY_PRESSED )
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIDialogWnd.cpp xray-monolith/src/xrGame/ui/UIDialogWnd.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIDialogWnd.cpp	2023-10-20 20:54:51.416326500 +0100
+++ xray-monolith/src/xrGame/ui/UIDialogWnd.cpp	2023-10-20 20:54:33.333035300 +0100
@@ -2,2 +2,3 @@
 #include "uidialogwnd.h"
+#include "UICursor.h"
 
@@ -8,2 +9,5 @@
 	m_bShowMe			= false;
+	m_bAllowMovement = false;
+	m_bNeedCursor = true;
+	m_bNeedCenterCursor = true;
 }
@@ -56,4 +61,4 @@
 {
-	R_ASSERT2(IsShown(), "dialog already hidden");
-	if (GetHolder())
+	//R_ASSERT2(IsShown(), "dialog already hidden");
+	if (IsShown() && GetHolder())
 		GetHolder()->StopDialog	(this);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIDialogWnd.h xray-monolith/src/xrGame/ui/UIDialogWnd.h
--- coc-1.4-xray-64/src/xrGame/ui/UIDialogWnd.h	2023-10-20 20:54:51.416326500 +0100
+++ xray-monolith/src/xrGame/ui/UIDialogWnd.h	2023-10-20 20:54:33.334037300 +0100
@@ -14,2 +14,5 @@
 	bool										m_bWorkInPause;
+	bool m_bAllowMovement;
+	bool m_bNeedCursor;
+	bool m_bNeedCenterCursor;
 				CUIDialogWnd					();
@@ -24,5 +27,8 @@
 			void SetHolder						(CDialogHolder* h)				{m_pParentHolder = h;};
-	virtual bool StopAnyMove					()								{return true;}
-	virtual bool NeedCursor						()const							{return true;}
-	virtual bool NeedCenterCursor				()const							{return true;}
+	void AllowMovement(bool b) { m_bAllowMovement = b; }
+	void AllowCursor(bool b) { m_bNeedCursor = b; }
+	void AllowCenterCursor(bool b) { m_bNeedCenterCursor = b; }
+	virtual bool StopAnyMove() { return !m_bAllowMovement; }
+	virtual bool NeedCursor() const { return m_bNeedCursor; }
+	virtual bool NeedCenterCursor() const { return m_bNeedCenterCursor; }
 	virtual bool WorkInPause					()const							{return m_bWorkInPause;}
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIDragDropListEx.cpp xray-monolith/src/xrGame/ui/UIDragDropListEx.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIDragDropListEx.cpp	2023-10-20 20:54:51.418326700 +0100
+++ xray-monolith/src/xrGame/ui/UIDragDropListEx.cpp	2023-10-20 20:54:33.335035500 +0100
@@ -6,4 +6,6 @@
 #include "UICursor.h"
+#include "../Level.h"
 //Alundaio
 #include "../Inventory.h" 
+#include <dinput.h>
 //-Alundaio
@@ -205,3 +223,13 @@
 
-	if(m_f_item_db_click && m_f_item_db_click(itm) ){
+	if (m_f_item_db_click)
+	{
+		if (Level().IR_GetKeyState(DIK_LCONTROL))
+		{
+			u32 size = itm->ChildsCount();
+			for (u32 j = 0; j < size; j++)
+				m_f_item_db_click(itm);
+		}
+
+		if (m_f_item_db_click(itm))
+		{
 		DestroyDragItem						();
@@ -209,2 +237,3 @@
 	}
+	}
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIDragDropReferenceList.cpp xray-monolith/src/xrGame/ui/UIDragDropReferenceList.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIDragDropReferenceList.cpp	2023-10-20 20:54:51.418326700 +0100
+++ xray-monolith/src/xrGame/ui/UIDragDropReferenceList.cpp	2023-10-20 20:54:33.335035500 +0100
@@ -88,2 +95,9 @@
 	CUIStatic* ref = m_references[cell_pos.x];
+
+	if (pSettings->line_exist(section, "icons_texture"))
+	{
+		LPCSTR icons_texture = pSettings->r_string(section, "icons_texture");
+		ref->SetShader(InventoryUtilities::GetCustomIconTextureShader(icons_texture));
+	}
+	else
 	ref->SetShader(InventoryUtilities::GetEquipmentIconsShader());
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIFrameWindow.cpp xray-monolith/src/xrGame/ui/UIFrameWindow.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIFrameWindow.cpp	2023-10-20 20:54:51.427326700 +0100
+++ xray-monolith/src/xrGame/ui/UIFrameWindow.cpp	2023-10-20 20:54:33.339035600 +0100
@@ -102,3 +103,3 @@
 	back_len.y					= rect.height()-m_tex_rect[fmLT].height()-m_tex_rect[fmRB].height();
-	R_ASSERT					(back_len.x+EPS_L>=0.0f && back_len.y+EPS_L>=0.0f);
+	//R_ASSERT(back_len.x+EPS_L>=0.0f && back_len.y+EPS_L>=0.0f);
 	
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIGameTutorial.cpp xray-monolith/src/xrGame/ui/UIGameTutorial.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIGameTutorial.cpp	2023-10-20 20:54:51.428328500 +0100
+++ xray-monolith/src/xrGame/ui/UIGameTutorial.cpp	2023-10-20 20:54:33.341035400 +0100
@@ -411,5 +417,5 @@
 		}
-		if(CurrentGameUI()->GetPdaMenu().IsShown())
+		if (CurrentGameUI()->TopInputReceiver() && CurrentGameUI()->TopInputReceiver()->IsShown())
 		{
-			CurrentGameUI()->HidePdaMenu();
+			CurrentGameUI()->TopInputReceiver()->OnKeyboardAction(dik, WINDOW_KEY_PRESSED);
 			return;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIGameTutorialSimpleItem.cpp xray-monolith/src/xrGame/ui/UIGameTutorialSimpleItem.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIGameTutorialSimpleItem.cpp	2023-10-20 20:54:51.429326700 +0100
+++ xray-monolith/src/xrGame/ui/UIGameTutorialSimpleItem.cpp	2023-10-20 20:54:33.341035400 +0100
@@ -247,20 +248,19 @@
 	{
-		bool bShowPda			= false;
 		CUIGameSP* ui_game_sp	= smart_cast<CUIGameSP*>(CurrentGameUI());
 
-		if (     !stricmp( m_pda_section, "pda_tasks"       ) ) {ui_game_sp->GetPdaMenu().SetActiveSubdialog("eptTasks");		bShowPda = true;	}
-		else if( !stricmp( m_pda_section, "pda_ranking"     ) ) {ui_game_sp->GetPdaMenu().SetActiveSubdialog("eptRanking");	bShowPda = true;	}
-		else if( !stricmp( m_pda_section, "pda_logs"        ) ) {ui_game_sp->GetPdaMenu().SetActiveSubdialog("eptLogs");		bShowPda = true;	}
-		else if( !stricmp( m_pda_section, "pda_show_second_task_wnd" ) )
+		if (!stricmp(m_pda_section, "pda_tasks"))
 		{
-			ui_game_sp->GetPdaMenu().Show_SecondTaskWnd(true);	bShowPda = true;
+			ui_game_sp->GetPdaMenu().SetActiveSubdialog("eptTasks");
 		}
-		
-		if ( ui_game_sp )
+		else if (!stricmp(m_pda_section, "pda_ranking"))
 		{
-			if ( ( !ui_game_sp->GetPdaMenu().IsShown() &&  bShowPda ) || 
-				(   ui_game_sp->GetPdaMenu().IsShown() && !bShowPda ) )
+			ui_game_sp->GetPdaMenu().SetActiveSubdialog("eptRanking");
+		}
+		else if (!stricmp(m_pda_section, "pda_logs"))
 			{
-				ui_game_sp->GetPdaMenu().HideDialog();
+			ui_game_sp->GetPdaMenu().SetActiveSubdialog("eptLogs");
 			}
+		else if (!stricmp(m_pda_section, "pda_show_second_task_wnd"))
+		{
+			ui_game_sp->GetPdaMenu().Show_SecondTaskWnd(true);
 		}
@@ -288,10 +288,2 @@
 
-	if ( g_pGameLevel )
-	{
-		CUIGameSP* ui_game_sp	= smart_cast<CUIGameSP*>( CurrentGameUI() );
-		if ( ui_game_sp && ui_game_sp->GetPdaMenu().IsShown() )
-		{
-			ui_game_sp->GetPdaMenu().HideDialog();
-		}
-	}
 	inherited::Stop				();
@@ -337,5 +329,18 @@
 	{
-		case 0:dik = MOUSE_1;break;
-		case 1:dik = MOUSE_2;break;
-		case 2:dik = MOUSE_3;break;
+	case 0: dik = MOUSE_1;
+		break;
+	case 1: dik = MOUSE_2;
+		break;
+	case 2: dik = MOUSE_3;
+		break;
+	case 3: dik = MOUSE_4;
+		break;
+	case 4: dik = MOUSE_5;
+		break;
+	case 5: dik = MOUSE_6;
+		break;
+	case 6: dik = MOUSE_7;
+		break;
+	case 7: dik = MOUSE_8;
+		break;
 		default:return;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIHudStatesWnd.cpp xray-monolith/src/xrGame/ui/UIHudStatesWnd.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIHudStatesWnd.cpp	2023-10-20 20:54:51.431326600 +0100
+++ xray-monolith/src/xrGame/ui/UIHudStatesWnd.cpp	2023-10-20 20:54:33.343035600 +0100
@@ -62,2 +61,7 @@
 	}
+
+	for (int i = 0; i < ALife::infl_max_count; ++i)
+	{
+		m_zone_cur_power[i] = 0.f;
+	}
 }
@@ -100,3 +109,7 @@
 	m_ui_health_bar   = UIHelper::CreateProgressBar( xml, "progress_bar_health", this );
+	m_ui_health_bar_show = true;
 	m_ui_stamina_bar  = UIHelper::CreateProgressBar( xml, "progress_bar_stamina", this );
+	m_ui_stamina_bar_show = true;
+	m_ui_psy_bar = UIHelper::CreateProgressBar(xml, "progress_bar_psy", this);
+	m_ui_psy_bar_show = true;
 //	m_back_v          = UIHelper::CreateStatic( xml, "back_v", this );
@@ -244,2 +257,10 @@
 	
+	// Health bar
+	if (m_ui_health_bar_show == false)
+	{
+		if (m_ui_health_bar->IsShown())
+			m_ui_health_bar->Show(false);
+	}
+	else
+	{
 	float cur_health = actor->GetfHealth();
@@ -251,4 +272,16 @@
 	}
+		if (!m_ui_health_bar->IsShown())
+			m_ui_health_bar->Show(true);
+	}
 	
+	// Stamina bar
+	if (m_ui_stamina_bar_show == false)
+	{
+		if (m_ui_stamina_bar->IsShown())
+			m_ui_stamina_bar->Show(false);
+	}
+	else
+	{
 	float cur_stamina = actor->conditions().GetPower();
+		clamp(cur_stamina, 0.0f, 1.0f);
 	m_ui_stamina_bar->SetProgressPos(iCeil(cur_stamina * 100.0f * 35.f) / 35.f);
@@ -258,2 +291,20 @@
 	}
+		if (!m_ui_stamina_bar->IsShown())
+			m_ui_stamina_bar->Show(true);
+	}
+
+	// Psy bar
+	if (m_ui_psy_bar_show == false)
+	{
+		if (m_ui_psy_bar->IsShown())
+			m_ui_psy_bar->Show(false);
+	}
+	else
+	{
+		float cur_psy = actor->conditions().GetPsyBar();
+		clamp(cur_psy, 0.0f, 1.0f);
+		m_ui_psy_bar->SetProgressPos(iCeil(cur_psy * 100.0f * 35.f) / 35.f);
+		if (!m_ui_psy_bar->IsShown())
+			m_ui_psy_bar->Show(true);
+	}
 
@@ -396,2 +447,10 @@
 
+	if (pSettings->line_exist(sect_name, "icons_texture"))
+	{
+		LPCSTR icons_texture = pSettings->r_string(sect_name, "icons_texture");
+		m_ui_weapon_icon->SetShader(InventoryUtilities::GetCustomIconTextureShader(icons_texture));
+	}
+	else
+		m_ui_weapon_icon->SetShader(InventoryUtilities::GetEquipmentIconsShader());
+
 	float h = texture_rect.height() * 0.8f;
@@ -406,5 +465,15 @@
 }
+
 // ------------------------------------------------------------------------------------------------
+#include <script_game_object.h>
+
+static float dwLastFrame;
+
 void CUIHudStatesWnd::UpdateZones()
 {
+	if (Device.dwFrame == dwLastFrame)
+		return;
+
+	dwLastFrame = Device.dwFrame;
+
 	//float actor_radia = m_actor->conditions().GetRadiation() * m_actor_radia_factor;
@@ -478,3 +547,3 @@
 	Fvector posf; 
-	posf.set( Device.vCameraPosition );
+	posf.set(Level().CurrentControlEntity()->Position());
 	Level().hud_zones_list->feel_touch_update( posf, m_zone_feel_radius_max );
@@ -502,3 +571,3 @@
 
-		Fvector P			= Device.vCameraPosition;
+		Fvector P = Level().CurrentControlEntity()->Position();
 		P.y					-= 0.5f;
@@ -541,4 +612,9 @@
 			zone_info.snd_time = 0.0f;
+			luabind::functor<bool> funct;
+			if (ai().script_engine().functor("_G.CZone_Touch", funct))
+			{
+				if (funct(pZone->lua_game_object()))
 			HUD_SOUND_ITEM::PlaySound( zone_type->detect_snds, Fvector().set(0,0,0), NULL, true, false );
 		} 
+		}
 		else
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIHudStatesWnd.h xray-monolith/src/xrGame/ui/UIHudStatesWnd.h
--- coc-1.4-xray-64/src/xrGame/ui/UIHudStatesWnd.h	2023-10-20 20:54:51.431326600 +0100
+++ xray-monolith/src/xrGame/ui/UIHudStatesWnd.h	2023-10-20 20:54:33.344035500 +0100
@@ -23,10 +23,8 @@
 
+public:
 	CUIStatic*			m_back;
-//	CUIStatic*			m_back_v;
-//	CUIStatic*			m_back_over_arrow;
-//	CUIStatic*			m_static_armor;
-
-//	CUIStatic*			m_resist_back[it_max];
 	CUIStatic*			m_indik[it_max];
 
+	u32 m_ui_weapon_ammo_color_active;
+	u32 m_ui_weapon_ammo_color_inactive;
 	CUITextWnd*			m_ui_weapon_cur_ammo;
@@ -43,18 +41,12 @@
 	CUIProgressBar*		m_ui_health_bar;
-//	CUIProgressBar*		m_ui_armor_bar;
 	CUIProgressBar*		m_ui_stamina_bar;
-
-//	CUIProgressShape*	m_progress_self;
+	CUIProgressBar* m_ui_psy_bar;
 	CUIStatic*			m_radia_damage;
-//	UI_Arrow*			m_arrow;
-//	UI_Arrow*			m_arrow_shadow;
-/*	
-	CUIStatic*			m_bleeding_lev1;
-	CUIStatic*			m_bleeding_lev2;
-	CUIStatic*			m_bleeding_lev3;
-	
-	CUIStatic*			m_radiation_lev1;
-	CUIStatic*			m_radiation_lev2;
-	CUIStatic*			m_radiation_lev3;
-*/
+
+	// Tronex
+	bool m_ui_health_bar_show;
+	bool m_ui_stamina_bar_show;
+	bool m_ui_psy_bar_show;
+
+private:
 	float				m_last_health;
@@ -63,3 +55,2 @@
 	float				m_radia_self;
-//	float				m_actor_radia_factor;
 	float				m_radia_hit;
@@ -68,3 +59,2 @@
 	float				m_zone_cur_power[ALife::infl_max_count];
-//--	float				m_zone_max_power[hud_it_max];//<-- CActorCondition
 	float				m_zone_feel_radius[ALife::infl_max_count ];
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIInventoryUpgradeWnd.cpp xray-monolith/src/xrGame/ui/UIInventoryUpgradeWnd.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIInventoryUpgradeWnd.cpp	2023-10-20 20:54:51.434326500 +0100
+++ xray-monolith/src/xrGame/ui/UIInventoryUpgradeWnd.cpp	2023-10-20 20:54:33.346035600 +0100
@@ -38,2 +38,3 @@
 #include "script_game_object.h" //Alundaio
+#include "ActorBackpack.h"
 
@@ -117,3 +118,3 @@
 	}
-	else if(smart_cast<CCustomOutfit*>(item) || smart_cast<CHelmet*>(item))
+	else if (smart_cast<CCustomOutfit*>(item) || smart_cast<CHelmet*>(item) || smart_cast<CBackpack*>(item))
 	{
@@ -222,2 +222,4 @@
 
+#include "UIGameCustom.h"
+
 bool CUIInventoryUpgradeWnd::install_item( CInventoryItem& inv_item, bool can_upgrade )
@@ -226,3 +228,12 @@
 	m_back->DetachAll();
-	m_btn_repair->Enable( (inv_item.GetCondition() < 0.99f) );
+
+	bool can_repair = CurrentGameUI()->GetActorMenu().CanRepairItem(&inv_item);
+	m_btn_repair->Enable(can_repair);
+
+	if (!can_repair)
+	{
+		LPCSTR message = CurrentGameUI()->GetActorMenu().RepairQuestion(&inv_item, false);
+		if (message != nullptr)
+			CurrentGameUI()->GetActorMenu().CallMessageBoxOK(message);
+	}
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIInventoryUtilities.cpp xray-monolith/src/xrGame/ui/UIInventoryUtilities.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIInventoryUtilities.cpp	2023-10-20 20:54:51.435326700 +0100
+++ xray-monolith/src/xrGame/ui/UIInventoryUtilities.cpp	2023-10-20 20:54:33.347035800 +0100
@@ -54,2 +53,5 @@
 ui_shader	*g_tmpWMShader				= NULL;
+
+xr_map<LPCSTR, ui_shader*> g_CustomIconShaders;
+
 static CUIStatic*	GetUIStatic				();
@@ -89,2 +91,4 @@
 	g_tmpWMShader = 0;
+
+	delete_data(g_CustomIconShaders);
 }
@@ -212,2 +215,21 @@
 
+ui_shader& InventoryUtilities::GetCustomIconTextureShader(LPCSTR name)
+{
+	xr_map<LPCSTR, ui_shader*>::iterator it = g_CustomIconShaders.find(name);
+
+	if (it != g_CustomIconShaders.end())
+		return *(it)->second;
+
+	ui_shader* shader = xr_new<ui_shader>();
+	(*shader)->create("hud\\default", name);
+
+	std::pair<LPCSTR, ui_shader*> name_shader;
+	name_shader.first = name;
+	name_shader.second = shader;
+
+	g_CustomIconShaders.insert(name_shader);
+
+	return *shader;
+}
+
 const ui_shader&	InventoryUtilities::GetMPCharIconsShader()
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIInventoryUtilities.h xray-monolith/src/xrGame/ui/UIInventoryUtilities.h
--- coc-1.4-xray-64/src/xrGame/ui/UIInventoryUtilities.h	2023-10-20 20:54:51.435326700 +0100
+++ xray-monolith/src/xrGame/ui/UIInventoryUtilities.h	2023-10-20 20:54:33.347035800 +0100
@@ -40,2 +39,3 @@
 const ui_shader& GetEquipmentIconsShader();
+	ui_shader & GetCustomIconTextureShader(LPCSTR name);
 // shader íà èêîíêè ïåðñîíàæåé â ìóëüòèïëååðå
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIItemInfo.cpp xray-monolith/src/xrGame/ui/UIItemInfo.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIItemInfo.cpp	2023-10-20 20:54:51.436326600 +0100
+++ xray-monolith/src/xrGame/ui/UIItemInfo.cpp	2023-10-20 20:54:33.348035500 +0100
@@ -26,2 +26,4 @@
 #include "UICellItem.h"
+#include "luabind/luabind.hpp"
+#include "script_game_object.h"
 
@@ -184,2 +186,41 @@
 
+//-- Tronex
+LPCSTR CUIItemInfo::GetItemName(CInventoryItem& pInvItem, LPCSTR m_item_name)
+{
+	luabind::functor<LPCSTR> functorGetName;
+	if (ai().script_engine().functor("ui_item.item_name", functorGetName))
+	{
+		CGameObject* GO = pInvItem.cast_game_object();
+		if (GO)
+			return functorGetName(GO->lua_game_object(), m_item_name);
+	}
+	return m_item_name;
+}
+
+LPCSTR CUIItemInfo::GetItemShortName(CInventoryItem& pInvItem, LPCSTR m_item_short_name)
+{
+	luabind::functor<LPCSTR> functorGetShortName;
+	if (ai().script_engine().functor("ui_item.item_short_name", functorGetShortName))
+	{
+		CGameObject* GO = pInvItem.cast_game_object();
+		if (GO)
+			return functorGetShortName(GO->lua_game_object(), m_item_short_name);
+	}
+	return m_item_short_name;
+}
+
+LPCSTR CUIItemInfo::GetItemDescription(CInventoryItem& pInvItem, LPCSTR m_item_description)
+{
+	luabind::functor<LPCSTR> functorGetDescription;
+	if (ai().script_engine().functor("ui_item.item_description", functorGetDescription))
+	{
+		CGameObject* GO = pInvItem.cast_game_object();
+		if (GO)
+			return functorGetDescription(GO->lua_game_object(), m_item_description);
+	}
+	return m_item_description;
+}
+
+//-- Tronex
+
 bool	IsGameTypeSingle();
@@ -204,3 +246,3 @@
 	{
-		UIName->SetText		(pInvItem->NameItem());
+		UIName->SetText(GetItemName(*pInvItem, pInvItem->NameItem())); //(pInvItem->NameItem());
 		UIName->AdjustHeightToText();
@@ -296,3 +337,4 @@
 			pItem->SetTextComplexMode			(true);
-			pItem->SetText						(*pInvItem->ItemDescription());
+			pItem->SetText(GetItemDescription(*pInvItem, *pInvItem->ItemDescription()));
+			//(*pInvItem->ItemDescription());
 			pItem->AdjustHeightToText			();
@@ -326,2 +368,8 @@
 		// Çàãðóæàåì êàðòèíêó
+		if (pSettings->line_exist(m_pInvItem->m_section_id.c_str(), "icons_texture"))
+		{
+			LPCSTR icons_texture = pSettings->r_string(m_pInvItem->m_section_id.c_str(), "icons_texture");
+			UIItemImage->SetShader(InventoryUtilities::GetCustomIconTextureShader(icons_texture));
+		}
+		else
 		UIItemImage->SetShader				(InventoryUtilities::GetEquipmentIconsShader());
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIItemInfo.h xray-monolith/src/xrGame/ui/UIItemInfo.h
--- coc-1.4-xray-64/src/xrGame/ui/UIItemInfo.h	2023-10-20 20:54:51.437327600 +0100
+++ xray-monolith/src/xrGame/ui/UIItemInfo.h	2023-10-20 20:54:33.348035500 +0100
@@ -70,2 +73,6 @@
 	CUIStatic*			UIItemImage;
+private:
+	LPCSTR GetItemName(CInventoryItem& pInvItem, LPCSTR m_item_name);
+	LPCSTR GetItemShortName(CInventoryItem& pInvItem, LPCSTR m_item_short_name);
+	LPCSTR GetItemDescription(CInventoryItem& pInvItem, LPCSTR m_item_description);
 };
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UILines.cpp xray-monolith/src/xrGame/ui/UILines.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UILines.cpp	2023-10-20 20:54:51.440326000 +0100
+++ xray-monolith/src/xrGame/ui/UILines.cpp	2023-10-20 20:54:33.351035700 +0100
@@ -9,2 +9,3 @@
 #include "StdAfx.h"
+#include <cstdio>
 
@@ -153,3 +161,8 @@
 					*pszTemp = '\0';
-					ptmp_line->AddSubLine( pszSearch , tcolor );
+					CUISubLine subline;
+					subline.m_text = pszSearch;
+					subline.m_color = tcolor;
+					subline.m_last_in_line = true;
+					//ptmp_line->AddSubLine(pszSearch, tcolor);
+					ptmp_line->AddSubLine(&subline);
 					pszSearch = pszTemp + 2;
@@ -186,6 +204,10 @@
 			tmp_line.Clear();
-		} else {
-			for ( int i = 0 ; i < vsz ; i++ ) {
-				const char *pszText = line->m_subLines[i].m_text.c_str();
-				const u32 tcolor = line->m_subLines[i].m_color;
+		}
+		else
+		{
+			for (int i = 0; i < vsz; i++)
+			{
+				CUISubLine* pSubLine = &line->m_subLines[i];
+				const char* pszText = pSubLine->m_text.c_str();
+				const u32 tcolor = pSubLine->m_color;
 				u16 uFrom = 0 , uPartLen = 0;
@@ -208,2 +231,4 @@
 				tmp_line.AddSubLine( szTempLine , tcolor );
+				if (pSubLine->m_last_in_line || i == (vsz -1))
+				{
 				m_lines.push_back( tmp_line );
@@ -212,3 +237,5 @@
 		}
-	} else
+		}
+	}
+	else
 	{
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UILogsWnd.cpp xray-monolith/src/xrGame/ui/UILogsWnd.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UILogsWnd.cpp	2023-10-20 20:54:51.447326600 +0100
+++ xray-monolith/src/xrGame/ui/UILogsWnd.cpp	2023-10-20 20:54:33.355035500 +0100
@@ -77,2 +78,12 @@
 	{
+		// Sort news by date correctly
+		struct {
+			bool operator()(CUIWindow* x, CUIWindow* y) {
+				CUINewsItemWnd* a = smart_cast<CUINewsItemWnd*>(x);
+				CUINewsItemWnd* b = smart_cast<CUINewsItemWnd*>(y);
+				return a->receive_time > b->receive_time;
+			}
+		} sortNewsDesc;
+		std::sort(m_items_ready.begin(), m_items_ready.end(), sortNewsDesc);
+
 		WINDOW_LIST::iterator it	= m_items_ready.begin();
@@ -178,2 +190,10 @@
 
+	// Sort news by date correctly
+	struct {
+		bool operator()(GAME_NEWS_DATA& a, GAME_NEWS_DATA& b) {
+			return a.receive_time < b.receive_time;
+		}
+	} sortNewsDesc;
+	std::sort(news_vector.begin(), news_vector.end(), sortNewsDesc);
+
 //	u32 currentNews = 0;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIMainIngameWnd.cpp xray-monolith/src/xrGame/ui/UIMainIngameWnd.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIMainIngameWnd.cpp	2023-10-20 20:54:51.451326700 +0100
+++ xray-monolith/src/xrGame/ui/UIMainIngameWnd.cpp	2023-10-20 20:54:33.359035500 +0100
@@ -561,3 +568,3 @@
 
-	if(b_snd)
+	if (b_snd && !UIZoneMap->disabled)
 		HUD_SOUND_ITEM::PlaySound	(m_contactSnd, Fvector().set(0,0,0), 0, true );
@@ -590,2 +596,10 @@
 
+	if (pSettings->line_exist(sect_name.c_str(), "icons_texture"))
+	{
+		LPCSTR icons_texture = pSettings->r_string(sect_name.c_str(), "icons_texture");
+		UIPickUpItemIcon->SetShader(InventoryUtilities::GetCustomIconTextureShader(icons_texture));
+	}
+	else
+		UIPickUpItemIcon->SetShader(GetEquipmentIconsShader());
+
 	float scale_x = m_iPickUpItemIconWidth/
@@ -861,2 +878,9 @@
 				CUIStatic* main_slot = m_quick_slots_icons[i];
+
+				if (pSettings->line_exist(item_name.c_str(), "icons_texture"))
+				{
+					LPCSTR icons_texture = pSettings->r_string(item_name.c_str(), "icons_texture");
+					main_slot->SetShader(InventoryUtilities::GetCustomIconTextureShader(icons_texture));
+				}
+				else
 				main_slot->SetShader(InventoryUtilities::GetEquipmentIconsShader());
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIMainIngameWnd.h xray-monolith/src/xrGame/ui/UIMainIngameWnd.h
--- coc-1.4-xray-64/src/xrGame/ui/UIMainIngameWnd.h	2023-10-20 20:54:51.451326700 +0100
+++ xray-monolith/src/xrGame/ui/UIMainIngameWnd.h	2023-10-20 20:54:33.359035500 +0100
@@ -28,3 +28,3 @@
 
-protected:
+public:
 	
@@ -45,3 +45,2 @@
 
-public:
 	CUIStatic*			m_ind_boost_psy;
@@ -175,2 +174,7 @@
 #endif
+DECLARE_SCRIPT_REGISTER_FUNCTION
 };
+
+add_to_type_list(CUIMainIngameWnd)
+#undef script_type_list
+#define script_type_list save_type_list(CUIMainIngameWnd)
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIMap.cpp xray-monolith/src/xrGame/ui/UIMap.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIMap.cpp	2023-10-20 20:54:51.452326700 +0100
+++ xray-monolith/src/xrGame/ui/UIMap.cpp	2023-10-20 20:54:33.359035500 +0100
@@ -502,2 +507,5 @@
 	{
+		// demonized: send pointer to this map into GlobalMap
+		MapWnd()->GlobalMap()->hoveredMap = this;
+
 		VERIFY(m_dwFocusReceiveTime>=0);
@@ -571,3 +581,3 @@
 	inherited::Init_internal	(name, pLtx, sect_name, sh_name);
-	CUIStatic::SetTextureColor	(0x7fffffff);
+	//CUIStatic::SetTextureColor(0x7fffffff);
 }
@@ -584,2 +594,8 @@
 {
+	if (!IsRounded())
+	{
+		inherited::Draw();
+		return;
+	}
+
 	u32	segments_count			= 20;
@@ -648,2 +663,5 @@
 {
+	if (!IsRounded())
+		return inherited::GetPointerTo(src, item_radius, pos, heading);
+
 	Fvector2 clip_center = GetStaticItem()->GetHeadingPivot();
@@ -666,2 +684,5 @@
 {
+	if (!IsRounded())
+		return inherited::NeedShowPointer(r);
+
 	Fvector2 clip_center = GetStaticItem()->GetHeadingPivot();
@@ -677,2 +698,5 @@
 {
+	if (!IsRounded())
+		return inherited::IsRectVisible(r);
+
 	Fvector2 clip_center	= GetStaticItem()->GetHeadingPivot();
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIMap.h xray-monolith/src/xrGame/ui/UIMap.h
--- coc-1.4-xray-64/src/xrGame/ui/UIMap.h	2023-10-20 20:54:51.452326700 +0100
+++ xray-monolith/src/xrGame/ui/UIMap.h	2023-10-20 20:54:33.360035400 +0100
@@ -14,3 +14,10 @@
 	Flags16			m_flags;
-	enum EFlags{	eLocked	=(1<<0),};
+
+	enum EFlags 
+	{
+		eLocked = (1 << 0),
+		eRounded = (1 << 1),
+		eRotate = (1 << 2)
+	};
+
 	float			m_pointer_dist;
@@ -51,2 +66,6 @@
 			void	SetLocked						(bool b)		{m_flags.set(eLocked,b);}
+	bool IsRounded() { return m_flags.test(eRounded); }
+	void SetRounded(bool b) { m_flags.set(eRounded, b); }
+	bool Rotate() { return m_flags.test(eRotate); }
+	void SetRotate(bool b) { m_flags.set(eRotate, b); }
 			void	SetPointerDistance				(float d)		{m_pointer_dist=d;};
@@ -89,2 +112,5 @@
 	void			Initialize				();
+
+	// demonized: pointer to hovered map on PDA
+	CUICustomMap* hoveredMap;
 protected:
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIMapInfo.cpp xray-monolith/src/xrGame/ui/UIMapInfo.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIMapInfo.cpp	2023-10-20 20:54:51.453326500 +0100
+++ xray-monolith/src/xrGame/ui/UIMapInfo.cpp	2023-10-20 20:54:33.361036300 +0100
@@ -41,3 +43,3 @@
 						st->AdjustHeightToText();											\
-						m_view->AddWindow(st, true)											\
+						m_view->AddWindow(st, true)
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIMapWnd.cpp xray-monolith/src/xrGame/ui/UIMapWnd.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIMapWnd.cpp	2023-10-20 20:54:51.455326900 +0100
+++ xray-monolith/src/xrGame/ui/UIMapWnd.cpp	2023-10-20 20:54:33.363035400 +0100
@@ -413,2 +422,3 @@
 
+extern BOOL mouseWheelInvertZoom;
 bool CUIMapWnd::OnMouseAction(float x, float y, EUIMessages mouse_action)
@@ -440,3 +450,3 @@
 		case WINDOW_MOUSE_WHEEL_DOWN:
-			UpdateZoom( true );
+			UpdateZoom(mouseWheelInvertZoom, true);
 			return true;
@@ -444,3 +454,3 @@
 		case WINDOW_MOUSE_WHEEL_UP:
-			UpdateZoom( false );
+			UpdateZoom(!mouseWheelInvertZoom, true);
 			return true;
@@ -454,4 +463,9 @@
 
-bool CUIMapWnd::UpdateZoom( bool b_zoom_in )
+// demonized: Zoom towards mouse cursor instead of map center
+BOOL pda_map_zoom_in_to_mouse = TRUE;
+BOOL pda_map_zoom_out_to_mouse = TRUE;
+bool CUIMapWnd::UpdateZoom(bool b_zoom_in, bool b_scroll_wheel)
 {
+	auto before_mouse_pos = GetGlobalMapCoordsForMouse();
+	before_mouse_pos.mul(-1);
 	float prev_zoom = GetZoom();
@@ -469,3 +483,31 @@
 
+	if (b_scroll_wheel && (pda_map_zoom_in_to_mouse || pda_map_zoom_out_to_mouse))
+	{
+		if (!fsimilar(prev_zoom, GetZoom()))
+		{
+			Frect vis_rect = ActiveMapRect();
+			vis_rect.getcenter(m_tgtCenter);
+
+			Fvector2 pos;
+			CUIGlobalMap* gm = GlobalMap();
+			gm->GetAbsolutePos(pos);
+			m_tgtCenter.sub(pos);
+			m_tgtCenter.div(gm->GetCurrentZoom());
+
+			// Zoom towards mouse
+			if (b_zoom_in && pda_map_zoom_in_to_mouse) {
+				auto temp = m_tgtCenter;
+				temp.add(before_mouse_pos).div(2).sub(m_tgtCenter);
+				m_tgtCenter.add(temp);
+			} else if (!b_zoom_in && pda_map_zoom_out_to_mouse) {
+				auto temp = m_tgtCenter;
+				temp.add(before_mouse_pos).div(2).sub(m_tgtCenter).mul(-1);
+				m_tgtCenter.add(temp);
+			}
 	
+			ResetActionPlanner();
+			HideCurHint();
+			return false;
+		}
+	} else {
 	if ( !fsimilar( prev_zoom, GetZoom() ) )
@@ -486,2 +528,3 @@
 	}
+	}
 	return true;
@@ -501,2 +544,29 @@
 
+// demonized: get global map coords under mouse cursor
+Fvector2 CUIMapWnd::GetGlobalMapCoordsForMouse()
+{
+	auto gm = GlobalMap();
+
+	// 1. Get cursor position in map space
+	// Normalize mouse coordinates in map canvas
+	Fvector2 pos_abs = { 0, 0 };
+	auto cursor_pos = GetUICursor().GetCursorPosition();
+	cursor_pos.sub(ActiveMapRect().lt);
+
+	// Invert mouse coords
+	cursor_pos.mul(-1);
+
+	// Get absolute left top of the current area of the map
+	Fvector2 map_abs = { 0, 0 };
+	Fvector2& current_zoom = gm->GetCurrentZoom();
+	gm->GetAbsolutePos(map_abs);
+	map_abs.sub(gm->WorkingArea().lt);
+	map_abs.div(current_zoom);
+
+	// Increment to mouse coordinates
+	pos_abs.add(map_abs);
+	pos_abs.add(cursor_pos.div(current_zoom));
+	return pos_abs;
+}
+
 void CUIMapWnd::ActivatePropertiesBox(CUIWindow* w)
@@ -505,9 +575,184 @@
 	luabind::functor<void> funct;
+	CMapSpot* sp = nullptr;
 	if (ai().script_engine().functor("pda.property_box_add_properties", funct))
 	{
-		CMapSpot* sp = smart_cast<CMapSpot*>(w);
+		sp = smart_cast<CMapSpot*>(w);
 		if (sp)
-			funct(m_UIPropertiesBox, sp->MapLocation()->ObjectID(), (LPCSTR)sp->MapLocation()->GetLevelName().c_str(), (LPCSTR)sp->MapLocation()->GetHint());
+			funct(m_UIPropertiesBox, sp->MapLocation()->ObjectID(), (LPCSTR)sp->MapLocation()->GetLevelName().c_str(),
+			      (LPCSTR)sp->MapLocation()->GetHint());
 	}
 	
+	// demonized: possibility to click trigger properties box anywhere on the map with right click
+	luabind::functor<void> rcFunct;
+	if (ai().script_engine().functor("_G.COnRightClickMap", rcFunct))
+	{
+		auto gm = GlobalMap();
+
+		// 1. Get cursor position in map space
+		// Normalize mouse coordinates in map canvas
+		Fvector2 cursor_pos = GetUICursor().GetCursorPosition();
+		cursor_pos.sub(ActiveMapRect().lt);
+
+		// Invert mouse coords
+		cursor_pos.mul(-1);
+
+		// Divide by zoom level
+		Fvector2 current_zoom = gm->GetCurrentZoom();
+		cursor_pos.div(current_zoom);
+
+		// Get absolute left top of the current area of the map
+		Fvector2 map_abs = { 0, 0 };
+		gm->GetAbsolutePos(map_abs);
+		map_abs.sub(gm->WorkingArea().lt).div(current_zoom);
+
+		// Increment to mouse coordinates
+		Fvector2 pos_abs = { 0, 0 };
+		pos_abs.add(map_abs).add(cursor_pos);
+
+		// 2. Get map position from global position
+		if (gm->hoveredMap) {
+
+			// Get position of the local map on global map
+			auto lm = gm->hoveredMap;
+			Frect lm_rect;
+			lm_rect.set(0, 0, 0, 0);
+			lm->GetAbsoluteRect(lm_rect);
+
+			// Normalize local map coordinates
+			Frect lm_wa = lm->WorkingArea();
+			lm_rect.lt.sub(lm_wa.lt);
+			lm_rect.rb.sub(lm_wa.rb);
+
+			// Divide by local map zoom level
+			Fvector2 lm_zoom = lm->GetCurrentZoom();
+			lm_rect.lt.div(lm_zoom);
+			lm_rect.rb.div(lm_zoom);
+
+			// Get cursor coordinates
+			Fvector2 lm_cursor_pos = GetUICursor().GetCursorPosition();
+			lm_cursor_pos.sub(ActiveMapRect().lt);
+
+			// Invert cursor coords
+			lm_cursor_pos.mul(-1);
+
+			// Divide by local map zoom level
+			lm_cursor_pos.div(lm_zoom);
+
+			// Get local map bounding rect
+			Frect lm_bound_rect = lm->BoundRect();
+			Fvector2 lm_bound_size = { 0, 0 };
+			lm_bound_rect.getsize(lm_bound_size);
+
+			// Get mouse coordinates relative to local map left top
+			Fvector2 lm_mouse_pos = { 0, 0 };
+			lm_mouse_pos.add(lm_rect.lt).add(lm_cursor_pos);
+
+			// Adjust local map rect based on bounding rect
+			lm_rect.rb.set(Fvector2().set(lm_rect.lt).sub(lm_bound_size));
+
+			// Adjust mouse coordinates for getting real world coordinates
+			Fvector2 lm_real_mouse_pos = { 0, 0 };
+			Fvector2 lm_adjusted_mouse_pos = { 0, 0 };
+			lm_adjusted_mouse_pos.add(lm_mouse_pos).mul(-1).mul(lm_zoom);
+
+			// Get real world coordinates
+			lm_real_mouse_pos.x = lm_bound_rect.lt.x + lm_adjusted_mouse_pos.x / lm_zoom.x;
+			lm_real_mouse_pos.y = lm_bound_rect.height() + lm_bound_rect.lt.y - lm_adjusted_mouse_pos.y / lm_zoom.x;
+			lm_real_mouse_pos.x /= UI().get_current_kx();
+
+			// Get map name
+			LPCSTR lm_name = lm->MapName().c_str();
+
+			// Get Y component of real world coordinates - raycast. Only on current level
+			// On other levels y will be taken from lvid
+			// Get accurate lvid as well
+			Fvector lm_real_pos = { lm_real_mouse_pos.x, 0, lm_real_mouse_pos.y };
+			u32 lm_lvid = u32(-1);
+			if (0 == xr_strcmp(g_pGameLevel->name().c_str(), lm_name)) {
+
+				// perform ray cast to get actual position
+				collide::rq_result R;
+				CObject* ignore = Actor();
+				Fbox lm_bv = g_pGameLevel->ObjectSpace.GetBoundingVolume();
+				Fvector start = { lm_real_mouse_pos.x, lm_bv.max.y, lm_real_mouse_pos.y };
+				Fvector dir = { 0, -1, 0 };
+				float range = lm_bv.max.y - lm_bv.min.y;
+				Fvector res;
+				if (Level().ObjectSpace.RayPick(start, dir, range, collide::rqtStatic, R, ignore))
+				{
+					res.mad(start, dir, R.range);
+					lm_real_pos.y = res.y;
+					lm_lvid = ai().level_graph().vertex_id(lm_real_pos);
+				}
+			}
+
+			bool lvid_not_set = lm_lvid == u32(-1);
+			u32 lm_gvid = u32(-1);
+
+			// Get gvid and set lvid if wasnt set
+			auto& gg = ai().game_graph();
+			u32 current_gvid = 0;
+			float dist = FLT_MAX;
+			while (gg.valid_vertex_id(current_gvid)) {
+				try {
+					auto vertex = gg.vertex(current_gvid);
+					if (!vertex) {
+						current_gvid++;
+						continue;
+					}
+					GameGraph::_LEVEL_ID level_id = vertex->level_id();
+					const GameGraph::LEVEL_MAP& levels = ai().game_graph().header().levels();
+					GameGraph::LEVEL_MAP::const_iterator I = levels.find(level_id);
+					if (I == levels.end()) {
+						current_gvid++;
+						continue;
+					}
+					LPCSTR level_name = I->second.name().c_str();
+					if (0 == xr_strcmp(level_name, lm_name)) {
+						Fvector3 pos = vertex->level_point();
+						float d = lm_real_pos.distance_to_xz_sqr(pos);
+						if (d < dist) {
+							dist = d;
+							lm_gvid = current_gvid;
+							if (lvid_not_set) {
+								lm_lvid = vertex->level_vertex_id();
+								lm_real_pos.y = pos.y;
+
+								// code below might crash
+								/*Fvector3 lvid_pos = ai().level_graph().vertex_position(lm_lvid);
+								lm_real_pos.y = lvid_pos.y;*/
+							}
+						}
+					}
+				} catch (std::exception& e) {
+					Msg("![UIMapWnd.cpp] _G.COnRightClickMap %s", e.what());
+				}
+				current_gvid++;
+			}
+
+			luabind::object table = luabind::newtable(ai().script_engine().lua());
+			/*table["gm_cursor_pos"] = cursor_pos;
+			table["gm_map_abs"] = map_abs;
+			table["lm_bound_rect"] = lm_bound_rect;
+			table["lm_bound_size"] = lm_bound_size;
+			table["gm_zoom"] = current_zoom;
+			table["lm_rect"] = lm_rect;
+			table["lm_zoom"] = lm_zoom;
+			table["lm_mouse_pos"] = lm_mouse_pos;
+			table["lm_mouse_pos_adjusted"] = lm_adjusted_mouse_pos;
+			table["lm_mouse_pos_real"] = lm_real_mouse_pos;*/
+			table["global_map_pos"] = pos_abs;
+			table["pos"] = lm_real_pos;
+			table["level_name"] = lm_name;
+			table["object_id"] = sp ? sp->MapLocation()->ObjectID() : 65535;
+			table["hint"] = sp ? sp->MapLocation()->GetHint() : NULL;
+			table["lvid"] = lm_lvid;
+			table["gvid"] = lm_gvid;
+
+			// 3. Lua
+			rcFunct(m_UIPropertiesBox, table);
+		}
+	}
+
+
 	if (m_UIPropertiesBox->GetItemsCount() > 0)
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIMapWnd.h xray-monolith/src/xrGame/ui/UIMapWnd.h
--- coc-1.4-xray-64/src/xrGame/ui/UIMapWnd.h	2023-10-20 20:54:51.455326900 +0100
+++ xray-monolith/src/xrGame/ui/UIMapWnd.h	2023-10-20 20:54:33.363035400 +0100
@@ -130,5 +131,5 @@
 			void				SetZoom					(float value);
-			bool				UpdateZoom				(bool b_zoom_in);
-
 
+	// demonized: zoom towards mouse cursor
+	bool UpdateZoom(bool b_zoom_in, bool b_scroll_wheel = false);
 			void				ShowHintStr				(CUIWindow* parent, LPCSTR text);
@@ -148,2 +149,4 @@
 
+	Fvector2 GetGlobalMapCoordsForMouse();
+
 	void						SetTargetMap			(CUICustomMap* m, bool bZoomIn = false);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIMessages.h xray-monolith/src/xrGame/ui/UIMessages.h
--- coc-1.4-xray-64/src/xrGame/ui/UIMessages.h	2023-10-20 20:54:51.458326800 +0100
+++ xray-monolith/src/xrGame/ui/UIMessages.h	2023-10-20 20:54:33.366036600 +0100
@@ -99,2 +99,8 @@
 	INVENTORY_EAT5_ACTION,
+	INVENTORY_EAT6_ACTION,
+	INVENTORY_EAT7_ACTION,
+	INVENTORY_EAT8_ACTION,
+	INVENTORY_EAT9_ACTION,
+	INVENTORY_EAT10_ACTION,
+	INVENTORY_EAT11_ACTION,
 	INVENTORY_DONATE_ACTION,
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIMMShniaga.cpp xray-monolith/src/xrGame/ui/UIMMShniaga.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIMMShniaga.cpp	2023-10-20 20:54:51.447326600 +0100
+++ xray-monolith/src/xrGame/ui/UIMMShniaga.cpp	2023-10-20 20:54:33.355035500 +0100
@@ -16,3 +16,2 @@
 #include "MainMenu.h"
-#include "../gamespy/GameSpy_Full.h"
 
@@ -96,4 +101,7 @@
 	m_sound->Init(xml_doc, "menu_sound");
+	if (!g_pGameLevel || !g_pGameLevel->bReady)
+	{
 	m_sound->music_Play();
 }
+}
 
@@ -318,7 +332,6 @@
 		m_shniaga->SetWndPos(pos);		
-	}else
+	}
+	else
 		ProcessEvent(E_Stop);
 
-	if (m_start_time > Device.dwTimeContinual - m_run_time*10/100)
-		ProcessEvent(E_Finilize);
 
@@ -352,3 +363,6 @@
 	else
+	{
 		GetMessageTarget()->SendMessage(m_selected, BUTTON_CLICKED);
+		ProcessEvent(E_Finilize);
+	}
 }
@@ -469,4 +486,9 @@
                 m_flags.set(fl_MovingStoped, TRUE);
-			}	break;
-		case E_Update:		m_sound->music_Update();
+		}
+		break;
+	case E_Update:
+		if (!g_pGameLevel || !g_pGameLevel->bReady)
+		{
+			m_sound->music_Update();
+		}
 			break;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIMotionIcon.cpp xray-monolith/src/xrGame/ui/UIMotionIcon.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIMotionIcon.cpp	2023-10-20 20:54:51.460328400 +0100
+++ xray-monolith/src/xrGame/ui/UIMotionIcon.cpp	2023-10-20 20:54:33.368035500 +0100
@@ -67,2 +66,5 @@
 
+	if (!IsShown())
+		return;
+
 	Pos	= clampr(Pos, 0.f, 100.f);
@@ -76,2 +78,5 @@
 
+	if (!IsShown())
+		return;
+
 	m_luminosity	= Pos;
@@ -81,2 +86,5 @@
 {
+	if (!IsShown())
+		return;
+
 	inherited::Draw();
@@ -91,3 +99,8 @@
 	}
-	if(m_bchanged){
+
+	if (!IsShown())
+		return;
+
+	if (m_bchanged)
+	{
 		m_bchanged = false;
@@ -121,3 +138,3 @@
 
-	if(g_pMotionIcon)
+	if (g_pMotionIcon && g_pMotionIcon->IsShown())
 		g_pMotionIcon->SetActorVisibility(who_id, value);
@@ -127,2 +144,5 @@
 {
+	if (!IsShown())
+		return;
+
 	clamp(value, 0.f, 1.f);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UINewsItemWnd.cpp xray-monolith/src/xrGame/ui/UINewsItemWnd.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UINewsItemWnd.cpp	2023-10-20 20:54:51.465326100 +0100
+++ xray-monolith/src/xrGame/ui/UINewsItemWnd.cpp	2023-10-20 20:54:33.372035500 +0100
@@ -33,2 +35,3 @@
 {
+	receive_time = news_data.receive_time;
 	shared_str time_str				= InventoryUtilities::GetTimeAndDateAsString( news_data.receive_time );
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UINewsItemWnd.h xray-monolith/src/xrGame/ui/UINewsItemWnd.h
--- coc-1.4-xray-64/src/xrGame/ui/UINewsItemWnd.h	2023-10-20 20:54:51.465326100 +0100
+++ xray-monolith/src/xrGame/ui/UINewsItemWnd.h	2023-10-20 20:54:33.372035500 +0100
@@ -4,2 +4,3 @@
 #include "xrUIXmlParser.h"
+#include "../alife_time_manager.h"
 class CUIStatic;
@@ -17,2 +18,6 @@
 
+	// Store GAME_NEWS_DATA time
+public:
+	ALife::_TIME_ID receive_time = 0;
+
 public:
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIOptConCom.cpp xray-monolith/src/xrGame/ui/UIOptConCom.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIOptConCom.cpp	2023-10-20 20:54:51.466326800 +0100
+++ xray-monolith/src/xrGame/ui/UIOptConCom.cpp	2023-10-20 20:54:33.372035500 +0100
@@ -8,5 +8,2 @@
 #include "../RegistryFuncs.h"
-#include "../../xrGameSpy/xrGameSpy_MainDefs.h"
-
-#include "gamespy/GameSpy_GP.h"
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIOptionsManagerScript.cpp xray-monolith/src/xrGame/ui/UIOptionsManagerScript.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIOptionsManagerScript.cpp	2023-10-20 20:54:51.468326800 +0100
+++ xray-monolith/src/xrGame/ui/UIOptionsManagerScript.cpp	2023-10-20 20:54:33.374035300 +0100
@@ -39,2 +46,13 @@
 
+extern xr_token* vid_quality_token;
+
+LPCSTR CUIOptionsManagerScript::GetRendererName(int index)
+{
+	for (int i = 0; vid_quality_token[i].name; i++)
+	{
+		if (i == index) return vid_quality_token[i].name;
+	}
+	return "";
+}
+
 #pragma optimize("s",on)
@@ -54,2 +72,3 @@
 			.def("NeedVidRestart",		&CUIOptionsManagerScript::NeedVidRestart )
+		.def("GetRendererName", &CUIOptionsManagerScript::GetRendererName)
 		];
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIOptionsManagerScript.h xray-monolith/src/xrGame/ui/UIOptionsManagerScript.h
--- coc-1.4-xray-64/src/xrGame/ui/UIOptionsManagerScript.h	2023-10-20 20:54:51.468326800 +0100
+++ xray-monolith/src/xrGame/ui/UIOptionsManagerScript.h	2023-10-20 20:54:33.374035300 +0100
@@ -15,2 +14,3 @@
 	bool 		NeedVidRestart			();
+	LPCSTR GetRendererName(int index);
 	DECLARE_SCRIPT_REGISTER_FUNCTION
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIOutfitInfo.cpp xray-monolith/src/xrGame/ui/UIOutfitInfo.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIOutfitInfo.cpp	2023-10-20 20:54:51.468326800 +0100
+++ xray-monolith/src/xrGame/ui/UIOutfitInfo.cpp	2023-10-20 20:54:33.374035300 +0100
@@ -78,2 +78,4 @@
 	m_value.SetVisible( false );
+	m_value.SetTextOffset(UI().is_widescreen() ? 208 : 262, 0);
+	m_value.SetTextColor(color_argb(255, 170, 170, 170));
 
@@ -87,6 +89,13 @@
 	m_progress.SetTwoPos( cur, comp );
+
+	if (cur != comp)
+	{
 	string32 buf;
-//	xr_sprintf( buf, sizeof(buf), "%d %%", (int)cur );
-	xr_sprintf( buf, sizeof(buf), "%.0f", cur );
+		float adj_value = cur - comp;
+		xr_sprintf(buf, sizeof(buf), adj_value >= 0 ? "+%.1f%%" : "%.1f%%", adj_value);
 	m_value.SetText( buf );
+		m_value.SetVisible(true);
+	}
+	else
+		m_value.SetVisible(false);
 }
@@ -304,2 +313,6 @@
 		
+		float max_power = actor->conditions().GetMaxFireWoundProtection();
+		cur /= max_power;
+		slot /= max_power;
+
 		m_items[ALife::eHitTypeFireWound]->SetProgressValue( cur, slot );
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIPdaWnd.cpp xray-monolith/src/xrGame/ui/UIPdaWnd.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIPdaWnd.cpp	2023-10-20 20:54:51.473326500 +0100
+++ xray-monolith/src/xrGame/ui/UIPdaWnd.cpp	2023-10-20 20:54:33.376035600 +0100
@@ -31,2 +31,8 @@
 
+#include "Actor.h"
+#include "Inventory.h"
+#include "../xrEngine/XR_IOConsole.h"
+#include "ui\UIProgressBar.h"
+#include "player_hud.h"
+
 #define PDA_XML		"pda.xml"
@@ -43,2 +49,6 @@
 	m_hint_wnd = NULL;
+	m_battery_bar = NULL;
+	m_power = 0.f;
+	last_cursor_pos.set(UI_BASE_WIDTH / 2.f, UI_BASE_HEIGHT / 2.f);
+	m_cursor_box.set(117.f, 39.f, UI_BASE_WIDTH - 121.f, UI_BASE_HEIGHT - 37.f);
 	Init();
@@ -75,5 +86,10 @@
 */
-	m_btn_close				= UIHelper::Create3tButton( uiXml, "close_button", this );
+	//m_btn_close = UIHelper::Create3tButton(uiXml, "close_button", this);
 	m_hint_wnd				= UIHelper::CreateHint( uiXml, "hint_wnd" );
 
+	m_battery_bar = xr_new<CUIProgressBar>();
+	m_battery_bar->SetAutoDelete(true);
+	AttachChild(m_battery_bar);
+	CUIXmlInit::InitProgressBar(uiXml, "battery_bar", 0, m_battery_bar);
+	m_battery_bar->Show(true);
 
@@ -126,3 +141,4 @@
 			{
-				HideDialog();
+				if (smart_cast<CPda*>(Actor()->inventory().ActiveItem()))
+					Actor()->inventory().Activate(NO_ACTIVE_SLOT);
 			}
@@ -132,3 +148,2 @@
 		{
-			//R_ASSERT						(m_pActiveDialog);
 			if (m_pActiveDialog)
@@ -139,2 +154,62 @@
 
+bool CUIPdaWnd::OnMouseAction(float x, float y, EUIMessages mouse_action)
+{
+	switch (mouse_action)
+	{
+	case WINDOW_LBUTTON_DOWN:
+	case WINDOW_RBUTTON_DOWN:
+	case WINDOW_LBUTTON_UP:
+	case WINDOW_RBUTTON_UP:
+	{
+		CPda* pda = smart_cast<CPda*>(Actor()->inventory().ActiveItem());
+		if (pda)
+		{
+			if (pda->IsPending())
+				return true;
+
+			if (mouse_action == WINDOW_LBUTTON_DOWN)
+				bButtonL = true;
+			else if (mouse_action == WINDOW_RBUTTON_DOWN)
+				bButtonR = true;
+			else if (mouse_action == WINDOW_LBUTTON_UP)
+				bButtonL = false;
+			else if (mouse_action == WINDOW_RBUTTON_UP)
+				bButtonR = false;
+		}
+		break;
+	}
+	}
+	CUIDialogWnd::OnMouseAction(x, y, mouse_action);
+	return true; //always true because StopAnyMove() == false
+}
+
+void CUIPdaWnd::MouseMovement(float x, float y)
+{
+	CPda* pda = smart_cast<CPda*>(Actor()->inventory().ActiveItem());
+	if (!pda) return;
+
+	x *= .1f;
+	y *= .1f;
+	clamp(x, -.15f, .15f);
+	clamp(y, -.15f, .15f);
+
+	if (_abs(x) < .05f)
+		x = 0.f;
+
+	if (_abs(y) < .05f)
+		y = 0.f;
+
+	bool buttonpressed = (bButtonL || bButtonR);
+
+	target_buttonpress = (buttonpressed ? -.0015f : 0.f);
+	target_joystickrot.set(x*-.75f, 0.f, y*.75f);
+
+	x += y * pda->m_thumb_rot[0];
+	y += x * pda->m_thumb_rot[1];
+
+	g_player_hud->m_bone_callback_params[r_finger0]->m_target.set(y*.15f, y*-.05f, (x*-.15f) + (buttonpressed ? .002f : 0.f));
+	g_player_hud->m_bone_callback_params[r_finger01]->m_target.set(0.f, 0.f, (x*-.25f) + (buttonpressed ? .01f : 0.f));
+	g_player_hud->m_bone_callback_params[r_finger02]->m_target.set(0.f, 0.f, (x*.75f) + (buttonpressed ? .025f : 0.f));
+}
+
 void CUIPdaWnd::Show(bool status)
@@ -154,3 +229,5 @@
 
-	}else
+		CurrentGameUI()->HideActorMenu();
+	}
+	else
 	{
@@ -174,3 +251,6 @@
 
-	m_clock->TextItemControl().SetText(InventoryUtilities::GetGameTimeAsString(InventoryUtilities::etpTimeToMinutes).c_str());
+	m_clock->TextItemControl().SetText(
+		InventoryUtilities::GetGameTimeAsString(InventoryUtilities::etpTimeToMinutes).c_str());
+
+	m_battery_bar->SetProgressPos(m_power);
 
@@ -222,7 +302,9 @@
 		m_sActiveSection = section;
-		SetActiveCaption();
 	}
-	else {
+	else
+	{
 		m_sActiveSection = "";
 	}
+
+	SetActiveCaption();
 }
@@ -242,2 +324,6 @@
 			SetCaption( buf );
+			UITabControl->Show(true);
+			m_clock->Show(true);
+			m_caption->Show(true);
+			m_battery_bar->Show(true);
 			return;
@@ -245,2 +331,15 @@
 	}
+
+	UITabControl->Show(false);
+	//m_clock->Show(false);
+	m_caption->Show(false);
+	//m_battery_bar->Show(false);
+}
+
+#include "UICursor.h"
+
+void CUIPdaWnd::ResetCursor()
+{
+	if (!last_cursor_pos.similar({ 0.f, 0.f }))
+		GetUICursor().SetUICursorPosition(last_cursor_pos);
 }
@@ -267,2 +366,7 @@
 {
+	if (Device.dwFrame == dwPDAFrame)
+		return;
+
+	dwPDAFrame = Device.dwFrame;
+
 	inherited::Draw();
@@ -344,13 +447,41 @@
 
+void CUIPdaWnd::Enable(bool status)
+{
+	if (status)
+		ResetCursor();
+	else
+	{
+		g_player_hud->reset_thumb(false);
+		ResetJoystick(false);
+		bButtonL = false;
+		bButtonR = false;
+	}
+
+	inherited::Enable(status);
+}
+
 bool CUIPdaWnd::OnKeyboardAction(int dik, EUIMessages keyboard_action)
 {
-	if ( is_binded(kACTIVE_JOBS, dik) )
+	if (IsShown() && (keyboard_action == WINDOW_KEY_PRESSED || keyboard_action == WINDOW_KEY_RELEASED))
+	{
+		if (!psActorFlags.test(AF_3D_PDA) && keyboard_action == WINDOW_KEY_PRESSED)
+		{
+			EGameActions action = get_binded_action(dik);
+
+			if (action == kQUIT || action == kINVENTORY || action == kACTIVE_JOBS)
 	{
-		if ( WINDOW_KEY_PRESSED == keyboard_action )
 			HideDialog();
+				return  action == kQUIT;
+			}
 
-		return true;
+			return inherited::OnKeyboardAction(dik, keyboard_action);
 	}	
 
+		CPda* pda = smart_cast<CPda*>(Actor()->inventory().ActiveItem());
+
+		if (!pda)
 	return inherited::OnKeyboardAction(dik,keyboard_action);
+
+		return pda->Action(get_binded_action(dik), keyboard_action == WINDOW_KEY_PRESSED ? CMD_START : CMD_STOP);
+	}
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIPdaWnd.h xray-monolith/src/xrGame/ui/UIPdaWnd.h
--- coc-1.4-xray-64/src/xrGame/ui/UIPdaWnd.h	2023-10-20 20:54:51.473326500 +0100
+++ xray-monolith/src/xrGame/ui/UIPdaWnd.h	2023-10-20 20:54:33.377035600 +0100
@@ -21,2 +21,3 @@
 class UIHint;
+class CUIProgressBar;
 
@@ -46,2 +47,8 @@
 
+	u32 dwPDAFrame;
+
+	CUIProgressBar* m_battery_bar;
+
+	bool bButtonL, bButtonR;
+
 public:
@@ -51,3 +58,3 @@
 	CUILogsWnd*				pUILogsWnd;
-	
+	Frect m_cursor_box;
 	CMapSpot*				pSelectedMapSpot;
@@ -67,3 +73,6 @@
 	virtual void 			Show				(bool status);
-	virtual bool			OnMouseAction				(float x, float y, EUIMessages mouse_action) {CUIDialogWnd::OnMouseAction(x,y,mouse_action);return true;} //always true because StopAnyMove() == false
+
+	virtual bool OnMouseAction(float x, float y, EUIMessages mouse_action);
+	void MouseMovement(float x, float y);
+	virtual void Enable(bool status);
 	virtual bool			OnKeyboardAction			(int dik, EUIMessages keyboard_action);
@@ -81,2 +90,3 @@
 			LPCSTR			GetActiveSection	()					{return m_sActiveSection.c_str();};
+	CUITabControl* GetTabControl() { return UITabControl; };
 			
@@ -88,2 +98,21 @@
 			void			UpdateRankingWnd	();
+	void ResetCursor();
+	float m_power;
+	Fvector2 last_cursor_pos;
+
+	Fvector target_joystickrot, joystickrot;
+	float target_buttonpress, buttonpress;
+
+	void ResetJoystick(bool bForce)
+	{
+		if (bForce)
+		{
+			joystickrot.set(0.f, 0.f, 0.f);
+			buttonpress = 0.f;
+		}
+		
+		target_joystickrot.set(0.f, 0.f, 0.f);
+		target_buttonpress = 0.f;
+	}
+
 			DECLARE_SCRIPT_REGISTER_FUNCTION
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIProgressBar.h xray-monolith/src/xrGame/ui/UIProgressBar.h
--- coc-1.4-xray-64/src/xrGame/ui/UIProgressBar.h	2023-10-20 20:54:51.473326500 +0100
+++ xray-monolith/src/xrGame/ui/UIProgressBar.h	2023-10-20 20:54:33.377035600 +0100
@@ -60,2 +66,9 @@
 
+	virtual void SetColor(u32 color) { m_UIProgressItem.SetTextureColor(color); }
+	
+	void UseColor(bool status) { m_bUseColor = status; }
+	virtual void SetMinColor(u32 color) { m_minColor.set(color); }
+	virtual void SetMiddleColor(u32 color) { m_middleColor.set(color); }
+	virtual void SetMaxColor(u32 color) { m_maxColor.set(color); }
+	
 	virtual void		Draw						();
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIProgressBar_script.cpp xray-monolith/src/xrGame/ui/UIProgressBar_script.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIProgressBar_script.cpp	2023-10-20 20:54:51.474326800 +0100
+++ xray-monolith/src/xrGame/ui/UIProgressBar_script.cpp	2023-10-20 20:54:33.378035500 +0100
@@ -17,3 +17,11 @@
 		.def("GetRange_max",			&CUIProgressBar::GetRange_max)
+		.def("SetRange", &CUIProgressBar::SetRange)
 
+		// Tronex
+		.def("ShowBackground", &CUIProgressBar::ShowBackground)
+		.def("SetColor", &CUIProgressBar::SetColor)
+		.def("UseColor", &CUIProgressBar::UseColor)
+		.def("SetMinColor", &CUIProgressBar::SetMinColor)
+		.def("SetMiddleColor", &CUIProgressBar::SetMinColor)
+		.def("SetMaxColor", &CUIProgressBar::SetMinColor)
 	];
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIStatic_script.cpp xray-monolith/src/xrGame/ui/UIStatic_script.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIStatic_script.cpp	2023-10-20 20:54:51.488326600 +0100
+++ xray-monolith/src/xrGame/ui/UIStatic_script.cpp	2023-10-20 20:54:33.390036600 +0100
@@ -30,5 +30,12 @@
 		.def("InitTexture",			&CUIStatic::InitTexture )
+		.def("InitTextureEx", &CUIStatic::InitTextureEx)
 		.def("SetTextureRect",		&CUIStatic::SetTextureRect_script)
 		.def("SetStretchTexture",	&CUIStatic::SetStretchTexture)
-		.def("GetTextureRect",		&CUIStatic::GetTextureRect_script),
+		.def("GetTextureRect", &CUIStatic::GetTextureRect_script)
+		.def("EnableHeading", &CUIStatic::EnableHeading)
+		.def("GetHeading", &CUIStatic::GetHeading)
+		.def("SetHeading", &CUIStatic::SetHeading)
+		.def("SetConstHeading", &CUIStatic::SetConstHeading)
+		.def("GetConstHeading", &CUIStatic::GetConstHeading)
+		,
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIStatsIcon.cpp xray-monolith/src/xrGame/ui/UIStatsIcon.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIStatsIcon.cpp	2023-10-20 20:54:51.490326800 +0100
+++ xray-monolith/src/xrGame/ui/UIStatsIcon.cpp	2023-10-20 20:54:33.391035100 +0100
@@ -37,2 +39,8 @@
 
+	if (pSettings->line_exist(artefact_name, "icons_texture"))
+	{
+		LPCSTR icons_texture = pSettings->r_string(artefact_name, "icons_texture");
+		m_tex_info[ARTEFACT][0].sh = InventoryUtilities::GetCustomIconTextureShader(icons_texture);
+	}
+	else
 	m_tex_info[ARTEFACT][0].sh = InventoryUtilities::GetEquipmentIconsShader();
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UITabControl.cpp xray-monolith/src/xrGame/ui/UITabControl.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UITabControl.cpp	2023-10-20 20:54:51.494326500 +0100
+++ xray-monolith/src/xrGame/ui/UITabControl.cpp	2023-10-20 20:54:33.395035500 +0100
@@ -94,2 +95,5 @@
 {
+	if (!GetAcceleratorsMode())
+		return;
+
 	if (TAB_CHANGED == msg)
@@ -150,2 +154,3 @@
 
+	if (GetAcceleratorsMode())
 	GetMessageTarget()->SendMessage			(this, TAB_CHANGED, NULL);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UITabControl_script.cpp xray-monolith/src/xrGame/ui/UITabControl_script.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UITabControl_script.cpp	2023-10-20 20:54:51.495326300 +0100
+++ xray-monolith/src/xrGame/ui/UITabControl_script.cpp	2023-10-20 20:54:33.395035500 +0100
@@ -19,3 +19,5 @@
 		.def("SetActiveTab",			&CUITabControl::SetActiveTab_script)
-		.def("GetButtonById",			&CUITabControl::GetButtonById_script),
+		.def("GetButtonById", &CUITabControl::GetButtonById_script)
+		.def("GetEnabled", &CUITabControl::GetAcceleratorsMode)
+		.def("SetEnabled", &CUITabControl::SetAcceleratorsMode),
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UITalkWnd.cpp xray-monolith/src/xrGame/ui/UITalkWnd.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UITalkWnd.cpp	2023-10-20 20:54:51.496327900 +0100
+++ xray-monolith/src/xrGame/ui/UITalkWnd.cpp	2023-10-20 20:54:33.397038100 +0100
@@ -177,2 +179,5 @@
 {
+	if (Actor()->cam_freelook != eflDisabled)
+		return;
+
 	CCameraBase* cam = Actor()->cam_Active();
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UITrackBar.cpp xray-monolith/src/xrGame/ui/UITrackBar.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UITrackBar.cpp	2023-10-20 20:54:51.500326200 +0100
+++ xray-monolith/src/xrGame/ui/UITrackBar.cpp	2023-10-20 20:54:33.399037000 +0100
@@ -179,2 +182,18 @@
 
+void CUITrackBar::SetIValue(int i)
+{
+	m_i_val = i;
+	UpdatePos();
+}
+
+void CUITrackBar::SetFValue(float f)
+{
+	if (m_b_is_float)
+		m_f_val = f;
+	else
+		m_f_val = iFloor(f);
+	
+	UpdatePos();
+}
+
 void CUITrackBar::SetStep(float step)
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UITrackBar.h xray-monolith/src/xrGame/ui/UITrackBar.h
--- coc-1.4-xray-64/src/xrGame/ui/UITrackBar.h	2023-10-20 20:54:51.501326400 +0100
+++ xray-monolith/src/xrGame/ui/UITrackBar.h	2023-10-20 20:54:33.400036000 +0100
@@ -35,2 +35,4 @@
 			float	GetFValue				(){return m_f_val;}
+	void SetIValue(int i);
+	void SetFValue(float f);
 			void	SetOptIBounds			(int imin, int imax);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIWindow.cpp xray-monolith/src/xrGame/ui/UIWindow.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIWindow.cpp	2023-10-20 20:54:51.506326400 +0100
+++ xray-monolith/src/xrGame/ui/UIWindow.cpp	2023-10-20 20:54:33.402036700 +0100
@@ -7,2 +7,4 @@
 #include "../Include/xrRender/UIRender.h"
+#include "../UIGameCustom.h"
+#include "../ui/UIDialogWnd.h"
 //#include "UIHelper.h"
@@ -164,6 +171,7 @@
 
-
 void CUIWindow::Draw()
 {
-	for(WINDOW_LIST_it it = m_ChildWndList.begin(); m_ChildWndList.end() != it; ++it){
+	for (WINDOW_LIST_it it = m_ChildWndList.begin(); m_ChildWndList.end() != it; ++it)
+	{
+		if (!(*it)) continue;
 		if(!(*it)->IsShown())		continue;
@@ -189,3 +197,5 @@
 {
-	if (GetUICursor().IsVisible())
+	CUIDialogWnd* TIR = CurrentGameUI() ? CurrentGameUI()->TopInputReceiver() : nullptr;
+
+	if (GetUICursor().IsVisible() || (TIR && !TIR->NeedCursor()))
 	{
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIWindow.h xray-monolith/src/xrGame/ui/UIWindow.h
--- coc-1.4-xray-64/src/xrGame/ui/UIWindow.h	2023-10-20 20:54:51.506326400 +0100
+++ xray-monolith/src/xrGame/ui/UIWindow.h	2023-10-20 20:54:33.403035200 +0100
@@ -178,2 +228,4 @@
 
+	virtual bool NeedCursor() const { return true; }
+
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIWindow_script.cpp xray-monolith/src/xrGame/ui/UIWindow_script.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIWindow_script.cpp	2023-10-20 20:54:51.506326400 +0100
+++ xray-monolith/src/xrGame/ui/UIWindow_script.cpp	2023-10-20 20:54:33.403035200 +0100
@@ -7,3 +7,3 @@
 #include "../GamePersistent.h"
-#include "UILabel.h"
+//#include "UILabel.h"
 #include "UIMMShniaga.h"
@@ -129,3 +161,6 @@
 		.def("HideDialog",				&CUIDialogWnd::HideDialog)
-		.def("GetHolder",				&CUIDialogWnd::GetHolder),
+		.def("GetHolder", &CUIDialogWnd::GetHolder)
+		.def("AllowMovement", &CUIDialogWnd::AllowMovement)
+		.def("AllowCursor", &CUIDialogWnd::AllowCursor)
+		.def("AllowCenterCursor", &CUIDialogWnd::AllowCenterCursor),
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIWpnParams.cpp xray-monolith/src/xrGame/ui/UIWpnParams.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIWpnParams.cpp	2023-10-20 20:54:51.507326400 +0100
+++ xray-monolith/src/xrGame/ui/UIWpnParams.cpp	2023-10-20 20:54:33.404036800 +0100
@@ -1,2 +1,2 @@
-#include "pch_script.h"
+ï»¿#include "pch_script.h"
 #include "UIWpnParams.h"
@@ -71,4 +76,8 @@
 	AttachChild(&m_textAmmoUsedType);
-	AttachChild(&m_stAmmoType1);
-	AttachChild(&m_stAmmoType2);
+	//AttachChild(&m_stAmmoType1);
+	//AttachChild(&m_stAmmoType2);
+	AttachChild(&m_textAccuracy_inc);
+	AttachChild(&m_textDamage_inc);
+	AttachChild(&m_textHandling_inc);
+	AttachChild(&m_textRPM_inc);
 }
@@ -107,6 +116,31 @@
 		CUIXmlInit::InitTextWnd			(xml_doc, "wpn_params:cap_ammo_used_type",	0, &m_textAmmoUsedType);
-		CUIXmlInit::InitStatic			(xml_doc, "wpn_params:static_ammo_type1",	0, &m_stAmmoType1);
-		CUIXmlInit::InitStatic			(xml_doc, "wpn_params:static_ammo_type2",	0, &m_stAmmoType2);
-	}
+		//CUIXmlInit::InitStatic			(xml_doc, "wpn_params:static_ammo_type1",	0, &m_stAmmoType1);
+		//CUIXmlInit::InitStatic			(xml_doc, "wpn_params:static_ammo_type2",	0, &m_stAmmoType2);
+
+		CUIXmlInit::InitTextWnd(xml_doc, "wpn_params:cap_accuracy_inc", 0, &m_textAccuracy_inc);
+		CUIXmlInit::InitTextWnd(xml_doc, "wpn_params:cap_damage_inc", 0, &m_textDamage_inc);
+		CUIXmlInit::InitTextWnd(xml_doc, "wpn_params:cap_handling_inc", 0, &m_textHandling_inc);
+		CUIXmlInit::InitTextWnd(xml_doc, "wpn_params:cap_rpm_inc", 0, &m_textRPM_inc);
+
+		// ÐÑÐ²Ð¾Ð´Ð¸Ð¼ Ð¸ÐºÐ¾Ð½ÐºÐ¸ Ð´Ð»Ñ Ð»ÑÐ±Ð¾Ð³Ð¾ ÐºÐ¾Ð»-Ð²Ð° ÑÐ¸Ð¿Ð¾Ð² Ð¿Ð°ÑÑÐ¾Ð½Ð¾Ð², Ð¾Ð¿Ð¸ÑÐ°Ð½Ð½ÑÑ Ð² XML --#SM+#--
+		bool bAmmoTypeExistInXML = false;
+		string128 str;
+		u8 iCnt = 0;
+		do //--> Ð¡ÑÐ¸ÑÑÐ²Ð°ÐµÐ¼ ÐºÐ¾Ð»-Ð²Ð¾ ÑÐ»Ð¾ÑÐ¾Ð² Ð¿Ð¾Ð´ Ð¸ÐºÐ¾Ð½ÐºÐ¸ Ð¿Ð°ÑÑÐ¾Ð½Ð¾Ð² Ð² XML
+		{
+			iCnt++;
+			xr_sprintf(str, sizeof(str), "wpn_params:static_ammo_type%d", iCnt);
+
+			bAmmoTypeExistInXML = xml_doc.NavigateToNode(str, 0) != nullptr;
+			if (bAmmoTypeExistInXML)
+			{
+				CUIStatic* pStAmmoType = new CUIStatic();
+				AttachChild(pStAmmoType);
+				CUIXmlInit::InitStatic(xml_doc, str, 0, pStAmmoType);
 
+				m_vecStAmmoTypes.push_back(pStAmmoType);
+			}
+		}
+		while (bAmmoTypeExistInXML);
+	}
 }
@@ -146,5 +180,26 @@
 		slot_hand   = iFloor(g_lua_wpn_params->m_functorHandling( slot_section, str_upgrades )*53.0f)/53.0f;
-		slot_damage = ( GameID() == eGameIDSingle ) ?
-			iFloor(g_lua_wpn_params->m_functorDamage( slot_section, str_upgrades )*53.0f)/53.0f
+		slot_damage = (GameID() == eGameIDSingle)
+			              ? iFloor(g_lua_wpn_params->m_functorDamage(slot_section, str_upgrades) * 53.0f) / 53.0f
 			: iFloor(g_lua_wpn_params->m_functorDamageMP( slot_section, str_upgrades )*53.0f)/53.0f;
+
+		string128 str_value;
+		float adj_value = cur_accur - slot_accur;
+		xr_sprintf(str_value, sizeof(str_value), adj_value >= 0 ? "+%.1f%%" : "%.1f%%", adj_value);
+		m_textAccuracy_inc.SetText(str_value);
+		adj_value = cur_damage - slot_damage;
+		xr_sprintf(str_value, sizeof(str_value), adj_value >= 0 ? "+%.1f%%" : "%.1f%%", adj_value);
+		m_textDamage_inc.SetText(str_value);
+		adj_value = cur_hand - slot_hand;
+		xr_sprintf(str_value, sizeof(str_value), adj_value >= 0 ? "+%.1f%%" : "%.1f%%", adj_value);
+		m_textHandling_inc.SetText(str_value);
+		adj_value = cur_rpm - slot_rpm;
+		xr_sprintf(str_value, sizeof(str_value), adj_value >= 0 ? "+%.1f%%" : "%.1f%%", adj_value);
+		m_textRPM_inc.SetText(str_value);
+	}
+	else
+	{
+		m_textAccuracy_inc.SetText("");
+		m_textDamage_inc.SetText("");
+		m_textHandling_inc.SetText("");
+		m_textRPM_inc.SetText("");
 	}
@@ -192,17 +247,27 @@
 
-		m_stAmmoType1.SetShader(InventoryUtilities::GetEquipmentIconsShader());
-		Frect				tex_rect;
-		tex_rect.x1			= float(pSettings->r_u32(ammo_types[0].c_str(), "inv_grid_x") * INV_GRID_WIDTH);
-		tex_rect.y1			= float(pSettings->r_u32(ammo_types[0].c_str(), "inv_grid_y") * INV_GRID_HEIGHT);
-		tex_rect.x2			= float(pSettings->r_u32(ammo_types[0].c_str(), "inv_grid_width") * INV_GRID_WIDTH );
-		tex_rect.y2			= float(pSettings->r_u32(ammo_types[0].c_str(), "inv_grid_height") * INV_GRID_HEIGHT);
-		tex_rect.rb.add		(tex_rect.lt);
-		m_stAmmoType1.SetTextureRect(tex_rect);
-		m_stAmmoType1.TextureOn();
-		m_stAmmoType1.SetStretchTexture(true);
-		m_stAmmoType1.SetWndSize(Fvector2().set((tex_rect.x2-tex_rect.x1)*UI().get_current_kx(), tex_rect.y2-tex_rect.y1));
+		int counter = 0;
+		xr_vector<shared_str> good_ammo;
+
+		xr_vector<shared_str>::iterator it = ammo_types.begin();
+		for (; it != ammo_types.end();)
+		{
+			if (ammo_types[counter] != NULL && !strstr(ammo_types[counter].c_str(), "_bad") && !strstr(
+				ammo_types[counter].c_str(), "_verybad"))
+				good_ammo.push_back(ammo_types[counter].c_str());
+
+			it++;
+			counter++;
+		}
+
+		// ÐÑÐ²Ð¾Ð´Ð¸Ð¼ Ð¸ÐºÐ¾Ð½ÐºÐ¸ Ð¿Ð°ÑÑÐ¾Ð½Ð¾Ð² --#SM+#--
+		for (u8 i = 0; i < m_vecStAmmoTypes.size(); i++)
+		{
+			CUIStatic& StAmmoType = *m_vecStAmmoTypes[i];
 
-		m_stAmmoType2.SetShader(InventoryUtilities::GetEquipmentIconsShader());
-		if(ammo_types.size()==1)
+			StAmmoType.SetShader(InventoryUtilities::GetEquipmentIconsShader());
+
+			Frect tex_rect;
+			if (i >= good_ammo.size())
 		{
+				//--> ÐÑ Ð¿ÑÐµÐ²ÑÑÐ¸Ð»Ð¸ ÐºÐ¾Ð»-Ð²Ð¾ ÑÐ¸Ð¿Ð¾Ð² Ð¿Ð°ÑÑÐ¾Ð½Ð¾Ð² Ñ ÑÐµÐºÑÑÐµÐ³Ð¾ Ð¾ÑÑÐ¶Ð¸Ñ - ÑÐºÑÑÐ²Ð°ÐµÐ¼ Ð»Ð¸ÑÐ½ÑÑ Ð¸ÐºÐ¾Ð½ÐºÑ
 			tex_rect.set(0,0,1,1);
@@ -211,12 +276,22 @@
 		{
-			tex_rect.x1			= float(pSettings->r_u32(ammo_types[1].c_str(), "inv_grid_x") * INV_GRID_WIDTH);
-			tex_rect.y1			= float(pSettings->r_u32(ammo_types[1].c_str(), "inv_grid_y") * INV_GRID_HEIGHT);
-			tex_rect.x2			= float(pSettings->r_u32(ammo_types[1].c_str(), "inv_grid_width") * INV_GRID_WIDTH );
-			tex_rect.y2			= float(pSettings->r_u32(ammo_types[1].c_str(), "inv_grid_height") * INV_GRID_HEIGHT);
+				if (pSettings->line_exist(good_ammo[i].c_str(), "icons_texture"))
+				{
+					LPCSTR icons_texture = pSettings->r_string(good_ammo[i].c_str(), "icons_texture");
+					StAmmoType.SetShader(InventoryUtilities::GetCustomIconTextureShader(icons_texture));
+				}
+
+				//--> ÐÐ½Ð°ÑÐµ Ð¾ÑÑÐ¸ÑÐ¾Ð²ÑÐ²Ð°ÐµÐ¼ ÐµÑ
+				tex_rect.x1 = float(pSettings->r_u32(good_ammo[i].c_str(), "inv_grid_x") * INV_GRID_WIDTH);
+				tex_rect.y1 = float(pSettings->r_u32(good_ammo[i].c_str(), "inv_grid_y") * INV_GRID_HEIGHT);
+				tex_rect.x2 = float(pSettings->r_u32(good_ammo[i].c_str(), "inv_grid_width") * INV_GRID_WIDTH);
+				tex_rect.y2 = float(pSettings->r_u32(good_ammo[i].c_str(), "inv_grid_height") * INV_GRID_HEIGHT);
 			tex_rect.rb.add		(tex_rect.lt);
 		}
-		m_stAmmoType2.SetTextureRect(tex_rect);
-		m_stAmmoType2.TextureOn();
-		m_stAmmoType2.SetStretchTexture(true);
-		m_stAmmoType2.SetWndSize(Fvector2().set((tex_rect.x2-tex_rect.x1)*UI().get_current_kx(), tex_rect.y2-tex_rect.y1));
+
+			StAmmoType.SetTextureRect(tex_rect);
+			StAmmoType.TextureOn();
+			StAmmoType.SetStretchTexture(true);
+			StAmmoType.SetWndSize(
+				Fvector2().set((tex_rect.x2 - tex_rect.x1) * UI().get_current_kx(), tex_rect.y2 - tex_rect.y1));
+		}
 	}
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIWpnParams.h xray-monolith/src/xrGame/ui/UIWpnParams.h
--- coc-1.4-xray-64/src/xrGame/ui/UIWpnParams.h	2023-10-20 20:54:51.508327200 +0100
+++ xray-monolith/src/xrGame/ui/UIWpnParams.h	2023-10-20 20:54:33.404036800 +0100
@@ -42,5 +42,9 @@
 	CUITextWnd				m_textAmmoCount2;
-	CUIStatic				m_stAmmoType1;
-	CUIStatic				m_stAmmoType2;
+	xr_vector<CUIStatic*> m_vecStAmmoTypes; //--#SM+#--
 	CUIStatic				m_Prop_line;
+
+	CUITextWnd m_textAccuracy_inc;
+	CUITextWnd m_textHandling_inc;
+	CUITextWnd m_textDamage_inc;
+	CUITextWnd m_textRPM_inc;
 };
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui/UIXmlInit.cpp xray-monolith/src/xrGame/ui/UIXmlInit.cpp
--- coc-1.4-xray-64/src/xrGame/ui/UIXmlInit.cpp	2023-10-20 20:54:51.508327200 +0100
+++ xray-monolith/src/xrGame/ui/UIXmlInit.cpp	2023-10-20 20:54:33.405035700 +0100
@@ -11,3 +11,3 @@
 #include "UITabControl.h"
-#include "UILabel.h"
+//#include "UILabel.h"
 #include "UIAnimatedStatic.h"
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui_base.cpp xray-monolith/src/xrGame/ui_base.cpp
--- coc-1.4-xray-64/src/xrGame/ui_base.cpp	2023-10-20 20:54:51.513326300 +0100
+++ xray-monolith/src/xrGame/ui_base.cpp	2023-10-20 20:54:33.410036600 +0100
@@ -58,8 +60,12 @@
 		src->push_back((*src)[0])	;
-		Fvector2 dir_pt,dir_uv;		float denum,t;
-		for (j=0; j<src->size()-1; j++)	{
+		Fvector2 dir_pt, dir_uv;
+		float denum, t;
+		for (u32 j = 0; j < src->size() - 1; j++)
+		{
 			if ((*src)[j].pt.similar((*src)[j+1].pt,EPS_S)) continue;
-			if (negative(cls[j]))	{
+			if (negative(cls[j]))
+			{
 				dest->push_back((*src)[j])	;
-				if (positive(cls[j+1]))	{
+				if (positive(cls[j + 1]))
+				{
 					// segment intersects plane
@@ -256,3 +270,12 @@
 {
-	return (Device.dwWidth)/float(Device.dwHeight) > (UI_BASE_WIDTH/UI_BASE_HEIGHT +0.01f);
+	return (float(Device.dwWidth) / float(Device.dwHeight)) > (UI_BASE_WIDTH / UI_BASE_HEIGHT + 0.01f);
+}
+
+u8 ui_core::screenmode()
+{
+	if ((float(Device.dwWidth) / float(Device.dwHeight)) > 1.8f)
+		return u8(2);
+	else if ((float(Device.dwWidth) / float(Device.dwHeight)) > (UI_BASE_WIDTH / UI_BASE_HEIGHT + 0.01f))
+		return u8(1);
+	return u8(0);
 }
@@ -271,7 +294,9 @@
 	string_path				str;
-	if(!is_widescreen()){
+	if (screenmode() == u8(0))
+	{
 		xr_sprintf(str, "%s", fn);
 		if ( NULL==strext(fn) ) xr_strcat(str, ".xml");
-	}else{
-
+	}
+	else
+	{
 		string_path			str_;
@@ -281,5 +306,6 @@
 			*strext(str)	= 0;
-			xr_strcat	(str, "_16.xml");
-		}else
-			xr_sprintf				(str, "%s_16", fn);
+			xr_strcat(str, screenmode() == u8(1) ? "_16.xml" : "_21.xml");
+		}
+		else
+			xr_sprintf(str, screenmode() == u8(1) ? "%s_16" : "%s_21", fn);
 
@@ -287,2 +313,13 @@
 		{
+			if (screenmode() == u8(2))
+			{
+				xr_sprintf(str, "%s_16", fn);
+				if (NULL == strext(fn)) xr_strcat(str, "_16.xml");
+
+				if (NULL != FS.exist(str_, "$game_config$", "ui\\", str))
+				{
+					return str;
+				}
+					
+			}
 			xr_sprintf(str, "%s", fn);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui_base.h xray-monolith/src/xrGame/ui_base.h
--- coc-1.4-xray-64/src/xrGame/ui_base.h	2023-10-20 20:54:51.514326400 +0100
+++ xray-monolith/src/xrGame/ui_base.h	2023-10-20 20:54:33.410036600 +0100
@@ -91,2 +93,3 @@
 	static	bool	is_widescreen					();
+	static u8 screenmode();
 	static	float	get_current_kx					();
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui_defs.h xray-monolith/src/xrGame/ui_defs.h
--- coc-1.4-xray-64/src/xrGame/ui_defs.h	2023-10-20 20:54:51.514326400 +0100
+++ xray-monolith/src/xrGame/ui_defs.h	2023-10-20 20:54:33.410036600 +0100
@@ -41,2 +61,7 @@
 	sPoly2D*	ClipPoly		(sPoly2D& S, sPoly2D& D) const;
+	void Clear() 
+	{
+		if (planes.size())
+			planes.clear();
+	}
 };
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ui_export_script.cpp xray-monolith/src/xrGame/ui_export_script.cpp
--- coc-1.4-xray-64/src/xrGame/ui_export_script.cpp	2023-10-20 20:54:51.514326400 +0100
+++ xray-monolith/src/xrGame/ui_export_script.cpp	2023-10-20 20:54:33.411035700 +0100
@@ -73,5 +73,5 @@
 			.def("GetDemoInfo",				&CMainMenu::GetDemoInfo)
-			.def("GetLoginMngr",			&CMainMenu::GetLoginMngr)
-			.def("GetAccountMngr",			&CMainMenu::GetAccountMngr)
-			.def("GetProfileStore",			&CMainMenu::GetProfileStore)
+		//.def("GetLoginMngr",			&CMainMenu::GetLoginMngr)
+		//.def("GetAccountMngr",			&CMainMenu::GetAccountMngr)
+		//.def("GetProfileStore",			&CMainMenu::GetProfileStore)
 	];
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/UICursor.cpp xray-monolith/src/xrGame/UICursor.cpp
--- coc-1.4-xray-64/src/xrGame/UICursor.cpp	2023-10-20 20:54:50.709326400 +0100
+++ xray-monolith/src/xrGame/UICursor.cpp	2023-10-20 20:54:32.660035700 +0100
@@ -76,2 +78,6 @@
 
+	u32 curFrame = Device.dwFrame;
+	if (curFrame == last_render_frame)
+		return;
+
 	m_static->SetWndPos	(vPos);
@@ -79,2 +85,4 @@
 	m_static->Draw		();
+
+	last_render_frame = curFrame;
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/UIDialogHolder.cpp xray-monolith/src/xrGame/UIDialogHolder.cpp
--- coc-1.4-xray-64/src/xrGame/UIDialogHolder.cpp	2023-10-20 20:54:50.711327000 +0100
+++ xray-monolith/src/xrGame/UIDialogHolder.cpp	2023-10-20 20:54:32.661035700 +0100
@@ -45,2 +46,4 @@
 
+#include "player_hud.h"
+
 void CDialogHolder::StartMenu(CUIDialogWnd* pDialog, bool bDoHideIndicators)
@@ -60,3 +63,5 @@
 		
-		if(bDoHideIndicators){
+		if (bDoHideIndicators)
+		{
+			if (!g_player_hud->m_adjust_mode)
 			psHUD_Flags.set				(HUD_CROSSHAIR_RT, FALSE);
@@ -132,2 +139,5 @@
 {
+	if (TopInputReceiver() == pDialog)
+		SetMainInputReceiver(NULL, false);
+
 	dlgItem itm		(pDialog);
@@ -141,5 +151,14 @@
 		(*it).enabled = false;
-	}
+		return;
 }
 
+	it = std::find(m_dialogsToRender_new.begin(), m_dialogsToRender_new.end(), itm);
+
+	if (it != m_dialogsToRender_new.end())
+	{
+		(*it).wnd->Show(false);
+		(*it).wnd->Enable(false);
+		(*it).enabled = false;
+	}
+}
 
@@ -229,3 +254,3 @@
 		for(; it!=m_dialogsToRender.end();++it)
-			if((*it).enabled && (*it).wnd->IsEnabled())
+			if ((*it).enabled && (*it).wnd && (*it).wnd->IsEnabled())
 				(*it).wnd->Update();
@@ -274,12 +303,12 @@
 		CObject* O = Level().CurrentEntity();
-		if( O ){
+		if (O)
+		{
 			IInputReceiver*		IR	= smart_cast<IInputReceiver*>( smart_cast<CGameObject*>(O) );
 			if (IR)
-//				IR->IR_OnKeyboardPress(get_binded_action(dik));
 			{
 				EGameActions action = get_binded_action(dik);
-				if(action!=kQUICK_USE_1 && action!=kQUICK_USE_2 && action!=kQUICK_USE_3 && action!=kQUICK_USE_4)
+				if (action > kDOWN && action < kCAM_1)
 					IR->IR_OnKeyboardPress(action);
 			}
-			return			(false);
+			return true;
 		}
@@ -361,3 +394,3 @@
 	if(!TIR->IR_process())	return false;
-	if (GetUICursor().IsVisible())
+	if (GetUICursor().IsVisible() || !TIR->NeedCursor())
 	{ 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/UIGameCustom.cpp xray-monolith/src/xrGame/UIGameCustom.cpp
--- coc-1.4-xray-64/src/xrGame/UIGameCustom.cpp	2023-10-20 20:54:50.714326800 +0100
+++ xray-monolith/src/xrGame/UIGameCustom.cpp	2023-10-20 20:54:32.663036200 +0100
@@ -167,3 +168,13 @@
     {
-        HidePdaMenu();
+		if (!psActorFlags.test(AF_3D_PDA)) HidePdaMenu();
+		
+		//---- before inventory mode ---------------------------
+		luabind::functor<bool> funct1;
+		if (ai().script_engine().functor("actor_menu_inventory.CUIActorMenu_OnMode_Inventory", funct1))
+		{
+			if (funct1())
+				return true;
+		}
+		//---------------------------------------------------------
+	
         auto actor = smart_cast<CInventoryOwner*>(Level().CurrentViewEntity());
@@ -181,2 +192,8 @@
         ActorMenu->HideDialog();
+	
+	//-------------------------------
+	luabind::functor<void> funct1;
+	if (ai().script_engine().functor("actor_menu_inventory.CUIActorMenu_OnHideActorMenu", funct1))
+		funct1();
+	//-------------------------------
 }
@@ -229,3 +247,3 @@
 	{
-		PdaMenu->ShowDialog(true);
+		PdaMenu->ShowDialog(false);
 		return true;
@@ -237,4 +255,4 @@
 {
-    if (PdaMenu->IsShown())
-        PdaMenu->HideDialog();
+	//if (PdaMenu->IsShown())
+	//	PdaMenu->HideDialog();
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/UIGameSP.cpp xray-monolith/src/xrGame/UIGameSP.cpp
--- coc-1.4-xray-64/src/xrGame/UIGameSP.cpp	2023-10-20 20:54:50.716326500 +0100
+++ xray-monolith/src/xrGame/UIGameSP.cpp	2023-10-20 20:54:32.666035600 +0100
@@ -23,2 +23,4 @@
 
+#include "Inventory.h"
+
 
@@ -40,3 +42,3 @@
 	HideActorMenu();
-	HidePdaMenu();
+	//HidePdaMenu();
 	CUIDialogWnd* mir = TopInputReceiver();
@@ -113,4 +115,11 @@
 		{
-			if ( !pActor->inventory_disabled() )
+			if (!psActorFlags.test(AF_3D_PDA) && !pActor->inventory_disabled())
+			{
+				luabind::functor<bool> funct;
+				if (ai().script_engine().functor("pda.pda_use", funct))
+				{
+					if (funct())
 				ShowPdaMenu();
+				}
+			}
 			break;
@@ -121,4 +129,8 @@
 			if ( !pActor->inventory_disabled() )
-				ShowActorMenu();
+			{
+				if (psActorFlags.test(AF_3D_PDA) && CurrentGameUI()->GetPdaMenu().IsShown())
+					pActor->inventory().Activate(NO_ACTIVE_SLOT);
 
+				ShowActorMenu();
+			}
 			break;
@@ -157,2 +170,12 @@
 
+	//---- before trade mode ---------------------------
+	luabind::functor<bool> funct1;
+	if (ai().script_engine().functor("actor_menu_inventory.CUIActorMenu_OnMode_Trade", funct1))
+	{
+		CGameObject* GO = smart_cast<CGameObject*>(pOtherOwner);
+		if (funct1(GO->lua_game_object()))
+			return;
+	}
+	//---------------------------------------------------------
+	
 	ActorMenu->SetActor		(pActorInv);
@@ -168,2 +191,12 @@
 
+	//---- before upgrade mode ---------------------------
+	luabind::functor<bool> funct1;
+	if (ai().script_engine().functor("actor_menu_inventory.CUIActorMenu_OnMode_Upgrade", funct1))
+	{
+		CGameObject* GO = smart_cast<CGameObject*>(pMech);
+		if (funct1(GO->lua_game_object()))
+			return;
+	}
+	//---------------------------------------------------------
+	
 	ActorMenu->SetActor		(pActorInv);
@@ -189,2 +222,12 @@
 
+	//---- before Loot mode ---------------------------
+	luabind::functor<bool> funct1;
+	if (ai().script_engine().functor("actor_menu_inventory.CUIActorMenu_OnMode_DeadBodySearch", funct1))
+	{
+		CGameObject* GO = smart_cast<CGameObject*>(pOtherOwner);
+		if (funct1(GO->lua_game_object()))
+			return;
+	}
+	//---------------------------------------------------------
+		
 	ActorMenu->SetActor		(pActorInv);
@@ -200,2 +243,12 @@
 	
+	//---- before Loot mode ---------------------------
+	luabind::functor<bool> funct1;
+	if (ai().script_engine().functor("actor_menu_inventory.CUIActorMenu_OnMode_DeadBodySearch", funct1))
+	{
+		CGameObject* GO = smart_cast<CGameObject*>(pBox);
+		if (funct1(GO->lua_game_object()))
+			return;
+	}
+	//---------------------------------------------------------
+	
 	ActorMenu->SetActor		(pActorInv);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/UIZoneMap.cpp xray-monolith/src/xrGame/UIZoneMap.cpp
--- coc-1.4-xray-64/src/xrGame/UIZoneMap.cpp	2023-10-20 20:54:50.722326700 +0100
+++ xray-monolith/src/xrGame/UIZoneMap.cpp	2023-10-20 20:54:32.671035500 +0100
@@ -24,2 +24,3 @@
 {	
+	disabled = false;
 }
@@ -42,3 +43,11 @@
 
+	BOOL bRotate = uiXml.ReadAttribInt("minimap:level_frame", 0, "rotate", TRUE);
+	BOOL bRounded = uiXml.ReadAttribInt("minimap:level_frame", 0, "rounded", TRUE);
+	BOOL bAspect = uiXml.ReadAttribInt("minimap:level_frame", 0, "aspect", TRUE);
+	u32 color = xml_init.GetColor(uiXml, "minimap:level_frame", 0, 0xff);
+
 	m_activeMap						= xr_new<CUIMiniMap>();
+	m_activeMap->SetRounded(bRounded);
+	m_activeMap->SetRotate(bRotate);
+	m_activeMap->SetTextureColor(color);
 	m_clipFrame.AttachChild			(m_activeMap);
@@ -58,3 +67,3 @@
 	{
-		float k = UI().get_current_kx();
+		float k = bAspect ? UI().get_current_kx() : 1;
 
@@ -106,3 +114,3 @@
 {
-	if ( !visible )
+	if (!visible || disabled)
 		return;
@@ -115,2 +123,5 @@
 {
+	if (disabled)
+		return;
+
 	CActor* pActor = smart_cast<CActor*>( Level().CurrentViewEntity() );
@@ -145,2 +158,3 @@
 {
+	if (m_activeMap->Rotate())
 	m_activeMap->SetHeading(angle);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/UIZoneMap.h xray-monolith/src/xrGame/UIZoneMap.h
--- coc-1.4-xray-64/src/xrGame/UIZoneMap.h	2023-10-20 20:54:50.722326700 +0100
+++ xray-monolith/src/xrGame/UIZoneMap.h	2023-10-20 20:54:32.671035500 +0100
@@ -13,2 +13,3 @@
 	bool						visible;
+	bool disabled;
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/vertex_path_inline.h xray-monolith/src/xrGame/vertex_path_inline.h
--- coc-1.4-xray-64/src/xrGame/vertex_path_inline.h	2023-10-20 20:54:51.517326600 +0100
+++ xray-monolith/src/xrGame/vertex_path_inline.h	2023-10-20 20:54:33.413036400 +0100
@@ -55,3 +55,4 @@
 	CGraphVertex			*t1 = best, *t2 = best->back();
-	for (u32 i=1; t2; t1 = t2, t2 = t2->back(), ++i) ;
+	u32 i = 1;
+	for (; t2; t1 = t2, t2 = t2->back(), ++i);
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Weapon.cpp xray-monolith/src/xrGame/Weapon.cpp
--- coc-1.4-xray-64/src/xrGame/Weapon.cpp	2023-10-20 20:54:50.723326700 +0100
+++ xray-monolith/src/xrGame/Weapon.cpp	2023-10-20 20:54:32.672035600 +0100
@@ -1,2 +1,2 @@
-////////////////////////////////////////////////////////////////////////////
+ï»¿////////////////////////////////////////////////////////////////////////////
 //	Modified by Axel DominatoR
@@ -31,2 +31,7 @@
 #include "Torch.h"
+#include "../xrCore/vector.h"
+#include "ActorNightVision.h"
+#include "HUDManager.h"
+#include "WeaponMagazinedWGrenade.h"
+#include "../xrEngine/GameMtlLib.h"
 
@@ -35,5 +40,47 @@
 
-BOOL	b_toggle_weapon_aim = FALSE;
+
+float f_weapon_deterioration = 1.0f;
 extern CUIXml*	pWpnScopeXml;
 
+//////////
+extern float scope_radius;
+
+Flags32 zoomFlags = {};
+extern float n_zoom_step_count;
+float sens_multiple = 1.0f;
+
+
+float CWeapon::SDS_Radius(bool alt) {
+	shared_str scope_tex_name;
+	if (m_zoomtype == 0 && zoomFlags.test(SDS))
+	{
+		if (0 != (m_flagsAddOnState & CSE_ALifeItemWeapon::eWeaponAddonScope) && m_scopes.size())
+		{
+			scope_tex_name = pSettings->r_string(GetScopeName(), alt ? "scope_texture_alt" : "scope_texture");
+		}
+		else
+		{
+			scope_tex_name = READ_IF_EXISTS(pSettings, r_string, cNameSect(), alt ? "scope_texture_alt" : "scope_texture", NULL);
+		}
+
+		if (scope_tex_name != 0) {
+			auto item = listScopeRadii.find(scope_tex_name);
+			if (item != listScopeRadii.end()) {
+				return item->second;
+			}
+			else {
+				return 0.0;
+			}
+		}
+		else {
+			return 0.0;
+		}
+	}
+	else {
+		return 0.0;
+	}
+}
+
+//////////
+
 CWeapon::CWeapon()
@@ -57,2 +104,3 @@
     eHandDependence = hdNone;
+	m_APk = 1.0f;
 
@@ -62,2 +110,6 @@
     m_zoom_params.m_pNight_vision = NULL;
+	m_zoom_params.m_fSecondVPFovFactor = 0.0f;
+
+	m_altAimPos = false;
+	m_zoomtype = 0;
 
@@ -81,6 +133,20 @@
     m_activation_speed_is_overriden = false;
-    m_cur_scope = NULL;
+	m_cur_scope = 0;
     m_bRememberActorNVisnStatus = false;
+	m_fLR_ShootingFactor = 0.f;
+	m_fUD_ShootingFactor = 0.f;
+	m_fBACKW_ShootingFactor = 0.f;
+	m_bCanBeLowered = false;
+	m_fSafeModeRotateTime = 0.f;
+	bClearJamOnly = false;
+
+	//PP.RQ.range = 0.f;
+	//PP.RQ.set(NULL, 0.f, -1);
+
+	bHasBulletsToHide = false;
+	bullet_cnt = 0;
+	IsCustomReloadAvaible = false;
 }
 
+extern int scope_2dtexactive; //crookr
 CWeapon::~CWeapon()
@@ -200,2 +266,149 @@
 
+void updateCurrentScope() {
+	if (!g_pGameLevel) return;
+
+	CInventoryOwner* pGameObject = smart_cast<CInventoryOwner*>(Level().Objects.net_Find(0));
+	if (pGameObject) {
+		if (pGameObject->inventory().ActiveItem()) {
+			CWeapon* weapon = smart_cast<CWeapon*>(pGameObject->inventory().ActiveItem());
+			if (weapon) {
+				weapon->UpdateZoomParams();
+			}
+		}
+	}
+}
+
+void CWeapon::UpdateZoomParams() {
+	//////////
+	m_zoom_params.m_fMinBaseZoomFactor = READ_IF_EXISTS(pSettings, r_float, cNameSect(), "min_scope_zoom_factor", 200.0f);
+
+
+	float zoom_multiple = 1.0f;
+	if (zoomFlags.test(SDS_ZOOM) && (SDS_Radius() > 0.0)) {
+		zoom_multiple = scope_scrollpower;
+	}
+
+	//////////
+
+	// Load scopes.xml if it's not loaded
+	if (pWpnScopeXml == nullptr)
+	{
+		pWpnScopeXml = new CUIXml();
+		pWpnScopeXml->Load(CONFIG_PATH, UI_PATH, "scopes.xml");
+	}
+
+	// update zoom factor
+	if (m_zoomtype == 2) //GL
+	{
+		m_zoom_params.m_bUseDynamicZoom = m_zoom_params.m_bUseDynamicZoom_GL || READ_IF_EXISTS(pSettings, r_bool, cNameSect(), "scope_dynamic_zoom_gl", false);
+		m_zoom_params.m_fScopeZoomFactor = g_player_hud->m_adjust_mode ? g_player_hud->m_adjust_zoom_factor[1] : READ_IF_EXISTS(pSettings, r_float, cNameSect(), "gl_zoom_factor", 0);
+	} else if (m_zoomtype == 1) //Alt
+	{
+		m_zoom_params.m_bUseDynamicZoom = m_zoom_params.m_bUseDynamicZoom_Alt || READ_IF_EXISTS(pSettings, r_bool, cNameSect(), "scope_dynamic_zoom_alt", false);
+		m_zoom_params.m_fScopeZoomFactor = (g_player_hud->m_adjust_mode ? g_player_hud->m_adjust_zoom_factor[2] : READ_IF_EXISTS(pSettings, r_float, cNameSect(), "scope_zoom_factor_alt", 0)) / (READ_IF_EXISTS(pSettings, r_string, cNameSect(), "scope_texture_alt", NULL) && zoomFlags.test(SDS_ZOOM) && (SDS_Radius(true) > 0.0) ? zoom_multiple : 1);
+	} else //Main Sight
+	{
+		m_zoom_params.m_bUseDynamicZoom = m_zoom_params.m_bUseDynamicZoom_Primary || READ_IF_EXISTS(pSettings, r_bool, cNameSect(), "scope_dynamic_zoom", false);
+		if (g_player_hud->m_adjust_mode)
+		{
+			m_zoom_params.m_fScopeZoomFactor = g_player_hud->m_adjust_zoom_factor[0] / zoom_multiple;
+		} else if (ALife::eAddonPermanent != m_eScopeStatus && 0 != (m_flagsAddOnState & CSE_ALifeItemWeapon::eWeaponAddonScope) && m_scopes.size())
+		{
+			m_zoom_params.m_fScopeZoomFactor = pSettings->r_float(GetScopeName(), "scope_zoom_factor") / zoom_multiple;
+		} else
+		{
+			m_zoom_params.m_fScopeZoomFactor = m_zoom_params.m_fBaseZoomFactor / zoom_multiple;
+		}
+	}
+
+	if (IsZoomed()) {
+		scope_radius = SDS_Radius();
+		if (m_zoomtype == 0 && zoomFlags.test(SDS_SPEED) && (scope_radius > 0.0)) {
+			sens_multiple = scope_scrollpower;
+		} else {
+			sens_multiple = 1.0f;
+		}
+
+
+		if (m_zoom_params.m_bUseDynamicZoom) {
+			SetZoomFactor(m_fRTZoomFactor / zoom_multiple);
+		} else {
+			SetZoomFactor(m_zoom_params.m_fScopeZoomFactor);
+		}
+	}
+}
+
+void CWeapon::UpdateUIScope()
+{
+	UpdateZoomParams();
+
+	// Change or remove scope texture
+	shared_str scope_tex_name;
+	if (m_zoomtype == 0)
+	{
+		if (0 != (m_flagsAddOnState & CSE_ALifeItemWeapon::eWeaponAddonScope) && m_scopes.size())
+		{
+			scope_tex_name = pSettings->r_string(GetScopeName(), "scope_texture");
+		}
+		else
+		{
+			scope_tex_name = READ_IF_EXISTS(pSettings, r_string, cNameSect(), "scope_texture", NULL);
+		}
+	}
+	else if (m_zoomtype == 1)
+	{
+		scope_tex_name = READ_IF_EXISTS(pSettings, r_string, cNameSect(), "scope_texture_alt", NULL);
+	}
+
+	if (!g_dedicated_server)
+	{
+		xr_delete(m_UIScope);
+		scope_2dtexactive = 0; //crookr
+
+		if (!scope_tex_name || scope_tex_name.equal("none") || g_player_hud->m_adjust_mode)
+			return;
+
+		m_UIScope = xr_new<CUIWindow>();
+		CUIXmlInit::InitWindow(*pWpnScopeXml, scope_tex_name.c_str(), 0, m_UIScope);
+	}
+}
+
+void CWeapon::SwitchZoomType()
+{
+	if (m_zoomtype == 0 && (m_altAimPos || g_player_hud->m_adjust_mode))
+	{
+		m_zoomtype = 1;
+        m_zoom_params.m_bUseDynamicZoom = m_zoom_params.m_bUseDynamicZoom_Alt || READ_IF_EXISTS(pSettings, r_bool, cNameSect(), "scope_dynamic_zoom_alt", false);
+	}
+	else if (IsGrenadeLauncherAttached())
+	{
+		SwitchState(eSwitch);
+		return;
+	}
+	else if (m_zoomtype != 0)
+	{
+		m_zoomtype = 0;
+        m_zoom_params.m_bUseDynamicZoom = m_zoom_params.m_bUseDynamicZoom_Primary || READ_IF_EXISTS(pSettings, r_bool, cNameSect(), "scope_dynamic_zoom", false);
+	}
+
+	UpdateUIScope();
+}
+
+extern float g_ironsights_factor;
+
+float CWeapon::GetHudFov()
+{
+	float base = inherited::GetHudFov();
+
+	/*
+	if (m_zoom_params.m_fBaseZoomFactor == 0.f)
+	{
+		base = _lerp(base, base * (g_ironsights_factor / 1.7f), m_zoom_params.m_fZoomRotationFactor);
+		clamp(base, 0.1f, 1.f);
+	}
+	*/
+
+	return base;
+}
+
 void CWeapon::ForceUpdateFireParticles()
@@ -245,5 +459,5 @@
     ////////////////////////////////////////////////////
-    // äèñïåðñèÿ ñòðåëüáû
+	// Ã¤Ã¨Ã±Ã¯Ã¥Ã°Ã±Ã¨Ã¿ Ã±Ã²Ã°Ã¥Ã«Ã¼Ã¡Ã»
 
-    //ïîäáðàñûâàíèå êàìåðû âî âðåìÿ îòäà÷è
+	//Ã¯Ã®Ã¤Ã¡Ã°Ã Ã±Ã»Ã¢Ã Ã­Ã¨Ã¥ ÃªÃ Ã¬Ã¥Ã°Ã» Ã¢Ã® Ã¢Ã°Ã¥Ã¬Ã¿ Ã®Ã²Ã¤Ã Ã·Ã¨
     u8 rm = READ_IF_EXISTS(pSettings, r_u8, section, "cam_return", 1);
@@ -297,4 +511,4 @@
 
-    //ïîäáðàñûâàíèå êàìåðû âî âðåìÿ îòäà÷è â ðåæèìå zoom ==> ironsight or scope
-    //zoom_cam_recoil.Clone( cam_recoil ); ==== íåëüçÿ !!!!!!!!!!
+	//Ã¯Ã®Ã¤Ã¡Ã°Ã Ã±Ã»Ã¢Ã Ã­Ã¨Ã¥ ÃªÃ Ã¬Ã¥Ã°Ã» Ã¢Ã® Ã¢Ã°Ã¥Ã¬Ã¿ Ã®Ã²Ã¤Ã Ã·Ã¨ Ã¢ Ã°Ã¥Ã¦Ã¨Ã¬Ã¥ zoom ==> ironsight or scope
+	//zoom_cam_recoil.Clone( cam_recoil ); ==== Ã­Ã¥Ã«Ã¼Ã§Ã¿ !!!!!!!!!!
     zoom_cam_recoil.RelaxSpeed = cam_recoil.RelaxSpeed;
@@ -359,2 +573,3 @@
     m_pdm.m_fPDM_disp_crouch_no_acc = pSettings->r_float(section, "PDM_disp_crouch_no_acc");
+	m_pdm.m_fPDM_disp_buckShot = READ_IF_EXISTS(pSettings, r_float, section, "PDM_disp_buckshot", 1.f);
     m_crosshair_inertion = READ_IF_EXISTS(pSettings, r_float, section, "crosshair_inertion", 5.91f);
@@ -389,3 +605,3 @@
 
-    // èíôîðìàöèÿ î âîçìîæíûõ àïãðåéäàõ è èõ âèçóàëèçàöèè â èíâåíòàðå
+	// Ã¨Ã­Ã´Ã®Ã°Ã¬Ã Ã¶Ã¨Ã¿ Ã® Ã¢Ã®Ã§Ã¬Ã®Ã¦Ã­Ã»Ãµ Ã Ã¯Ã£Ã°Ã¥Ã©Ã¤Ã Ãµ Ã¨ Ã¨Ãµ Ã¢Ã¨Ã§Ã³Ã Ã«Ã¨Ã§Ã Ã¶Ã¨Ã¨ Ã¢ Ã¨Ã­Ã¢Ã¥Ã­Ã²Ã Ã°Ã¥
     m_eScopeStatus = (ALife::EWeaponAddonStatus)pSettings->r_s32(section, "scope_status");
@@ -394,4 +610,8 @@
 
+	m_altAimPos = READ_IF_EXISTS(pSettings, r_bool, section, "use_alt_aim_hud", false);
+
     m_zoom_params.m_bZoomEnabled = !!pSettings->r_bool(section, "zoom_enabled");
     m_zoom_params.m_fZoomRotateTime = pSettings->r_float(section, "zoom_rotate_time");
+	m_fZoomRotateModifier = READ_IF_EXISTS(pSettings, r_float, section, "zoom_rotate_modifier", 1);
+	m_zoom_params.m_fBaseZoomFactor = READ_IF_EXISTS(pSettings, r_float, cNameSect(), "scope_zoom_factor", 0);
 
@@ -416,4 +636,6 @@
     {
-        shared_str scope_tex_name = pSettings->r_string(cNameSect(), "scope_texture");
-        m_zoom_params.m_fScopeZoomFactor = pSettings->r_float(cNameSect(), "scope_zoom_factor");
+		shared_str scope_tex_name = READ_IF_EXISTS(pSettings, r_string, cNameSect(), "scope_texture", NULL);
+
+		if (!!scope_tex_name && !scope_tex_name.equal("none") && !g_player_hud->m_adjust_mode)
+		{
         if (!g_dedicated_server)
@@ -429,2 +651,3 @@
     }
+	}
 
@@ -455,2 +678,3 @@
 
+	m_zoom_params.m_fSecondVPFovFactor = READ_IF_EXISTS(pSettings, r_float, section, "scope_lense_fov", 0.0f);
     m_zoom_params.m_bHideCrosshairInZoom = true;
@@ -487,2 +713,33 @@
 	m_flags.set( FUsingCondition, READ_IF_EXISTS( pSettings, r_bool, section, "use_condition", TRUE ));
+
+	m_APk = READ_IF_EXISTS(pSettings, r_float, section, "ap_modifier", 1.0f);
+
+	m_bCanBeLowered = READ_IF_EXISTS(pSettings, r_bool, section, "can_be_lowered", false);
+
+	m_fSafeModeRotateTime = READ_IF_EXISTS(pSettings, r_float, section, "weapon_lower_speed", 1.f);
+
+	UpdateUIScope();
+
+	// Rezy safemode blend anms
+	m_safemode_anm[0].name = READ_IF_EXISTS(pSettings, r_string, *hud_sect, "safemode_anm", nullptr);
+	m_safemode_anm[1].name = READ_IF_EXISTS(pSettings, r_string, *hud_sect, "safemode_anm2", nullptr);
+	m_safemode_anm[0].speed = READ_IF_EXISTS(pSettings, r_float, *hud_sect, "safemode_anm_speed", 1.f);
+	m_safemode_anm[1].speed = READ_IF_EXISTS(pSettings, r_float, *hud_sect, "safemode_anm_speed2", 1.f);
+	m_safemode_anm[0].power = READ_IF_EXISTS(pSettings, r_float, *hud_sect, "safemode_anm_power", 1.f);
+	m_safemode_anm[1].power = READ_IF_EXISTS(pSettings, r_float, *hud_sect, "safemode_anm_power2", 1.f);
+
+	m_shoot_shake_mat.identity();
+}
+
+// demonized: World model on stalkers adjustments
+void CWeapon::set_mFirePoint(Fvector &fire_point) {
+	vLoadedFirePoint = fire_point;
+}
+
+void CWeapon::set_mFirePoint2(Fvector &fire_point) {
+	vLoadedFirePoint2 = fire_point;
+}
+
+void CWeapon::set_mShellPoint(Fvector &fire_point) {
+	vLoadedShellPoint = fire_point;
 }
@@ -514,4 +771,13 @@
 
+void GetZoomData(const float scope_factor, float& delta, float& min_zoom_factor);
+
 BOOL CWeapon::net_Spawn(CSE_Abstract* DC)
 {
+	if (m_zoom_params.m_bUseDynamicZoom)
+	{
+		float delta, min_zoom_factor;
+		GetZoomData(m_zoom_params.m_fScopeZoomFactor, delta, min_zoom_factor);
+		m_fRTZoomFactor = min_zoom_factor;
+	}
+	else
     m_fRTZoomFactor = m_zoom_params.m_fScopeZoomFactor;
@@ -521,3 +788,2 @@
 
-    //iAmmoCurrent					= E->a_current;
     iAmmoElapsed = E->a_elapsed;
@@ -528,3 +794,3 @@
 
-    m_DefaultCartridge.Load(m_ammoTypes[m_ammoType].c_str(), m_ammoType);
+	m_DefaultCartridge.Load(m_ammoTypes[m_ammoType].c_str(), m_ammoType, m_APk);
     if (iAmmoElapsed)
@@ -551,3 +817,3 @@
 
-    //óäàëèòü îáúåêòû ïàðòèêëîâ
+	//Ã³Ã¤Ã Ã«Ã¨Ã²Ã¼ Ã®Ã¡ÃºÃ¥ÃªÃ²Ã» Ã¯Ã Ã°Ã²Ã¨ÃªÃ«Ã®Ã¢
     StopFlameParticles();
@@ -691,3 +960,3 @@
         if (OnClient()) SetAmmoElapsed(int(AmmoElapsed));
-        OnStateSwitch(u32(state));
+			OnStateSwitch(u32(state), GetState());
     }
@@ -724,2 +994,5 @@
     UpdateXForm();
+
+	if (ParentIsActor())
+		Actor()->set_safemode(false);
 }
@@ -728,2 +1001,5 @@
 {
+	m_fLR_ShootingFactor = 0.f;
+	m_fUD_ShootingFactor = 0.f;
+	m_fBACKW_ShootingFactor = 0.f;
     m_dwWeaponIndependencyTime = Level().timeServer();
@@ -751,3 +1027,3 @@
     inherited::OnActiveItem();
-    //åñëè ìû çàíðóæàåìñÿ è îðóæèå áûëî â ðóêàõ
+	//Ã¥Ã±Ã«Ã¨ Ã¬Ã» Ã§Ã Ã­Ã°Ã³Ã¦Ã Ã¥Ã¬Ã±Ã¿ Ã¨ Ã®Ã°Ã³Ã¦Ã¨Ã¥ Ã¡Ã»Ã«Ã® Ã¢ Ã°Ã³ÃªÃ Ãµ
     //.	SetState					(eIdle);
@@ -788,2 +1064,13 @@
 
+bool CWeapon::NeedBlendAnm()
+{
+	if (GetState() == eIdle && Actor()->is_safemode())
+		return true;
+
+	if (IsZoomed() && psDeviceFlags2.test(rsAimSway))
+		return true;
+
+	return inherited::NeedBlendAnm();
+}
+
 void CWeapon::OnH_B_Chield()
@@ -798,5 +1085,6 @@
 extern u32 hud_adj_mode;
+
 bool CWeapon::AllowBore()
 {
-    return true;
+	return !Actor()->is_safemode();
 }
@@ -807,6 +1095,6 @@
     UpdateHUDAddonsVisibility();
-    //ïîäñâåòêà îò âûñòðåëà
+	//Ã¯Ã®Ã¤Ã±Ã¢Ã¥Ã²ÃªÃ  Ã®Ã² Ã¢Ã»Ã±Ã²Ã°Ã¥Ã«Ã 
     UpdateLight();
 
-    //íàðèñîâàòü ïàðòèêëû
+	//Ã­Ã Ã°Ã¨Ã±Ã®Ã¢Ã Ã²Ã¼ Ã¯Ã Ã°Ã²Ã¨ÃªÃ«Ã»
     UpdateFlameParticles();
@@ -823,2 +1111,3 @@
             if (hud_adj_mode == 0 &&
+				g_player_hud->script_anim_part == u8(-1) &&
                 GetState() == eIdle &&
@@ -842,7 +1131,6 @@
             R_ASSERT(pA);
-            CTorch* pTorch = smart_cast<CTorch*>(pA->inventory().ItemFromSlot(TORCH_SLOT));
-            if (pTorch && pTorch->GetNightVisionStatus())
+			if (pA->GetNightVisionStatus())
             {
-                m_bRememberActorNVisnStatus = pTorch->GetNightVisionStatus();
-                pTorch->SwitchNightVision(false, false);
+				m_bRememberActorNVisnStatus = pA->GetNightVisionStatus();
+				pA->SwitchNightVision(false, false, false);
             }
@@ -868,8 +1157,4 @@
     {
-        CTorch* pTorch = smart_cast<CTorch*>(pA->inventory().ItemFromSlot(TORCH_SLOT));
-        if (pTorch)
-        {
-            pTorch->SwitchNightVision(true, false);
-            pTorch->GetNightVision()->PlaySounds(CNightVisionEffector::eIdleSound);
-        }
+		pA->SwitchNightVision(true, false, false);
+		pA->GetNightVision()->PlaySounds(CNightVisionEffector::eIdleSound);
     }
@@ -879,3 +1164,3 @@
 {
-    return !(IsZoomed() && ZoomTexture() && !IsRotatingToZoom());
+	return !Device.m_SecondViewport.IsSVPFrame() && !(IsZoomed() && ZoomTexture() && !IsRotatingToZoom());
 }
@@ -886,7 +1171,6 @@
 
-    //íàðèñîâàòü ïîäñâåòêó
-
+	//Ã­Ã Ã°Ã¨Ã±Ã®Ã¢Ã Ã²Ã¼ Ã¯Ã®Ã¤Ã±Ã¢Ã¥Ã²ÃªÃ³
     RenderLight();
 
-    //åñëè ìû â ðåæèìå ñíàéïåðêè, òî ñàì HUD ðèñîâàòü íå íàäî
+	//Ã¥Ã±Ã«Ã¨ Ã¬Ã» Ã¢ Ã°Ã¥Ã¦Ã¨Ã¬Ã¥ Ã±Ã­Ã Ã©Ã¯Ã¥Ã°ÃªÃ¨, Ã²Ã® Ã±Ã Ã¬ HUD Ã°Ã¨Ã±Ã®Ã¢Ã Ã²Ã¼ Ã­Ã¥ Ã­Ã Ã¤Ã®
     if (IsZoomed() && !IsRotatingToZoom() && ZoomTexture())
@@ -901,2 +1185,5 @@
 {
+	m_fLR_ShootingFactor = 0.f;
+	m_fUD_ShootingFactor = 0.f;
+	m_fBACKW_ShootingFactor = 0.f;
     if (H_Parent())
@@ -927,2 +1214,4 @@
 
+	CActor* pActor = smart_cast<CActor*>(H_Parent());
+
     switch (cmd)
@@ -930,5 +1219,2 @@
     case kWPN_FIRE:
-    {
-        //åñëè îðóæèå ÷åì-òî çàíÿòî, òî íè÷åãî íå äåëàòü
-        {
             if (IsPending())
@@ -937,7 +1223,13 @@
             if (flags&CMD_START)
+		{
+			if (pActor && pActor->is_safemode())
+			{
+				pActor->set_safemode(false);
+				return true;
+			}
+
                 FireStart();
+		}
             else
                 FireEnd();
-        };
-    }
     return true;
@@ -945,3 +1237,5 @@
     {
-        return SwitchAmmoType(flags);
+			//Disabled for script usage
+			//return SwitchAmmoType(flags);
+			return true;
     }
@@ -951,3 +1245,3 @@
         {
-            if (b_toggle_weapon_aim)
+			if (psActorFlags.test(AF_AIM_TOGGLE))
             {
@@ -959,3 +1253,8 @@
                         {
-                            if (GetState() != eIdle)
+							if (pActor && pActor->is_safemode())
+								pActor->set_safemode(false);
+
+							if (GetState() != eAimStart && HudAnimationExist("anm_idle_aim_start"))
+								SwitchState(eAimStart);
+							else if (GetState() != eIdle)
                                 SwitchState(eIdle);
@@ -965,2 +1265,6 @@
                     else
+					{
+						if (GetState() != eAimEnd && HudAnimationExist("anm_idle_aim_end"))
+							SwitchState(eAimEnd);
+
                         OnZoomOut();
@@ -968,2 +1272,3 @@
             }
+			}
             else
@@ -974,3 +1279,8 @@
                     {
-                        if (GetState() != eIdle)
+						if (pActor && pActor->is_safemode())
+							pActor->set_safemode(false);
+
+						if (GetState() != eAimStart && HudAnimationExist("anm_idle_aim_start"))
+							SwitchState(eAimStart);
+						else if (GetState() != eIdle)
                             SwitchState(eIdle);
@@ -979,6 +1290,9 @@
                 }
-                else
-                    if (IsZoomed())
+				else if (IsZoomed())
+				{
+					if (GetState() != eAimEnd && HudAnimationExist("anm_idle_aim_end"))
+						SwitchState(eAimEnd);
                         OnZoomOut();
             }
+			}
             return true;
@@ -990,3 +1304,3 @@
     case kWPN_ZOOM_DEC:
-        if (IsZoomEnabled() && IsZoomed())
+		if (IsZoomEnabled() && IsZoomed() && (flags & CMD_START))
         {
@@ -998,2 +1312,29 @@
             return false;
+	case kWPN_FUNC:
+		{
+			if (flags & CMD_START && !IsPending())
+			{
+				if (pActor && pActor->is_safemode())
+					pActor->set_safemode(false);
+
+				SwitchZoomType();
+			}
+			return true;
+		}
+	case kSAFEMODE:
+		{
+			if (pActor && flags & CMD_START && !IsPending() && m_bCanBeLowered)
+			{
+				bool new_state = !pActor->is_safemode();
+				pActor->set_safemode(new_state);
+				SetPending(TRUE);
+
+				if (!new_state && m_safemode_anm[1].name)
+					PlayBlendAnm(m_safemode_anm[1].name, m_safemode_anm[1].speed, m_safemode_anm[1].power, false);
+				else if (m_safemode_anm[0].name)
+					PlayBlendAnm(m_safemode_anm[0].name, m_safemode_anm[0].speed, m_safemode_anm[0].power, false);
+			}
+			return true;
+		}
+	break;
     }
@@ -1086,2 +1428,5 @@
 {
+	if (const_cast<CWeapon*>(this)->unlimited_ammo())
+		return 999;
+
     int ae_count = iAmmoElapsed;
@@ -1092,3 +1437,3 @@
 
-    //÷òîá íå äåëàòü ëèøíèõ ïåðåñ÷åòîâ
+	//Ã·Ã²Ã®Ã¡ Ã­Ã¥ Ã¤Ã¥Ã«Ã Ã²Ã¼ Ã«Ã¨Ã¸Ã­Ã¨Ãµ Ã¯Ã¥Ã°Ã¥Ã±Ã·Ã¥Ã²Ã®Ã¢
     if (m_pInventory->ModifyFrame() <= m_BriefInfo_CalcFrame)
@@ -1195,3 +1541,3 @@
 
-BOOL CWeapon::IsMisfire() const
+bool CWeapon::IsMisfire() const
 {
@@ -1199,2 +1545,8 @@
 }
+
+void CWeapon::SetMisfireScript(bool b)
+{
+	bMisfire = b;
+}
+
 void CWeapon::Reload()
@@ -1204,2 +1556,26 @@
 
+void CWeapon::HUD_VisualBulletUpdate(bool force, int force_idx)
+{
+	if (!bHasBulletsToHide)
+		return;
+
+	if (!GetHUDmode())	return;
+
+	bool hide = true;
+
+	//Msg("Print %d bullets", last_hide_bullet);
+
+	if (last_hide_bullet == bullet_cnt || force) hide = false;
+
+	for (u8 b = 0; b < bullet_cnt; b++)
+	{
+		u16 bone_id = HudItemData()->m_model->LL_BoneID(bullets_bones[b]);
+
+		if (bone_id != BI_NONE)
+			HudItemData()->set_bone_visible(bullets_bones[b], !hide);
+
+		if (b == last_hide_bullet) hide = false;
+	}
+}
+
 bool CWeapon::IsGrenadeLauncherAttached() const
@@ -1238,10 +1616,15 @@
 
-shared_str wpn_scope = "wpn_scope";
-shared_str wpn_silencer = "wpn_silencer";
-shared_str wpn_grenade_launcher = "wpn_launcher";
+#define WPN_SCOPE "wpn_scope"
+#define WPN_SILENCER "wpn_silencer"
+#define WPN_GRENADE_LAUNCHER "wpn_launcher"
 
 void CWeapon::UpdateHUDAddonsVisibility()
-{//actor only
+{
+	//actor only
     if (!GetHUDmode())										return;
 
+	static shared_str wpn_scope = WPN_SCOPE;
+	static shared_str wpn_silencer = WPN_SILENCER;
+	static shared_str wpn_grenade_launcher = WPN_GRENADE_LAUNCHER;
+
     //.	return;
@@ -1288,3 +1668,8 @@
 {
-    IKinematics* pWeaponVisual = smart_cast<IKinematics*>(Visual()); R_ASSERT(pWeaponVisual);
+	static shared_str wpn_scope = WPN_SCOPE;
+	static shared_str wpn_silencer = WPN_SILENCER;
+	static shared_str wpn_grenade_launcher = WPN_GRENADE_LAUNCHER;
+
+	IKinematics* pWeaponVisual = smart_cast<IKinematics*>(Visual());
+	R_ASSERT(pWeaponVisual);
 
@@ -1362,3 +1747,13 @@
 void CWeapon::InitAddons()
-{}
+{
+	UpdateUIScope();
+}
+
+bool CWeapon::ZoomHideCrosshair()
+{
+	if (g_player_hud->m_adjust_mode)
+		return false;
+
+	return m_zoom_params.m_bHideCrosshairInZoom || ZoomTexture();
+}
 
@@ -1366,14 +1761,23 @@
 {
-    return IsScopeAttached() ? m_zoom_params.m_fScopeZoomFactor : m_zoom_params.m_fIronSightZoomFactor;
+	return m_zoom_params.m_fScopeZoomFactor;
 };
-void GetZoomData(const float scope_factor, float& delta, float& min_zoom_factor);
+
 void CWeapon::OnZoomIn()
 {
+    //////////
+    scope_radius = SDS_Radius();
+
+	if ((scope_radius > 0.0) && zoomFlags.test(SDS_SPEED)) {
+		sens_multiple = scope_scrollpower;
+	}
+	else {
+		sens_multiple = 1.0f;
+	}
+    //////////
+    
     m_zoom_params.m_bIsZoomModeNow = true;
     if (m_zoom_params.m_bUseDynamicZoom)
-        SetZoomFactor(m_fRTZoomFactor);
+		SetZoomFactor(scope_radius > 0.0 ? m_fRTZoomFactor / scope_scrollpower : m_fRTZoomFactor);
     else
-        m_zoom_params.m_fCurrentZoomFactor = CurrentZoomFactor();
-
-    EnableHudInertion(FALSE);
+		SetZoomFactor(CurrentZoomFactor());
 
@@ -1386,3 +1790,3 @@
     if (m_zoom_params.m_sUseBinocularVision.size() && IsScopeAttached() && NULL == m_zoom_params.m_pVision)
-        m_zoom_params.m_pVision = xr_new<CBinocularsVision>(m_zoom_params.m_sUseBinocularVision/*"wpn_binoc"*/);
+		m_zoom_params.m_pVision = xr_new<CBinocularsVision>(m_zoom_params.m_sUseBinocularVision);
 
@@ -1395,3 +1799,4 @@
             {
-                m_zoom_params.m_pNight_vision = xr_new<CNightVisionEffector>(m_zoom_params.m_sUseZoomPostprocess/*"device_torch"*/);
+				m_zoom_params.m_pNight_vision = xr_new<CNightVisionEffector>(
+					m_zoom_params.m_sUseZoomPostprocess);
             }
@@ -1399,2 +1804,4 @@
     }
+
+	g_player_hud->updateMovementLayerState();
 }
@@ -1404,5 +1811,8 @@
     m_zoom_params.m_bIsZoomModeNow = false;
-    m_fRTZoomFactor = GetZoomFactor();//store current
+    if (m_zoom_params.m_bUseDynamicZoom)
+    {
+        m_fRTZoomFactor = scope_radius > 0.0 ? GetZoomFactor() * scope_scrollpower : GetZoomFactor(); //store current
+    }
+    
     m_zoom_params.m_fCurrentZoomFactor = g_fov;
-    EnableHudInertion(TRUE);
 
@@ -1421,2 +1831,9 @@
     }
+
+	g_player_hud->updateMovementLayerState();
+    
+    scope_radius = 0.0;
+    scope_2dtexactive = 0;
+    sens_multiple = 1.0f;
+
 }
@@ -1428,4 +1845,7 @@
     else
+	{
+		scope_2dtexactive = 0; //crookr
         return NULL;
 }
+}
 
@@ -1487,6 +1907,8 @@
 
-    if (m_eScopeStatus == ALife::eAddonAttachable)
+	if (m_eScopeStatus == ALife::eAddonAttachable && m_scopes.size())
     {
-        m_addon_holder_range_modifier = READ_IF_EXISTS(pSettings, r_float, GetScopeName(), "holder_range_modifier", m_holder_range_modifier);
-        m_addon_holder_fov_modifier = READ_IF_EXISTS(pSettings, r_float, GetScopeName(), "holder_fov_modifier", m_holder_fov_modifier);
+		m_addon_holder_range_modifier = READ_IF_EXISTS(pSettings, r_float, GetScopeName(), "holder_range_modifier",
+		                                               m_holder_range_modifier);
+		m_addon_holder_fov_modifier = READ_IF_EXISTS(pSettings, r_float, GetScopeName(), "holder_fov_modifier",
+		                                             m_holder_fov_modifier);
     }
@@ -1526,2 +1948,17 @@
 
+// demonized: World model on stalkers adjustments
+void CWeapon::set_mOffset(Fvector position, Fvector orientation) {
+	orientation.mul(PI / 180.f);
+
+	m_Offset.setHPB(orientation.x, orientation.y, orientation.z);
+	m_Offset.translate_over(position);
+}
+
+void CWeapon::set_mStrapOffset(Fvector position, Fvector orientation) {
+	orientation.mul(PI / 180.f);
+
+	m_StrapOffset.setHPB(orientation.x, orientation.y, orientation.z);
+	m_StrapOffset.translate_over(position);
+}
+
 void CWeapon::create_physic_shell()
@@ -1597,3 +2034,3 @@
 {
-    if (GetAmmoElapsed() || m_ammoTypes.empty())
+	if (const_cast<CWeapon*>(this)->unlimited_ammo() || GetAmmoElapsed() || m_ammoTypes.empty())
         return				(const_cast<CWeapon*>(this));
@@ -1618,3 +2056,3 @@
 {
-    if (m_ammoTypes.empty())
+	if (const_cast<CWeapon*>(this)->unlimited_ammo() || m_ammoTypes.empty())
         return				(this);
@@ -1654,12 +2093,47 @@
 
-void CWeapon::UpdateHudAdditonal(Fmatrix& trans)
+ICF static BOOL pick_trace_callback(collide::rq_result& result, LPVOID params)
 {
-    CActor* pActor = smart_cast<CActor*>(H_Parent());
-    if (!pActor)		return;
+	PickParam* pp = (PickParam*)params;
+	++pp->pass;
 
-    if ((IsZoomed() && m_zoom_params.m_fZoomRotationFactor <= 1.f) ||
-        (!IsZoomed() && m_zoom_params.m_fZoomRotationFactor > 0.f))
+	if (result.O)
     {
-        u8 idx = GetCurrentHudOffsetIdx();
-        //		if(idx==0)					return;
+		pp->RQ = result;
+		return FALSE;
+	}
+	else
+	{
+		CDB::TRI* T = Level().ObjectSpace.GetStaticTris() + result.element;
+
+		SGameMtl* mtl = GMLib.GetMaterialByIdx(T->material);
+		pp->power *= mtl->fVisTransparencyFactor;
+		if (pp->power > 0.34f)
+		{
+			return TRUE;
+		}
+	}
+	pp->RQ = result;
+	return FALSE;
+}
+
+/*void CWeapon::net_Relcase(CObject* object)
+{
+	if (!ParentIsActor())
+		return;
+
+	if (PP.RQ.O == object)
+		PP.RQ.O = NULL;
+
+	RQS.r_clear();
+}*/
+
+// ÐÐ±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°Ñ ÑÐµÐºÑÑÐµÐ³Ð¾ ÑÑÐ´Ð°
+void CWeapon::UpdateHudAdditional(Fmatrix& trans)
+{
+	CActor* pActor = smart_cast<CActor*>(H_Parent());
+	if (!pActor)
+		return;
+
+	if (IsZoomed() && (pActor->is_safemode()))
+		OnZoomOut();
 
@@ -1667,9 +2141,343 @@
         R_ASSERT(hi);
+
+	/*PP.RQ.O = 0;
+	PP.RQ.range = 3.f;
+	PP.RQ.element = -1;
+	PP.power = 1.0f;
+	PP.pass = 0;
+	RQS.r_clear();
+
+	const Fmatrix& fire_mat = HudItemData()->m_model->LL_GetTransform(HudItemData()->m_measures.m_fire_bone);
+	Fvector pos; // = get_LastFP();
+	Fvector offs = g_player_hud->m_adjust_mode ? g_player_hud->m_adjust_firepoint_shell[0][0] : HudItemData()->m_measures.m_fire_point_offset;
+	offs.z -= g_freelook_z_offset;
+	fire_mat.transform_tiny(pos, offs);
+	HudItemData()->m_item_transform.transform_tiny(pos);
+	Fvector offs;
+	fire_mat.transform_tiny(offs, { 0, 0, -pos.z -.5f }); //otherwise you can shoot through thin walls
+	pos.add(offs);
+	
+	// add RQ for weapon barrel collision
+	collide::ray_defs RD(pos, get_ParticlesXFORM().k, 3.f, CDB::OPT_CULL, collide::rqtBoth);
+	if (Level().ObjectSpace.RayQuery(RQS, RD, pick_trace_callback, &PP, NULL, Level().CurrentEntity()))
+		clamp(PP.RQ.range, 0.f, 3.f);
+
+	//Msg("RQ range: %f", PP.RQ.range);
+	*/
+
+	u8 idx = GetCurrentHudOffsetIdx();
+
+	//============= ÐÐ¾Ð²Ð¾ÑÐ¾Ñ ÑÑÐ²Ð¾Ð»Ð° Ð²Ð¾ Ð²ÑÐµÐ¼Ñ Ð°Ð¸Ð¼Ð° =============//
+	{
         Fvector						curr_offs, curr_rot;
+
+		if (g_player_hud->m_adjust_mode)
+		{
+			if (idx == 0)
+			{
+				curr_offs = { 0.f, 0.f, 0.f };
+				curr_rot = { 0.f, 0.f, 0.f };
+			}
+			else
+			{
+				curr_offs = g_player_hud->m_adjust_offset[0][idx]; //pos,aim
+				curr_rot = g_player_hud->m_adjust_offset[1][idx]; //rot,aim
+			}
+		}
+		else
+		{
         curr_offs = hi->m_measures.m_hands_offset[0][idx];//pos,aim
         curr_rot = hi->m_measures.m_hands_offset[1][idx];//rot,aim
+		}
+
+		float factor;
+		
+		if (idx == 4 || last_idx == 4)
+			factor = Device.fTimeDelta / m_fSafeModeRotateTime;
+		else
+			factor = Device.fTimeDelta /
+			(m_zoom_params.m_fZoomRotateTime * cur_silencer_koef.zoom_rotate_time * cur_scope_koef.zoom_rotate_time
+					* cur_launcher_koef.zoom_rotate_time);
+
+		if (curr_offs.similar(m_hud_offset[0], EPS))
+		{
+			m_hud_offset[0].set(curr_offs);
+		}
+		else
+		{
+			Fvector diff;
+			diff.set(curr_offs);
+			diff.sub(m_hud_offset[0]);
+			diff.mul(factor * 2.5f);
+			m_hud_offset[0].add(diff);
+		}
+
+		if (curr_rot.similar(m_hud_offset[1], EPS))
+		{
+			m_hud_offset[1].set(curr_rot);
+		}
+		else
+		{
+			Fvector diff;
+			diff.set(curr_rot);
+			diff.sub(m_hud_offset[1]);
+			diff.mul(factor * 2.5f);
+			m_hud_offset[1].add(diff);
+		}
+
+		// Remove pending state before weapon has fully moved to the new position to remove some delay
+		if (curr_offs.similar(m_hud_offset[0], .02f) && curr_rot.similar(m_hud_offset[1], .02f))
+		{
+			if ((idx == 4 || last_idx == 4) && IsPending()) SetPending(FALSE);
+			last_idx = idx;
+		}
+
+		Fmatrix hud_rotation;
+		hud_rotation.identity();
+		hud_rotation.rotateX(m_hud_offset[1].x);
+
+		Fmatrix hud_rotation_y;
+		hud_rotation_y.identity();
+		hud_rotation_y.rotateY(m_hud_offset[1].y);
+		hud_rotation.mulA_43(hud_rotation_y);
+
+		hud_rotation_y.identity();
+		hud_rotation_y.rotateZ(m_hud_offset[1].z);
+		hud_rotation.mulA_43(hud_rotation_y);
+
+		hud_rotation.translate_over(m_hud_offset[0]);
+		trans.mulB_43(hud_rotation);
+
+		if (pActor->IsZoomAimingMode())
+			m_zoom_params.m_fZoomRotationFactor += factor;
+		else
+			m_zoom_params.m_fZoomRotationFactor -= factor;
+
+		clamp(m_zoom_params.m_fZoomRotationFactor, 0.f, 1.f);
+	}
+
+	//============= ÐÐ¾Ð´Ð³Ð¾ÑÐ°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ Ð¾Ð±ÑÐ¸Ðµ Ð¿ÐµÑÐµÐ¼ÐµÐ½Ð½ÑÐµ =============//
+	clamp(idx, u8(0), u8(1));
+	bool bForAim = (idx == 1);
+
+	static float fAvgTimeDelta = Device.fTimeDelta;
+	fAvgTimeDelta = _inertion(fAvgTimeDelta, Device.fTimeDelta, 0.8f);
+
+	//============= Ð¡Ð´Ð²Ð¸Ð³ Ð¾ÑÑÐ¶Ð¸Ñ Ð¿ÑÐ¸ ÑÑÑÐµÐ»ÑÐ±Ðµ =============//
+	if (hi->m_measures.m_shooting_params.bShootShake)
+	{
+		// ÐÐ°ÑÐ°Ð¼ÐµÑÑÑ ÑÐ´Ð²Ð¸Ð³Ð°
+		float fShootingReturnSpeedMod = _lerp(
+			hi->m_measures.m_shooting_params.m_ret_speed,
+			hi->m_measures.m_shooting_params.m_ret_speed_aim,
+			m_zoom_params.m_fZoomRotationFactor);
+
+		float fShootingBackwOffset = _lerp(
+			hi->m_measures.m_shooting_params.m_shot_offset_BACKW.x,
+			hi->m_measures.m_shooting_params.m_shot_offset_BACKW.y,
+			m_zoom_params.m_fZoomRotationFactor);
+
+		Fvector4 vShOffsets; // x = L, y = R, z = U, w = D
+		vShOffsets.x = _lerp(
+			hi->m_measures.m_shooting_params.m_shot_max_offset_LRUD.x,
+			hi->m_measures.m_shooting_params.m_shot_max_offset_LRUD_aim.x,
+			m_zoom_params.m_fZoomRotationFactor);
+		vShOffsets.y = _lerp(
+			hi->m_measures.m_shooting_params.m_shot_max_offset_LRUD.y,
+			hi->m_measures.m_shooting_params.m_shot_max_offset_LRUD_aim.y,
+			m_zoom_params.m_fZoomRotationFactor);
+		vShOffsets.z = _lerp(
+			hi->m_measures.m_shooting_params.m_shot_max_offset_LRUD.z,
+			hi->m_measures.m_shooting_params.m_shot_max_offset_LRUD_aim.z,
+			m_zoom_params.m_fZoomRotationFactor);
+		vShOffsets.w = _lerp(
+			hi->m_measures.m_shooting_params.m_shot_max_offset_LRUD.w,
+			hi->m_measures.m_shooting_params.m_shot_max_offset_LRUD_aim.w,
+			m_zoom_params.m_fZoomRotationFactor);
+
+		// ÐÐ»Ð°Ð²Ð½Ð¾Ðµ Ð·Ð°ÑÑÑÐ°Ð½Ð¸Ðµ ÑÐ´Ð²Ð¸Ð³Ð° Ð¾Ñ ÑÑÑÐµÐ»ÑÐ±Ñ (Ð¾ÑÐ½Ð¾Ð²Ð½Ð¾Ðµ, Ð½Ð¾ Ð±ÐµÐ· Ð»Ð¸Ð½ÐµÐ¹Ð½Ð¾Ð¹ Ð½Ð¸ÐºÐ¾Ð³Ð´Ð° Ð½Ðµ Ð¾Ð¿ÑÑÑÐ¸Ñ Ð´Ð¾ Ð¿Ð¾Ð»Ð½Ð¾Ð³Ð¾ 0.0f)
+		m_fLR_ShootingFactor *= clampr(1.f - fAvgTimeDelta * fShootingReturnSpeedMod, 0.0f, 1.0f);
+		m_fUD_ShootingFactor *= clampr(1.f - fAvgTimeDelta * fShootingReturnSpeedMod, 0.0f, 1.0f);
+		m_fBACKW_ShootingFactor *= clampr(1.f - fAvgTimeDelta * fShootingReturnSpeedMod, 0.0f, 1.0f);
+
+		// ÐÐ¸Ð½Ð¸Ð¼Ð°Ð»ÑÐ½Ð¾Ðµ Ð»Ð¸Ð½ÐµÐ¹Ð½Ð¾Ðµ Ð·Ð°ÑÑÑÐ°Ð½Ð¸Ðµ ÑÐ´Ð²Ð¸Ð³Ð° Ð¾Ñ ÑÑÑÐµÐ»ÑÐ±Ñ Ð¿ÑÐ¸ Ð¿Ð¾ÐºÐ¾Ðµ (Ð³Ð¾ÑÐ¸Ð·Ð¾Ð½ÑÐ°Ð»Ñ)
+		{
+			float fRetSpeedMod = fShootingReturnSpeedMod * 0.125f;
+			if (m_fLR_ShootingFactor < 0.0f)
+			{
+				m_fLR_ShootingFactor += fAvgTimeDelta * fRetSpeedMod;
+				clamp(m_fLR_ShootingFactor, -1.0f, 0.0f);
+			}
+			else
+			{
+				m_fLR_ShootingFactor -= fAvgTimeDelta * fRetSpeedMod;
+				clamp(m_fLR_ShootingFactor, 0.0f, 1.0f);
+			}
+		}
+
+		// ÐÐ¸Ð½Ð¸Ð¼Ð°Ð»ÑÐ½Ð¾Ðµ Ð»Ð¸Ð½ÐµÐ¹Ð½Ð¾Ðµ Ð·Ð°ÑÑÑÐ°Ð½Ð¸Ðµ ÑÐ´Ð²Ð¸Ð³Ð° Ð¾Ñ ÑÑÑÐµÐ»ÑÐ±Ñ Ð¿ÑÐ¸ Ð¿Ð¾ÐºÐ¾Ðµ (Ð²ÐµÑÑÐ¸ÐºÐ°Ð»Ñ)
+		{
+			float fRetSpeedMod = fShootingReturnSpeedMod * 0.125f;
+			if (m_fUD_ShootingFactor < 0.0f)
+			{
+				m_fUD_ShootingFactor += fAvgTimeDelta * fRetSpeedMod;
+				clamp(m_fUD_ShootingFactor, -1.0f, 0.0f);
+			}
+			else
+			{
+				m_fUD_ShootingFactor -= fAvgTimeDelta * fRetSpeedMod;
+				clamp(m_fUD_ShootingFactor, 0.0f, 1.0f);
+			}
+		}
+
+		// ÐÐ¸Ð½Ð¸Ð¼Ð°Ð»ÑÐ½Ð¾Ðµ Ð»Ð¸Ð½ÐµÐ¹Ð½Ð¾Ðµ Ð·Ð°ÑÑÑÐ°Ð½Ð¸Ðµ ÑÐ´Ð²Ð¸Ð³Ð° Ð¾Ñ ÑÑÑÐµÐ»ÑÐ±Ñ Ð¿ÑÐ¸ Ð¿Ð¾ÐºÐ¾Ðµ (Ð²Ð¿ÐµÑÑÐ´\Ð½Ð°Ð·Ð°Ð´)
+		{
+			float fRetSpeedMod = fShootingReturnSpeedMod * 0.125f;
+			m_fBACKW_ShootingFactor -= fAvgTimeDelta * fRetSpeedMod;
+			clamp(m_fBACKW_ShootingFactor, 0.0f, 1.0f);
+		}
+
+		// ÐÑÐ¸Ð¼ÐµÐ½ÑÐµÐ¼ ÑÐ´Ð²Ð¸Ð³ Ð¾Ñ ÑÑÑÐµÐ»ÑÐ±Ñ Ðº ÑÑÐ´Ñ
+		{
+			float fLR_lim = (m_fLR_ShootingFactor < 0.0f ? vShOffsets.x : vShOffsets.y);
+			float fUD_lim = (m_fUD_ShootingFactor < 0.0f ? vShOffsets.z : vShOffsets.w);
+
+			Fvector curr_offs;
+			curr_offs = {
+				fLR_lim * m_fLR_ShootingFactor, fUD_lim * -1.f * m_fUD_ShootingFactor,
+				-1.f * fShootingBackwOffset * m_fBACKW_ShootingFactor
+			};
+
+			m_shoot_shake_mat.translate_over(curr_offs);
+			trans.mulB_43(m_shoot_shake_mat);
+		}
+	}
+
+	//======== ÐÑÐ¾Ð²ÐµÑÑÐµÐ¼ Ð´Ð¾ÑÑÑÐ¿Ð½Ð¾ÑÑÑ Ð¸Ð½ÐµÑÑÐ¸Ð¸ Ð¸ ÑÑÑÐµÐ¹ÑÐ° ========//
+	if (!g_player_hud->inertion_allowed())
+		return;
+
+	float fYMag = pActor->fFPCamYawMagnitude;
+	float fPMag = pActor->fFPCamPitchMagnitude;
+
+	//============= ÐÐ¾ÐºÐ¾Ð²Ð¾Ð¹ ÑÑÑÐµÐ¹Ñ Ñ Ð¾ÑÑÐ¶Ð¸ÐµÐ¼ =============//
+	// Ð Ð°ÑÑÑÐ¸ÑÑÐ²Ð°ÐµÐ¼ ÑÐ°ÐºÑÐ¾Ñ Ð±Ð¾ÐºÐ¾Ð²Ð¾Ð¹ ÑÐ¾Ð´ÑÐ±Ñ
+	float fStrafeMaxTime = hi->m_measures.m_strafe_offset[2][idx].y;
+	// ÐÐ°ÐºÑ. Ð²ÑÐµÐ¼Ñ Ð² ÑÐµÐºÑÐ½Ð´Ð°Ñ, Ð·Ð° ÐºÐ¾ÑÐ¾ÑÐ¾Ðµ Ð¼Ñ Ð½Ð°ÐºÐ»Ð¾Ð½Ð¸Ð¼ÑÑ Ð¸Ð· ÑÐµÐ½ÑÑÐ°Ð»ÑÐ½Ð¾Ð³Ð¾ Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ
+	if (fStrafeMaxTime <= EPS)
+		fStrafeMaxTime = 0.01f;
+
+	float fStepPerUpd = fAvgTimeDelta / fStrafeMaxTime; // ÐÐµÐ»Ð¸ÑÐ¸Ð½Ð° Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ ÑÐ°ÐºÑÐ¾ÑÐ° Ð¿Ð¾Ð²Ð¾ÑÐ¾ÑÐ°
+
+	// ÐÐ¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ Ð±Ð¾ÐºÐ¾Ð²Ð¾Ð¹ Ð½Ð°ÐºÐ»Ð¾Ð½ Ð¾Ñ Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ñ ÐºÐ°Ð¼ÐµÑÑ
+	float fCamReturnSpeedMod = 1.5f;
+	// ÐÐ¾ÑÐºÐ¾Ð»ÑÐºÐ¾ ÑÑÐºÐ¾ÑÑÐµÐ¼ Ð½Ð¾ÑÐ¼Ð°Ð»Ð¸Ð·Ð°ÑÐ¸Ñ Ð½Ð°ÐºÐ»Ð¾Ð½Ð°, Ð¿Ð¾Ð»ÑÑÐµÐ½Ð½Ð¾Ð³Ð¾ Ð¾Ñ Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ñ ÐºÐ°Ð¼ÐµÑÑ (ÑÐ¾Ð»ÑÐºÐ¾ Ð¾Ñ Ð±ÐµÐ´ÑÐ°)
+
+	// ÐÑÑÑÐ¸ÑÑÐ²Ð°ÐµÐ¼ Ð¼Ð¸Ð½Ð¸Ð¼Ð°Ð»ÑÐ½ÑÑ ÑÐºÐ¾ÑÐ¾ÑÑÑ Ð¿Ð¾Ð²Ð¾ÑÐ¾ÑÐ° ÐºÐ°Ð¼ÐµÑÑ Ð´Ð»Ñ Ð½Ð°ÑÐ°Ð»Ð° Ð¸Ð½ÐµÑÑÐ¸Ð¸
+	float fStrafeMinAngle = _lerp(
+		hi->m_measures.m_strafe_offset[3][0].y,
+		hi->m_measures.m_strafe_offset[3][1].y,
+		m_zoom_params.m_fZoomRotationFactor);
+
+	// ÐÑÑÑÐ¸ÑÑÐ²Ð°ÐµÐ¼ Ð¼ÐºÑÐ¸Ð¼Ð°Ð»ÑÐ½ÑÐ¹ Ð½Ð°ÐºÐ»Ð¾Ð½ Ð¾Ñ Ð¿Ð¾Ð²Ð¾ÑÐ¾ÑÐ° ÐºÐ°Ð¼ÐµÑÑ
+	float fCamLimitBlend = _lerp(
+		hi->m_measures.m_strafe_offset[3][0].x,
+		hi->m_measures.m_strafe_offset[3][1].x,
+		m_zoom_params.m_fZoomRotationFactor);
+
+	// Ð¡ÑÐ¸ÑÐ°ÐµÐ¼ ÑÑÑÐµÐ¹Ñ Ð¾Ñ Ð¿Ð¾Ð²Ð¾ÑÐ¾ÑÐ° ÐºÐ°Ð¼ÐµÑÑ
+	if (abs(fYMag) > (m_fLR_CameraFactor == 0.0f ? fStrafeMinAngle : 0.0f))
+	{
+		//--> ÐÐ°Ð¼ÐµÑÐ° ÐºÑÑÑÐ¸ÑÑÑ Ð¿Ð¾ Ð¾ÑÐ¸ Y
+		m_fLR_CameraFactor -= (fYMag * fAvgTimeDelta * 0.75f);
+		clamp(m_fLR_CameraFactor, -fCamLimitBlend, fCamLimitBlend);
+	}
+	else
+	{
+		//--> ÐÐ°Ð¼ÐµÑÐ° Ð½Ðµ Ð¿Ð¾Ð²Ð¾ÑÐ°ÑÐ¸Ð²Ð°ÐµÑÑÑ - ÑÐ±Ð¸ÑÐ°ÐµÐ¼ Ð½Ð°ÐºÐ»Ð¾Ð½
+		if (m_fLR_CameraFactor < 0.0f)
+		{
+			m_fLR_CameraFactor += fStepPerUpd * (bForAim ? 1.0f : fCamReturnSpeedMod);
+			clamp(m_fLR_CameraFactor, -fCamLimitBlend, 0.0f);
+		}
+		else
+		{
+			m_fLR_CameraFactor -= fStepPerUpd * (bForAim ? 1.0f : fCamReturnSpeedMod);
+			clamp(m_fLR_CameraFactor, 0.0f, fCamLimitBlend);
+		}
+	}
+
+	// ÐÐ¾Ð±Ð°Ð²Ð»ÑÐµÐ¼ Ð±Ð¾ÐºÐ¾Ð²Ð¾Ð¹ Ð½Ð°ÐºÐ»Ð¾Ð½ Ð¾Ñ ÑÐ¾Ð´ÑÐ±Ñ Ð²Ð±Ð¾Ðº
+	float fChangeDirSpeedMod = 3;
+	// ÐÐ¾ÑÐºÐ¾Ð»ÑÐºÐ¾ Ð±ÑÑÑÑÐ¾ Ð¼ÐµÐ½ÑÐµÐ¼ Ð½Ð°Ð¿ÑÐ°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð½Ð°Ð¿ÑÐ°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð½Ð°ÐºÐ»Ð¾Ð½Ð°, ÐµÑÐ»Ð¸ Ð¾Ð½Ð¾ Ð² Ð´ÑÑÐ³ÑÑ ÑÑÐ¾ÑÐ¾Ð½Ñ Ð¾Ñ ÑÐµÐºÑÑÐµÐ³Ð¾
+	u32 iMovingState = pActor->MovingState();
+	if ((iMovingState & mcLStrafe) != 0)
+	{
+		// ÐÐ²Ð¸Ð¶ÐµÐ¼ÑÑ Ð²Ð»ÐµÐ²Ð¾
+		float fVal = (m_fLR_MovingFactor > 0.f ? fStepPerUpd * fChangeDirSpeedMod : fStepPerUpd);
+		m_fLR_MovingFactor -= fVal;
+	}
+	else if ((iMovingState & mcRStrafe) != 0)
+	{
+		// ÐÐ²Ð¸Ð¶ÐµÐ¼ÑÑ Ð²Ð¿ÑÐ°Ð²Ð¾
+		float fVal = (m_fLR_MovingFactor < 0.f ? fStepPerUpd * fChangeDirSpeedMod : fStepPerUpd);
+		m_fLR_MovingFactor += fVal;
+	}
+	else
+	{
+		// ÐÐ²Ð¸Ð³Ð°ÐµÐ¼ÑÑ Ð² Ð»ÑÐ±Ð¾Ð¼ Ð´ÑÑÐ³Ð¾Ð¼ Ð½Ð°Ð¿ÑÐ°Ð²Ð»ÐµÐ½Ð¸Ð¸ - Ð¿Ð»Ð°Ð²Ð½Ð¾ ÑÐ±Ð¸ÑÐ°ÐµÐ¼ Ð½Ð°ÐºÐ»Ð¾Ð½
+		if (m_fLR_MovingFactor < 0.0f)
+		{
+			m_fLR_MovingFactor += fStepPerUpd;
+			clamp(m_fLR_MovingFactor, -1.0f, 0.0f);
+		}
+		else
+		{
+			m_fLR_MovingFactor -= fStepPerUpd;
+			clamp(m_fLR_MovingFactor, 0.0f, 1.0f);
+		}
+	}
+	clamp(m_fLR_MovingFactor, -1.0f, 1.0f); // Ð¤Ð°ÐºÑÐ¾Ñ Ð±Ð¾ÐºÐ¾Ð²Ð¾Ð¹ ÑÐ¾Ð´ÑÐ±Ñ Ð½Ðµ Ð´Ð¾Ð»Ð¶ÐµÐ½ Ð¿ÑÐµÐ²ÑÑÐ°ÑÑ ÑÑÐ¸ Ð»Ð¸Ð¼Ð¸ÑÑ
+
+	// ÐÑÑÐ¸ÑÐ»ÑÐµÐ¼ Ð¸ Ð½Ð¾ÑÐ¼Ð°Ð»Ð¸Ð·Ð¸ÑÑÐµÐ¼ Ð¸ÑÐ¾Ð³Ð¾Ð²ÑÐ¹ ÑÐ°ÐºÑÐ¾Ñ Ð½Ð°ÐºÐ»Ð¾Ð½Ð°
+	float fLR_Factor = m_fLR_MovingFactor; 
+	fLR_Factor += m_fLR_CameraFactor;
+
+	clamp(fLR_Factor, -1.0f, 1.0f); // Ð¤Ð°ÐºÑÐ¾Ñ Ð±Ð¾ÐºÐ¾Ð²Ð¾Ð¹ ÑÐ¾Ð´ÑÐ±Ñ Ð½Ðµ Ð´Ð¾Ð»Ð¶ÐµÐ½ Ð¿ÑÐµÐ²ÑÑÐ°ÑÑ ÑÑÐ¸ Ð»Ð¸Ð¼Ð¸ÑÑ
+
+	// ÐÑÐ¾Ð¸Ð·Ð²Ð¾Ð´Ð¸Ð¼ Ð½Ð°ÐºÐ»Ð¾Ð½ ÑÑÐ²Ð¾Ð»Ð° Ð´Ð»Ñ Ð½Ð¾ÑÐ¼Ð°Ð»ÑÐ½Ð¾Ð³Ð¾ ÑÐµÐ¶Ð¸Ð¼Ð° Ð¸ Ð°Ð¸Ð¼Ð°
+	for (int _idx = 0; _idx <= 1; _idx++) //<-- ÐÐ»Ñ Ð¿Ð»Ð°Ð²Ð½Ð¾Ð³Ð¾ Ð¿ÐµÑÐµÑÐ¾Ð´Ð°
+	{
+		bool bEnabled = (hi->m_measures.m_strafe_offset[2][_idx].x != 0.0f);
+		if (!bEnabled)
+			continue;
+
+		Fvector curr_offs, curr_rot;
+
+		// Ð¡Ð¼ÐµÑÐµÐ½Ð¸Ðµ Ð¿Ð¾Ð·Ð¸ÑÐ¸Ð¸ ÑÑÐ´Ð° Ð² ÑÑÑÐµÐ¹ÑÐµ
+		curr_offs = hi->m_measures.m_strafe_offset[0][_idx]; // pos
+		curr_offs.mul(fLR_Factor); // Ð£Ð¼Ð½Ð¾Ð¶Ð°ÐµÐ¼ Ð½Ð° ÑÐ°ÐºÑÐ¾Ñ ÑÑÑÐµÐ¹ÑÐ°
+
+		// ÐÐ¾Ð²Ð¾ÑÐ¾Ñ ÑÑÐ´Ð° Ð² ÑÑÑÐµÐ¹ÑÐµ
+		curr_rot = hi->m_measures.m_strafe_offset[1][_idx]; // rot
+		curr_rot.mul(-PI / 180.f); // ÐÑÐµÐ¾Ð±ÑÐ°Ð·ÑÐµÐ¼ ÑÐ³Ð»Ñ Ð² ÑÐ°Ð´Ð¸Ð°Ð½Ñ
+		curr_rot.mul(fLR_Factor); // Ð£Ð¼Ð½Ð¾Ð¶Ð°ÐµÐ¼ Ð½Ð° ÑÐ°ÐºÑÐ¾Ñ ÑÑÑÐµÐ¹ÑÐ°
+
+		// ÐÑÐ³ÐºÐ¸Ð¹ Ð¿ÐµÑÐµÑÐ¾Ð´ Ð¼ÐµÐ¶Ð´Ñ Ð±ÐµÐ´ÑÐ¾Ð¼ \ Ð¿ÑÐ¸ÑÐµÐ»Ð¾Ð¼
+		if (_idx == 0)
+		{
+			// ÐÑ Ð±ÐµÐ´ÑÐ°
+			curr_offs.mul(1.f - m_zoom_params.m_fZoomRotationFactor);
+			curr_rot.mul(1.f - m_zoom_params.m_fZoomRotationFactor);
+		}
+		else
+		{
+			// ÐÐ¾ Ð²ÑÐµÐ¼Ñ Ð°Ð¸Ð¼Ð°
         curr_offs.mul(m_zoom_params.m_fZoomRotationFactor);
         curr_rot.mul(m_zoom_params.m_fZoomRotationFactor);
+		}
 
         Fmatrix						hud_rotation;
+		Fmatrix hud_rotation_y;
+
         hud_rotation.identity();
@@ -1677,3 +2485,2 @@
 
-        Fmatrix						hud_rotation_y;
         hud_rotation_y.identity();
@@ -1688,12 +2495,146 @@
         trans.mulB_43(hud_rotation);
+	}
 
-        if (pActor->IsZoomAimingMode())
-            m_zoom_params.m_fZoomRotationFactor += Device.fTimeDelta / m_zoom_params.m_fZoomRotateTime;
+	//============= ÐÐ½ÐµÑÑÐ¸Ñ Ð¾ÑÑÐ¶Ð¸Ñ =============//
+	// ÐÐ°ÑÐ°Ð¼ÐµÑÑÑ Ð¸Ð½ÐµÑÑÐ¸Ð¸
+	float fInertiaSpeedMod = _lerp(
+		hi->m_measures.m_inertion_params.m_tendto_speed,
+		hi->m_measures.m_inertion_params.m_tendto_speed_aim,
+		m_zoom_params.m_fZoomRotationFactor);
+
+	float fInertiaReturnSpeedMod = _lerp(
+		hi->m_measures.m_inertion_params.m_tendto_ret_speed,
+		hi->m_measures.m_inertion_params.m_tendto_ret_speed_aim,
+		m_zoom_params.m_fZoomRotationFactor);
+
+	float fInertiaMinAngle = _lerp(
+		hi->m_measures.m_inertion_params.m_min_angle,
+		hi->m_measures.m_inertion_params.m_min_angle_aim,
+		m_zoom_params.m_fZoomRotationFactor);
+
+	Fvector4 vIOffsets; // x = L, y = R, z = U, w = D
+	vIOffsets.x = _lerp(
+		hi->m_measures.m_inertion_params.m_offset_LRUD.x,
+		hi->m_measures.m_inertion_params.m_offset_LRUD_aim.x,
+		m_zoom_params.m_fZoomRotationFactor);
+	vIOffsets.y = _lerp(
+		hi->m_measures.m_inertion_params.m_offset_LRUD.y,
+		hi->m_measures.m_inertion_params.m_offset_LRUD_aim.y,
+		m_zoom_params.m_fZoomRotationFactor);
+	vIOffsets.z = _lerp(
+		hi->m_measures.m_inertion_params.m_offset_LRUD.z,
+		hi->m_measures.m_inertion_params.m_offset_LRUD_aim.z,
+		m_zoom_params.m_fZoomRotationFactor);
+	vIOffsets.w = _lerp(
+		hi->m_measures.m_inertion_params.m_offset_LRUD.w,
+		hi->m_measures.m_inertion_params.m_offset_LRUD_aim.w,
+		m_zoom_params.m_fZoomRotationFactor);
+
+	// ÐÑÑÑÐ¸ÑÑÐ²Ð°ÐµÐ¼ Ð¸Ð½ÐµÑÑÐ¸Ñ Ð¸Ð· Ð¿Ð¾Ð²Ð¾ÑÐ¾ÑÐ¾Ð² ÐºÐ°Ð¼ÐµÑÑ
+	bool bIsInertionPresent = m_fLR_InertiaFactor != 0.0f || m_fUD_InertiaFactor != 0.0f;
+	if (abs(fYMag) > fInertiaMinAngle || bIsInertionPresent)
+	{
+		float fSpeed = fInertiaSpeedMod;
+		if (fYMag > 0.0f && m_fLR_InertiaFactor > 0.0f ||
+			fYMag < 0.0f && m_fLR_InertiaFactor < 0.0f)
+		{
+			fSpeed *= 2.f; //--> Ð£ÑÐºÐ¾ÑÑÐµÐ¼ Ð¸Ð½ÐµÑÑÐ¸Ñ Ð¿ÑÐ¸ Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ð¸ Ð² Ð¿ÑÐ¾ÑÐ¸Ð²Ð¾Ð¿Ð¾Ð»Ð¾Ð¶Ð½ÑÑ ÑÑÐ¾ÑÐ¾Ð½Ñ
+		}
+
+		m_fLR_InertiaFactor -= (fYMag * fAvgTimeDelta * fSpeed); // ÐÐ¾ÑÐ¸Ð·Ð¾Ð½ÑÐ°Ð»Ñ (Ð¼.Ð±. > |1.0|)
+	}
+
+	if (abs(fPMag) > fInertiaMinAngle || bIsInertionPresent)
+	{
+		float fSpeed = fInertiaSpeedMod;
+		if (fPMag > 0.0f && m_fUD_InertiaFactor > 0.0f ||
+			fPMag < 0.0f && m_fUD_InertiaFactor < 0.0f)
+		{
+			fSpeed *= 2.f; //--> Ð£ÑÐºÐ¾ÑÑÐµÐ¼ Ð¸Ð½ÐµÑÑÐ¸Ñ Ð¿ÑÐ¸ Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ð¸ Ð² Ð¿ÑÐ¾ÑÐ¸Ð²Ð¾Ð¿Ð¾Ð»Ð¾Ð¶Ð½ÑÑ ÑÑÐ¾ÑÐ¾Ð½Ñ
+		}
+
+		m_fUD_InertiaFactor -= (fPMag * fAvgTimeDelta * fSpeed); // ÐÐµÑÑÐ¸ÐºÐ°Ð»Ñ (Ð¼.Ð±. > |1.0|)
+	}
+
+	clamp(m_fLR_InertiaFactor, -1.0f, 1.0f);
+	clamp(m_fUD_InertiaFactor, -1.0f, 1.0f);
+
+	// ÐÐ»Ð°Ð²Ð½Ð¾Ðµ Ð·Ð°ÑÑÑÐ°Ð½Ð¸Ðµ Ð¸Ð½ÐµÑÑÐ¸Ð¸ (Ð¾ÑÐ½Ð¾Ð²Ð½Ð¾Ðµ, Ð½Ð¾ Ð±ÐµÐ· Ð»Ð¸Ð½ÐµÐ¹Ð½Ð¾Ð¹ Ð½Ð¸ÐºÐ¾Ð³Ð´Ð° Ð½Ðµ Ð¾Ð¿ÑÑÑÐ¸Ñ Ð¸Ð½ÐµÑÑÐ¸Ñ Ð´Ð¾ Ð¿Ð¾Ð»Ð½Ð¾Ð³Ð¾ 0.0f)
+	m_fLR_InertiaFactor *= clampr(1.f - fAvgTimeDelta * fInertiaReturnSpeedMod, 0.0f, 1.0f);
+	m_fUD_InertiaFactor *= clampr(1.f - fAvgTimeDelta * fInertiaReturnSpeedMod, 0.0f, 1.0f);
+
+	// ÐÐ¸Ð½Ð¸Ð¼Ð°Ð»ÑÐ½Ð¾Ðµ Ð»Ð¸Ð½ÐµÐ¹Ð½Ð¾Ðµ Ð·Ð°ÑÑÑÐ°Ð½Ð¸Ðµ Ð¸Ð½ÐµÑÑÐ¸Ð¸ Ð¿ÑÐ¸ Ð¿Ð¾ÐºÐ¾Ðµ (Ð³Ð¾ÑÐ¸Ð·Ð¾Ð½ÑÐ°Ð»Ñ)
+	if (fYMag == 0.0f)
+	{
+		float fRetSpeedMod = (fYMag == 0.0f ? 1.0f : 0.75f) * (fInertiaReturnSpeedMod * 0.075f);
+		if (m_fLR_InertiaFactor < 0.0f)
+		{
+			m_fLR_InertiaFactor += fAvgTimeDelta * fRetSpeedMod;
+			clamp(m_fLR_InertiaFactor, -1.0f, 0.0f);
+		}
         else
-            m_zoom_params.m_fZoomRotationFactor -= Device.fTimeDelta / m_zoom_params.m_fZoomRotateTime;
+		{
+			m_fLR_InertiaFactor -= fAvgTimeDelta * fRetSpeedMod;
+			clamp(m_fLR_InertiaFactor, 0.0f, 1.0f);
+		}
+	}
 
-        clamp(m_zoom_params.m_fZoomRotationFactor, 0.f, 1.f);
+	// ÐÐ¸Ð½Ð¸Ð¼Ð°Ð»ÑÐ½Ð¾Ðµ Ð»Ð¸Ð½ÐµÐ¹Ð½Ð¾Ðµ Ð·Ð°ÑÑÑÐ°Ð½Ð¸Ðµ Ð¸Ð½ÐµÑÑÐ¸Ð¸ Ð¿ÑÐ¸ Ð¿Ð¾ÐºÐ¾Ðµ (Ð²ÐµÑÑÐ¸ÐºÐ°Ð»Ñ)
+	if (fPMag == 0.0f)
+	{
+		float fRetSpeedMod = (fPMag == 0.0f ? 1.0f : 0.75f) * (fInertiaReturnSpeedMod * 0.075f);
+		if (m_fUD_InertiaFactor < 0.0f)
+		{
+			m_fUD_InertiaFactor += fAvgTimeDelta * fRetSpeedMod;
+			clamp(m_fUD_InertiaFactor, -1.0f, 0.0f);
+		}
+		else
+		{
+			m_fUD_InertiaFactor -= fAvgTimeDelta * fRetSpeedMod;
+			clamp(m_fUD_InertiaFactor, 0.0f, 1.0f);
+		}
+	}
+
+	// ÐÑÐ¸Ð¼ÐµÐ½ÑÐµÐ¼ Ð¸Ð½ÐµÑÑÐ¸Ñ Ðº ÑÑÐ´Ñ
+	float fLR_lim = (m_fLR_InertiaFactor < 0.0f ? vIOffsets.x : vIOffsets.y);
+	float fUD_lim = (m_fUD_InertiaFactor < 0.0f ? vIOffsets.z : vIOffsets.w);
+
+	Fvector curr_offs;
+	curr_offs = {fLR_lim * -1.f * m_fLR_InertiaFactor, fUD_lim * m_fUD_InertiaFactor, 0.0f};
+
+	Fmatrix hud_rotation;
+	hud_rotation.identity();
+	hud_rotation.translate_over(curr_offs);
+	trans.mulB_43(hud_rotation);
     }
+
+// ÐÐ¾Ð±Ð°Ð²Ð¸ÑÑ ÑÑÑÐµÐºÑ ÑÐ´Ð²Ð¸Ð³Ð° Ð¾ÑÑÐ¶Ð¸Ñ Ð¾Ñ Ð²ÑÑÑÑÐµÐ»Ð°
+void CWeapon::AddHUDShootingEffect()
+{
+	if (IsHidden() || ParentIsActor() == false)
+		return;
+
+	// ÐÑÐ´Ð°ÑÐ° Ð½Ð°Ð·Ð°Ð´
+	m_fBACKW_ShootingFactor = 1.0f;
+
+	// ÐÑÐ´Ð°ÑÐ° Ð² Ð±Ð¾ÐºÐ°
+	float fPowerMin = 0.0f;
+	attachable_hud_item* hi = HudItemData();
+	if (hi != nullptr)
+	{
+		if (!hi->m_measures.m_shooting_params.bShootShake)
+			return;
+		fPowerMin = clampr(hi->m_measures.m_shooting_params.m_min_LRUD_power, 0.0f, 0.99f);
 }
 
+	float fPowerRnd = 1.0f - fPowerMin;
+
+	m_fLR_ShootingFactor = ::Random.randF(-fPowerRnd, fPowerRnd);
+	m_fLR_ShootingFactor += (m_fLR_ShootingFactor >= 0.0f ? fPowerMin : -fPowerMin);
+
+	m_fUD_ShootingFactor = ::Random.randF(-fPowerRnd, fPowerRnd);
+	m_fUD_ShootingFactor += (m_fUD_ShootingFactor >= 0.0f ? fPowerMin : -fPowerMin);
+}
+
+
 void CWeapon::SetAmmoElapsed(int ammo_count)
@@ -1709,3 +2650,3 @@
             CCartridge			l_cartridge;
-            l_cartridge.Load(m_ammoTypes[m_ammoType].c_str(), m_ammoType);
+			l_cartridge.Load(m_ammoTypes[m_ammoType].c_str(), m_ammoType, m_APk);
             while (uAmmo > m_magazine.size())
@@ -1763,2 +2704,5 @@
     ZoomTexture()->Draw();
+
+	//crookr
+	scope_2dtexactive = ZoomTexture()->IsShown() ? 1 : 0;
 }
@@ -1781,2 +2725,29 @@
 
+float CWeapon::GetMagazineWeight(const decltype(CWeapon::m_magazine)& mag) const
+{
+	float res = 0;
+	const char* last_type = nullptr;
+	float last_ammo_weight = 0;
+	for (auto& c : mag)
+	{
+		// Usually ammos in mag have same type, use this fact to improve performance
+		if (last_type != c.m_ammoSect.c_str())
+		{
+			last_type = c.m_ammoSect.c_str();
+			last_ammo_weight = c.Weight();
+		}
+		res += last_ammo_weight;
+	}
+	return res;
+}
+
+void CWeapon::AmmoTypeForEach(const luabind::functor<bool> &funct)
+{
+	for (u8 i = 0; i < u8(m_ammoTypes.size()); ++i)
+	{
+		if (funct(i, *m_ammoTypes[i]))
+			break;
+	}
+}
+
 float CWeapon::Weight() const
@@ -1797,9 +2769,3 @@
 
-    if (iAmmoElapsed)
-    {
-        float w = pSettings->r_float(m_ammoTypes[m_ammoType].c_str(), "inv_weight");
-        float bs = pSettings->r_float(m_ammoTypes[m_ammoType].c_str(), "box_size");
-
-        if (bs > 0) res += w*(iAmmoElapsed / bs);
-    }
+	res += GetMagazineWeight(m_magazine);
     return res;
@@ -1829,15 +2795,2 @@
 
-BOOL CWeapon::ParentIsActor()
-{
-    CObject* O = H_Parent();
-    if (!O)
-        return FALSE;
-
-    CEntityAlive* EA = smart_cast<CEntityAlive*>(O);
-    if (!EA)
-        return FALSE;
-
-    return EA->cast_actor() != 0;
-}
-
 extern u32 hud_adj_mode;
@@ -1869,5 +2822,5 @@
 
-void CWeapon::OnStateSwitch(u32 S)
+void CWeapon::OnStateSwitch(u32 S, u32 oldState)
 {
-    inherited::OnStateSwitch(S);
+	inherited::OnStateSwitch(S, oldState);
     m_BriefInfo_CalcFrame = 0;
@@ -1895,2 +2848,5 @@
     }
+
+	if (ParentIsActor() && smart_cast<CActor*>(H_Parent())->inventory().ActiveItem() == this && GetState() != eIdle)
+		Actor()->set_safemode(false);
 }
@@ -1907,7 +2863,8 @@
 
-    bool b_aiming = ((IsZoomed() && m_zoom_params.m_fZoomRotationFactor <= 1.f) ||
-        (!IsZoomed() && m_zoom_params.m_fZoomRotationFactor > 0.f));
-
-    if (!b_aiming)
+	if (m_bCanBeLowered && Actor()->is_safemode())
+		return 4;
+	else if (!IsZoomed())
         return		0;
+	else if (m_zoomtype == 1)
+		return 3;
     else
@@ -1931,2 +2888,23 @@
 
+void NewGetZoomData(const float scope_factor, float& delta, float& min_zoom_factor, float zoom, float min_zoom)
+{
+	
+	float def_fov = float(g_fov);
+	float min_zoom_k = 0.3f;
+	float delta_factor_total = def_fov - scope_factor;
+	VERIFY(delta_factor_total > 0);
+	float loc_min_zoom_factor = ((atan(tan(def_fov * (0.5 * PI / 180)) / g_ironsights_factor) / (0.5 * PI / 180)) / 0.75f) * (scope_radius > 0.0 ? scope_scrollpower : 1);
+
+	//Msg("min zoom factor %f, min zoom %f, loc min zoom factor %f", min_zoom_factor, min_zoom, loc_min_zoom_factor);
+
+	if (min_zoom < loc_min_zoom_factor) {
+		min_zoom_factor = min_zoom;
+	}
+	else {
+		min_zoom_factor = loc_min_zoom_factor;
+	}
+
+	delta = ((delta_factor_total * (1 - min_zoom_k)) / n_zoom_step_count) * (zoom / def_fov);
+}
+
 void CWeapon::ZoomInc()
@@ -1936,7 +2914,16 @@
     float delta, min_zoom_factor;
-    GetZoomData(m_zoom_params.m_fScopeZoomFactor, delta, min_zoom_factor);
-
-    float f = GetZoomFactor() - delta;
-    clamp(f, m_zoom_params.m_fScopeZoomFactor, min_zoom_factor);
-    SetZoomFactor(f);
+	float power = scope_radius > 0.0 ? scope_scrollpower : 1;
+	//
+	if (zoomFlags.test(NEW_ZOOM)) {
+		NewGetZoomData(m_zoom_params.m_fScopeZoomFactor * power, delta, min_zoom_factor, GetZoomFactor() * power, m_zoom_params.m_fMinBaseZoomFactor);
+	}
+	else {
+        GetZoomData(m_zoom_params.m_fScopeZoomFactor * power, delta, min_zoom_factor);
+	}
+	//
+	float f = GetZoomFactor() * power - delta;
+	clamp(f, m_zoom_params.m_fScopeZoomFactor * power, min_zoom_factor);
+	SetZoomFactor(f / power);
+	//
+	m_fRTZoomFactor = GetZoomFactor() * power;
 }
@@ -1948,7 +2935,16 @@
     float delta, min_zoom_factor;
-    GetZoomData(m_zoom_params.m_fScopeZoomFactor, delta, min_zoom_factor);
-
-    float f = GetZoomFactor() + delta;
-    clamp(f, m_zoom_params.m_fScopeZoomFactor, min_zoom_factor);
-    SetZoomFactor(f);
+	float power = scope_radius > 0.0 ? scope_scrollpower : 1;
+	//
+	if (zoomFlags.test(NEW_ZOOM)) {
+		NewGetZoomData(m_zoom_params.m_fScopeZoomFactor * power, delta, min_zoom_factor, GetZoomFactor() * power, m_zoom_params.m_fMinBaseZoomFactor);
+	}
+	else {
+        GetZoomData(m_zoom_params.m_fScopeZoomFactor * power, delta, min_zoom_factor);
+	}
+	//
+	float f = GetZoomFactor() * power + delta;
+	clamp(f, m_zoom_params.m_fScopeZoomFactor * power, min_zoom_factor);
+	SetZoomFactor(f / power);
+	//
+	m_fRTZoomFactor = GetZoomFactor() * power;
 }
@@ -1979 +2976,18 @@
 }
\ No newline at end of file
+
+float CWeapon::GetSecondVPFov() const
+{
+	if (m_zoom_params.m_bUseDynamicZoom && IsSecondVPZoomPresent())
+		return (m_fRTZoomFactor / 100.f) * g_fov;
+
+	return GetSecondVPZoomFactor() * g_fov;
+}
+
+void CWeapon::UpdateSecondVP()
+{
+	if (!(ParentIsActor() && (m_pInventory != NULL) && (m_pInventory->ActiveItem() == this)))
+		return;
+
+	CActor* pActor = smart_cast<CActor*>(H_Parent());
+	Device.m_SecondViewport.SetSVPActive(m_zoomtype == 0 && pActor->cam_Active() == pActor->cam_FirstEye() && IsSecondVPZoomPresent() && m_zoom_params.m_fZoomRotationFactor > 0.05f);
+}
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Weapon.h xray-monolith/src/xrGame/Weapon.h
--- coc-1.4-xray-64/src/xrGame/Weapon.h	2023-10-20 20:54:50.724326600 +0100
+++ xray-monolith/src/xrGame/Weapon.h	2023-10-20 20:54:32.673035500 +0100
@@ -1,2 +1,2 @@
-#pragma once
+ï»¿#pragma once
 
@@ -16,2 +16,4 @@
 
+#include "NewZoomFlag.h"
+
 class CEntity;
@@ -26,2 +28,22 @@
 
+extern float f_weapon_deterioration;
+
+extern std::map<shared_str, float> listScopeRadii;
+
+extern float scope_scrollpower;
+extern float sens_multiple;
+
+struct PickParam
+{
+	collide::rq_result RQ;
+	float power;
+	u32 pass;
+};
+
+struct SafemodeAnm
+{
+	LPCSTR name;
+	float power, speed;
+};
+
 class CWeapon : public CHudItemObject,
@@ -61,2 +85,19 @@
 
+	float CWeapon::GetSecondVPFov() const;
+	IC float GetZRotatingFactor()    const { return m_zoom_params.m_fZoomRotationFactor; }
+	IC float GetSecondVPZoomFactor() const { return m_zoom_params.m_fSecondVPFovFactor; }
+	IC float IsSecondVPZoomPresent() const { return GetSecondVPZoomFactor() > 0.005f; }
+
+
+	// Up
+	// Magazine system & etc
+	xr_vector<shared_str> bullets_bones;
+	int bullet_cnt;
+	int last_hide_bullet;
+	bool bHasBulletsToHide;
+
+	virtual void HUD_VisualBulletUpdate(bool force = false, int force_idx = -1);
+
+	void UpdateSecondVP();
+
     virtual void			UpdateCL();
@@ -81,2 +122,10 @@
     virtual void			reload(LPCSTR section);
+
+	// demonized: World model on stalkers adjustments
+	void set_mOffset(Fvector position, Fvector orientation);
+	void set_mStrapOffset(Fvector position, Fvector orientation);
+	void set_mFirePoint(Fvector &fire_point);
+	void set_mFirePoint2(Fvector &fire_point);
+	void set_mShellPoint(Fvector &fire_point);
+
     virtual void			create_physic_shell();
@@ -91,2 +140,4 @@
 
+	virtual bool NeedBlendAnm();
+
 public:
@@ -99,3 +150,3 @@
 protected:
-    //âðåìÿ óäàëåíèÿ îðóæèÿ
+	//Ã¢Ã°Ã¥Ã¬Ã¿ Ã³Ã¤Ã Ã«Ã¥Ã­Ã¨Ã¿ Ã®Ã°Ã³Ã¦Ã¨Ã¿
     ALife::_TIME_ID			m_dwWeaponRemoveTime;
@@ -104,2 +155,4 @@
     virtual bool			IsHudModeNow();
+	virtual bool SOParentIsActor() { return ParentIsActor(); }
+	u8 last_idx;
 public:
@@ -114,4 +167,6 @@
         eMisfire,
-        eMagEmpty,
         eSwitch,
+		eSwitchMode,
+		eAimStart,
+		eAimEnd,
     };
@@ -122,2 +178,3 @@
         eSubstateReloadEnd,
+		eSubstateReloadInProcessEmptyEnd,
     };
@@ -135,3 +194,4 @@
 
-    BOOL					IsMisfire() const;
+	bool IsMisfire() const;
+	void SetMisfireScript(bool b);
     BOOL					CheckForMisfire();
@@ -155,2 +218,3 @@
     bool					bMisfire;
+	bool bClearJamOnly; //used for "reload" misfire animation
 
@@ -161,2 +225,4 @@
 
+	bool IsCustomReloadAvaible;
+
     bool IsGrenadeLauncherAttached() const;
@@ -187,9 +255,9 @@
 	
-    //îáíîâëåíèå âèäèìîñòè äëÿ êîñòî÷åê àääîíîâ
+	//Ã®Ã¡Ã­Ã®Ã¢Ã«Ã¥Ã­Ã¨Ã¥ Ã¢Ã¨Ã¤Ã¨Ã¬Ã®Ã±Ã²Ã¨ Ã¤Ã«Ã¿ ÃªÃ®Ã±Ã²Ã®Ã·Ã¥Ãª Ã Ã¤Ã¤Ã®Ã­Ã®Ã¢
     void UpdateAddonsVisibility();
     void UpdateHUDAddonsVisibility();
-    //èíèöèàëèçàöèÿ ñâîéñòâ ïðèñîåäèíåííûõ àääîíîâ
+	//Ã¨Ã­Ã¨Ã¶Ã¨Ã Ã«Ã¨Ã§Ã Ã¶Ã¨Ã¿ Ã±Ã¢Ã®Ã©Ã±Ã²Ã¢ Ã¯Ã°Ã¨Ã±Ã®Ã¥Ã¤Ã¨Ã­Ã¥Ã­Ã­Ã»Ãµ Ã Ã¤Ã¤Ã®Ã­Ã®Ã¢
     virtual void InitAddons();
 
-    //äëÿ îòîáðîàæåíèÿ èêîíîê àïãðåéäîâ â èíòåðôåéñå
+	//Ã¤Ã«Ã¿ Ã®Ã²Ã®Ã¡Ã°Ã®Ã Ã¦Ã¥Ã­Ã¨Ã¿ Ã¨ÃªÃ®Ã­Ã®Ãª Ã Ã¯Ã£Ã°Ã¥Ã©Ã¤Ã®Ã¢ Ã¢ Ã¨Ã­Ã²Ã¥Ã°Ã´Ã¥Ã©Ã±Ã¥
     int	GetScopeX()
@@ -223,4 +296,9 @@
     }
+
     const shared_str GetScopeName() const
     {
+		if (m_scopes.size() < 1)
+		{
+			return {};
+		}
         return pSettings->r_string(m_scopes[m_cur_scope], "scope_name");
@@ -245,7 +325,8 @@
     }//dont use!!! for buy menu only!!!
+	
 protected:
-    //ñîñòîÿíèå ïîäêëþ÷åííûõ àääîíîâ
+	//Ã±Ã®Ã±Ã²Ã®Ã¿Ã­Ã¨Ã¥ Ã¯Ã®Ã¤ÃªÃ«Ã¾Ã·Ã¥Ã­Ã­Ã»Ãµ Ã Ã¤Ã¤Ã®Ã­Ã®Ã¢
     u8 m_flagsAddOnState;
 
-    //âîçìîæíîñòü ïîäêëþ÷åíèÿ ðàçëè÷íûõ àääîíîâ
+	//Ã¢Ã®Ã§Ã¬Ã®Ã¦Ã­Ã®Ã±Ã²Ã¼ Ã¯Ã®Ã¤ÃªÃ«Ã¾Ã·Ã¥Ã­Ã¨Ã¿ Ã°Ã Ã§Ã«Ã¨Ã·Ã­Ã»Ãµ Ã Ã¤Ã¤Ã®Ã­Ã®Ã¢
     ALife::EWeaponAddonStatus	m_eScopeStatus;
@@ -254,3 +335,3 @@
 
-    //íàçâàíèÿ ñåêöèé ïîäêëþ÷àåìûõ àääîíîâ
+
     shared_str		m_sScopeName;
@@ -259,3 +340,3 @@
 
-    //ñìåùåíèå èêîíîâ àïãðåéäîâ â èíâåíòàðå
+	//Ã±Ã¬Ã¥Ã¹Ã¥Ã­Ã¨Ã¥ Ã¨ÃªÃ®Ã­Ã®Ã¢ Ã Ã¯Ã£Ã°Ã¥Ã©Ã¤Ã®Ã¢ Ã¢ Ã¨Ã­Ã¢Ã¥Ã­Ã²Ã Ã°Ã¥
     int	m_iScopeX, m_iScopeY;
@@ -268,15 +349,13 @@
     {
-        bool			m_bZoomEnabled;			//ðàçðåøåíèå ðåæèìà ïðèáëèæåíèÿ
+        float m_fMinBaseZoomFactor;
+		bool m_bZoomEnabled;
         bool			m_bHideCrosshairInZoom;
         bool			m_bZoomDofEnabled;
-
-        bool			m_bIsZoomModeNow;		//êîãäà ðåæèì ïðèáëèæåíèÿ âêëþ÷åí
-        float			m_fCurrentZoomFactor;	//òåêóùèé ôàêòîð ïðèáëèæåíèÿ
-        float			m_fZoomRotateTime;		//âðåìÿ ïðèáëèæåíèÿ
-
-        float			m_fIronSightZoomFactor;	//êîýôôèöèåíò óâåëè÷åíèÿ ïðèöåëèâàíèÿ
-        float			m_fScopeZoomFactor;		//êîýôôèöèåíò óâåëè÷åíèÿ ïðèöåëà
-
+		bool m_bIsZoomModeNow;
+		float m_fCurrentZoomFactor;
+		float m_fZoomRotateTime;
+		float m_fBaseZoomFactor;
+		float m_fScopeZoomFactor;
         float			m_fZoomRotationFactor;
-
+		float m_fSecondVPFovFactor;
         Fvector			m_ZoomDof;
@@ -285,2 +364,5 @@
         BOOL			m_bUseDynamicZoom;
+		BOOL m_bUseDynamicZoom_Primary;
+		BOOL m_bUseDynamicZoom_Alt;
+		BOOL m_bUseDynamicZoom_GL;
         shared_str		m_sUseZoomPostprocess;
@@ -309,6 +392,3 @@
 
-    bool			ZoomHideCrosshair()
-    {
-        return m_zoom_params.m_bHideCrosshairInZoom || ZoomTexture();
-    }
+	bool ZoomHideCrosshair();
 
@@ -324,3 +405,3 @@
     virtual	float			CurrentZoomFactor();
-    //ïîêàçûâàåò, ÷òî îðóæèå íàõîäèòñÿ â ñîîñòîÿíèè ïîâîðîòà äëÿ ïðèáëèæåííîãî ïðèöåëèâàíèÿ
+	//Ã¯Ã®ÃªÃ Ã§Ã»Ã¢Ã Ã¥Ã², Ã·Ã²Ã® Ã®Ã°Ã³Ã¦Ã¨Ã¥ Ã­Ã ÃµÃ®Ã¤Ã¨Ã²Ã±Ã¿ Ã¢ Ã±Ã®Ã®Ã±Ã²Ã®Ã¿Ã­Ã¨Ã¨ Ã¯Ã®Ã¢Ã®Ã°Ã®Ã²Ã  Ã¤Ã«Ã¿ Ã¯Ã°Ã¨Ã¡Ã«Ã¨Ã¦Ã¥Ã­Ã­Ã®Ã£Ã® Ã¯Ã°Ã¨Ã¶Ã¥Ã«Ã¨Ã¢Ã Ã­Ã¨Ã¿
     bool			IsRotatingToZoom() const
@@ -332,2 +413,22 @@
 
+	// Tronex script exports
+	void AmmoTypeForEach(const luabind::functor<bool>& funct);
+	float GetMagazineWeightScript() const { return GetMagazineWeight(m_magazine); }
+	int GetAmmoCount_forType_Script(LPCSTR type) const { return GetAmmoCount_forType(type); }
+	LPCSTR GetGrenadeLauncherNameScript() const { return *GetGrenadeLauncherName(); }
+	LPCSTR GetSilencerNameScript() const { return *GetSilencerName(); }
+	LPCSTR GetScopeNameScript() const { return *GetScopeName(); }
+	float GetFireDispersionScript() const { return fireDispersionBase; }
+	float RPMScript() const { return fOneShotTime; }
+	float RealRPMScript() const { return 60.0f / fOneShotTime; } // Return actual RPM like in configs
+	float ModeRPMScript() const { return fModeShotTime; }
+	float ModeRealRPMScript() const { return 60.0f / fModeShotTime; }
+
+	//Setters
+	void SetFireDispersionScript(float val) { fireDispersionBase = val; }
+	void SetRPM(float newOneShotTime) { fOneShotTime = newOneShotTime; } // Input - time between shots like received from getter
+	void SetRealRPM(float rpm) { fOneShotTime = 60.0f / rpm; } // Input - actual RPM like in configs
+	void SetModeRPM(float newOneShotTime) { fModeShotTime = newOneShotTime; } // Input - time between shots like received from getter
+	void SetModeRealRPM(float rpm) { fModeShotTime = 60.0f / rpm; } // Input - actual RPM like in configs
+
     virtual float				Weight() const;
@@ -368,5 +473,8 @@
     bool					m_can_be_strapped;
+	float m_fSafeModeRotateTime;
+	SafemodeAnm m_safemode_anm[2];
 
     Fmatrix					m_Offset;
-    // 0-èñïîëüçóåòñÿ áåç ó÷àñòèÿ ðóê, 1-îäíà ðóêà, 2-äâå ðóêè
+	Fvector m_hud_offset[2];
+	// 0-Ã¨Ã±Ã¯Ã®Ã«Ã¼Ã§Ã³Ã¥Ã²Ã±Ã¿ Ã¡Ã¥Ã§ Ã³Ã·Ã Ã±Ã²Ã¨Ã¿ Ã°Ã³Ãª, 1-Ã®Ã¤Ã­Ã  Ã°Ã³ÃªÃ , 2-Ã¤Ã¢Ã¥ Ã°Ã³ÃªÃ¨
     EHandDependence			eHandDependence;
@@ -375,5 +483,6 @@
 public:
-    //çàãðóæàåìûå ïàðàìåòðû
+	//Ã§Ã Ã£Ã°Ã³Ã¦Ã Ã¥Ã¬Ã»Ã¥ Ã¯Ã Ã°Ã Ã¬Ã¥Ã²Ã°Ã»
     Fvector					vLoadedFirePoint;
     Fvector					vLoadedFirePoint2;
+	bool m_bCanBeLowered;
 
@@ -381,2 +490,10 @@
     firedeps				m_current_firedeps;
+	//collide::rq_results RQS;
+	//PickParam PP;
+
+public:
+	//virtual collide::rq_result& GetRQ() { return PP.RQ; }
+	//virtual void net_Relcase(CObject* object);
+	Fmatrix m_shoot_shake_mat;
+	void UpdateZoomParams();
 
@@ -384,8 +501,12 @@
     virtual void			UpdateFireDependencies_internal();
+	void UpdateUIScope();
+	void SwitchZoomType();
+	float GetHudFov();
     virtual void			UpdatePosition(const Fmatrix& transform);	//.
     virtual void			UpdateXForm();
-    virtual void			UpdateHudAdditonal(Fmatrix&);
+	virtual void UpdateHudAdditional(Fmatrix& trans);
     IC		void			UpdateFireDependencies()
     {
-        if (dwFP_Frame == Device.dwFrame) return; UpdateFireDependencies_internal();
+		if (dwFP_Frame == Device.dwFrame) return;
+		UpdateFireDependencies_internal();
     };
@@ -430,6 +562,6 @@
     virtual bool			MovingAnimAllowedNow();
-    virtual void			OnStateSwitch(u32 S);
+	virtual void OnStateSwitch(u32 S, u32 oldState);
     virtual void			OnAnimationEnd(u32 state);
 
-    //òðàññèðîâàíèå ïîëåòà ïóëè
+	//Ã²Ã°Ã Ã±Ã±Ã¨Ã°Ã®Ã¢Ã Ã­Ã¨Ã¥ Ã¯Ã®Ã«Ã¥Ã²Ã  Ã¯Ã³Ã«Ã¨
     virtual	void			FireTrace(const Fvector& P, const Fvector& D);
@@ -437,6 +569,4 @@
 
-    virtual void			FireStart()
-    {
-        CShootingObject::FireStart();
-    }
+	virtual void FireStart();
+
     virtual void			FireEnd();
@@ -446,5 +576,6 @@
 
-    // îáðàáîòêà âèçóàëèçàöèè âûñòðåëà
+	// Ã®Ã¡Ã°Ã Ã¡Ã®Ã²ÃªÃ  Ã¢Ã¨Ã§Ã³Ã Ã«Ã¨Ã§Ã Ã¶Ã¨Ã¨ Ã¢Ã»Ã±Ã²Ã°Ã¥Ã«Ã 
     virtual void			OnShot()
-    {};
+	{
+	};
     virtual void			AddShotEffector();
@@ -467,3 +600,3 @@
 
-    //ïàðàìåòû îðóæèÿ â çàâèñèìîòè îò åãî ñîñòîÿíèÿ èñïðàâíîñòè
+	//Ã¯Ã Ã°Ã Ã¬Ã¥Ã²Ã» Ã®Ã°Ã³Ã¦Ã¨Ã¿ Ã¢ Ã§Ã Ã¢Ã¨Ã±Ã¨Ã¬Ã®Ã²Ã¨ Ã®Ã² Ã¥Ã£Ã® Ã±Ã®Ã±Ã²Ã®Ã¿Ã­Ã¨Ã¿ Ã¨Ã±Ã¯Ã°Ã Ã¢Ã­Ã®Ã±Ã²Ã¨
     float					GetConditionDispersionFactor() const;
@@ -476,7 +609,43 @@
 
+	// Getters
+	float GetCamRelaxSpeed() { return cam_recoil.RelaxSpeed; };
+	float GetCamRelaxSpeed_AI() { return cam_recoil.RelaxSpeed_AI; };
+	float GetCamDispersion() { return cam_recoil.Dispersion; };
+	float GetCamDispersionInc() { return cam_recoil.DispersionInc; };
+	float GetCamDispersionFrac() { return cam_recoil.DispersionFrac; };
+	float GetCamMaxAngleVert() { return cam_recoil.MaxAngleVert; };
+	float GetCamMaxAngleHorz() { return cam_recoil.MaxAngleHorz; };
+	float GetCamStepAngleHorz() { return cam_recoil.StepAngleHorz; };
+	float GetZoomCamRelaxSpeed() { return zoom_cam_recoil.RelaxSpeed; };
+	float GetZoomCamRelaxSpeed_AI() { return zoom_cam_recoil.RelaxSpeed_AI; };
+	float GetZoomCamDispersion() { return zoom_cam_recoil.Dispersion; };
+	float GetZoomCamDispersionInc() { return zoom_cam_recoil.DispersionInc; };
+	float GetZoomCamDispersionFrac() { return zoom_cam_recoil.DispersionFrac; };
+	float GetZoomCamMaxAngleVert() { return zoom_cam_recoil.MaxAngleVert; };
+	float GetZoomCamMaxAngleHorz() { return zoom_cam_recoil.MaxAngleHorz; };
+	float GetZoomCamStepAngleHorz() { return zoom_cam_recoil.StepAngleHorz; };
+
+	// Setters
+	void SetCamRelaxSpeed(float val) { cam_recoil.RelaxSpeed = val; };
+	void SetCamRelaxSpeed_AI(float val) { cam_recoil.RelaxSpeed_AI = val; };
+	void SetCamDispersion(float val) { cam_recoil.Dispersion = val; };
+	void SetCamDispersionInc(float val) { cam_recoil.DispersionInc = val; };
+	void SetCamDispersionFrac(float val) { cam_recoil.DispersionFrac = val; };
+	void SetCamMaxAngleVert(float val) { cam_recoil.MaxAngleVert = val; };
+	void SetCamMaxAngleHorz(float val) { cam_recoil.MaxAngleHorz = val; };
+	void SetCamStepAngleHorz(float val) { cam_recoil.StepAngleHorz = val; };
+	void SetZoomCamRelaxSpeed(float val) { zoom_cam_recoil.RelaxSpeed = val; };
+	void SetZoomCamRelaxSpeed_AI(float val) { zoom_cam_recoil.RelaxSpeed_AI = val; };
+	void SetZoomCamDispersion(float val) { zoom_cam_recoil.Dispersion = val; };
+	void SetZoomCamDispersionInc(float val) { zoom_cam_recoil.DispersionInc = val; };
+	void SetZoomCamDispersionFrac(float val) { zoom_cam_recoil.DispersionFrac = val; };
+	void SetZoomCamMaxAngleVert(float val) { zoom_cam_recoil.MaxAngleVert = val; };
+	void SetZoomCamMaxAngleHorz(float val) { zoom_cam_recoil.MaxAngleHorz = val; };
+	void SetZoomCamStepAngleHorz(float val) { zoom_cam_recoil.StepAngleHorz = val; };
+
 protected:
-    //ôàêòîð óâåëè÷åíèÿ äèñïåðñèè ïðè ìàêñèìàëüíîé èçíîøåíîñòè
-    //(íà ñêîëüêî ïðîöåíòîâ óâåëè÷èòñÿ äèñïåðñèÿ)
+	//Ã´Ã ÃªÃ²Ã®Ã° Ã³Ã¢Ã¥Ã«Ã¨Ã·Ã¥Ã­Ã¨Ã¿ Ã¤Ã¨Ã±Ã¯Ã¥Ã°Ã±Ã¨Ã¨ Ã¯Ã°Ã¨ Ã¬Ã ÃªÃ±Ã¨Ã¬Ã Ã«Ã¼Ã­Ã®Ã© Ã¨Ã§Ã­Ã®Ã¸Ã¥Ã­Ã®Ã±Ã²Ã¨
+	//(Ã­Ã  Ã±ÃªÃ®Ã«Ã¼ÃªÃ® Ã¯Ã°Ã®Ã¶Ã¥Ã­Ã²Ã®Ã¢ Ã³Ã¢Ã¥Ã«Ã¨Ã·Ã¨Ã²Ã±Ã¿ Ã¤Ã¨Ã±Ã¯Ã¥Ã°Ã±Ã¨Ã¿)
     float					fireDispersionConditionFactor;
-    //âåðîÿòíîñòü îñå÷êè ïðè ìàêñèìàëüíîé èçíîøåíîñòè
+	//Ã¢Ã¥Ã°Ã®Ã¿Ã²Ã­Ã®Ã±Ã²Ã¼ Ã®Ã±Ã¥Ã·ÃªÃ¨ Ã¯Ã°Ã¨ Ã¬Ã ÃªÃ±Ã¨Ã¬Ã Ã«Ã¼Ã­Ã®Ã© Ã¨Ã§Ã­Ã®Ã¸Ã¥Ã­Ã®Ã±Ã²Ã¨
 
@@ -485,8 +654,8 @@
     //	float					misfireConditionK;
-    float misfireStartCondition;			//èçíîøåííîñòü, ïðè êîòîðîé ïîÿâëÿåòñÿ øàíñ îñå÷êè
-    float misfireEndCondition;				//èçíîøåíîñòü ïðè êîòîðîé øàíñ îñå÷êè ñòàíîâèòñÿ êîíñòàíòíûì
-    float misfireStartProbability;			//øàíñ îñå÷êè ïðè èçíîøåíîñòè áîëüøå ÷åì misfireStartCondition
-    float misfireEndProbability;			//øàíñ îñå÷êè ïðè èçíîøåíîñòè áîëüøå ÷åì misfireEndCondition
-    float conditionDecreasePerQueueShot;	//óâåëè÷åíèå èçíîøåíîñòè ïðè âûñòðåëå î÷åðåäüþ
-    float conditionDecreasePerShot;			//óâåëè÷åíèå èçíîøåíîñòè ïðè îäèíî÷íîì âûñòðåëå
+	float misfireStartCondition; //Ã¨Ã§Ã­Ã®Ã¸Ã¥Ã­Ã­Ã®Ã±Ã²Ã¼, Ã¯Ã°Ã¨ ÃªÃ®Ã²Ã®Ã°Ã®Ã© Ã¯Ã®Ã¿Ã¢Ã«Ã¿Ã¥Ã²Ã±Ã¿ Ã¸Ã Ã­Ã± Ã®Ã±Ã¥Ã·ÃªÃ¨
+	float misfireEndCondition; //Ã¨Ã§Ã­Ã®Ã¸Ã¥Ã­Ã®Ã±Ã²Ã¼ Ã¯Ã°Ã¨ ÃªÃ®Ã²Ã®Ã°Ã®Ã© Ã¸Ã Ã­Ã± Ã®Ã±Ã¥Ã·ÃªÃ¨ Ã±Ã²Ã Ã­Ã®Ã¢Ã¨Ã²Ã±Ã¿ ÃªÃ®Ã­Ã±Ã²Ã Ã­Ã²Ã­Ã»Ã¬
+	float misfireStartProbability; //Ã¸Ã Ã­Ã± Ã®Ã±Ã¥Ã·ÃªÃ¨ Ã¯Ã°Ã¨ Ã¨Ã§Ã­Ã®Ã¸Ã¥Ã­Ã®Ã±Ã²Ã¨ Ã¡Ã®Ã«Ã¼Ã¸Ã¥ Ã·Ã¥Ã¬ misfireStartCondition
+	float misfireEndProbability; //Ã¸Ã Ã­Ã± Ã®Ã±Ã¥Ã·ÃªÃ¨ Ã¯Ã°Ã¨ Ã¨Ã§Ã­Ã®Ã¸Ã¥Ã­Ã®Ã±Ã²Ã¨ Ã¡Ã®Ã«Ã¼Ã¸Ã¥ Ã·Ã¥Ã¬ misfireEndCondition
+	float conditionDecreasePerQueueShot; //Ã³Ã¢Ã¥Ã«Ã¨Ã·Ã¥Ã­Ã¨Ã¥ Ã¨Ã§Ã­Ã®Ã¸Ã¥Ã­Ã®Ã±Ã²Ã¨ Ã¯Ã°Ã¨ Ã¢Ã»Ã±Ã²Ã°Ã¥Ã«Ã¥ Ã®Ã·Ã¥Ã°Ã¥Ã¤Ã¼Ã¾
+	float conditionDecreasePerShot; //Ã³Ã¢Ã¥Ã«Ã¨Ã·Ã¥Ã­Ã¨Ã¥ Ã¨Ã§Ã­Ã®Ã¸Ã¥Ã­Ã®Ã±Ã²Ã¨ Ã¯Ã°Ã¨ Ã®Ã¤Ã¨Ã­Ã®Ã·Ã­Ã®Ã¬ Ã¢Ã»Ã±Ã²Ã°Ã¥Ã«Ã¥
 
@@ -502,2 +672,13 @@
 
+	// Setters
+	void SetMisfireStartCondition(float val)
+	{
+		misfireStartCondition = val;
+	};
+
+	void SetMisfireEndCondition(float val)
+	{
+		misfireEndCondition = val;
+	};
+
 protected:
@@ -510,2 +691,3 @@
         float					m_fPDM_disp_crouch_no_acc;
+		float m_fPDM_disp_buckShot;
     };
@@ -516,12 +699,13 @@
 protected:
-    //äëÿ îòäà÷è îðóæèÿ
+	//Ã¤Ã«Ã¿ Ã®Ã²Ã¤Ã Ã·Ã¨ Ã®Ã°Ã³Ã¦Ã¨Ã¿
     Fvector					m_vRecoilDeltaAngle;
 
-    //äëÿ ñòàëêåðîâ, ÷òîá îíè çíàëè ýôôåêòèâíûå ãðàíèöû èñïîëüçîâàíèÿ
-    //îðóæèÿ
+	//Ã¤Ã«Ã¿ Ã±Ã²Ã Ã«ÃªÃ¥Ã°Ã®Ã¢, Ã·Ã²Ã®Ã¡ Ã®Ã­Ã¨ Ã§Ã­Ã Ã«Ã¨ Ã½Ã´Ã´Ã¥ÃªÃ²Ã¨Ã¢Ã­Ã»Ã¥ Ã£Ã°Ã Ã­Ã¨Ã¶Ã» Ã¨Ã±Ã¯Ã®Ã«Ã¼Ã§Ã®Ã¢Ã Ã­Ã¨Ã¿
+	//Ã®Ã°Ã³Ã¦Ã¨Ã¿
     float					m_fMinRadius;
     float					m_fMaxRadius;
+	float m_fZoomRotateModifier;
 
 protected:
-    //äëÿ âòîðîãî ñòâîëà
+	//Ã¤Ã«Ã¿ Ã¢Ã²Ã®Ã°Ã®Ã£Ã® Ã±Ã²Ã¢Ã®Ã«Ã 
     void			StartFlameParticles2();
@@ -531,3 +715,3 @@
     shared_str				m_sFlameParticles2;
-    //îáúåêò ïàðòèêëîâ äëÿ ñòðåëüáû èç 2-ãî ñòâîëà
+	//Ã®Ã¡ÃºÃ¥ÃªÃ² Ã¯Ã Ã°Ã²Ã¨ÃªÃ«Ã®Ã¢ Ã¤Ã«Ã¿ Ã±Ã²Ã°Ã¥Ã«Ã¼Ã¡Ã» Ã¨Ã§ 2-Ã£Ã® Ã±Ã²Ã¢Ã®Ã«Ã 
     CParticlesObject*		m_pFlameParticles2;
@@ -540,3 +724,3 @@
     {
-        return /*int(m_magazine.size())*/iAmmoElapsed;
+		return iAmmoElapsed;
     }
@@ -556,2 +742,4 @@
 
+	float m_APk;
+
     virtual	float			Get_PDM_Base()	const
@@ -560,2 +748,23 @@
     };
+
+	virtual float Get_Silencer_PDM_Base() const
+	{
+		return cur_silencer_koef.pdm_base;
+	};
+
+	virtual float Get_Scope_PDM_Base() const
+	{
+		return cur_scope_koef.pdm_base;
+	};
+
+	virtual float Get_Launcher_PDM_Base() const
+	{
+		return cur_launcher_koef.pdm_base;
+	};
+
+	virtual float Get_PDM_BuckShot() const
+	{
+		return m_pdm.m_fPDM_disp_buckShot;
+	};
+
     virtual	float			Get_PDM_Vel_F()	const
@@ -564,2 +773,18 @@
     };
+
+	virtual float Get_Silencer_PDM_Vel() const
+	{
+		return cur_silencer_koef.pdm_vel;
+	};
+
+	virtual float Get_Scope_PDM_Vel() const
+	{
+		return cur_scope_koef.pdm_vel;
+	};
+
+	virtual float Get_Launcher_PDM_Vel() const
+	{
+		return cur_launcher_koef.pdm_vel;
+	};
+
     virtual	float			Get_PDM_Accel_F()	const
@@ -568,2 +793,18 @@
     };
+
+	virtual float Get_Silencer_PDM_Accel() const
+	{
+		return cur_silencer_koef.pdm_accel;
+	};
+
+	virtual float Get_Scope_PDM_Accel() const
+	{
+		return cur_scope_koef.pdm_accel;
+	};
+
+	virtual float Get_Launcher_PDM_Accel() const
+	{
+		return cur_launcher_koef.pdm_accel;
+	};
+
     virtual	float			Get_PDM_Crouch()	const
@@ -580,2 +823,18 @@
     };
+
+	virtual float Get_Silencer_CrosshairInertion() const
+	{
+		return cur_silencer_koef.crosshair_inertion;
+	};
+
+	virtual float Get_Scope_CrosshairInertion() const
+	{
+		return cur_scope_koef.crosshair_inertion;
+	};
+
+	virtual float Get_Launcher_CrosshairInertion() const
+	{
+		return cur_launcher_koef.crosshair_inertion;
+	};
+
     float			GetFirstBulletDisp()	const
@@ -584,2 +843,103 @@
     };
+
+	// Setters
+	virtual void Set_PDM_Base(float val) 
+	{
+		m_pdm.m_fPDM_disp_base = val;
+	};
+
+	virtual void Set_Silencer_PDM_Base(float val) 
+	{
+		cur_silencer_koef.pdm_base = val;
+	};
+
+	virtual void Set_Scope_PDM_Base(float val) 
+	{
+		cur_scope_koef.pdm_base = val;
+	};
+
+	virtual void Set_Launcher_PDM_Base(float val) 
+	{
+		cur_launcher_koef.pdm_base = val;
+	};
+
+	virtual void Set_PDM_BuckShot(float val) 
+	{
+		m_pdm.m_fPDM_disp_buckShot = val;
+	};
+
+	virtual void Set_PDM_Vel_F(float val) 
+	{
+		m_pdm.m_fPDM_disp_vel_factor = val;
+	};
+
+	virtual void Set_Silencer_PDM_Vel(float val) 
+	{
+		cur_silencer_koef.pdm_vel = val;
+	};
+
+	virtual void Set_Scope_PDM_Vel(float val) 
+	{
+		cur_scope_koef.pdm_vel = val;
+	};
+
+	virtual void Set_Launcher_PDM_Vel(float val) 
+	{
+		cur_launcher_koef.pdm_vel = val;
+	};
+
+	virtual void Set_PDM_Accel_F(float val) 
+	{
+		m_pdm.m_fPDM_disp_accel_factor = val;
+	};
+
+	virtual void Set_Silencer_PDM_Accel(float val) 
+	{
+		cur_silencer_koef.pdm_accel = val;
+	};
+
+	virtual void Set_Scope_PDM_Accel(float val) 
+	{
+		cur_scope_koef.pdm_accel = val;
+	};
+
+	virtual void Set_Launcher_PDM_Accel(float val) 
+	{
+		cur_launcher_koef.pdm_accel = val;
+	};
+
+	virtual void Set_PDM_Crouch(float val) 
+	{
+		m_pdm.m_fPDM_disp_crouch = val;
+	};
+
+	virtual void Set_PDM_Crouch_NA(float val) 
+	{
+		m_pdm.m_fPDM_disp_crouch_no_acc = val;
+	};
+
+	virtual void SetCrosshairInertion(float val) 
+	{
+		m_crosshair_inertion = val;
+	};
+
+	virtual void Set_Silencer_CrosshairInertion(float val) 
+	{
+		cur_silencer_koef.crosshair_inertion = val;
+	};
+
+	virtual void Set_Scope_CrosshairInertion(float val) 
+	{
+		cur_scope_koef.crosshair_inertion = val;
+	};
+
+	virtual void Set_Launcher_CrosshairInertion(float val)
+	{
+		cur_launcher_koef.crosshair_inertion = val;
+	};
+
+	void SetFirstBulletDisp(float val)
+	{
+		m_first_bullet_controller.set_fire_dispertion(val);
+	};
 protected:
@@ -588,5 +948,5 @@
 
-    //äëÿ ïîäñ÷åòà â GetSuitableAmmoTotal
+	//Ã¤Ã«Ã¿ Ã¯Ã®Ã¤Ã±Ã·Ã¥Ã²Ã  Ã¢ GetSuitableAmmoTotal
     mutable int				m_iAmmoCurrentTotal;
-    mutable u32				m_BriefInfo_CalcFrame;	//êàäð íà êîòîðîì ïðîñ÷èòàëè êîë-âî ïàòðîíîâ
+	mutable u32 m_BriefInfo_CalcFrame; //ÃªÃ Ã¤Ã° Ã­Ã  ÃªÃ®Ã²Ã®Ã°Ã®Ã¬ Ã¯Ã°Ã®Ã±Ã·Ã¨Ã²Ã Ã«Ã¨ ÃªÃ®Ã«-Ã¢Ã® Ã¯Ã Ã²Ã°Ã®Ã­Ã®Ã¢
     bool					m_bAmmoWasSpawned;
@@ -597,14 +957,2 @@
     xr_vector<shared_str>	m_ammoTypes;
-    /*
-        struct SScopes
-        {
-        shared_str			m_sScopeName;
-        int					m_iScopeX;
-        int					m_iScopeY;
-        };
-        DEFINE_VECTOR(SScopes*, SCOPES_VECTOR, SCOPES_VECTOR_IT);
-        SCOPES_VECTOR			m_scopes;
-
-        u8						cur_scope;
-        */
 
@@ -614,5 +962,7 @@
 
+	bool m_altAimPos;
+	u8 m_zoomtype;
+
     CWeaponAmmo*			m_pCurrentAmmo;
     u8						m_ammoType;
-    //-	shared_str				m_ammoName; <== deleted
     bool					m_bHasTracers;
@@ -623,2 +973,3 @@
     CCartridge				m_DefaultCartridge;
+	CCartridge m_lastCartridge;
     float					m_fCurrentCartirdgeDisp;
@@ -631,2 +982,29 @@
 
+	const decltype(m_magazine)& GetMagazine() { return m_magazine; };
+	float GetMagazineWeight(const decltype(m_magazine)& mag) const;
+
+	virtual float GetHitPower() { return fvHitPower[g_SingleGameDifficulty]; };
+	virtual float GetHitPowerCritical() { return fvHitPowerCritical[g_SingleGameDifficulty]; };
+	virtual float GetHitImpulse() { return fHitImpulse; };
+	virtual float GetFireDistance() { return fireDistance; };
+
+	// Setters
+	virtual void SetHitPower(float val) {
+		for (int i = ESingleGameDifficulty::egdNovice; i < ESingleGameDifficulty::egdCount; i++) {
+			fvHitPower[i] = val;
+		}
+	};
+	virtual void SetHitPowerCritical(float val) {
+		for (int i = ESingleGameDifficulty::egdNovice; i < ESingleGameDifficulty::egdCount; i++) {
+			fvHitPowerCritical[i] = val;
+		}
+	};
+	virtual void SetHitImpulse(float val) { fHitImpulse = val; };
+	virtual void SetFireDistance(float val) { fireDistance = val; };
+	
+	IC u8 GetZoomType() const
+	{
+		return m_zoomtype;
+	}
+	
 protected:
@@ -662,3 +1042,2 @@
     virtual BOOL			ParentMayHaveAimBullet();
-    virtual BOOL			ParentIsActor();
 
@@ -668,2 +1047,3 @@
     bool			install_upgrade_hit(LPCSTR section, bool test);
+	bool install_upgrade_hud(LPCSTR section, bool test);
     bool			install_upgrade_addon(LPCSTR section, bool test);
@@ -685,3 +1065,9 @@
 public:
+	float m_fLR_ShootingFactor; // Ð¤Ð°ÐºÑÐ¾Ñ Ð³Ð¾ÑÐ¸Ð·Ð¾Ð½ÑÐ°Ð»ÑÐ½Ð¾Ð³Ð¾ ÑÐ´Ð²Ð¸Ð³Ð° ÑÑÐ´Ð° Ð¿ÑÐ¸ ÑÑÑÐµÐ»ÑÐ±Ðµ [-1; +1]
+	float m_fUD_ShootingFactor; // Ð¤Ð°ÐºÑÐ¾Ñ Ð²ÐµÑÑÐ¸ÐºÐ°Ð»ÑÐ½Ð¾Ð³Ð¾ ÑÐ´Ð²Ð¸Ð³Ð° ÑÑÐ´Ð° Ð¿ÑÐ¸ ÑÑÑÐµÐ»ÑÐ±Ðµ [-1; +1]
+	float m_fBACKW_ShootingFactor; // Ð¤Ð°ÐºÑÐ¾Ñ ÑÐ´Ð²Ð¸Ð³Ð° ÑÑÐ´Ð° Ð² ÑÑÐ¾ÑÐ¾Ð½Ñ Ð»Ð¸ÑÐ° Ð¿ÑÐ¸ ÑÑÑÐµÐ»ÑÐ±Ðµ [0; +1]
+public:
     virtual void			SetActivationSpeedOverride(Fvector const& speed);
+	void AddHUDShootingEffect();
+
     bool			GetRememberActorNVisnStatus()
@@ -691,2 +1077,4 @@
     virtual void			EnableActorNVisnAfterZoom();
+	virtual float GetInertionAimFactor() { return 1.f - m_zoom_params.m_fZoomRotationFactor; };
+	//--> [ÐÑ 1.0 - ÐÐ½ÐµÑÑÐ¸Ñ Ð¾Ñ Ð±ÐµÐ´ÑÐ°, Ð´Ð¾ 0.0 - ÐÐ½ÐµÑÑÐ¸Ñ Ð¿ÑÐ¸ Ð·ÑÐ¼Ð¼Ðµ] ÐÐ°ÐºÑÑ Ð¸Ð½ÐµÑÑÐ¸Ñ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ
 
@@ -697,2 +1086,4 @@
     };
+    
+    float SDS_Radius(bool alt = false);
 };
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/weapon_dump_impl.cpp xray-monolith/src/xrGame/weapon_dump_impl.cpp
--- coc-1.4-xray-64/src/xrGame/weapon_dump_impl.cpp	2023-10-20 20:54:51.522326300 +0100
+++ xray-monolith/src/xrGame/weapon_dump_impl.cpp	2023-10-20 20:54:33.420036900 +0100
@@ -2,2 +2,3 @@
 #include "Weapon.h"
+#include "player_hud.h"
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/WeaponAK74.cpp xray-monolith/src/xrGame/WeaponAK74.cpp
--- coc-1.4-xray-64/src/xrGame/WeaponAK74.cpp	2023-10-20 20:54:50.724326600 +0100
+++ xray-monolith/src/xrGame/WeaponAK74.cpp	2023-10-20 20:54:32.673035500 +0100
@@ -2,2 +2,5 @@
 #include "WeaponAK74.h"
+#include "Weapon.h"
+#include "WeaponMagazined.h"
+#include "WeaponMagazinedWGrenade.h"
 
@@ -17,3 +20,197 @@
 		class_<CWeaponAK74,CGameObject>("CWeaponAK74")
+			.def(constructor<>()),
+			
+		class_<CWeapon,CGameObject>("CWeapon")
 			.def(constructor<>())
+			.def("can_kill", (bool (CWeapon::*)() const)&CWeapon::can_kill)
+			
+			.def("IsGrenadeLauncherAttached", &CWeapon::IsGrenadeLauncherAttached)
+			.def("GrenadeLauncherAttachable", &CWeapon::GrenadeLauncherAttachable)
+			.def("GetGrenadeLauncherName", &CWeapon::GetGrenadeLauncherNameScript)
+			
+			.def("IsScopeAttached", &CWeapon::IsScopeAttached)
+			.def("ScopeAttachable", &CWeapon::ScopeAttachable)
+			.def("GetScopeName", &CWeapon::GetScopeNameScript)
+			
+			.def("IsSilencerAttached", &CWeapon::IsSilencerAttached)
+			.def("SilencerAttachable", &CWeapon::SilencerAttachable)
+			.def("GetSilencerName", &CWeapon::GetSilencerNameScript)
+			
+			.def("IsZoomEnabled", &CWeapon::IsZoomEnabled)
+			.def("IsZoomed", &CWeapon::IsZoomed)
+			.def("GetZoomFactor", &CWeapon::GetZoomFactor)
+			.def("SetZoomFactor", &CWeapon::SetZoomFactor)
+			
+			.def("IsSingleHanded", &CWeapon::IsSingleHanded)
+			
+			.def("GetBaseDispersion", &CWeapon::GetBaseDispersion)
+			.def("GetFireDispersion", &CWeapon::GetFireDispersionScript)
+			
+			.def("GetMisfireStartCondition", &CWeapon::GetMisfireStartCondition)
+			.def("GetMisfireEndCondition", &CWeapon::GetMisfireEndCondition)
+			
+			.def("GetAmmoElapsed", &CWeapon::GetAmmoElapsed)
+			.def("GetAmmoMagSize", &CWeapon::GetAmmoMagSize)
+			.def("GetSuitableAmmoTotal", &CWeapon::GetSuitableAmmoTotal)
+			.def("SetAmmoElapsed", &CWeapon::SetAmmoElapsed)
+			.def("SwitchAmmoType", &CWeapon::SwitchAmmoType)
+			.def("GetMagazineWeight", &CWeapon::GetMagazineWeightScript)
+			.def("GetAmmoCount_forType", &CWeapon::GetAmmoCount_forType_Script)
+			.def("set_ef_main_weapon_type", &CWeapon::set_ef_main_weapon_type)
+			.def("set_ef_weapon_type", &CWeapon::set_ef_weapon_type)
+			.def("SetAmmoType", &CWeapon::SetAmmoType)
+			.def("GetAmmoType", &CWeapon::GetAmmoType)
+			.def("AmmoTypeForEach", &CWeapon::AmmoTypeForEach)
+			.def("RPM", &CWeapon::RPMScript)
+			.def("RealRPM", &CWeapon::RealRPMScript)
+			.def("ModeRPM", &CWeapon::ModeRPMScript)
+			.def("ModeRealRPM", &CWeapon::ModeRealRPMScript)
+			.def("GetZoomType", &CWeapon::GetZoomType)
+			
+			.def("Get_PDM_Base", &CWeapon::Get_PDM_Base)
+			.def("Get_Silencer_PDM_Base", &CWeapon::Get_Silencer_PDM_Base)
+			.def("Get_Scope_PDM_Base", &CWeapon::Get_Scope_PDM_Base)
+			.def("Get_Launcher_PDM_Base", &CWeapon::Get_Launcher_PDM_Base)
+			.def("Get_PDM_BuckShot", &CWeapon::Get_PDM_BuckShot)
+			.def("Get_PDM_Vel_F", &CWeapon::Get_PDM_Vel_F)
+			.def("Get_Silencer_PDM_Vel", &CWeapon::Get_Silencer_PDM_Vel)
+			.def("Get_Scope_PDM_Vel", &CWeapon::Get_Scope_PDM_Vel)
+			.def("Get_Launcher_PDM_Vel", &CWeapon::Get_Launcher_PDM_Vel)
+			.def("Get_PDM_Accel_F", &CWeapon::Get_PDM_Accel_F)
+			.def("Get_Silencer_PDM_Accel", &CWeapon::Get_Silencer_PDM_Accel)
+			.def("Get_Scope_PDM_Accel", &CWeapon::Get_Scope_PDM_Accel)
+			.def("Get_Launcher_PDM_Accel", &CWeapon::Get_Launcher_PDM_Accel)
+			.def("Get_PDM_Crouch", &CWeapon::Get_PDM_Crouch)
+			.def("Get_PDM_Crouch_NA", &CWeapon::Get_PDM_Crouch_NA)
+			.def("GetCrosshairInertion", &CWeapon::GetCrosshairInertion)
+			.def("Get_Silencer_CrosshairInertion", &CWeapon::Get_Silencer_CrosshairInertion)
+			.def("Get_Scope_CrosshairInertion", &CWeapon::Get_Scope_CrosshairInertion)
+			.def("Get_Launcher_CrosshairInertion", &CWeapon::Get_Launcher_CrosshairInertion)
+			
+			.def("GetFirstBulletDisp", &CWeapon::GetFirstBulletDisp)
+			.def("GetHitPower", &CWeapon::GetHitPower)
+			.def("GetHitPowerCritical", &CWeapon::GetHitPowerCritical)
+			.def("GetHitImpulse", &CWeapon::GetHitImpulse)
+			.def("GetFireDistance", &CWeapon::GetFireDistance)
+			.def("GetFireMode", &CWeapon::GetCurrentFireMode)
+
+			.def("GetInertionAimFactor", &CWeapon::GetInertionAimFactor)
+
+			// Setters
+			.def("SetFireDispersion", &CWeapon::SetFireDispersionScript)
+			.def("SetMisfireStartCondition", &CWeapon::SetMisfireStartCondition)
+			.def("SetMisfireEndCondition", &CWeapon::SetMisfireEndCondition)
+			.def("SetRPM", &CWeapon::SetRPM)
+			.def("SetRealRPM", &CWeapon::SetRealRPM)
+			.def("SetModeRPM", &CWeapon::SetModeRPM)
+			.def("SetModeRealRPM", &CWeapon::SetModeRealRPM)
+			.def("Set_PDM_Base", &CWeapon::Set_PDM_Base)
+			.def("Set_Silencer_PDM_Base", &CWeapon::Set_Silencer_PDM_Base)
+			.def("Set_Scope_PDM_Base", &CWeapon::Set_Scope_PDM_Base)
+			.def("Set_Launcher_PDM_Base", &CWeapon::Set_Launcher_PDM_Base)
+			.def("Set_PDM_BuckShot", &CWeapon::Set_PDM_BuckShot)
+			.def("Set_PDM_Vel_F", &CWeapon::Set_PDM_Vel_F)
+			.def("Set_Silencer_PDM_Vel", &CWeapon::Set_Silencer_PDM_Vel)
+			.def("Set_Scope_PDM_Vel", &CWeapon::Set_Scope_PDM_Vel)
+			.def("Set_Launcher_PDM_Vel", &CWeapon::Set_Launcher_PDM_Vel)
+			.def("Set_PDM_Accel_F", &CWeapon::Set_PDM_Accel_F)
+			.def("Set_Silencer_PDM_Accel", &CWeapon::Set_Silencer_PDM_Accel)
+			.def("Set_Scope_PDM_Accel", &CWeapon::Set_Scope_PDM_Accel)
+			.def("Set_Launcher_PDM_Accel", &CWeapon::Set_Launcher_PDM_Accel)
+			.def("Set_PDM_Crouch", &CWeapon::Set_PDM_Crouch)
+			.def("Set_PDM_Crouch_NA", &CWeapon::Set_PDM_Crouch_NA)
+			.def("SetCrosshairInertion", &CWeapon::SetCrosshairInertion)
+			.def("Set_Silencer_CrosshairInertion", &CWeapon::Set_Silencer_CrosshairInertion)
+			.def("Set_Scope_CrosshairInertion", &CWeapon::Set_Scope_CrosshairInertion)
+			.def("Set_Launcher_CrosshairInertion", &CWeapon::Set_Launcher_CrosshairInertion)
+			.def("SetFirstBulletDisp", &CWeapon::SetFirstBulletDisp)
+			.def("SetHitPower", &CWeapon::SetHitPower)
+			.def("SetHitPowerCritical", &CWeapon::SetHitPowerCritical)
+			.def("SetHitImpulse", &CWeapon::SetHitImpulse)
+			.def("SetFireDistance", &CWeapon::SetFireDistance)
+
+			// demonized: World model on stalkers adjustments
+			.def("Set_mOffset", &CWeapon::set_mOffset)
+			.def("Set_mStrapOffset", &CWeapon::set_mStrapOffset)
+			.def("Set_mFirePoint", &CWeapon::set_mFirePoint)
+			.def("Set_mFirePoint2", &CWeapon::set_mFirePoint2)
+			.def("Set_mShellPoint", &CWeapon::set_mShellPoint)
+
+			// Cam Recoil
+			// Getters
+			.def("GetCamRelaxSpeed", &CWeapon::GetCamRelaxSpeed)
+			.def("GetCamRelaxSpeed_AI", &CWeapon::GetCamRelaxSpeed_AI)
+			.def("GetCamDispersion", &CWeapon::GetCamDispersion)
+			.def("GetCamDispersionInc", &CWeapon::GetCamDispersionInc)
+			.def("GetCamDispersionFrac", &CWeapon::GetCamDispersionFrac)
+			.def("GetCamMaxAngleVert", &CWeapon::GetCamMaxAngleVert)
+			.def("GetCamMaxAngleHorz", &CWeapon::GetCamMaxAngleHorz)
+			.def("GetCamStepAngleHorz", &CWeapon::GetCamStepAngleHorz)
+			.def("GetZoomCamRelaxSpeed", &CWeapon::GetZoomCamRelaxSpeed)
+			.def("GetZoomCamRelaxSpeed_AI", &CWeapon::GetZoomCamRelaxSpeed_AI)
+			.def("GetZoomCamDispersion", &CWeapon::GetZoomCamDispersion)
+			.def("GetZoomCamDispersionInc", &CWeapon::GetZoomCamDispersionInc)
+			.def("GetZoomCamDispersionFrac", &CWeapon::GetZoomCamDispersionFrac)
+			.def("GetZoomCamMaxAngleVert", &CWeapon::GetZoomCamMaxAngleVert)
+			.def("GetZoomCamMaxAngleHorz", &CWeapon::GetZoomCamMaxAngleHorz)
+			.def("GetZoomCamStepAngleHorz", &CWeapon::GetZoomCamStepAngleHorz)
+
+			// Setters
+			.def("SetCamRelaxSpeed", &CWeapon::SetCamRelaxSpeed)
+			.def("SetCamRelaxSpeed_AI", &CWeapon::SetCamRelaxSpeed_AI)
+			.def("SetCamDispersion", &CWeapon::SetCamDispersion)
+			.def("SetCamDispersionInc", &CWeapon::SetCamDispersionInc)
+			.def("SetCamDispersionFrac", &CWeapon::SetCamDispersionFrac)
+			.def("SetCamMaxAngleVert", &CWeapon::SetCamMaxAngleVert)
+			.def("SetCamMaxAngleHorz", &CWeapon::SetCamMaxAngleHorz)
+			.def("SetCamStepAngleHorz", &CWeapon::SetCamStepAngleHorz)
+			.def("SetZoomCamRelaxSpeed", &CWeapon::SetZoomCamRelaxSpeed)
+			.def("SetZoomCamRelaxSpeed_AI", &CWeapon::SetZoomCamRelaxSpeed_AI)
+			.def("SetZoomCamDispersion", &CWeapon::SetZoomCamDispersion)
+			.def("SetZoomCamDispersionInc", &CWeapon::SetZoomCamDispersionInc)
+			.def("SetZoomCamDispersionFrac", &CWeapon::SetZoomCamDispersionFrac)
+			.def("SetZoomCamMaxAngleVert", &CWeapon::SetZoomCamMaxAngleVert)
+			.def("SetZoomCamMaxAngleHorz", &CWeapon::SetZoomCamMaxAngleHorz)
+			.def("SetZoomCamStepAngleHorz", &CWeapon::SetZoomCamStepAngleHorz)
+			
+			.def("Cost", &CWeapon::Cost)
+			.def("Weight", &CWeapon::Weight)
+
+			.def("IsMisfire", &CWeapon::IsMisfire)
+			.def("SetMisfire", &CWeapon::SetMisfireScript)
+
+			.def("IsPending", &CWeapon::IsPending)
+			.def("SetPending", &CWeapon::SetPending)
+
+			.enum_("EWeaponStates")
+			[
+				value("eFire", int(EWeaponStates::eFire)),
+				value("eFire2", int(EWeaponStates::eFire2)),
+				value("eReload", int(EWeaponStates::eReload)),
+				value("eMisfire", int(EWeaponStates::eMisfire)),
+				value("eSwitch", int(EWeaponStates::eSwitch)),
+				value("eSwitchMode", int(EWeaponStates::eSwitchMode))
+			]
+			.enum_("EWeaponSubStates")
+			[
+				value("eSubstateReloadBegin", int(EWeaponSubStates::eSubstateReloadBegin)),
+				value("eSubstateReloadInProcess", int(EWeaponSubStates::eSubstateReloadInProcess)),
+				value("eSubstateReloadEnd", int(EWeaponSubStates::eSubstateReloadEnd))
+			],
+			
+		class_<CWeaponMagazined,CWeapon>("CWeaponMagazined")
+			.def(constructor<>())
+			.def("SetFireMode", &CWeaponMagazined::SetFireMode),
+			
+		class_<CWeaponMagazinedWGrenade,CWeaponMagazined>("CWeaponMagazinedWGrenade")
+			.def(constructor<>())
+			.def("GetGrenadeLauncherMode", &CWeaponMagazinedWGrenade::GetGrenadeLauncherMode)
+			.def("SetGrenadeLauncherMode", &CWeaponMagazinedWGrenade::SetGrenadeLauncherMode)
+
+			.def("SetAmmoElapsed2", &CWeaponMagazinedWGrenade::SetAmmoElapsed2)
+			.def("GetAmmoElapsed2", &CWeaponMagazinedWGrenade::GetAmmoElapsed2)
+			.def("GetAmmoMagSize2", &CWeaponMagazinedWGrenade::GetAmmoMagSize2)
+			.def("SetAmmoType2", &CWeaponMagazinedWGrenade::SetAmmoType2)
+			.def("GetAmmoType2", &CWeaponMagazinedWGrenade::GetAmmoType2)
+			.def("AmmoTypeForEach2", &CWeaponMagazinedWGrenade::AmmoTypeForEach2)
 	];
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/WeaponAmmo.cpp xray-monolith/src/xrGame/WeaponAmmo.cpp
--- coc-1.4-xray-64/src/xrGame/WeaponAmmo.cpp	2023-10-20 20:54:50.725326800 +0100
+++ xray-monolith/src/xrGame/WeaponAmmo.cpp	2023-10-20 20:54:32.674035500 +0100
@@ -19,7 +19,9 @@
 	m_ammoSect = NULL;
+	m_InvShortName = NULL;
 	param_s.Init();
 	bullet_material_idx = u16(-1);
+	m_4to1_tracer = false;
 }
 
-void CCartridge::Load(LPCSTR section, u8 LocalAmmoType) 
+void CCartridge::Load(LPCSTR section, u8 LocalAmmoType, float ap_mod)
 {
@@ -34,3 +36,6 @@
 	param_s.kAP					= pSettings->r_float(section, "k_ap");
+	param_s.kAP *= ap_mod;
+	param_s.k_cam_dispersion = READ_IF_EXISTS(pSettings, r_float, section, "k_cam_dispersion", 1.0f);
 	param_s.u8ColorID			= READ_IF_EXISTS(pSettings, r_u8, section, "tracer_color_ID", 0);
+	param_s.kBulletSpeed = READ_IF_EXISTS(pSettings, r_float, section, "k_bullet_speed", 1.0f);
 	
@@ -75,4 +80,24 @@
 
+float CCartridge::Weight() const
+{
+	auto s = m_ammoSect.c_str();
+	float res = 0;
+	if (s)
+	{
+		float box = pSettings->r_float(s, "box_size");
+		if (box > 0)
+		{
+			float w = pSettings->r_float(s, "inv_weight");
+			res = w / box;
+		}
+	}
+	return res;
+}
+
 CWeaponAmmo::CWeaponAmmo(void) 
 {
+	m_4to1_tracer = false;
+	m_boxSize = 0;
+	m_boxCurr = 0;
+	cartridge_param.Init();
 }
@@ -103,4 +128,5 @@
 	if (pSettings->line_exist(section, "4to1_tracer"))
-		m_4to1_tracer = !!pSettings->r_bool(section, "4to1_tracer");;
+		m_4to1_tracer = !!pSettings->r_bool(section, "4to1_tracer");
 
+	cartridge_param.kBulletSpeed = READ_IF_EXISTS(pSettings, r_float, section, "k_bullet_speed", 1.0f);
 	cartridge_param.buckShot		= pSettings->r_s32(  section, "buck_shot");
@@ -236,2 +265,4 @@
 {
+	if (m_boxSize > 0)
+	{
 	float res = inherited::Weight();
@@ -239,5 +269,6 @@
 	res *= (float)m_boxCurr/(float)m_boxSize;
-
 	return res;
 }
+	return 0;
+}
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/WeaponAmmo.h xray-monolith/src/xrGame/WeaponAmmo.h
--- coc-1.4-xray-64/src/xrGame/WeaponAmmo.h	2023-10-20 20:54:50.725326800 +0100
+++ xray-monolith/src/xrGame/WeaponAmmo.h	2023-10-20 20:54:32.674035500 +0100
@@ -6,3 +6,3 @@
 {
-	float	kDist, kDisp, kHit/*, kCritical*/, kImpulse, kAP, kAirRes;
+	float kDist, kDisp, kHit/*, kCritical*/, kImpulse, kAP, kAirRes, kBulletSpeed, k_cam_dispersion;
 	int		buckShot;
@@ -14,3 +14,3 @@
 	{
-		kDist = kDisp = kHit = kImpulse = 1.0f;
+		kDist = kDisp = kHit = kImpulse = kBulletSpeed = 1.0f;
 //		kCritical = 0.0f;
@@ -22,2 +22,3 @@
 		u8ColorID     = 0;
+		k_cam_dispersion = 1.0f;
 	}
@@ -29,6 +30,8 @@
 	CCartridge();
-	void Load(LPCSTR section, u8 LocalAmmoType);
-
+	void Load(LPCSTR section, u8 LocalAmmoType, float ap_mod = 1.0f);
+	float Weight() const;
 	shared_str	m_ammoSect;
-	enum{
+
+	enum
+	{
 		cfTracer				= (1<<0),
@@ -48,2 +52,4 @@
 	shared_str	m_InvShortName;
+
+	LPCSTR GetInventoryName() { return m_InvShortName.c_str(); };
 	virtual void				DumpActiveParams		(shared_str const & section_name, CInifile & dst_ini) const;
@@ -85,2 +92,8 @@
 	virtual CInventoryItem *can_make_killing	(const CInventory *inventory) const;
+
+	DECLARE_SCRIPT_REGISTER_FUNCTION
 };
+
+add_to_type_list(CWeaponAmmo)
+#undef script_type_list
+#define script_type_list save_type_list(CWeaponAmmo)
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/WeaponAutomaticShotgun.cpp xray-monolith/src/xrGame/WeaponAutomaticShotgun.cpp
--- coc-1.4-xray-64/src/xrGame/WeaponAutomaticShotgun.cpp	2023-10-20 20:54:50.725326800 +0100
+++ xray-monolith/src/xrGame/WeaponAutomaticShotgun.cpp	2023-10-20 20:54:32.675036000 +0100
@@ -8,2 +8,3 @@
 #include "actor.h"
+#include "script_game_object.h"
 
@@ -23,6 +24,13 @@
 
-	if(pSettings->line_exist(section, "tri_state_reload")){
+	if (pSettings->line_exist(section, "tri_state_reload"))
+	{
 		m_bTriStateReload = !!pSettings->r_bool(section, "tri_state_reload");
 	};
-	if(m_bTriStateReload){
+	if (pSettings->line_exist(section, "bas_state_reload"))
+	{
+		IsCustomReloadAvaible = !!pSettings->r_bool(section, "bas_state_reload");
+	}
+	
+	if (m_bTriStateReload)
+	{
 		m_sounds.LoadSound(section, "snd_open_weapon", "sndOpen", false, m_eSoundOpen);
@@ -32,4 +40,7 @@
 		m_sounds.LoadSound(section, "snd_close_weapon", "sndClose", false, m_eSoundClose);
-	};
 
+		m_sounds.LoadSound(section, "snd_close_weapon_empty", "sndCloseEmpty", false, m_eSoundClose);
+
+		m_sounds.LoadSound(section, "snd_shoot_last", "sndShootL", false, m_eSoundShot);
+	};
 }
@@ -38,2 +49,7 @@
 {
+	if (cmd == kWPN_FIRE && flags & CMD_START)
+	{
+		if (GetState() == eFire)
+			return true;
+	}
 	if(inherited::Action(cmd, flags)) return true;
@@ -42,3 +58,3 @@
 		cmd==kWPN_FIRE && flags&CMD_START &&
-		m_sub_state==eSubstateReloadInProcess		)//îñòàíîâèòü ïåðåçàãðóçêó
+		m_sub_state == eSubstateReloadInProcess || m_sub_state == eSubstateReloadInProcessEmptyEnd) //ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
 	{
@@ -46,2 +62,3 @@
 		m_sub_state = eSubstateReloadEnd;
+		if(IsCustomReloadAvaible) SwitchState(eReload);
 		return true;
@@ -56,20 +73,39 @@
 
-	switch(m_sub_state){
-		case eSubstateReloadBegin:{
+	switch (m_sub_state)
+	{
+	case eSubstateReloadBegin:
+		{
 			m_sub_state = eSubstateReloadInProcess;
 			SwitchState(eReload);
-		}break;
+		}
+		break;
 
-		case eSubstateReloadInProcess:{
-			if( 0 != AddCartridge(1) ){
+	case eSubstateReloadInProcess:
+		{
+			if (0 != AddCartridge(1))
+			{
 				m_sub_state = eSubstateReloadEnd;
 			}
+			else if (BeginReloadWasEmpty && IsCustomReloadAvaible)
+			{
+				m_sub_state = eSubstateReloadInProcessEmptyEnd;
+				
+			}
 			SwitchState(eReload);
-		}break;
+		}
+		break;
 
-		case eSubstateReloadEnd:{
+	case eSubstateReloadEnd:
+		{
+			BeginReloadWasEmpty = false;
 			m_sub_state = eSubstateReloadBegin;
 			SwitchState(eIdle);
-		}break;
-		
+		}
+		break;
+	case eSubstateReloadInProcessEmptyEnd:
+		{
+			m_sub_state = eSubstateReloadBegin;
+			SwitchState(eReload);
+		}
+		break;
 	};
@@ -93,6 +131,7 @@
 
-void CWeaponAutomaticShotgun::OnStateSwitch	(u32 S)
+void CWeaponAutomaticShotgun::OnStateSwitch(u32 S, u32 oldState)
 {
-	if(!m_bTriStateReload || S != eReload){
-		inherited::OnStateSwitch(S);
+	if (!m_bTriStateReload || S != eReload)
+	{
+		inherited::OnStateSwitch(S, oldState);
 		return;
@@ -100,5 +139,6 @@
 
-	CWeapon::OnStateSwitch(S);
+	CWeapon::OnStateSwitch(S, oldState);
 
-	if( m_magazine.size() == (u32)iMagazineSize || !HaveCartridgeInInventory(1) ){
+	if (m_magazine.size() == (u32)iMagazineSize || !HaveCartridgeInInventory(1))
+	{
 			switch2_EndReload		();
@@ -121,2 +161,5 @@
 		break;
+	case eSubstateReloadInProcessEmptyEnd:
+		switch2_EndReload();
+		break;
 	};
@@ -124,4 +167,25 @@
 
+void CWeaponAutomaticShotgun::PlaySoundShot()
+{
+	// Temp fix for shotguns last shot
+	if (iAmmoElapsed > 1 || !HudAnimationExist("anm_shot_l"))
+	{
+		inherited::PlaySoundShot();
+	}
+	else
+	{
+		if (m_sounds.FindSoundItem("sndShootL", false))
+		{
+			m_sounds.PlaySound("sndShootL", get_LastFP(), H_Root(), !!GetHUDmode(), false, (u8)-1);
+		}
+		else
+		{
+			inherited::PlaySoundShot();
+		}
+	}
+}
+
 void CWeaponAutomaticShotgun::switch2_StartReload()
 {
+	BeginReloadWasEmpty = !m_magazine.size();
 	PlaySound			("sndOpen",get_LastFP());
@@ -133,2 +197,3 @@
 {
+	if (ParentIsActor()) Actor()->callback(GameObject::eWeaponNoAmmoAvailable)(lua_game_object(), GetSuitableAmmoTotal());
 	PlaySound	("sndAddCartridge",get_LastFP());
@@ -141,2 +206,5 @@
 	SetPending			(FALSE);
+	if (BeginReloadWasEmpty && m_sounds.FindSoundItem("sndCloseEmpty", false))
+		PlaySound("sndCloseEmpty", get_LastFP());
+	else
 	PlaySound			("sndClose",get_LastFP());
@@ -148,3 +217,3 @@
 	VERIFY(GetState()==eReload);
-	PlayHUDMotion("anm_open",FALSE,this,GetState());
+	PlayHUDMotion("anm_open",TRUE, this, GetState());
 }
@@ -159,2 +230,5 @@
 
+	if (BeginReloadWasEmpty && HudAnimationExist("anm_close_empty"))
+		PlayHUDMotion("anm_close_empty", FALSE, this, GetState());
+	else
 	PlayHUDMotion("anm_close",FALSE,this,GetState());
@@ -195,3 +269,3 @@
 
-	if( !HaveCartridgeInInventory(1) )
+	if (!HaveCartridgeInInventory(1) || iAmmoElapsed >= iMagazineSize)
 		return 0;
@@ -203,3 +277,3 @@
 	if (m_DefaultCartridge.m_LocalAmmoType != m_ammoType)
-		m_DefaultCartridge.Load(m_ammoTypes[m_ammoType].c_str(), m_ammoType);
+		m_DefaultCartridge.Load(m_ammoTypes[m_ammoType].c_str(), m_ammoType, m_APk);
 	CCartridge l_cartridge = m_DefaultCartridge;
@@ -220,3 +294,3 @@
 
-	//âûêèíóòü êîðîáêó ïàòðîíîâ, åñëè îíà ïóñòàÿ
+	//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½, ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
 	if(m_pCurrentAmmo && !m_pCurrentAmmo->m_boxCurr && OnServer()) 
@@ -251,3 +325,3 @@
 #endif
-		l_cartridge.Load( m_ammoTypes[LocalAmmoType].c_str(), LocalAmmoType );
+		l_cartridge.Load(m_ammoTypes[LocalAmmoType].c_str(), LocalAmmoType, m_APk);
 	}
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/WeaponAutomaticShotgun.h xray-monolith/src/xrGame/WeaponAutomaticShotgun.h
--- coc-1.4-xray-64/src/xrGame/WeaponAutomaticShotgun.h	2023-10-20 20:54:50.726327700 +0100
+++ xray-monolith/src/xrGame/WeaponAutomaticShotgun.h	2023-10-20 20:54:32.675036000 +0100
@@ -32,5 +32,6 @@
 	void			TriStateReload			();
-	virtual void	OnStateSwitch			(u32 S);
-
+	virtual void OnStateSwitch(u32 S, u32 oldState);
+	virtual void PlaySoundShot();
 	bool			HaveCartridgeInInventory(u8 cnt);
+	bool BeginReloadWasEmpty;
 	virtual u8		AddCartridge			(u8 cnt);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/WeaponBinoculars.cpp xray-monolith/src/xrGame/WeaponBinoculars.cpp
--- coc-1.4-xray-64/src/xrGame/WeaponBinoculars.cpp	2023-10-20 20:54:50.726327700 +0100
+++ xray-monolith/src/xrGame/WeaponBinoculars.cpp	2023-10-20 20:54:32.675036000 +0100
@@ -11,2 +11,5 @@
 
+extern float n_zoom_step_count;
+float czoom;
+
 CWeaponBinoculars::CWeaponBinoculars()
@@ -58,2 +61,3 @@
 	inherited::OnZoomIn		();
+    SetZoomFactor(czoom);
 }
@@ -77,4 +81,4 @@
 {
-	inherited::net_Spawn	(DC);
-	return					TRUE;
+    czoom = CWeaponBinoculars::m_zoom_params.m_fScopeZoomFactor;
+	return inherited::net_Spawn(DC);
 }
@@ -98,3 +102,3 @@
 	bool b_is_active_item = m_pInventory->ActiveItem()==this;
-	return b_is_active_item && H_Parent() && IsZoomed() && !IsRotatingToZoom() && m_binoc_vision;
+	return b_is_active_item && H_Parent() && IsZoomed() && ZoomTexture() && !IsRotatingToZoom() && m_binoc_vision;
 }
@@ -116,3 +120,12 @@
 	delta = (delta_factor_total*(1-min_zoom_k) )/zoom_step_count;
+}
 
+void newGetZoomData(const float scope_factor, float& delta, float& min_zoom_factor, float c_zoom)
+{
+    float def_fov = float(g_fov);
+    float min_zoom_k = 0.3f;
+    float delta_factor_total = def_fov - scope_factor;
+    VERIFY(delta_factor_total > 0);
+    min_zoom_factor = def_fov - delta_factor_total * min_zoom_k;
+    delta = (delta_factor_total * (1 - min_zoom_k)) / n_zoom_step_count * (c_zoom / def_fov);
 }
@@ -122,3 +135,3 @@
 	float delta,min_zoom_factor;
-	GetZoomData(m_zoom_params.m_fScopeZoomFactor, delta, min_zoom_factor);
+    newGetZoomData(m_zoom_params.m_fScopeZoomFactor, delta, min_zoom_factor, czoom);
 
@@ -127,2 +140,3 @@
 	SetZoomFactor			( f );
+    czoom = f;
 }
@@ -132,3 +146,3 @@
 	float delta,min_zoom_factor;
-	GetZoomData(m_zoom_params.m_fScopeZoomFactor,delta,min_zoom_factor);
+    newGetZoomData(m_zoom_params.m_fScopeZoomFactor, delta, min_zoom_factor, czoom);
 
@@ -137,3 +151,3 @@
 	SetZoomFactor			( f );
-
+    czoom = f;
 }
@@ -161,2 +176,4 @@
 {
+	inherited::net_Relcase(object);
+
 	if (!m_binoc_vision)
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/WeaponBinocularsVision.cpp xray-monolith/src/xrGame/WeaponBinocularsVision.cpp
--- coc-1.4-xray-64/src/xrGame/WeaponBinocularsVision.cpp	2023-10-20 20:54:50.727327100 +0100
+++ xray-monolith/src/xrGame/WeaponBinocularsVision.cpp	2023-10-20 20:54:32.676035500 +0100
@@ -66,2 +80,16 @@
 
+struct check_pred
+{
+	check_pred() { apos = Actor()->Position(); };
+	Fvector apos;
+	IC void operator()(SBinocVisibleObj* _it) {
+		auto object_ = _it->m_object;
+		CEntityAlive*	EA = smart_cast<CEntityAlive*>(object_);
+		Fvector opos = Fvector(object_->Position());
+		if (!EA->g_Alive() ||
+			(0 > opos.sub(apos).dotproduct(Device.vCameraDirection)))
+			_it->m_flags.set(flVisObjNotValid, TRUE);
+	};
+};
+
 void SBinocVisibleObj::Update()
@@ -220,3 +257,3 @@
 		const CObject*	_object_			= (*v_it).m_object;
-		if (!pActor->memory().visual().visible_now(smart_cast<const CGameObject*>(_object_)))
+		if (!pActor->memory().visual().visible_right_now(smart_cast<const CGameObject*>(_object_)))
 			continue;
@@ -229,2 +266,4 @@
 		
+		Fvector opos = Fvector(object_->Position());
+		if (0 > opos.sub(Actor()->Position()).dotproduct(Device.vCameraDirection)) continue;
 
@@ -247,5 +289,8 @@
 	}
+
+	/*
 	std::sort								(m_active_objects.begin(), m_active_objects.end());
 
-	while(m_active_objects.size() && m_active_objects.back()->m_flags.test(flVisObjNotValid)){
+	while (m_active_objects.size() && m_active_objects.back()->m_flags.test(flVisObjNotValid))
+	{
 		xr_delete							(m_active_objects.back());
@@ -253,2 +298,19 @@
 	}
+	*/
+
+	// death or invis
+	for_each(m_active_objects.begin(), m_active_objects.end(), check_pred());
+
+	m_active_objects.erase(
+		remove_if(
+			m_active_objects.begin(),
+			m_active_objects.end(),
+			[](SBinocVisibleObj* _it) {
+			if (!_it) return true;
+			bool res = _it->m_flags.test(flVisObjNotValid);
+			if (res) xr_delete(_it);
+			return res;
+		}),
+		m_active_objects.end()
+		);
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/WeaponBinocularsVision.h xray-monolith/src/xrGame/WeaponBinocularsVision.h
--- coc-1.4-xray-64/src/xrGame/WeaponBinocularsVision.h	2023-10-20 20:54:50.727327100 +0100
+++ xray-monolith/src/xrGame/WeaponBinocularsVision.h	2023-10-20 20:54:32.676035500 +0100
@@ -44,3 +53,3 @@
 	void	Load				(const shared_str& section);
-	HUD_SOUND_COLLECTION		m_sounds;
+	HUD_SOUND_COLLECTION_LAYERED m_sounds;
 };
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/weaponBM16.cpp xray-monolith/src/xrGame/weaponBM16.cpp
--- coc-1.4-xray-64/src/xrGame/weaponBM16.cpp	2023-10-20 20:54:51.521326400 +0100
+++ xray-monolith/src/xrGame/weaponBM16.cpp	2023-10-20 20:54:33.419036400 +0100
@@ -2,2 +2,4 @@
 #include "weaponBM16.h"
+#include "entity.h"
+#include "Actor.h"
 
@@ -26,6 +28,6 @@
 	case 1:
-		PlayHUDMotion("anm_shot_1",FALSE,this,GetState());
+		PlayHUDMotion("anm_shot_1",TRUE, this, GetState(), 1.f, 0.f, false);
 		break;
 	case 2:
-		PlayHUDMotion("anm_shot_2",FALSE,this,GetState());
+		PlayHUDMotion("anm_shot_2",TRUE, this, GetState(), 1.f, 0.f, false);
 		break;
@@ -39,9 +41,9 @@
 	case 0:
-		PlayHUDMotion("anm_show_0",TRUE,this,GetState());
+		PlayHUDMotion("anm_show_0",TRUE, this, GetState(), 1.f, 0.f, false);
 		break;
 	case 1:
-		PlayHUDMotion("anm_show_1",TRUE,this,GetState());
+		PlayHUDMotion("anm_show_1",TRUE, this, GetState(), 1.f, 0.f, false);
 		break;
 	case 2:
-		PlayHUDMotion("anm_show_2",TRUE,this,GetState());
+		PlayHUDMotion("anm_show_2",TRUE, this, GetState(), 1.f, 0.f, false);
 		break;
@@ -66,3 +68,3 @@
 
-void CWeaponBM16::PlayAnimBore()
+bool CWeaponBM16::TryPlayAnimBore()
 {
@@ -71,11 +73,25 @@
 	case 0:
+		if (HudAnimationExist("anm_bore_0"))
+		{
 		PlayHUDMotion("anm_bore_0",TRUE,this,GetState());
+			return true;
+		}
 		break;
 	case 1:
+		if (HudAnimationExist("anm_bore_1"))
+		{
 		PlayHUDMotion("anm_bore_1",TRUE,this,GetState());
+			return true;
+		}
 		break;
 	case 2:
+		if (HudAnimationExist("anm_bore_2"))
+		{
 		PlayHUDMotion("anm_bore_2",TRUE,this,GetState());
+			return true;
+		}
 		break;
 	}
+
+	return false;
 }
@@ -99,2 +115,4 @@
 {
+	bool bAccelerated = isActorAccelerated(Actor()->MovingState(), IsZoomed());
+
 	switch( m_magazine.size() )
@@ -102,9 +120,9 @@
 	case 0:
-		PlayHUDMotion("anm_idle_moving_0",TRUE,this,GetState());
+		PlayHUDMotion("anm_idle_moving_0",TRUE, this, GetState(), bAccelerated ? 1.f : .75f);
 		break;
 	case 1:
-		PlayHUDMotion("anm_idle_moving_1",TRUE,this,GetState());
+		PlayHUDMotion("anm_idle_moving_1",TRUE, this, GetState(), bAccelerated ? 1.f : .75f);
 		break;
 	case 2:
-		PlayHUDMotion("anm_idle_moving_2",TRUE,this,GetState());
+		PlayHUDMotion("anm_idle_moving_2",TRUE, this, GetState(), bAccelerated ? 1.f : .75f);
 		break;
@@ -131,3 +149,5 @@
 {
-	if(TryPlayAnimIdle())	return;
+	CActor* pActor = smart_cast<CActor*>(H_Parent());
+	if (!pActor)
+		return;
 
@@ -137,26 +157,109 @@
 		{
-		case 0:{
+		case 0:
+			{
 			PlayHUDMotion("anm_idle_aim_0", TRUE, NULL, GetState());
-		}break;
-		case 1:{
+			}
+			break;
+		case 1:
+			{
 			PlayHUDMotion("anm_idle_aim_1", TRUE, NULL, GetState());
-		}break;
-		case 2:{
+			}
+			break;
+		case 2:
+			{
 			PlayHUDMotion("anm_idle_aim_2", TRUE, NULL, GetState());
-		}break;
+			}
+			break;
 		};
-	}else{
+
+		return;
+	}
+
+	CEntity::SEntityState st;
+	pActor->g_State(st);
+	if (pActor->AnyMove())
+	{
+		if (pActor->is_safemode())
+		{
 		switch (m_magazine.size())
 		{
-		case 0:{
+			case 0:
+			{
 			PlayHUDMotion("anm_idle_0", TRUE, NULL, GetState());
-		}break;
-		case 1:{
+			}
+			break;
+			case 1:
+			{
 			PlayHUDMotion("anm_idle_1", TRUE, NULL, GetState());
-		}break;
-		case 2:{
+			}
+			break;
+			case 2:
+			{
 			PlayHUDMotion("anm_idle_2", TRUE, NULL, GetState());
-		}break;
+			}
+			break;
 		};
+
+			return;
+		}
+
+		if (st.bSprint)
+		{
+			PlayAnimIdleSprint();
+			return;
 	}
+		else if (!st.bCrouch)
+		{
+			PlayAnimIdleMoving();
+			return;
+		}
+		else if (st.bCrouch)
+		{
+			switch (m_magazine.size())
+			{
+			case 0:
+			{
+				HudAnimationExist("anm_idle_moving_crouch_0")
+					? PlayHUDMotion("anm_idle_moving_crouch_0", TRUE, NULL, GetState())
+					: PlayHUDMotion("anm_idle_moving_0", TRUE, NULL, GetState(), .7f);
+			}
+			break;
+			case 1:
+			{
+				HudAnimationExist("anm_idle_moving_crouch_1")
+					? PlayHUDMotion("anm_idle_moving_crouch_1", TRUE, NULL, GetState())
+					: PlayHUDMotion("anm_idle_moving_1", TRUE, NULL, GetState(), .7f);
+			}
+			break;
+			case 2:
+			{
+				HudAnimationExist("anm_idle_moving_crouch_2")
+					? PlayHUDMotion("anm_idle_moving_crouch_2", TRUE, NULL, GetState())
+					: PlayHUDMotion("anm_idle_moving_2", TRUE, NULL, GetState(), .7f);
+			}
+			break;
+			};
+
+			return;
+		}
+	}
+	
+	switch (m_magazine.size())
+	{
+	case 0:
+	{
+		PlayHUDMotion("anm_idle_0", TRUE, NULL, GetState());
+	}
+	break;
+	case 1:
+	{
+		PlayHUDMotion("anm_idle_1", TRUE, NULL, GetState());
+	}
+	break;
+	case 2:
+	{
+		PlayHUDMotion("anm_idle_2", TRUE, NULL, GetState());
+	}
+	break;
+	};
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/weaponBM16.h xray-monolith/src/xrGame/weaponBM16.h
--- coc-1.4-xray-64/src/xrGame/weaponBM16.h	2023-10-20 20:54:51.521326400 +0100
+++ xray-monolith/src/xrGame/weaponBM16.h	2023-10-20 20:54:33.419036400 +0100
@@ -22,3 +22,3 @@
 	virtual void	PlayAnimHide					();
-	virtual void	PlayAnimBore					();
+	virtual bool TryPlayAnimBore();
 	DECLARE_SCRIPT_REGISTER_FUNCTION
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/WeaponFire.cpp xray-monolith/src/xrGame/WeaponFire.cpp
--- coc-1.4-xray-64/src/xrGame/WeaponFire.cpp	2023-10-20 20:54:50.730326400 +0100
+++ xray-monolith/src/xrGame/WeaponFire.cpp	2023-10-20 20:54:32.679036900 +0100
@@ -51,4 +53,12 @@
 {
-	return conditionDecreasePerShot;
-};
+	return conditionDecreasePerShot * f_weapon_deterioration;
+}
+
+void CWeapon::FireStart()
+{
+	if (ParentIsActor())
+		Actor()->StopSprint();
+
+	CShootingObject::FireStart();
+}
 
@@ -73,3 +83,3 @@
 //	Msg("Deterioration = %f", Deterioration);
-	ChangeCondition(-GetWeaponDeterioration()*l_cartridge.param_s.impair);
+	ChangeCondition(-GetWeaponDeterioration() * l_cartridge.param_s.impair * cur_silencer_koef.condition_shot_dec);
 
@@ -121,4 +132,9 @@
 
+	// Interactive Grass FX
+	extern Fvector4 ps_ssfx_int_grass_params_2;
+	Fvector ShotPos = Fvector().mad(P, D, 1.5f);
+	g_pGamePersistent->GrassBendersAddShot(cast_game_object()->ID(), ShotPos, D, 3.0f, 20.0f, ps_ssfx_int_grass_params_2.z, ps_ssfx_int_grass_params_2.w);
 	
 	// Ammo
+	m_lastCartridge = l_cartridge;
 	m_magazine.pop_back	();
@@ -138,4 +154,3 @@
 	SwitchState(eIdle);
-
-	bWorking = false;
+	FireEnd();
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/WeaponKnife.cpp xray-monolith/src/xrGame/WeaponKnife.cpp
--- coc-1.4-xray-64/src/xrGame/WeaponKnife.cpp	2023-10-20 20:54:50.733327100 +0100
+++ xray-monolith/src/xrGame/WeaponKnife.cpp	2023-10-20 20:54:32.681035400 +0100
@@ -39,2 +39,4 @@
 	m_Hit2SpashDir.set	(0.f,0.f,1.f);
+
+	dwUpdateSounds_Frame = 0;
 }
@@ -52,2 +54,4 @@
 	m_sounds.LoadSound(section,"snd_shoot"		, "sndShot"		, false, SOUND_TYPE_WEAPON_SHOOTING		);
+	m_sounds.LoadSound(section, "snd_draw", "sndShow", false, SOUND_TYPE_ITEM_TAKING);
+	m_sounds.LoadSound(section, "snd_holster", "sndHide", false, SOUND_TYPE_ITEM_HIDING);
 	
@@ -73,5 +77,5 @@
 
-void CWeaponKnife::OnStateSwitch	(u32 S)
+void CWeaponKnife::OnStateSwitch(u32 S, u32 oldState)
 {
-	inherited::OnStateSwitch(S);
+	inherited::OnStateSwitch(S, oldState);
 	switch (S)
@@ -85,3 +89,6 @@
 	case eHiding:
+		if (oldState != eHiding)
+		{
 		switch2_Hiding	();
+		}
 		break;
@@ -268,2 +281,18 @@
 
+void CWeaponKnife::UpdateCL()
+{
+	inherited::UpdateCL();
+
+	if (Device.dwFrame == dwUpdateSounds_Frame)
+		return;
+
+	dwUpdateSounds_Frame = Device.dwFrame;
+
+	Fvector P = get_LastFP();
+
+	m_sounds.SetPosition("sndShow", P);
+	m_sounds.SetPosition("sndHide", P);
+}
+
+
 void CWeaponKnife::switch2_Attacking	(u32 state)
@@ -273,5 +302,5 @@
 	if(state==eFire)
-		PlayHUDMotion("anm_attack",		FALSE, this, state);
+		PlayHUDMotion("anm_attack", TRUE, this, state);
 	else //eFire2
-		PlayHUDMotion("anm_attack2",	FALSE, this, state);
+		PlayHUDMotion("anm_attack2", TRUE, this, state);
 
@@ -293,2 +322,3 @@
 	PlayHUDMotion("anm_hide", TRUE, this, GetState());
+	PlaySound("sndHide", get_LastFP());
 }
@@ -304,3 +334,5 @@
 	VERIFY(GetState()==eShowing);
-	PlayHUDMotion("anm_show", FALSE, this, GetState());
+	if (ParentIsActor()) g_player_hud->attach_item(this);
+	PlayHUDMotion("anm_show", FALSE, this, GetState(), 1.f, 0.f, false);
+	PlaySound("sndShow", get_LastFP());
 }
@@ -310,3 +342,2 @@
 {	
-	inherited::FireStart();
 	SwitchState			(eFire);
@@ -322,8 +353,11 @@
 {
-	if(inherited::Action(cmd, flags)) return true;
 	switch(cmd) 
 	{
+	case kWPN_FIRE:
+		if (flags & CMD_START && !IsPending())
+			FireStart();
 
+		return true;
 		case kWPN_ZOOM : 
-			if(flags&CMD_START) 
+		if (flags & CMD_START && !IsPending())
 				Fire2Start			();
@@ -332,2 +366,5 @@
 	}
+
+	if (inherited::Action(cmd, flags)) return true;
+
 	return false;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/WeaponKnife.h xray-monolith/src/xrGame/WeaponKnife.h
--- coc-1.4-xray-64/src/xrGame/WeaponKnife.h	2023-10-20 20:54:50.733327100 +0100
+++ xray-monolith/src/xrGame/WeaponKnife.h	2023-10-20 20:54:32.682035500 +0100
@@ -11,2 +12,3 @@
 protected:
+	virtual void UpdateCL();
 
@@ -20,3 +22,3 @@
 	virtual void		OnMotionMark				(u32 state, const motion_marks&);
-	virtual void		OnStateSwitch				(u32 S);
+	virtual void OnStateSwitch(u32 S, u32 oldState);
 
@@ -46,2 +48,4 @@
 
+	u32 dwUpdateSounds_Frame;
+
 protected:
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/WeaponMagazined.cpp xray-monolith/src/xrGame/WeaponMagazined.cpp
--- coc-1.4-xray-64/src/xrGame/WeaponMagazined.cpp	2023-10-20 20:54:50.734326800 +0100
+++ xray-monolith/src/xrGame/WeaponMagazined.cpp	2023-10-20 20:54:32.683035500 +0100
@@ -1,2 +1,2 @@
-#include "pch_script.h"
+ï»¿#include "pch_script.h"
 
@@ -5,4 +5,4 @@
 #include "ParticlesObject.h"
-#include "scope.h"
-#include "silencer.h"
+#include "Scope.h"
+#include "Silencer.h"
 #include "GrenadeLauncher.h"
@@ -23,2 +23,3 @@
 #include "script_game_object.h"
+#include "player_hud.h"
 #include "HudSound.h"
@@ -27,3 +28,5 @@
 
-ENGINE_API	bool	g_dedicated_server;
+extern ENGINE_API bool g_dedicated_server;
+ENGINE_API extern float psHUD_FOV;
+ENGINE_API extern float psHUD_FOV_def;
 
@@ -47,7 +50,5 @@
     m_eSoundReload = ESoundTypes(SOUND_TYPE_WEAPON_RECHARGING | eSoundType);
-#ifdef NEW_SOUNDS
     m_eSoundReloadEmpty = ESoundTypes(SOUND_TYPE_WEAPON_RECHARGING | eSoundType);
-#endif
-    m_sounds_enabled = true;
 
+	m_sounds_enabled = true;
     m_sSndShotCurrent = NULL;
@@ -57,3 +58,3 @@
     m_iShotNum = 0;
-    m_fOldBulletSpeed = 0;
+	m_fOldBulletSpeed = 0.f;
     m_iQueueSize = WEAPON_ININITE_QUEUE;
@@ -98,13 +100,13 @@
 	//Alundaio: LAYERED_SND_SHOOT
-#ifdef LAYERED_SND_SHOOT
-	m_layered_sounds.LoadSound(section, "snd_shoot", "sndShot", false, m_eSoundShot);
-	//if (WeaponSoundExist(section, "snd_shoot_actor"))
-	//	m_layered_sounds.LoadSound(section, "snd_shoot_actor", "sndShotActor", false, m_eSoundShot);
-#else
 	m_sounds.LoadSound(section, "snd_shoot", "sndShot", false, m_eSoundShot);
-	//if (WeaponSoundExist(section, "snd_shoot_actor"))
-	//	m_sounds.LoadSound(section, "snd_shoot_actor", "sndShot", false, m_eSoundShot);
-#endif
+	if (WeaponSoundExist(section, "snd_shoot_actor"))
+		m_sounds.LoadSound(section, "snd_shoot_actor", "sndShotActor", false, m_eSoundShot);
 	//-Alundaio
 
+	//misfire shot
+	if (WeaponSoundExist(section, "snd_shot_misfire"))
+		m_sounds.LoadSound(section, "snd_shot_misfire", "sndShotMisfire", false, m_eSoundShot);
+	if (WeaponSoundExist(section, "snd_shot_misfire_actor"))
+		m_sounds.LoadSound(section, "snd_shot_misfire_actor", "sndShotMisfireActor", false, m_eSoundShot);
+
     m_sounds.LoadSound(section, "snd_empty", "sndEmptyClick", true, m_eSoundEmptyClick);
@@ -112,3 +114,2 @@
 
-#ifdef NEW_SOUNDS //AVO: custom sounds go here
     if (WeaponSoundExist(section, "snd_reload_empty"))
@@ -117,3 +118,22 @@
         m_sounds.LoadSound(section, "snd_reload_misfire", "sndReloadMisfire", true, m_eSoundReloadMisfire);
-#endif //-NEW_SOUNDS
+	if (WeaponSoundExist(section, "snd_switch_mode"))
+		m_sounds.LoadSound(section, "snd_switch_mode", "sndSwitchMode", true, m_eSoundEmptyClick);
+	if (WeaponSoundExist(section, "snd_misfire"))
+		m_sounds.LoadSound(section, "snd_misfire", "sndClickMisfire", true, m_eSoundEmptyClick);
+
+	if (WeaponSoundExist(section, "snd_reload_actor"))
+		m_sounds.LoadSound(section, "snd_reload_actor", "sndReloadActor", true, m_eSoundReload);
+	if (WeaponSoundExist(section, "snd_reload_empty_actor"))
+		m_sounds.LoadSound(section, "snd_reload_empty_actor", "sndReloadEmptyActor", true, m_eSoundReloadEmpty);
+	if (WeaponSoundExist(section, "snd_reload_misfire_actor"))
+		m_sounds.LoadSound(section, "snd_reload_misfire_actor", "sndReloadMisfireActor", true, m_eSoundReloadMisfire);
+	if (WeaponSoundExist(section, "snd_empty_actor"))
+		m_sounds.LoadSound(section, "snd_empty_actor", "sndEmptyClickActor", true, m_eSoundEmptyClick);
+	if (WeaponSoundExist(section, "snd_misfire_actor"))
+		m_sounds.LoadSound(section, "snd_misfire_actor", "sndClickMisfireActor", true, m_eSoundEmptyClick);
+
+	if (WeaponSoundExist(section, "snd_draw_actor"))
+		m_sounds.LoadSound(section, "snd_draw_actor", "sndShowActor", true, m_eSoundShow);
+	if (WeaponSoundExist(section, "snd_holster_actor"))
+		m_sounds.LoadSound(section, "snd_holster_actor", "sndHideActor", true, m_eSoundHide);
 
@@ -121,3 +141,3 @@
 
-    //çâóêè è ïàðòèêëû ãëóøèòåëÿ, åñëèò òàêîé åñòü
+	//Ã§Ã¢Ã³ÃªÃ¨ Ã¨ Ã¯Ã Ã°Ã²Ã¨ÃªÃ«Ã» Ã£Ã«Ã³Ã¸Ã¨Ã²Ã¥Ã«Ã¿, Ã¥Ã±Ã«Ã¨Ã² Ã²Ã ÃªÃ®Ã© Ã¥Ã±Ã²Ã¼
     if (m_eSilencerStatus == ALife::eAddonAttachable || m_eSilencerStatus == ALife::eAddonPermanent)
@@ -130,7 +150,2 @@
 		//Alundaio: LAYERED_SND_SHOOT Silencer
-#ifdef LAYERED_SND_SHOOT
-		m_layered_sounds.LoadSound(section, "snd_silncer_shot", "sndSilencerShot", false, m_eSoundShot);
-		if (WeaponSoundExist(section, "snd_silncer_shot_actor"))
-			m_layered_sounds.LoadSound(section, "snd_silncer_shot_actor", "sndSilencerShotActor", false, m_eSoundShot);
-#else
 		m_sounds.LoadSound(section, "snd_silncer_shot", "sndSilencerShot", false, m_eSoundShot);
@@ -138,5 +153,10 @@
 		m_sounds.LoadSound(section, "snd_silncer_shot_actor", "sndSilencerShotActor", false, m_eSoundShot);
-#endif
 		//-Alundaio
 
+		//misfire shot
+		if (WeaponSoundExist(section, "snd_silncer_shot_misfire"))
+			m_sounds.LoadSound(section, "snd_silncer_shot_misfire", "sndSilencerShotMisfire", false, m_eSoundShot);
+		if (WeaponSoundExist(section, "snd_silncer_shot_misfire_actor"))
+			m_sounds.LoadSound(section, "snd_silncer_shot_misfire_actor", "sndSilencerShotMisfireActor", false, m_eSoundShot);
+		
     }
@@ -168,2 +189,25 @@
     LoadSilencerKoeffs();
+	LoadScopeKoeffs();
+
+	empty_click_layer = READ_IF_EXISTS(pSettings, r_string, *hud_sect, "empty_click_anm", nullptr);
+
+	if (empty_click_layer)
+	{
+		empty_click_speed = READ_IF_EXISTS(pSettings, r_float, *hud_sect, "empty_click_anm_speed", 1.f);
+		empty_click_power = READ_IF_EXISTS(pSettings, r_float, *hud_sect, "empty_click_anm_power", 1.f);
+	}
+
+	if (pSettings->line_exist(section, "bullet_bones"))
+	{
+		bHasBulletsToHide = true;
+		LPCSTR str = pSettings->r_string(section, "bullet_bones");
+		for (int i = 0, count = _GetItemCount(str); i < count; ++i)
+		{
+			string128 bullet_bone_name;
+			_GetItem(str, i, bullet_bone_name);
+			bullets_bones.push_back(bullet_bone_name);
+			bullet_cnt++;
+		}
+
+	}
 }
@@ -271,3 +316,3 @@
             {
-                m_ammoType = i;
+					m_set_next_ammoType_on_reload = i;
                 SetPending(TRUE);
@@ -311,8 +356,46 @@
 
-    if (GetNextState() != eMagEmpty && GetNextState() != eReload)
+	inherited::OnMagazineEmpty();
+}
+
+int CWeaponMagazined::CheckAmmoBeforeReload(u8& v_ammoType)
     {
-        SwitchState(eMagEmpty);
+	if (m_set_next_ammoType_on_reload != undefined_ammo_type)
+		v_ammoType = m_set_next_ammoType_on_reload;
+
+	//Msg("Ammo type in next reload : %d", m_set_next_ammoType_on_reload);
+
+	if (m_ammoTypes.size() <= v_ammoType)
+	{
+		//Msg("Ammo type is wrong : %d", v_ammoType);
+		return 0;
     }
 
-    inherited::OnMagazineEmpty();
+	LPCSTR tmp_sect_name = m_ammoTypes[v_ammoType].c_str();
+
+	if (!tmp_sect_name)
+	{
+		//Msg("Sect name is wrong");
+		return 0;
+	}
+
+	CWeaponAmmo* ammo = smart_cast<CWeaponAmmo*>(m_pInventory->GetAny(tmp_sect_name));
+
+	if (!ammo && !m_bLockType)
+	{
+		for (u8 i = 0; i < u8(m_ammoTypes.size()); ++i)
+		{
+			//Ð¿ÑÐ¾Ð²ÐµÑÐ¸ÑÑ Ð¿Ð°ÑÑÐ¾Ð½Ñ Ð²ÑÐµÑ Ð¿Ð¾Ð´ÑÐ¾Ð´ÑÑÐ¸Ñ ÑÐ¸Ð¿Ð¾Ð²
+			ammo = smart_cast<CWeaponAmmo*>(m_pInventory->GetAny(m_ammoTypes[i].c_str()));
+			if (ammo)
+			{
+				v_ammoType = i;
+				break;
+			}
+		}
+	}
+
+	//Msg("Ammo type %d", v_ammoType);
+
+	return GetAmmoCount(v_ammoType);
+
 }
@@ -321,2 +404,5 @@
 {
+	last_hide_bullet = -1;
+	HUD_VisualBulletUpdate();
+
     xr_map<LPCSTR, u16> l_ammo;
@@ -367,3 +453,3 @@
         }
-        if (l_it->second && !unlimited_ammo()) SpawnAmmo(l_it->second, l_it->first);
+		if (l_it->second /*&& !unlimited_ammo()*/) SpawnAmmo(l_it->second, l_it->first);
     }
@@ -373,6 +459,15 @@
 {
+	m_needReload = false;
     m_BriefInfo_CalcFrame = 0;
 
-    //óñòðàíèòü îñå÷êó ïðè ïåðåçàðÿäêå
-    if (IsMisfire())	bMisfire = false;
+	//Ã³Ã±Ã²Ã°Ã Ã­Ã¨Ã²Ã¼ Ã®Ã±Ã¥Ã·ÃªÃ³ Ã¯Ã°Ã¨ Ã¯Ã¥Ã°Ã¥Ã§Ã Ã°Ã¿Ã¤ÃªÃ¥
+	if (IsMisfire())
+	{
+		bMisfire = false;
+		if (bClearJamOnly)
+		{
+			bClearJamOnly = false;
+			return;
+		}
+	}
 
@@ -401,3 +496,3 @@
 
-        //ïîïûòàòüñÿ íàéòè â èíâåíòàðå ïàòðîíû òåêóùåãî òèïà
+		//Ã¯Ã®Ã¯Ã»Ã²Ã Ã²Ã¼Ã±Ã¿ Ã­Ã Ã©Ã²Ã¨ Ã¢ Ã¨Ã­Ã¢Ã¥Ã­Ã²Ã Ã°Ã¥ Ã¯Ã Ã²Ã°Ã®Ã­Ã» Ã²Ã¥ÃªÃ³Ã¹Ã¥Ã£Ã® Ã²Ã¨Ã¯Ã 
         m_pCurrentAmmo = smart_cast<CWeaponAmmo*>(m_pInventory->GetAny(tmp_sect_name));
@@ -408,3 +503,3 @@
             {
-                //ïðîâåðèòü ïàòðîíû âñåõ ïîäõîäÿùèõ òèïîâ
+				//Ã¯Ã°Ã®Ã¢Ã¥Ã°Ã¨Ã²Ã¼ Ã¯Ã Ã²Ã°Ã®Ã­Ã» Ã¢Ã±Ã¥Ãµ Ã¯Ã®Ã¤ÃµÃ®Ã¤Ã¿Ã¹Ã¨Ãµ Ã²Ã¨Ã¯Ã®Ã¢
                 m_pCurrentAmmo = smart_cast<CWeaponAmmo*>(m_pInventory->GetAny(m_ammoTypes[i].c_str()));
@@ -419,6 +514,6 @@
 
-    //íåò ïàòðîíîâ äëÿ ïåðåçàðÿäêè
+	//Ã­Ã¥Ã² Ã¯Ã Ã²Ã°Ã®Ã­Ã®Ã¢ Ã¤Ã«Ã¿ Ã¯Ã¥Ã°Ã¥Ã§Ã Ã°Ã¿Ã¤ÃªÃ¨
     if (!m_pCurrentAmmo && !unlimited_ammo()) return;
 
-    //ðàçðÿäèòü ìàãàçèí, åñëè çàãðóæàåì ïàòðîíàìè äðóãîãî òèïà
+	//Ã°Ã Ã§Ã°Ã¿Ã¤Ã¨Ã²Ã¼ Ã¬Ã Ã£Ã Ã§Ã¨Ã­, Ã¥Ã±Ã«Ã¨ Ã§Ã Ã£Ã°Ã³Ã¦Ã Ã¥Ã¬ Ã¯Ã Ã²Ã°Ã®Ã­Ã Ã¬Ã¨ Ã¤Ã°Ã³Ã£Ã®Ã£Ã® Ã²Ã¨Ã¯Ã 
     if (!m_bLockType && !m_magazine.empty() &&
@@ -426,3 +521,3 @@
         *m_magazine.back().m_ammoSect)))
-        UnloadMagazine();
+		UnloadMagazine(!unlimited_ammo());
 
@@ -431,3 +526,3 @@
     if (m_DefaultCartridge.m_LocalAmmoType != m_ammoType)
-        m_DefaultCartridge.Load(m_ammoTypes[m_ammoType].c_str(), m_ammoType);
+		m_DefaultCartridge.Load(m_ammoTypes[m_ammoType].c_str(), m_ammoType, m_APk);
     CCartridge l_cartridge = m_DefaultCartridge;
@@ -446,3 +541,3 @@
 
-    //âûêèíóòü êîðîáêó ïàòðîíîâ, åñëè îíà ïóñòàÿ
+	//Ã¢Ã»ÃªÃ¨Ã­Ã³Ã²Ã¼ ÃªÃ®Ã°Ã®Ã¡ÃªÃ³ Ã¯Ã Ã²Ã°Ã®Ã­Ã®Ã¢, Ã¥Ã±Ã«Ã¨ Ã®Ã­Ã  Ã¯Ã³Ã±Ã²Ã Ã¿
     if (m_pCurrentAmmo && !m_pCurrentAmmo->m_boxCurr && OnServer())
@@ -460,5 +555,6 @@
 
-void CWeaponMagazined::OnStateSwitch(u32 S)
+void CWeaponMagazined::OnStateSwitch(u32 S, u32 oldState)
 {
-    inherited::OnStateSwitch(S);
+	HUD_VisualBulletUpdate();
+	inherited::OnStateSwitch(S, oldState);
     CInventoryOwner* owner = smart_cast<CInventoryOwner*>(this->H_Parent());
@@ -476,4 +572,7 @@
         break;
-    case eMagEmpty:
-        switch2_Empty();
+	case eAimStart:
+		switch2_StartAim();
+		break;
+	case eAimEnd:
+		switch2_EndAim();
         break;
@@ -492,2 +591,3 @@
             m_sounds_enabled = owner->CanPlayShHdRldSounds();
+		if (oldState != eHiding)
         switch2_Hiding();
@@ -505,4 +605,4 @@
 
-    //êîãäà ïðîèñõîäèò àïäåéò ñîñòîÿíèÿ îðóæèÿ
-    //íè÷åãî äðóãîãî íå äåëàòü
+	//ÃªÃ®Ã£Ã¤Ã  Ã¯Ã°Ã®Ã¨Ã±ÃµÃ®Ã¤Ã¨Ã² Ã Ã¯Ã¤Ã¥Ã©Ã² Ã±Ã®Ã±Ã²Ã®Ã¿Ã­Ã¨Ã¿ Ã®Ã°Ã³Ã¦Ã¨Ã¿
+	//Ã­Ã¨Ã·Ã¥Ã£Ã® Ã¤Ã°Ã³Ã£Ã®Ã£Ã® Ã­Ã¥ Ã¤Ã¥Ã«Ã Ã²Ã¼
     if (GetNextState() == GetState())
@@ -522,5 +623,6 @@
             state_Fire(dt);
-        }break;
-        case eMisfire:		state_Misfire(dt);	break;
-        case eMagEmpty:		state_MagEmpty(dt);	break;
+			}
+			break;
+		case eMisfire: state_Misfire(dt);
+			break;
         case eHidden:		break;
@@ -542,11 +644,29 @@
     m_sounds.SetPosition("sndHide", P);
-    //. nah	m_sounds.SetPosition("sndShot", P);
     m_sounds.SetPosition("sndReload", P);
 
-#ifdef NEW_SOUNDS //AVO: custom sounds go here
+	// New Sounds
     if (m_sounds.FindSoundItem("sndReloadEmpty", false))
         m_sounds.SetPosition("sndReloadEmpty", P);
-#endif //-NEW_SOUNDS
-
-    //. nah	m_sounds.SetPosition("sndEmptyClick", P);
+	if (m_sounds.FindSoundItem("sndReloadMisfire", false))
+		m_sounds.SetPosition("sndReloadMisfire", P);
+	if (m_sounds.FindSoundItem("sndReloadActor", false))
+		m_sounds.SetPosition("sndReloadActor", P);
+	if (m_sounds.FindSoundItem("sndReloadEmptyActor", false))
+		m_sounds.SetPosition("sndReloadEmptyActor", P);
+	if (m_sounds.FindSoundItem("sndReloadMisfireActor", false))
+		m_sounds.SetPosition("sndReloadMisfireActor", P);
+	if (m_sounds.FindSoundItem("sndEmptyClickActor", false))
+		m_sounds.SetPosition("sndEmptyClickActor", P);
+	if (m_sounds.FindSoundItem("sndShowActor", false))
+		m_sounds.SetPosition("sndShowActor", P); 
+	if (m_sounds.FindSoundItem("sndHideActor", false))
+		m_sounds.SetPosition("sndHideActor", P);
+	if (m_sounds.FindSoundItem("sndClickMisfire", false))
+		m_sounds.SetPosition("sndClickMisfire", P);
+	if (m_sounds.FindSoundItem("sndClickMisfireActor", false))
+		m_sounds.SetPosition("sndClickMisfireActor", P);
+	if (m_sounds.FindSoundItem("sndShotMisfire", false))
+		m_sounds.SetPosition("sndShotMisfire", P);
+	if (m_sounds.FindSoundItem("sndShotMisfireActor", false))
+		m_sounds.SetPosition("sndShotMisfireActor", P);
 }
@@ -595,10 +716,5 @@
 
-        while (!m_magazine.empty() && fShotTimeCounter < 0 && (IsWorking() || m_bFireSingleShot) && (m_iQueueSize < 0 || m_iShotNum < m_iQueueSize))
+		while (!m_magazine.empty() && fShotTimeCounter < 0 && (IsWorking() || m_bFireSingleShot) && (m_iQueueSize < 0 ||
+			m_iShotNum < m_iQueueSize))
         {
-            if (CheckForMisfire())
-            {
-                StopShooting();
-                return;
-            }
-
             m_bFireSingleShot = false;
@@ -607,3 +723,3 @@
 			//Alundaio: Cycle down RPM after two shots; used for Abakan/AN-94
-			if (GetCurrentFireMode() == 2 || (bCycleDown == true && m_iShotNum <= 1) )
+			if (GetCurrentFireMode() == 3 || GetCurrentFireMode() == 2 || (bCycleDown == true && m_iShotNum < 1))
 			{
@@ -617,2 +733,3 @@
 
+			CheckForMisfire();
             OnShot();
@@ -623,2 +740,11 @@
                 FireTrace(m_vStartPos, m_vStartDir);
+
+			if (bMisfire)
+			{
+				CGameObject* object = smart_cast<CGameObject*>(H_Parent());
+				if (object)
+					object->callback(GameObject::eOnWeaponJammed)(object->lua_game_object(), this->lua_game_object());
+				StopShooting();
+				return;
+			}
         }
@@ -665,5 +791,2 @@
 
-void CWeaponMagazined::state_MagEmpty(float dt)
-{}
-
 void CWeaponMagazined::SetDefaults()
@@ -673,40 +796,44 @@
 
-void CWeaponMagazined::OnShot()
+void CWeaponMagazined::PlaySoundShot()
 {
-    // SoundWeaponMagazined.cpp
-
+	if (ParentIsActor())
+	{
+		if (bMisfire)
+		{
+			string128 sndNameMisfire;
+			strconcat(sizeof(sndNameMisfire), sndNameMisfire, m_sSndShotCurrent.c_str(), "MisfireActor");
+			if (m_sounds.FindSoundItem(sndNameMisfire, false))
+			{
+				m_sounds.PlaySound(sndNameMisfire, get_LastFP(), H_Root(), !!GetHUDmode(), false, (u8)-1);
+				return;
+			}
+		}
 
+		string128 sndName;
+		strconcat(sizeof(sndName), sndName, m_sSndShotCurrent.c_str(), "Actor");
+		if (m_sounds.FindSoundItem(sndName, false))
+		{
+			m_sounds.PlaySound(sndName, get_LastFP(), H_Root(), !!GetHUDmode(), false, (u8)-1);
+			return;
+		}
+	}
 	
-//Alundaio: LAYERED_SND_SHOOT
-#ifdef LAYERED_SND_SHOOT
-	//Alundaio: Actor sounds
-	if (ParentIsActor())
+	if (bMisfire)
 	{
-		/*
-		if (strcmp(m_sSndShotCurrent.c_str(), "sndShot") == 0 && pSettings->line_exist(m_section_id,"snd_shoot_actor") && m_layered_sounds.FindSoundItem("sndShotActor", false))
-			m_layered_sounds.PlaySound("sndShotActor", get_LastFP(), H_Root(), !!GetHUDmode(), false, (u8)-1);
-		else if (strcmp(m_sSndShotCurrent.c_str(), "sndSilencerShot") == 0 && pSettings->line_exist(m_section_id,"snd_silncer_shot_actor") && m_layered_sounds.FindSoundItem("sndSilencerShotActor", false))
-			m_layered_sounds.PlaySound("sndSilencerShotActor", get_LastFP(), H_Root(), !!GetHUDmode(), false, (u8)-1);
-		else 
-		*/
-			m_layered_sounds.PlaySound(m_sSndShotCurrent.c_str(), get_LastFP(), H_Root(), !!GetHUDmode(), false, (u8)-1);
-	} else
-		m_layered_sounds.PlaySound(m_sSndShotCurrent.c_str(), get_LastFP(), H_Root(), !!GetHUDmode(), false, (u8)-1);
-#else
-	//Alundaio: Actor sounds
-	if (ParentIsActor())
+		string128 sndNameMisfire;
+		strconcat(sizeof(sndNameMisfire), sndNameMisfire, m_sSndShotCurrent.c_str(), "Misfire");
+		if (m_sounds.FindSoundItem(sndNameMisfire, false))
 	{
-		/*
-		if (strcmp(m_sSndShotCurrent.c_str(), "sndShot") == 0 && pSettings->line_exist(m_section_id, "snd_shoot_actor")&& snd_silncer_shot m_sounds.FindSoundItem("sndShotActor", false))
-			PlaySound("sndShotActor", get_LastFP(), (u8)(m_iShotNum - 1));
-		else if (strcmp(m_sSndShotCurrent.c_str(), "sndSilencerShot") == 0 && pSettings->line_exist(m_section_id, "snd_silncer_shot_actor") && m_sounds.FindSoundItem("sndSilencerShotActor", false))
-			PlaySound("sndSilencerShotActor", get_LastFP(), (u8)(m_iShotNum - 1));
-		else
-		*/
-			PlaySound(m_sSndShotCurrent.c_str(), get_LastFP(), (u8)-1);
+			m_sounds.PlaySound(sndNameMisfire, get_LastFP(), H_Root(), !!GetHUDmode(), false, (u8)-1);
+			return;
+		}
 	}
-	else
-		PlaySound(m_sSndShotCurrent.c_str(), get_LastFP(), (u8)-1); //Alundaio: Play sound at index (ie. snd_shoot, snd_shoot1, snd_shoot2, snd_shoot3)
-#endif
-//-Alundaio
+
+	m_sounds.PlaySound(m_sSndShotCurrent.c_str(), get_LastFP(), H_Root(), !!GetHUDmode(), false, (u8)-1);
+}
+
+void CWeaponMagazined::OnShot()
+{
+	// Shot Sound
+	PlaySoundShot();
 
@@ -718,2 +845,5 @@
 
+	// Update bullets
+	HUD_VisualBulletUpdate();
+
     // Shell Drop
@@ -723,6 +853,6 @@
 
-    // Îãîíü èç ñòâîëà
+	// ÃÃ£Ã®Ã­Ã¼ Ã¨Ã§ Ã±Ã²Ã¢Ã®Ã«Ã 
     StartFlameParticles();
 
-    //äûì èç ñòâîëà
+	//Ã¤Ã»Ã¬ Ã¨Ã§ Ã±Ã²Ã¢Ã®Ã«Ã 
     ForceUpdateFireParticles();
@@ -728,3 +858,13 @@
     ForceUpdateFireParticles();
+
     StartSmokeParticles(get_LastFP(), vel);
+
+#ifdef EXTENDED_WEAPON_CALLBACKS
+	CGameObject* object = smart_cast<CGameObject*>(H_Parent());
+	if (object)
+		object->callback(GameObject::eOnWeaponFired)(object->lua_game_object(), this->lua_game_object(), iAmmoElapsed);
+#endif
+
+	// Ð­ÑÑÐµÐºÑ ÑÐ´Ð²Ð¸Ð³Ð° (Ð¾ÑÐ´Ð°ÑÐ°)
+	AddHUDShootingEffect();
 }
@@ -733,2 +873,26 @@
 {
+	if (ParentIsActor())
+	{
+		if (bMisfire)
+		{
+			if (m_sounds.FindSoundItem("sndClickMisfireActor", false))
+				PlaySound("sndClickMisfireActor", get_LastFP());
+			else if (m_sounds.FindSoundItem("sndClickMisfire", false))
+				PlaySound("sndClickMisfire", get_LastFP());
+			else
+				PlaySound("sndEmptyClick", get_LastFP());
+		}
+		else
+		{
+			if (m_sounds.FindSoundItem("sndEmptyClickActor", false))
+				PlaySound("sndEmptyClickActor", get_LastFP());
+			else
+				PlaySound("sndEmptyClick", get_LastFP());
+		}
+	}
+	else
+	{
+		if (bMisfire && m_sounds.FindSoundItem("sndClickMisfire", false))
+			PlaySound("sndClickMisfire", get_LastFP());
+		else
     PlaySound("sndEmptyClick", get_LastFP());
@@ -736,2 +900,6 @@
 
+	if (empty_click_layer)
+		PlayBlendAnm(empty_click_layer, empty_click_speed, empty_click_power);
+}
+
 void CWeaponMagazined::OnAnimationEnd(u32 state)
@@ -740,6 +908,16 @@
     {
-    case eReload:	ReloadMagazine();	SwitchState(eIdle);	break;	// End of reload animation
-    case eHiding:	SwitchState(eHidden);   break;	// End of Hide
-    case eShowing:	SwitchState(eIdle);		break;	// End of Show
-    case eIdle:		switch2_Idle();			break;  // Keep showing idle
+	case eReload: if (m_needReload) ReloadMagazine();
+		SwitchState(eIdle);
+		break; // End of reload animation
+	case eHiding: SwitchState(eHidden);
+		break; // End of Hide
+	case eShowing: SwitchState(eIdle);
+		break; // End of Show
+	case eIdle: switch2_Idle();
+		break; // Keep showing idle
+	case eAimStart: SwitchState(eIdle);		break;
+	case eAimEnd:   SwitchState(eIdle);		break;
+	case eSwitchMode: UpdateFireMode();
+		SwitchState(eIdle);
+		break; // Back to idle
     }
@@ -748,2 +926,8 @@
 
+void CWeaponMagazined::UpdateFireMode()
+{
+	m_iCurFireMode = (m_iCurFireMode + (m_nextFireMode ? 1 : -1) + m_aFireModes.size()) % m_aFireModes.size();
+	SetQueueSize(GetCurrentFireMode());
+}
+
 void CWeaponMagazined::switch2_Idle()
@@ -795,22 +980,22 @@
 
-void CWeaponMagazined::switch2_Empty()
+void CWeaponMagazined::PlayReloadSound()
 {
-    OnZoomOut();
-
-    if (!TryReload())
+	if (m_sounds_enabled)
     {
-        OnEmptyClick();
-    }
-    else
+		if (bMisfire && iAmmoElapsed)
     {
-        inherited::FireEnd();
-    }
-}
-void CWeaponMagazined::PlayReloadSound()
+			if (ParentIsActor())
 {
-    if (m_sounds_enabled)
+				if (m_sounds.FindSoundItem("sndReloadMisfireActor", false))
     {
-#ifdef NEW_SOUNDS //AVO: use custom sounds
-        if (bMisfire)
+					PlaySound("sndReloadMisfireActor", get_LastFP());
+					return;
+				}
+				if (m_sounds.FindSoundItem("sndReloadActor", false))
         {
+					PlaySound("sndReloadActor", get_LastFP());
+					return;
+				}
+			}
+
             //TODO: make sure correct sound is loaded in CWeaponMagazined::Load(LPCSTR section)
@@ -825,2 +1010,16 @@
             {
+				if (ParentIsActor())
+				{
+					if (m_sounds.FindSoundItem("sndReloadEmptyActor", false))
+					{
+						PlaySound("sndReloadEmptyActor", get_LastFP());
+						return;
+					}
+					if (m_sounds.FindSoundItem("sndReloadActor", false))
+					{
+						PlaySound("sndReloadActor", get_LastFP());
+						return;
+					}
+				}
+
                 if (m_sounds.FindSoundItem("sndReloadEmpty", false))
@@ -831,7 +1030,15 @@
             else
-                PlaySound("sndReload", get_LastFP());
+			{
+				if (ParentIsActor())
+				{
+					if (m_sounds.FindSoundItem("sndReloadActor", false))
+					{
+						PlaySound("sndReloadActor", get_LastFP());
+						return;
         }
-#else
+				}
+
         PlaySound("sndReload", get_LastFP());
-#endif //-AVO
+			}
+		}
     }
@@ -843,2 +1050,3 @@
 
+	m_needReload = true;
     PlayReloadSound();
@@ -853,3 +1062,8 @@
     if (m_sounds_enabled)
+	{
+		if (ParentIsActor() && m_sounds.FindSoundItem("sndHideActor", false))
+			m_sounds.PlaySound("sndHideActor", get_LastFP(), H_Root(), !!GetHUDmode(), false, (u8)-1);
+		else
         PlaySound("sndHide", get_LastFP());
+	}
 
@@ -867,2 +1081,3 @@
     RemoveShotEffector();
+	m_nearwall_last_hud_fov = psHUD_FOV_def;
 }
@@ -868,6 +1083,14 @@
 }
+
 void CWeaponMagazined::switch2_Showing()
 {
+	if (ParentIsActor()) g_player_hud->attach_item(this);
+
     if (m_sounds_enabled)
+	{
+		if (ParentIsActor() && m_sounds.FindSoundItem("sndShowActor", false))
+			PlaySound("sndShowActor", get_LastFP());
+		else
         PlaySound("sndShow", get_LastFP());
+	}
 
@@ -881,3 +1104,3 @@
 
-    //åñëè îðóæèå ÷åì-òî çàíÿòî, òî íè÷åãî íå äåëàòü
+	//Ã¥Ã±Ã«Ã¨ Ã®Ã°Ã³Ã¦Ã¨Ã¥ Ã·Ã¥Ã¬-Ã²Ã® Ã§Ã Ã­Ã¿Ã²Ã®, Ã²Ã® Ã­Ã¨Ã·Ã¥Ã£Ã® Ã­Ã¥ Ã¤Ã¥Ã«Ã Ã²Ã¼
     if (IsPending()) return false;
@@ -889,2 +1112,6 @@
         if (flags&CMD_START)
+			{
+				if (ParentIsActor() && Actor()->is_safemode())
+					Actor()->set_safemode(false);
+
             if (iAmmoElapsed < iMagazineSize || IsMisfire())
@@ -892,2 +1119,3 @@
     }
+		}
     return true;
@@ -897,6 +1125,8 @@
         {
-            OnPrevFireMode();
+				m_nextFireMode = false;
+				PlayAnimFireModeSwitch();
             return true;
         };
-    }break;
+		}
+		break;
     case kWPN_FIREMODE_NEXT:
@@ -905,6 +1135,8 @@
         {
-            OnNextFireMode();
+				m_nextFireMode = true;
+				PlayAnimFireModeSwitch();
             return true;
         };
-    }break;
+		}
+		break;
     }
@@ -913,2 +1145,63 @@
 
+void CWeaponMagazined::PlayAnimFireModeSwitch()
+{
+	if (!m_bHasDifferentFireModes) return;
+	if (m_aFireModes.size() <= 1) return;
+	if (GetState() != eIdle) return;
+
+	if (HudAnimationExist("anm_switch_mode"))
+	{
+		SetPending(TRUE);
+		iAmmoElapsed == 0 && HudAnimationExist("anm_switch_mode_empty")
+			? PlayHUDMotion("anm_switch_mode_empty", TRUE, this, eSwitchMode)
+			: PlayHUDMotion("anm_switch_mode", TRUE, this, eSwitchMode);
+	}
+	else
+		UpdateFireMode();
+
+	if (m_sounds.FindSoundItem("sndSwitchMode", false))
+		PlaySound("sndSwitchMode", get_LastFP());
+}
+
+bool CWeaponMagazined::TryPlayAnimBore()
+{
+	if (iAmmoElapsed == 0 && HudAnimationExist("anm_bore_empty"))
+	{
+		PlayHUDMotion("anm_bore_empty", TRUE, this, GetState());
+		return true;
+	}
+	
+	return inherited::TryPlayAnimBore();
+}
+
+void CWeaponMagazined::PlayAnimIdleSprint()
+{
+	iAmmoElapsed == 0 && HudAnimationExist("anm_idle_sprint_empty")
+		? PlayHUDMotion("anm_idle_sprint_empty", TRUE, NULL, GetState())
+		: inherited::PlayAnimIdleSprint();
+}
+
+void CWeaponMagazined::PlayAnimIdleMoving()
+{
+	bool bAccelerated = isActorAccelerated(Actor()->MovingState(), IsZoomed());
+
+	iAmmoElapsed == 0 && HudAnimationExist("anm_idle_moving_empty")
+		? PlayHUDMotion("anm_idle_moving_empty", TRUE, NULL, GetState(), bAccelerated ? 1.f : .75f)
+		: inherited::PlayAnimIdleMoving();
+}
+
+bool CWeaponMagazined::PlayAnimCrouchIdleMoving()
+{
+	if (iAmmoElapsed == 0)
+	{
+		HudAnimationExist("anm_idle_moving_crouch_empty")
+			? PlayHUDMotion("anm_idle_moving_crouch_empty", TRUE, NULL, GetState())
+			: HudAnimationExist("anm_idle_moving_empty") ? PlayHUDMotion("anm_idle_moving_empty", TRUE, NULL, GetState(), .7f) : inherited::PlayAnimCrouchIdleMoving();
+
+		return true;
+	}
+
+	return inherited::PlayAnimCrouchIdleMoving();
+}
+
 bool CWeaponMagazined::CanAttach(PIItem pIItem)
@@ -955,8 +1248,10 @@
         {
-            if (pSettings->r_string((*it), "scope_name") == item_section_name)
+			LPCSTR iter_scope_name = pSettings->r_string((*it), "scope_name");
+			if (!xr_strcmp(iter_scope_name, item_section_name))
+			{
                 return true;
         }
+		}
         return false;
     }
-    //	   return true;
     else if (m_eSilencerStatus == ALife::eAddonAttachable &&
@@ -1016,3 +1311,3 @@
         {
-            //óíè÷òîæèòü ïîäñîåäèíåííóþ âåùü èç èíâåíòàðÿ
+			//Ã³Ã­Ã¨Ã·Ã²Ã®Ã¦Ã¨Ã²Ã¼ Ã¯Ã®Ã¤Ã±Ã®Ã¥Ã¤Ã¨Ã­Ã¥Ã­Ã­Ã³Ã¾ Ã¢Ã¥Ã¹Ã¼ Ã¨Ã§ Ã¨Ã­Ã¢Ã¥Ã­Ã²Ã Ã°Ã¿
             //.			pIItem->Drop					();
@@ -1094,11 +1389,6 @@
 }
-/*
-void CWeaponMagazined::LoadAddons()
-{
-m_zoom_params.m_fIronSightZoomFactor = READ_IF_EXISTS( pSettings, r_float, cNameSect(), "ironsight_zoom_factor", 50.0f );
-}
-*/
+
+extern int scope_2dtexactive; //crookr
 void CWeaponMagazined::InitAddons()
 {
-    m_zoom_params.m_fIronSightZoomFactor = READ_IF_EXISTS(pSettings, r_float, cNameSect(), "ironsight_zoom_factor", 50.0f);
     if (IsScopeAttached())
@@ -1108,7 +1398,3 @@
         {
-            //m_scopes[cur_scope]->m_sScopeName = pSettings->r_string(cNameSect(), "scope_name");
-            //m_scopes[cur_scope]->m_iScopeX	 = pSettings->r_s32(cNameSect(),"scope_x");
-            //m_scopes[cur_scope]->m_iScopeY	 = pSettings->r_s32(cNameSect(),"scope_y");
-
-            scope_tex_name = pSettings->r_string(GetScopeName(), "scope_texture");
+			scope_tex_name = READ_IF_EXISTS(pSettings, r_string, GetScopeName(), "scope_texture", NULL);
             m_zoom_params.m_fScopeZoomFactor = pSettings->r_float(GetScopeName(), "scope_zoom_factor");
@@ -1117,2 +1403,3 @@
             m_zoom_params.m_sUseBinocularVision = READ_IF_EXISTS(pSettings, r_string, GetScopeName(), "scope_alive_detector", 0);
+			m_fRTZoomFactor = m_zoom_params.m_fScopeZoomFactor;
             if (m_UIScope)
@@ -1120,5 +1407,6 @@
                 xr_delete(m_UIScope);
+				scope_2dtexactive = 0;//crookr
             }
 
-            if (!g_dedicated_server)
+			if (!g_dedicated_server && scope_tex_name != NULL)
             {
@@ -1129,2 +1417,3 @@
         }
+		ApplyScopeKoeffs();
     }
@@ -1132,14 +1421,11 @@
     {
-        if (m_UIScope)
+		if (m_eScopeStatus != ALife::eAddonPermanent && m_UIScope)
         {
             xr_delete(m_UIScope);
+			scope_2dtexactive = 0;//crookr
         }
-
-        if (IsZoomEnabled())
-        {
-            m_zoom_params.m_fIronSightZoomFactor = pSettings->r_float(cNameSect(), "scope_zoom_factor");
-        }
+		ResetScopeKoeffs();
     }
 
-    if (IsSilencerAttached()/* && SilencerAttachable() */)
+	if (IsSilencerAttached())
     {
@@ -1149,3 +1435,3 @@
 
-        //ïîäñâåòêà îò âûñòðåëà
+		//Load silencer values
         LoadLights(*cNameSect(), "silencer_");
@@ -1159,3 +1445,3 @@
 
-        //ïîäñâåòêà îò âûñòðåëà
+		//Load normal values
         LoadLights(*cNameSect(), "");
@@ -1178,10 +1464,45 @@
         m_silencer_koef.cam_disper_inc = READ_IF_EXISTS(pSettings, r_float, sect, "cam_dispersion_inc_k", 1.0f);
+		m_silencer_koef.pdm_base = READ_IF_EXISTS(pSettings, r_float, sect, "PDM_disp_base_k", 1.0f);
+		m_silencer_koef.pdm_accel = READ_IF_EXISTS(pSettings, r_float, sect, "PDM_disp_accel_k", 1.0f);
+		m_silencer_koef.pdm_vel = READ_IF_EXISTS(pSettings, r_float, sect, "PDM_disp_vel_k", 1.0f);
+		m_silencer_koef.crosshair_inertion = READ_IF_EXISTS(pSettings, r_float, sect, "crosshair_inertion_k", 1.0f);
+		m_silencer_koef.zoom_rotate_time = READ_IF_EXISTS(pSettings, r_float, sect, "zoom_rotate_time_k", 1.0f);
+		m_silencer_koef.condition_shot_dec = READ_IF_EXISTS(pSettings, r_float, sect, "condition_shot_dec_k", 1.0f);
+	}
+
+	clamp(m_silencer_koef.hit_power, 0.01f, 2.0f);
+	clamp(m_silencer_koef.hit_impulse, 0.01f, 2.0f);
+	clamp(m_silencer_koef.bullet_speed, 0.01f, 2.0f);
+	clamp(m_silencer_koef.fire_dispersion, 0.01f, 2.0f);
+	clamp(m_silencer_koef.cam_dispersion, 0.01f, 2.0f);
+	clamp(m_silencer_koef.cam_disper_inc, 0.01f, 2.0f);
+	clamp(m_silencer_koef.pdm_base, 0.01f, 2.0f);
+	clamp(m_silencer_koef.pdm_accel, 0.01f, 2.0f);
+	clamp(m_silencer_koef.pdm_vel, 0.01f, 2.0f);
+	clamp(m_silencer_koef.crosshair_inertion, 0.01f, 2.0f);
+	clamp(m_silencer_koef.zoom_rotate_time, 0.01f, 2.0f);
+	clamp(m_silencer_koef.condition_shot_dec, 0.01f, 2.0f);
     }
 
-    clamp(m_silencer_koef.hit_power, 0.0f, 1.0f);
-    clamp(m_silencer_koef.hit_impulse, 0.0f, 1.0f);
-    clamp(m_silencer_koef.bullet_speed, 0.0f, 1.0f);
-    clamp(m_silencer_koef.fire_dispersion, 0.0f, 3.0f);
-    clamp(m_silencer_koef.cam_dispersion, 0.0f, 1.0f);
-    clamp(m_silencer_koef.cam_disper_inc, 0.0f, 1.0f);
+void CWeaponMagazined::LoadScopeKoeffs()
+{
+	if (m_eScopeStatus == ALife::eAddonAttachable)
+	{
+		LPCSTR sect = GetScopeName().c_str();
+		m_scope_koef.cam_dispersion = READ_IF_EXISTS(pSettings, r_float, sect, "cam_dispersion_k", 1.0f);
+		m_scope_koef.cam_disper_inc = READ_IF_EXISTS(pSettings, r_float, sect, "cam_dispersion_inc_k", 1.0f);
+		m_scope_koef.pdm_base = READ_IF_EXISTS(pSettings, r_float, sect, "PDM_disp_base_k", 1.0f);
+		m_scope_koef.pdm_accel = READ_IF_EXISTS(pSettings, r_float, sect, "PDM_disp_accel_k", 1.0f);
+		m_scope_koef.pdm_vel = READ_IF_EXISTS(pSettings, r_float, sect, "PDM_disp_vel_k", 1.0f);
+		m_scope_koef.crosshair_inertion = READ_IF_EXISTS(pSettings, r_float, sect, "crosshair_inertion_k", 1.0f);
+		m_scope_koef.zoom_rotate_time = READ_IF_EXISTS(pSettings, r_float, sect, "zoom_rotate_time_k", 1.0f);
+	}
+
+	clamp(m_scope_koef.cam_dispersion, 0.01f, 2.0f);
+	clamp(m_scope_koef.cam_disper_inc, 0.01f, 2.0f);
+	clamp(m_scope_koef.pdm_base, 0.01f, 2.0f);
+	clamp(m_scope_koef.pdm_accel, 0.01f, 2.0f);
+	clamp(m_scope_koef.pdm_vel, 0.01f, 2.0f);
+	clamp(m_scope_koef.crosshair_inertion, 0.01f, 2.0f);
+	clamp(m_scope_koef.zoom_rotate_time, 0.01f, 2.0f);
 }
@@ -1193,2 +1514,7 @@
 
+void CWeaponMagazined::ApplyScopeKoeffs()
+{
+	cur_scope_koef = m_scope_koef;
+}
+
 void CWeaponMagazined::ResetSilencerKoeffs()
@@ -1198,6 +1524,16 @@
 
+void CWeaponMagazined::ResetScopeKoeffs()
+{
+	cur_scope_koef.Reset();
+}
+
 void CWeaponMagazined::PlayAnimShow()
 {
+
+	HUD_VisualBulletUpdate();
+
     VERIFY(GetState() == eShowing);
-    PlayHUDMotion("anm_show", FALSE, this, GetState());
+	iAmmoElapsed == 0 && HudAnimationExist("anm_show_empty")
+		? PlayHUDMotion("anm_show_empty", FALSE, this, GetState(), 1.f, 0.f, false)
+		: PlayHUDMotion("anm_show", FALSE, this, GetState(), 1.f, 0.f, false);
 }
@@ -1207,3 +1543,5 @@
     VERIFY(GetState() == eHiding);
-    PlayHUDMotion("anm_hide", TRUE, this, GetState());
+	iAmmoElapsed == 0 && HudAnimationExist("anm_hide_empty")
+		? PlayHUDMotion("anm_hide_empty", TRUE, this, GetState())
+		: PlayHUDMotion("anm_hide", TRUE, this, GetState());
 }
@@ -1214,3 +1552,3 @@
 #ifdef NEW_ANIMS //AVO: use new animations
-    if (bMisfire)
+	if (bMisfire && iAmmoElapsed != 0)
     {
@@ -1218,3 +1556,7 @@
         if (HudAnimationExist("anm_reload_misfire"))
+		{
             PlayHUDMotion("anm_reload_misfire", TRUE, this, GetState());
+			bClearJamOnly = true;
+			return;
+		}
         else
@@ -1243,3 +1585,5 @@
 {
-    PlayHUDMotion("anm_idle_aim", TRUE, NULL, GetState());
+	iAmmoElapsed == 0 && HudAnimationExist("anm_idle_aim_empty")
+		? PlayHUDMotion("anm_idle_aim_empty", TRUE, NULL, GetState())
+		: PlayHUDMotion("anm_idle_aim", TRUE, NULL, GetState());
 }
@@ -1252,5 +1596,10 @@
         PlayAnimAim();
+		return;
     }
-    else
-        inherited::PlayAnimIdle();
+
+	if (TryPlayAnimIdle()) return;
+
+	iAmmoElapsed == 0 && HudAnimationExist("anm_idle_empty")
+		? PlayHUDMotion("anm_idle_empty", TRUE, NULL, GetState())
+		: PlayHUDMotion("anm_idle", TRUE, NULL, GetState());
 }
@@ -1260,3 +1609,51 @@
     VERIFY(GetState() == eFire);
-    PlayHUDMotion("anm_shots", FALSE, this, GetState());
+	if (iAmmoElapsed > 1 || !HudAnimationExist("anm_shot_l"))
+	{
+		if(!IsZoomed() || !HudAnimationExist("anm_shots_aim"))
+			PlayHUDMotion("anm_shots", TRUE, this, GetState(), 1.f, 0.f, false);
+		else
+			PlayHUDMotion("anm_shots_aim", TRUE, this, GetState(), 1.f, 0.f, false);
+	}
+	else 
+	{
+		if (!IsZoomed() || !HudAnimationExist("anm_shots_aim_l"))
+			PlayHUDMotion("anm_shot_l", TRUE, this, GetState(), 1.f, 0.f, false);
+		else
+			PlayHUDMotion("anm_shots_aim_l", TRUE, this, GetState(), 1.f, 0.f, false);
+	}
+}
+
+void CWeaponMagazined::OnMotionMark(u32 state, const motion_marks& M)
+{
+	inherited::OnMotionMark(state, M);
+
+	if (state == eReload)
+	{
+		if (bClearJamOnly)
+		{
+			bMisfire = false;
+			bClearJamOnly = false;
+			return;
+		}
+		
+		if (bHasBulletsToHide && xr_strcmp(M.name.c_str(),"lmg_reload")==0)
+		{
+			u8 ammo_type = m_ammoType;
+			int ae = CheckAmmoBeforeReload(ammo_type);
+
+			if (ammo_type == m_ammoType)
+			{
+				ae += iAmmoElapsed;
+			}
+
+			last_hide_bullet = ae >= bullet_cnt ? bullet_cnt : bullet_cnt - ae - 1;
+
+			HUD_VisualBulletUpdate();
+		}
+		else
+		{
+			if (m_needReload)
+				ReloadMagazine();
+		}
+	}
 }
@@ -1315,3 +1713,2 @@
 
-//ïåðåêëþ÷åíèå ðåæèìîâ ñòðåëüáû îäèíî÷íûìè è î÷åðåäÿìè
 bool CWeaponMagazined::SwitchMode()
@@ -1330,18 +1727,2 @@
 
-void	CWeaponMagazined::OnNextFireMode()
-{
-    if (!m_bHasDifferentFireModes) return;
-    if (GetState() != eIdle) return;
-    m_iCurFireMode = (m_iCurFireMode + 1 + m_aFireModes.size()) % m_aFireModes.size();
-    SetQueueSize(GetCurrentFireMode());
-};
-
-void	CWeaponMagazined::OnPrevFireMode()
-{
-    if (!m_bHasDifferentFireModes) return;
-    if (GetState() != eIdle) return;
-    m_iCurFireMode = (m_iCurFireMode - 1 + m_aFireModes.size()) % m_aFireModes.size();
-    SetQueueSize(GetCurrentFireMode());
-};
-
 void	CWeaponMagazined::OnH_A_Chield()
@@ -1368,3 +1749,3 @@
     //	return m_iShotNum*conditionDecreasePerShot;
-    return (m_iShotNum == 1) ? conditionDecreasePerShot : conditionDecreasePerQueueShot;
+	return ((m_iShotNum == 1) ? conditionDecreasePerShot : conditionDecreasePerQueueShot) * f_weapon_deterioration;
 };
@@ -1412,2 +1795,11 @@
 
+	if (bHasBulletsToHide)
+	{
+		last_hide_bullet = ae >= bullet_cnt ? bullet_cnt : bullet_cnt - ae - 1;
+
+		if (ae == 0) last_hide_bullet = -1;
+
+		//HUD_VisualBulletUpdate();
+	}
+
     if (HasFireModes())
@@ -1523,7 +1917,3 @@
     {
-#ifdef LAYERED_SND_SHOOT
-		m_layered_sounds.LoadSound(section, "snd_shoot", "sndShot", false, m_eSoundShot);
-#else
         m_sounds.LoadSound(section, "snd_shoot", "sndShot", false, m_eSoundShot);
-#endif
     }
@@ -1545,3 +1935,2 @@
 
-#ifdef NEW_SOUNDS //AVO: custom sounds go here
     result2 = process_if_exists_set(section, "snd_reload_empty", &CInifile::r_string, str, test);
@@ -1552,7 +1941,2 @@
     result |= result2;
-#endif //-NEW_SOUNDS
-
-    //snd_shoot1     = weapons\ak74u_shot_1 ??
-    //snd_shoot2     = weapons\ak74u_shot_2 ??
-    //snd_shoot3     = weapons\ak74u_shot_3 ??
 
@@ -1566,7 +1952,3 @@
         {
-#ifdef LAYERED_SND_SHOOT
-			m_layered_sounds.LoadSound(section, "snd_silncer_shot", "sndSilencerShot", false, m_eSoundShot);
-#else
 			m_sounds.LoadSound(section, "snd_silncer_shot", "sndSilencerShot", false, m_eSoundShot);
-#endif
         }
@@ -1576,18 +1958,6 @@
     // fov for zoom mode
-    result |= process_if_exists(section, "ironsight_zoom_factor", &CInifile::r_float, m_zoom_params.m_fIronSightZoomFactor, test);
+	result |= process_if_exists(section, "scope_zoom_factor", &CInifile::r_float, m_zoom_params.m_fBaseZoomFactor,
+	                            test);
 
-    if (IsScopeAttached())
-    {
-        //if ( m_eScopeStatus == ALife::eAddonAttachable )
-        {
-            result |= process_if_exists(section, "scope_zoom_factor", &CInifile::r_float, m_zoom_params.m_fScopeZoomFactor, test);
-        }
-    }
-    else
-    {
-        if (IsZoomEnabled())
-        {
-            result |= process_if_exists(section, "scope_zoom_factor", &CInifile::r_float, m_zoom_params.m_fIronSightZoomFactor, test);
-        }
-    }
+	UpdateUIScope();
 
@@ -1595,3 +1965,4 @@
 }
-//òåêóùàÿ äèñïåðñèÿ (â ðàäèàíàõ) îðóæèÿ ñ ó÷åòîì èñïîëüçóåìîãî ïàòðîíà è íåäèñïåðñèîííûõ ïóëü
+
+//Ã²Ã¥ÃªÃ³Ã¹Ã Ã¿ Ã¤Ã¨Ã±Ã¯Ã¥Ã°Ã±Ã¨Ã¿ (Ã¢ Ã°Ã Ã¤Ã¨Ã Ã­Ã Ãµ) Ã®Ã°Ã³Ã¦Ã¨Ã¿ Ã± Ã³Ã·Ã¥Ã²Ã®Ã¬ Ã¨Ã±Ã¯Ã®Ã«Ã¼Ã§Ã³Ã¥Ã¬Ã®Ã£Ã® Ã¯Ã Ã²Ã°Ã®Ã­Ã  Ã¨ Ã­Ã¥Ã¤Ã¨Ã±Ã¯Ã¥Ã°Ã±Ã¨Ã®Ã­Ã­Ã»Ãµ Ã¯Ã³Ã«Ã¼
 float CWeaponMagazined::GetFireDispersion(float cartridge_k, bool for_crosshair)
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/WeaponMagazined.h xray-monolith/src/xrGame/WeaponMagazined.h
--- coc-1.4-xray-64/src/xrGame/WeaponMagazined.h	2023-10-20 20:54:50.735326900 +0100
+++ xray-monolith/src/xrGame/WeaponMagazined.h	2023-10-20 20:54:32.684036100 +0100
@@ -29,7 +29,8 @@
     ESoundTypes		m_eSoundReload;
-#ifdef NEW_SOUNDS //AVO: new sounds go here
     ESoundTypes		m_eSoundReloadEmpty;
     ESoundTypes		m_eSoundReloadMisfire;
-#endif //-NEW_SOUNDS
+
     bool			m_sounds_enabled;
+	bool m_nextFireMode;
+	bool m_needReload;
     // General
@@ -42,3 +43,2 @@
     virtual void	switch2_Fire();
-    virtual void	switch2_Empty();
     virtual void	switch2_Reload();
@@ -48,3 +48,7 @@
 
+	virtual void switch2_StartAim();
+	virtual void switch2_EndAim();
+
     virtual void	OnShot();
+	virtual void PlaySoundShot();
 
@@ -53,3 +57,3 @@
     virtual void	OnAnimationEnd(u32 state);
-    virtual void	OnStateSwitch(u32 S);
+	virtual void OnStateSwitch(u32 S, u32 oldState);
 
@@ -59,2 +63,7 @@
 
+private:
+	LPCSTR empty_click_layer;
+	float empty_click_speed;
+	float empty_click_power;
+
 protected:
@@ -62,6 +71,7 @@
     void	ApplySilencerKoeffs();
+	void ApplyScopeKoeffs();
     void	ResetSilencerKoeffs();
+	void ResetScopeKoeffs();
 
     virtual void	state_Fire(float dt);
-    virtual void	state_MagEmpty(float dt);
     virtual void	state_Misfire(float dt);
@@ -73,2 +83,4 @@
     void	LoadSilencerKoeffs();
+	void LoadScopeKoeffs();
+
     virtual CWeaponMagazined*cast_weapon_magazined()
@@ -88,2 +100,5 @@
 
+	virtual void OnMotionMark(u32 state, const motion_marks& M);
+	virtual int     CheckAmmoBeforeReload(u8& v_ammoType);
+
     virtual void	OnH_A_Chield();
@@ -156,4 +176,3 @@
     virtual void	OnZoomOut();
-    void	OnNextFireMode();
-    void	OnPrevFireMode();
+
     bool	HasFireModes()
@@ -172,2 +192,9 @@
 
+	virtual void SetFireMode(int mode)
+	{
+		if (mode >= m_aFireModes.size()) mode = 0;
+		m_iCurFireMode = mode;
+		SetQueueSize(GetCurrentFireMode());
+	};
+
     virtual void	save(NET_Packet &output_packet);
@@ -189,2 +216,5 @@
     virtual void	PlayAnimIdle();
+	virtual void PlayAnimIdleMoving();
+	virtual bool PlayAnimCrouchIdleMoving();
+	virtual void PlayAnimIdleSprint();
     virtual void	PlayAnimShoot();
@@ -192,2 +222,6 @@
     virtual void	PlayAnimAim();
+	virtual void PlayAnimFireModeSwitch();
+	virtual bool TryPlayAnimBore();
+
+	virtual void UpdateFireMode();
 
@@ -208,8 +243,2 @@
     bool WeaponSoundExist(LPCSTR section, LPCSTR sound_name);
-
-	//Alundaio: LAYERED_SND_SHOOT
-#ifdef LAYERED_SND_SHOOT
-	HUD_SOUND_COLLECTION_LAYERED m_layered_sounds;
-#endif
-	//-Alundaio
 };
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/WeaponMagazinedWGrenade.cpp xray-monolith/src/xrGame/WeaponMagazinedWGrenade.cpp
--- coc-1.4-xray-64/src/xrGame/WeaponMagazinedWGrenade.cpp	2023-10-20 20:54:50.735326900 +0100
+++ xray-monolith/src/xrGame/WeaponMagazinedWGrenade.cpp	2023-10-20 20:54:32.684036100 +0100
@@ -46,2 +47,3 @@
     }
+	LoadLauncherKoeffs();
 
@@ -126,5 +128,5 @@
     {
+		m_needReload = true;
         PlaySound("sndReloadG", get_LastFP2());
-
-        PlayHUDMotion("anm_reload_g", FALSE, this, GetState());
+		PlayHUDMotion("anm_reload_g", TRUE, this, GetState());
         SetPending(TRUE);
@@ -143,2 +145,8 @@
         StartFlameParticles2();
+
+#ifndef EXTENDED_WEAPON_CALLBACKS
+		CGameObject* object = smart_cast<CGameObject*>(H_Parent());
+		if (object)
+			object->callback(GameObject::eOnWeaponFired)(object->lua_game_object(), this->lua_game_object(), iAmmoElapsed);
+#endif
     }
@@ -148,5 +156,35 @@
 
+void CWeaponMagazinedWGrenade::PlayAnimFireModeSwitch()
+{
+	if (IsGrenadeLauncherAttached())
+	{
+		if (!m_bGrenadeMode)
+		{
+			if (!m_bHasDifferentFireModes) return;
+			if (m_aFireModes.size() <= 1) return;
+			if (GetState() != eIdle) return;
+
+			if (HudAnimationExist("anm_switch_mode_w_gl"))
+			{
+				SetPending(TRUE);
+				iAmmoElapsed == 0 && HudAnimationExist("anm_switch_mode_w_gl_empty")
+					? PlayHUDMotion("anm_switch_mode_w_gl_empty", TRUE, this, eSwitchMode)
+					: PlayHUDMotion("anm_switch_mode_w_gl", TRUE, this, eSwitchMode);
+			}
+			else
+				UpdateFireMode();
+
+			if (m_sounds.FindSoundItem("sndSwitchMode", false))
+				PlaySound("sndSwitchMode", get_LastFP());
+		}
+	}
+	else
+	{
+		inherited::PlayAnimFireModeSwitch();
+	}
+}
+
 bool CWeaponMagazinedWGrenade::SwitchMode()
 {
-    bool bUsefulStateToSwitch = ((eIdle == GetState()) || (eHidden == GetState()) || (eMisfire == GetState()) || (eMagEmpty == GetState())) && (!IsPending());
+	bool bUsefulStateToSwitch = ((eIdle == GetState()) || (eHidden == GetState()) || (eMisfire == GetState())) && (!IsPending());
 
@@ -158,3 +196,3 @@
 
-    OnZoomOut();
+	//OnZoomOut();
 
@@ -177,2 +215,6 @@
 
+	m_zoomtype = m_bGrenadeMode ? 2 : 0;
+
+	UpdateUIScope();
+
     iMagazineSize = m_bGrenadeMode ? 1 : iMagazineSize2;
@@ -184,18 +226,45 @@
 
-    xr_vector<CCartridge> l_magazine;
-    while (m_magazine.size())
+	m_magazine.swap(m_magazine2);
+	iAmmoElapsed = (int)m_magazine.size();
+
+	if (m_bGrenadeMode && !getRocketCount())
     {
-        l_magazine.push_back(m_magazine.back()); m_magazine.pop_back();
+		shared_str fake_grenade_name = pSettings->r_string(m_ammoTypes[m_ammoType].c_str(), "fake_grenade_name");
+
+		CRocketLauncher::SpawnRocket(*fake_grenade_name, this);
     }
-    while (m_magazine2.size())
+
+	m_BriefInfo_CalcFrame = 0;
+}
+
+void CWeaponMagazinedWGrenade::SetAmmoElapsed2(int ammo_count)
+{
+	iAmmoElapsed2 = ammo_count;
+
+	u32 uAmmo = u32(iAmmoElapsed2);
+
+	if (uAmmo != m_magazine2.size())
+	{
+		if (uAmmo > m_magazine2.size())
     {
-        m_magazine.push_back(m_magazine2.back()); m_magazine2.pop_back();
+			CCartridge l_cartridge;
+			l_cartridge.Load(m_ammoTypes2[m_ammoType2].c_str(), m_ammoType2, m_APk);
+			while (uAmmo > m_magazine2.size())
+				m_magazine2.push_back(l_cartridge);
     }
-    while (l_magazine.size())
+		else
     {
-        m_magazine2.push_back(l_magazine.back()); l_magazine.pop_back();
+			while (uAmmo < m_magazine2.size())
+				m_magazine2.pop_back();
+		};
+	};
     }
-    iAmmoElapsed = (int) m_magazine.size();
 
-    m_BriefInfo_CalcFrame = 0;
+void CWeaponMagazinedWGrenade::AmmoTypeForEach2(const luabind::functor<bool> &funct)
+{
+	for (u8 i = 0; i < u8(m_ammoTypes2.size()); ++i)
+	{
+		if (funct(i, *m_ammoTypes2[i]))
+			break;
+	}
 }
@@ -209,2 +278,10 @@
 
+		if (ParentIsActor() && Actor()->is_safemode())
+		{
+			Actor()->set_safemode(false);
+
+			if (iAmmoElapsed)
+				return false;
+		}
+
         if (flags&CMD_START)
@@ -224,3 +301,3 @@
 
-    switch (cmd)
+	/*switch (cmd)
     {
@@ -232,3 +309,3 @@
     }
-    }
+	}*/
     return false;
@@ -242,3 +320,3 @@
 
-    //ðåæèì ñòðåëüáû ïîäñòâîëüíèêà
+	//ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
     if (m_bGrenadeMode)
@@ -267,3 +345,3 @@
     }
-    //ðåæèì ñòðåëüáû î÷åðåäÿìè
+		//ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
     else
@@ -419,3 +497,3 @@
 
-    //ïåðåçàðÿäêà ïîäñòâîëüíîãî ãðàíàòîìåòà
+	//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
     if (iAmmoElapsed && !getRocketCount() && m_bGrenadeMode)
@@ -428,3 +506,3 @@
 
-void CWeaponMagazinedWGrenade::OnStateSwitch(u32 S)
+void CWeaponMagazinedWGrenade::OnStateSwitch(u32 S, u32 oldState)
 {
@@ -439,6 +517,7 @@
         }
-    }break;
+		}
+		break;
     }
 
-    inherited::OnStateSwitch(S);
+	inherited::OnStateSwitch(S, oldState);
     UpdateGrenadeVisibility(!!iAmmoElapsed || S == eReload);
@@ -452,4 +531,6 @@
     {
+			SetPending(FALSE);
         SwitchState(eIdle);
-    }break;
+		}
+		break;
     case eFire:
@@ -511,3 +593,3 @@
 
-        //óíè÷òîæèòü ïîäñòâîëüíèê èç èíâåíòàðÿ
+		//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
         if (b_send_event)
@@ -536,7 +618,10 @@
         m_flagsAddOnState &= ~CSE_ALifeItemWeapon::eWeaponAddonGrenadeLauncher;
-        if (m_bGrenadeMode)
+
+		// Now we need to unload GL's magazine
+		if (!m_bGrenadeMode)
         {
-            UnloadMagazine();
             PerformSwitchGL();
         }
+		UnloadMagazine();
+		PerformSwitchGL();
 
@@ -547,2 +632,4 @@
 
+		InitAddons();
+
         return CInventoryItemObject::Detach(item_section_name, b_spawn_item);
@@ -562,2 +649,7 @@
             CRocketLauncher::m_fLaunchSpeed = pSettings->r_float(*m_sGrenadeLauncherName, "grenade_vel");
+			ApplyLauncherKoeffs();
+		}
+		else
+		{
+			ResetLauncherKoeffs();
         }
@@ -566,2 +658,35 @@
 
+void CWeaponMagazinedWGrenade::LoadLauncherKoeffs()
+{
+	if (m_eGrenadeLauncherStatus == ALife::eAddonAttachable)
+	{
+		LPCSTR sect = GetGrenadeLauncherName().c_str();
+		m_launcher_koef.cam_dispersion = READ_IF_EXISTS(pSettings, r_float, sect, "cam_dispersion_k", 1.0f);
+		m_launcher_koef.cam_disper_inc = READ_IF_EXISTS(pSettings, r_float, sect, "cam_dispersion_inc_k", 1.0f);
+		m_launcher_koef.pdm_base = READ_IF_EXISTS(pSettings, r_float, sect, "PDM_disp_base_k", 1.0f);
+		m_launcher_koef.pdm_accel = READ_IF_EXISTS(pSettings, r_float, sect, "PDM_disp_accel_k", 1.0f);
+		m_launcher_koef.pdm_vel = READ_IF_EXISTS(pSettings, r_float, sect, "PDM_disp_vel_k", 1.0f);
+		m_launcher_koef.crosshair_inertion = READ_IF_EXISTS(pSettings, r_float, sect, "crosshair_inertion_k", 1.0f);
+		m_launcher_koef.zoom_rotate_time = READ_IF_EXISTS(pSettings, r_float, sect, "zoom_rotate_time_k", 1.0f);
+	}
+
+	clamp(m_launcher_koef.cam_dispersion, 0.01f, 2.0f);
+	clamp(m_launcher_koef.cam_disper_inc, 0.01f, 2.0f);
+	clamp(m_launcher_koef.pdm_base, 0.01f, 2.0f);
+	clamp(m_launcher_koef.pdm_accel, 0.01f, 2.0f);
+	clamp(m_launcher_koef.pdm_vel, 0.01f, 2.0f);
+	clamp(m_launcher_koef.crosshair_inertion, 0.01f, 2.0f);
+	clamp(m_launcher_koef.zoom_rotate_time, 0.01f, 2.0f);
+}
+
+void CWeaponMagazinedWGrenade::ApplyLauncherKoeffs()
+{
+	cur_launcher_koef = m_launcher_koef;
+}
+
+void CWeaponMagazinedWGrenade::ResetLauncherKoeffs()
+{
+	cur_launcher_koef.Reset();
+}
+
 bool	CWeaponMagazinedWGrenade::UseScopeTexture()
@@ -575,3 +700,3 @@
 {
-    if (IsGrenadeLauncherAttached() && m_bGrenadeMode) return m_zoom_params.m_fIronSightZoomFactor;
+	if (IsGrenadeLauncherAttached() && m_bGrenadeMode) return m_zoom_params.m_fScopeZoomFactor;
     return inherited::CurrentZoomFactor();
@@ -579,3 +704,3 @@
 
-//âèðòóàëüíûå ôóíêöèè äëÿ ïðîèãðûâàíèÿ àíèìàöèè HUD
+//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ HUD
 void CWeaponMagazinedWGrenade::PlayAnimShow()
@@ -586,8 +711,15 @@
         if (!m_bGrenadeMode)
-            PlayHUDMotion("anm_show_w_gl", FALSE, this, GetState());
+			HUD_VisualBulletUpdate();
+
+		if (!m_bGrenadeMode)
+			iAmmoElapsed == 0 && HudAnimationExist("anm_show_empty_w_gl")
+			? PlayHUDMotion("anm_show_empty_w_gl", FALSE, this, GetState(), 1.f, 0.f, false)
+			: PlayHUDMotion("anm_show_w_gl", FALSE, this, GetState(), 1.f, 0.f, false);
         else
-            PlayHUDMotion("anm_show_g", FALSE, this, GetState());
+			iAmmoElapsed == 0 && HudAnimationExist("anm_show_empty_g")
+			? PlayHUDMotion("anm_show_empty_g", FALSE, this, GetState(), 1.f, 0.f, false)
+			: PlayHUDMotion("anm_show_g", FALSE, this, GetState(), 1.f, 0.f, false);
     }
     else
-        PlayHUDMotion("anm_show", FALSE, this, GetState());
+		inherited::PlayAnimShow();
 }
@@ -600,8 +732,12 @@
         if (!m_bGrenadeMode)
-            PlayHUDMotion("anm_hide_w_gl", TRUE, this, GetState());
+			iAmmoElapsed == 0 && HudAnimationExist("anm_hide_empty_w_gl")
+			? PlayHUDMotion("anm_hide_empty_w_gl", TRUE, this, GetState())
+			: PlayHUDMotion("anm_hide_w_gl", TRUE, this, GetState());
         else
-            PlayHUDMotion("anm_hide_g", TRUE, this, GetState());
+			iAmmoElapsed == 0 && HudAnimationExist("anm_hide_empty_g")
+			? PlayHUDMotion("anm_hide_empty_g", TRUE, this, GetState())
+			: PlayHUDMotion("anm_hide_g", TRUE, this, GetState());
 
     else
-        PlayHUDMotion("anm_hide", TRUE, this, GetState());
+		inherited::PlayAnimHide();
 }
@@ -618,3 +754,7 @@
             if (HudAnimationExist("anm_reload_misfire_w_gl"))
+			{
                 PlayHUDMotion("anm_reload_misfire_w_gl", TRUE, this, GetState());
+				bClearJamOnly = true;
+				return;
+			}
             else
@@ -649,2 +789,5 @@
 {
+	if (GetState() == eSwitch)
+		return;
+
     if (IsGrenadeLauncherAttached())
@@ -654,5 +797,9 @@
             if (m_bGrenadeMode)
-                PlayHUDMotion("anm_idle_g_aim", /*FALSE*/TRUE, NULL, GetState()); //AVO: fix fast anim switch
-            else
-                PlayHUDMotion("anm_idle_w_gl_aim", TRUE, NULL, GetState());
+				iAmmoElapsed == 0 && HudAnimationExist("anm_idle_empty_g_aim")
+				? PlayHUDMotion("anm_idle_empty_g_aim", TRUE, NULL, GetState())
+				: PlayHUDMotion("anm_idle_g_aim", TRUE, NULL, GetState());
+			else
+				iAmmoElapsed == 0 && HudAnimationExist("anm_idle_empty_w_gl_aim")
+				? PlayHUDMotion("anm_idle_empty_w_gl_aim", TRUE, NULL, GetState())
+				: PlayHUDMotion("anm_idle_w_gl_aim", TRUE, NULL, GetState());
         }
@@ -662,3 +809,3 @@
             CActor* pActor = smart_cast<CActor*>(H_Parent());
-            if (pActor)
+			if (pActor && pActor->AnyMove())
             {
@@ -666,3 +813,5 @@
                 pActor->g_State(st);
-                if (st.bSprint)
+				if (pActor->is_safemode())
+					act_state = 0;
+				else if (st.bSprint)
                 {
@@ -670,4 +819,3 @@
                 }
-                else
-                    if (pActor->AnyMove() && (!st.bCrouch))
+				else if (!st.bCrouch)
                     {
@@ -675,4 +823,3 @@
                     }
-                    else
-                        if (pActor->AnyMove() && (st.bCrouch))
+				else if (st.bCrouch)
                         {
@@ -685,15 +832,21 @@
                 if (act_state == 0)
-                    PlayHUDMotion("anm_idle_g", /*FALSE*/TRUE, NULL, GetState()); //AVO: fix fast anim switch
-                else
-                    if (act_state == 1)
-                        PlayHUDMotion("anm_idle_sprint_g", TRUE, NULL, GetState());
-                    else
-                        if (act_state == 2)
-                            PlayHUDMotion("anm_idle_moving_g", TRUE, NULL, GetState());
-                        else
-                            if (act_state == 3)
+					iAmmoElapsed == 0 && HudAnimationExist("anm_idle_empty_g")
+					? PlayHUDMotion("anm_idle_empty_g", TRUE, NULL, GetState())
+					: PlayHUDMotion("anm_idle_g", TRUE, NULL, GetState());
+				else if (act_state == 1)
+					iAmmoElapsed == 0 && HudAnimationExist("anm_idle_sprint_empty_g")
+					? PlayHUDMotion("anm_idle_sprint_empty_g", TRUE, NULL, GetState())
+					: PlayHUDMotion("anm_idle_sprint_g", TRUE, NULL, GetState());
+				else if (act_state == 2)
+				{
+					iAmmoElapsed == 0 && HudAnimationExist("anm_idle_moving_empty_g")
+						? PlayHUDMotion("anm_idle_moving_empty_g", TRUE, NULL, GetState())
+						: PlayHUDMotion("anm_idle_moving_g", TRUE, NULL, GetState());
+				}
+				else if (act_state == 3)
                             {
 #ifdef NEW_ANIMS //AVO: custom move animation
-                                if (HudAnimationExist("anm_idle_moving_crouch_g")) 
-                                    PlayHUDMotion("anm_idle_moving_crouch_g", TRUE, NULL, GetState());
+					iAmmoElapsed == 0 && HudAnimationExist("anm_idle_moving_crouch_empty_g")
+						? PlayHUDMotion("anm_idle_moving_crouch_empty_g", TRUE, NULL, GetState())
+						: iAmmoElapsed == 0 && HudAnimationExist("anm_idle_moving_empty_g") ? PlayHUDMotion("anm_idle_moving_empty_g", TRUE, NULL, GetState(), .7f) : PlayHUDMotion("anm_idle_moving_g", TRUE, NULL, GetState(), .7f);
 #endif //-NEW_ANIMS
@@ -704,15 +857,21 @@
                 if (act_state == 0)
-                    PlayHUDMotion("anm_idle_w_gl", /*FALSE*/TRUE, NULL, GetState()); //AVO: fix fast anim switch
-                else
-                    if (act_state == 1)
-                        PlayHUDMotion("anm_idle_sprint_w_gl", TRUE, NULL, GetState());
-                    else
-                        if (act_state == 2)
-                            PlayHUDMotion("anm_idle_moving_w_gl", TRUE, NULL, GetState());
-                        else
-                            if (act_state == 3)
+					iAmmoElapsed == 0 && HudAnimationExist("anm_idle_empty_w_gl")
+						? PlayHUDMotion("anm_idle_empty_w_gl", TRUE, NULL, GetState())
+						: PlayHUDMotion("anm_idle_w_gl", TRUE, NULL, GetState());
+				else if (act_state == 1)
+					iAmmoElapsed == 0 && HudAnimationExist("anm_idle_sprint_empty_w_gl")
+						? PlayHUDMotion("anm_idle_sprint_empty_w_gl", TRUE, NULL, GetState())
+						: PlayHUDMotion("anm_idle_sprint_w_gl", TRUE, NULL, GetState());
+				else if (act_state == 2)
+				{
+					iAmmoElapsed == 0 && HudAnimationExist("anm_idle_moving_empty_w_gl")
+						? PlayHUDMotion("anm_idle_moving_empty_w_gl", TRUE, NULL, GetState())
+						: PlayHUDMotion("anm_idle_moving_w_gl", TRUE, NULL, GetState());
+				}
+				else if (act_state == 3)
                             {
 #ifdef NEW_ANIMS //AVO: custom move animation
-                                if (HudAnimationExist("anm_idle_moving_crouch_w_gl"))
-                                    PlayHUDMotion("anm_idle_moving_crouch_w_gl", TRUE, NULL, GetState());
+					iAmmoElapsed == 0 && HudAnimationExist("anm_idle_moving_crouch_empty_w_gl")
+						? PlayHUDMotion("anm_idle_moving_crouch_empty_w_gl", TRUE, NULL, GetState())
+						: iAmmoElapsed == 0 && HudAnimationExist("anm_idle_moving_empty_w_gl") ? PlayHUDMotion("anm_idle_moving_empty_w_gl", TRUE, NULL, GetState(), .7f) : PlayHUDMotion("anm_idle_moving_w_gl", TRUE, NULL, GetState(), .7f);
 #endif //-NEW_ANIMS
@@ -730,3 +889,16 @@
     {
-        PlayHUDMotion("anm_shots_g", FALSE, this, eFire);
+		if (iAmmoElapsed > 1 || !HudAnimationExist("anm_shot_g_l"))
+		{
+			if (!IsZoomed() || !HudAnimationExist("anm_shots_g_aim"))
+				PlayHUDMotion("anm_shots_g", TRUE, this, GetState(), 1.f, 0.f, false);
+			else
+				PlayHUDMotion("anm_shots_g_aim", TRUE, this, GetState(), 1.f, 0.f, false);
+		}
+		else
+		{
+			if(!IsZoomed() || !HudAnimationExist("anm_shot_g_l_aim"))
+				PlayHUDMotion("anm_shot_g_l", TRUE, this, GetState(), 1.f, 0.f, false);
+			else
+				PlayHUDMotion("anm_shot_g_l_aim", TRUE, this, GetState(), 1.f, 0.f, false);
+		}		
     }
@@ -736,3 +908,16 @@
         if (IsGrenadeLauncherAttached())
-            PlayHUDMotion("anm_shots_w_gl", FALSE, this, GetState());
+			if (iAmmoElapsed > 1 || !HudAnimationExist("anm_shot_w_gl_l"))
+			{
+				if (!IsZoomed() || !HudAnimationExist("anm_shots_w_gl_aim"))
+					PlayHUDMotion("anm_shots_w_gl", TRUE, this, GetState(), 1.f, 0.f, false);
+				else
+					PlayHUDMotion("anm_shots_w_gl_aim", TRUE, this, GetState(), 1.f, 0.f, false);
+			}
+			else
+			{
+				if (!IsZoomed() || !HudAnimationExist("anm_shot_w_gl_l_aim"))
+					PlayHUDMotion("anm_shot_w_gl_l", TRUE, this, GetState(), 1.f, 0.f, false);
+				else
+					PlayHUDMotion("anm_shot_w_gl_l_aim", TRUE, this, GetState(), 1.f, 0.f, false);
+			}
         else
@@ -745,8 +930,12 @@
     if (m_bGrenadeMode)
-        PlayHUDMotion("anm_switch_g", /*FALSE*/ TRUE, this, eSwitch); //AVO: fix fast anim switch
+		iAmmoElapsed == 0 && HudAnimationExist("anm_switch_g_empty")
+		? PlayHUDMotion("anm_switch_g_empty", TRUE, this, eSwitch)
+		: HudAnimationExist("anm_switch_g") ? PlayHUDMotion("anm_switch_g", TRUE, this, eSwitch) : SwitchState(eSwitch);
     else
-        PlayHUDMotion("anm_switch", /*FALSE*/ TRUE, this, eSwitch); //AVO: fix fast anim switch
+		iAmmoElapsed == 0 && HudAnimationExist("anm_switch_empty")
+		? PlayHUDMotion("anm_switch_empty", TRUE, this, eSwitch)
+		: HudAnimationExist("anm_switch") ? PlayHUDMotion("anm_switch", TRUE, this, eSwitch) : SwitchState(eSwitch);
 }
 
-void CWeaponMagazinedWGrenade::PlayAnimBore()
+bool CWeaponMagazinedWGrenade::TryPlayAnimBore()
 {
@@ -755,8 +944,34 @@
         if (m_bGrenadeMode)
-            PlayHUDMotion("anm_bore_g", TRUE, this, GetState());
+		{
+			if (iAmmoElapsed == 0 && HudAnimationExist("anm_bore_empty_g"))
+			{
+				PlayHUDMotion("anm_bore_empty_g", TRUE, NULL, GetState());
+				return true;
+			}
+
+			if (HudAnimationExist("anm_bore_g"))
+			{
+				PlayHUDMotion("anm_bore_g", TRUE, NULL, GetState());
+				return true;
+			}
+		}
         else
-            PlayHUDMotion("anm_bore_w_gl", TRUE, this, GetState());
+		{
+			if (iAmmoElapsed == 0 && HudAnimationExist("anm_bore_empty_w_gl"))
+			{
+				PlayHUDMotion("anm_bore_empty_w_gl", TRUE, NULL, GetState());
+				return true;
+			}
+
+			if (HudAnimationExist("anm_bore_w_gl"))
+			{
+				PlayHUDMotion("anm_bore_w_gl", TRUE, NULL, GetState());
+				return true;
+			}
+		}
     }
     else
-        inherited::PlayAnimBore();
+		return inherited::TryPlayAnimBore();
+
+	return false;
 }
@@ -820,2 +1035,10 @@
 
+float CWeaponMagazinedWGrenade::Weight() const
+{
+	float res = inherited::Weight();
+	res += GetMagazineWeight(m_magazine2);
+
+	return res;
+}
+
 bool CWeaponMagazinedWGrenade::IsNecessaryItem(const shared_str& item_sect)
@@ -832,7 +1055,10 @@
 
-    if (!b_aiming)
+	if (Actor()->is_safemode())
+		return 4;
+	else if (!IsZoomed())
         return		0;
-    else
-        if (m_bGrenadeMode)
+	else if (m_bGrenadeMode)
             return		2;
+	else if (m_zoomtype == 1)
+		return 3;
         else
@@ -936,2 +1163,9 @@
     info.cur_ammo._set(int_str);
+
+	if (bHasBulletsToHide && !m_bGrenadeMode)
+	{
+		last_hide_bullet = ae >= bullet_cnt ? bullet_cnt : bullet_cnt - ae - 1;
+		if (ae == 0) last_hide_bullet = -1;
+	}
+
     if (HasFireModes())
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/WeaponMagazinedWGrenade.h xray-monolith/src/xrGame/WeaponMagazinedWGrenade.h
--- coc-1.4-xray-64/src/xrGame/WeaponMagazinedWGrenade.h	2023-10-20 20:54:50.735326900 +0100
+++ xray-monolith/src/xrGame/WeaponMagazinedWGrenade.h	2023-10-20 20:54:32.685035500 +0100
@@ -17,3 +17,3 @@
 	virtual void	Load				(LPCSTR section);
-	
+	void LoadLauncherKoeffs();
 	virtual BOOL	net_Spawn			(CSE_Abstract* DC);
@@ -30,5 +30,5 @@
 	virtual bool	Attach					(PIItem pIItem, bool b_send_event);
-	virtual bool	Detach					(const char* item_section_name, bool b_spawn_item);
+	virtual bool Detach(LPCSTR item_section_name, bool b_spawn_item);
 	virtual bool	CanAttach				(PIItem pIItem);
-	virtual bool	CanDetach				(const char* item_section_name);
+	virtual bool CanDetach(LPCSTR item_section_name);
 	virtual void	InitAddons				();
@@ -40,5 +40,9 @@
 	
-	virtual void	OnStateSwitch	(u32 S);
+	virtual void OnStateSwitch(u32 S, u32 oldState);
 	
 	virtual void	switch2_Reload	();
+	virtual void switch2_StartAim();
+	virtual void switch2_EndAim();
+
+
 	virtual void	state_Fire		(float dt);
@@ -52,3 +56,3 @@
 
-	//ïåðåêëþ÷åíèå â ðåæèì ïîäñòâîëüíèêà
+	//Ð¿ÐµÑÐµÐºÐ»ÑÑÐµÐ½Ð¸Ðµ Ð² ÑÐµÐ¶Ð¸Ð¼ Ð¿Ð¾Ð´ÑÑÐ²Ð¾Ð»ÑÐ½Ð¸ÐºÐ°
 	virtual bool	SwitchMode		();
@@ -60,4 +64,4 @@
 	virtual bool	IsNecessaryItem	    (const shared_str& item_sect);
-
-	//âèðòóàëüíûå ôóíêöèè äëÿ ïðîèãðûâàíèÿ àíèìàöèè HUD
+	virtual float Weight() const;
+	//Ð²Ð¸ÑÑÑÐ°Ð»ÑÐ½ÑÐµ ÑÑÐ½ÐºÑÐ¸Ð¸ Ð´Ð»Ñ Ð¿ÑÐ¾Ð¸Ð³ÑÑÐ²Ð°Ð½Ð¸Ñ Ð°Ð½Ð¸Ð¼Ð°ÑÐ¸Ð¸ HUD
 	virtual void	PlayAnimShow		();
@@ -68,3 +72,35 @@
 	virtual void	PlayAnimModeSwitch	();
-	virtual void	PlayAnimBore		();
+	virtual void PlayAnimFireModeSwitch();
+	virtual bool TryPlayAnimBore();
+
+	//Script exports
+	void SetAmmoElapsed2(int ammo_count);
+	void AmmoTypeForEach2(const luabind::functor<bool>& funct);
+	virtual void SetAmmoType2(u8 type) { m_ammoType2 = type; };
+	u8 GetAmmoType2() { return m_ammoType2; };
+	int GetAmmoCount2(u8 ammo2_type) const;
+
+	IC int GetAmmoElapsed2() const
+	{
+		return iAmmoElapsed2;
+	}
+
+	IC int GetAmmoMagSize2() const
+	{
+		return iMagazineSize2;
+	}
+
+	IC bool GetGrenadeLauncherMode() const
+	{
+		return m_bGrenadeMode;
+	}
+
+	IC void SetGrenadeLauncherMode(bool mode)
+	{
+		if (!IsGrenadeLauncherAttached())
+			return;
+
+		if (mode != m_bGrenadeMode)
+			PerformSwitchGL();
+	}
 	
@@ -75,7 +111,5 @@
 	
-			int		GetAmmoCount2				( u8 ammo2_type ) const;
-
 public:
-	//äîïîëíèòåëüíûå ïàðàìåòðû ïàòðîíîâ 
-	//äëÿ ïîäñòâîëüíèêà
+	//Ð´Ð¾Ð¿Ð¾Ð»Ð½Ð¸ÑÐµÐ»ÑÐ½ÑÐµ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÑ Ð¿Ð°ÑÑÐ¾Ð½Ð¾Ð² 
+	//Ð´Ð»Ñ Ð¿Ð¾Ð´ÑÑÐ²Ð¾Ð»ÑÐ½Ð¸ÐºÐ°
 //-	CWeaponAmmo*			m_pAmmo2;
@@ -93,2 +127,6 @@
 	virtual void UpdateGrenadeVisibility(bool visibility);
+
+protected:
+	void ApplyLauncherKoeffs();
+	void ResetLauncherKoeffs();
 };
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/WeaponPistol.cpp xray-monolith/src/xrGame/WeaponPistol.cpp
--- coc-1.4-xray-64/src/xrGame/WeaponPistol.cpp	2023-10-20 20:54:50.737326600 +0100
+++ xray-monolith/src/xrGame/WeaponPistol.cpp	2023-10-20 20:54:32.685035500 +0100
@@ -12,7 +12,3 @@
 CWeaponPistol::~CWeaponPistol(void)
-{}
-
-void CWeaponPistol::net_Destroy()
 {
-    inherited::net_Destroy();
 }
@@ -26,125 +22,2 @@
 
-void CWeaponPistol::OnH_B_Chield()
-{
-    inherited::OnH_B_Chield();
-}
-
-void CWeaponPistol::PlayAnimShow()
-{
-    VERIFY(GetState() == eShowing);
-
-    if (iAmmoElapsed == 0)
-        PlayHUDMotion("anm_show_empty", FALSE, this, GetState());
-    else
-        inherited::PlayAnimShow();
-}
-
-void CWeaponPistol::PlayAnimBore()
-{
-    if (iAmmoElapsed == 0)
-        PlayHUDMotion("anm_bore_empty", TRUE, this, GetState());
-    else
-        inherited::PlayAnimBore();
-}
-
-void CWeaponPistol::PlayAnimIdleSprint()
-{
-    if (iAmmoElapsed == 0)
-    {
-        PlayHUDMotion("anm_idle_sprint_empty", TRUE, NULL, GetState());
-    }
-    else
-    {
-        inherited::PlayAnimIdleSprint();
-    }
-}
-
-void CWeaponPistol::PlayAnimIdleMoving()
-{
-    if (iAmmoElapsed == 0)
-    {
-        PlayHUDMotion("anm_idle_moving_empty", TRUE, NULL, GetState());
-    }
-    else
-    {
-        inherited::PlayAnimIdleMoving();
-    }
-}
-
-void CWeaponPistol::PlayAnimIdle()
-{
-    if (TryPlayAnimIdle()) return;
-
-    if (iAmmoElapsed == 0)
-    {
-        PlayHUDMotion("anm_idle_empty", TRUE, NULL, GetState());
-    }
-    else
-    {
-        inherited::PlayAnimIdle();
-    }
-}
-
-void CWeaponPistol::PlayAnimAim()
-{
-    if (iAmmoElapsed == 0)
-        PlayHUDMotion("anm_idle_aim_empty", TRUE, NULL, GetState());
-    else
-        inherited::PlayAnimAim();
-}
-
-void CWeaponPistol::PlayAnimReload()
-{
-    /*VERIFY(GetState() == eReload);
-    if (iAmmoElapsed == 0)
-    {
-    PlayHUDMotion("anm_reload_empty", TRUE, this, GetState());
-    }
-    else
-    {
-    PlayHUDMotion("anm_reload", TRUE, this, GetState());
-    }*/
-    inherited::PlayAnimReload(); //AVO: refactored to use grand-parent (CWeaponMagazined) function
-}
-
-void CWeaponPistol::PlayAnimHide()
-{
-    VERIFY(GetState() == eHiding);
-    if (iAmmoElapsed == 0)
-    {
-        PlaySound("sndClose", get_LastFP());
-        PlayHUDMotion("anm_hide_empty", TRUE, this, GetState());
-    }
-    else
-        inherited::PlayAnimHide();
-}
-
-void CWeaponPistol::PlayAnimShoot()
-{
-    VERIFY(GetState() == eFire);
-    if (iAmmoElapsed > 1)
-    {
-        PlayHUDMotion("anm_shots", FALSE, this, GetState());
-    }
-    else
-    {
-        PlayHUDMotion("anm_shot_l", FALSE, this, GetState());
-    }
-}
-
-void CWeaponPistol::switch2_Reload()
-{
-    inherited::switch2_Reload();
-}
-
-void CWeaponPistol::OnAnimationEnd(u32 state)
-{
-    inherited::OnAnimationEnd(state);
-}
-
-void CWeaponPistol::OnShot()
-{
-	inherited::OnShot(); //Alundaio: not changed from inherited, so instead of copying changes from weaponmagazined, we just do this
-}
-
 void CWeaponPistol::UpdateSounds()
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/WeaponPistol.h xray-monolith/src/xrGame/WeaponPistol.h
--- coc-1.4-xray-64/src/xrGame/WeaponPistol.h	2023-10-20 20:54:50.737326600 +0100
+++ xray-monolith/src/xrGame/WeaponPistol.h	2023-10-20 20:54:32.686035500 +0100
@@ -13,20 +13,2 @@
 
-    virtual void	switch2_Reload();
-
-    virtual void	OnShot();
-    virtual void	OnAnimationEnd(u32 state);
-    virtual void	net_Destroy();
-    virtual void	OnH_B_Chield();
-
-    //àíèìàöèè
-    virtual void	PlayAnimShow();
-    virtual void	PlayAnimIdle();
-    virtual void	PlayAnimIdleMoving();
-    virtual void	PlayAnimIdleSprint();
-    virtual void	PlayAnimHide();
-    virtual void	PlayAnimReload();
-    virtual void	PlayAnimShoot();
-    virtual void	PlayAnimBore();
-    virtual void	PlayAnimAim();
-
     virtual void	UpdateSounds();
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/WeaponRevolver.cpp xray-monolith/src/xrGame/WeaponRevolver.cpp
--- coc-1.4-xray-64/src/xrGame/WeaponRevolver.cpp	2023-10-20 20:54:50.739326500 +0100
+++ xray-monolith/src/xrGame/WeaponRevolver.cpp	2023-10-20 20:54:32.688035300 +0100
@@ -15,8 +15,2 @@
 
-void CWeaponRevolver::net_Destroy()
-{
-	inherited::net_Destroy();
-}
-
-
 void CWeaponRevolver::Load	(LPCSTR section)
@@ -28,66 +22,2 @@
 
-void CWeaponRevolver::OnH_B_Chield		()
-{
-	inherited::OnH_B_Chield		();
-}
-
-void CWeaponRevolver::PlayAnimShow	()
-{
-	VERIFY(GetState()==eShowing);
-
-	if(iAmmoElapsed==0)
-		PlayHUDMotion("anm_show_empty", FALSE, this, GetState());
-	else
-		inherited::PlayAnimShow();
-}
-
-void CWeaponRevolver::PlayAnimBore()
-{
-	if(iAmmoElapsed==0)
-		PlayHUDMotion	("anm_bore_empty", TRUE, this, GetState());
-	else
-		inherited::PlayAnimBore();
-}
-
-void CWeaponRevolver::PlayAnimIdleSprint()
-{
-	if(iAmmoElapsed==0)
-	{
-		PlayHUDMotion("anm_idle_sprint_empty", TRUE, NULL, GetState());
-	}else{
-		inherited::PlayAnimIdleSprint();
-	}
-}
-
-void CWeaponRevolver::PlayAnimIdleMoving()
-{
-	if(iAmmoElapsed==0)
-	{
-		PlayHUDMotion("anm_idle_moving_empty", TRUE, NULL, GetState());
-	}else{
-		inherited::PlayAnimIdleMoving();
-	}
-}
-
-
-void CWeaponRevolver::PlayAnimIdle()
-{
-	if (TryPlayAnimIdle()) return;
-
-	if(iAmmoElapsed==0)
-	{
-		PlayHUDMotion("anm_idle_empty", TRUE, NULL, GetState());
-	}else{
-		inherited::PlayAnimIdle		();
-	}
-}
-
-void CWeaponRevolver::PlayAnimAim()
-{
-	if(iAmmoElapsed==0)
-		PlayHUDMotion("anm_idle_aim_empty", TRUE, NULL, GetState());
-	else
-		inherited::PlayAnimAim();
-}
-
 void CWeaponRevolver::PlayAnimReload()
@@ -98,55 +28,23 @@
 		PlayHUDMotion("anm_reload_1", TRUE, this, GetState());
-	}else if(iAmmoElapsed==2){
-		PlayHUDMotion("anm_reload_2", TRUE, this, GetState());
-	}else if(iAmmoElapsed==3){
-		PlayHUDMotion("anm_reload_3", TRUE, this, GetState());
-	}else if(iAmmoElapsed==4){
-		PlayHUDMotion("anm_reload_4", TRUE, this, GetState());
-	}else if(iAmmoElapsed==5){
-		PlayHUDMotion("anm_reload_5", TRUE, this, GetState());
-	}else{
-		PlayHUDMotion("anm_reload", TRUE, this, GetState());                
 	}
-}
-
-
-void CWeaponRevolver::PlayAnimHide()
-{
-	VERIFY(GetState()==eHiding);
-	if(iAmmoElapsed==0) 
+	else if (iAmmoElapsed == 2)
 	{
-		PlaySound			("sndClose", get_LastFP());
-		PlayHUDMotion		("anm_hide_empty" , TRUE, this, GetState());
-	} 
-	else 
-		inherited::PlayAnimHide();
+		PlayHUDMotion("anm_reload_2", TRUE, this, GetState());
 }
-
-void CWeaponRevolver::PlayAnimShoot	()
+	else if (iAmmoElapsed == 3)
 {
-	VERIFY(GetState()==eFire);
-	if(iAmmoElapsed > 1) 
-	{
-		PlayHUDMotion("anm_shots" , FALSE, this, GetState());
+		PlayHUDMotion("anm_reload_3", TRUE, this, GetState());
 	}
-	else 
+	else if (iAmmoElapsed == 4)
 	{
-		PlayHUDMotion("anm_shot_l", FALSE, this, GetState()); 
-	}
+		PlayHUDMotion("anm_reload_4", TRUE, this, GetState());
 }
-
-
-void CWeaponRevolver::switch2_Reload()
+	else if (iAmmoElapsed == 5)
 {
-	inherited::switch2_Reload();
+		PlayHUDMotion("anm_reload_5", TRUE, this, GetState());
 }
-
-void CWeaponRevolver::OnAnimationEnd(u32 state)
+	else
 {
-	inherited::OnAnimationEnd(state);
+		PlayHUDMotion("anm_reload", TRUE, this, GetState());
 }
-
-void CWeaponRevolver::OnShot		()
-{
-	inherited::OnShot(); //Alundaio: not changed from inherited, so instead of copying changes from weaponmagazined, we just do this
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/WeaponRevolver.h xray-monolith/src/xrGame/WeaponRevolver.h
--- coc-1.4-xray-64/src/xrGame/WeaponRevolver.h	2023-10-20 20:54:50.740326700 +0100
+++ xray-monolith/src/xrGame/WeaponRevolver.h	2023-10-20 20:54:32.688035300 +0100
@@ -12,21 +12,3 @@
 	virtual void	Load			(LPCSTR section);
-	
-	virtual void	switch2_Reload	();
-
-	virtual void	OnShot			();
-	virtual void	OnAnimationEnd	(u32 state);
-	virtual void	net_Destroy		();
-	virtual void	OnH_B_Chield	();
-
-	//àíèìàöèè
-	virtual void	PlayAnimShow	();
-	virtual void	PlayAnimIdle	();
-	virtual void	PlayAnimIdleMoving	();
-	virtual void	PlayAnimIdleSprint	();
-	virtual void	PlayAnimHide	();
 	virtual void	PlayAnimReload	();
-	virtual void	PlayAnimShoot	();
-	virtual void	PlayAnimBore	();
-	virtual void	PlayAnimAim		();
-	//virtual void	PlayReloadSound		();
 	virtual void	UpdateSounds	();
@@ -34,5 +17,3 @@
 	virtual bool	AllowFireWhileWorking() {return true;}
-
 	ESoundTypes			m_eSoundClose;
-	//ESoundTypes			m_eSoundReloadEmpty;  
 };
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/WeaponRG6.cpp xray-monolith/src/xrGame/WeaponRG6.cpp
--- coc-1.4-xray-64/src/xrGame/WeaponRG6.cpp	2023-10-20 20:54:50.738326700 +0100
+++ xray-monolith/src/xrGame/WeaponRG6.cpp	2023-10-20 20:54:32.686035500 +0100
@@ -51,6 +51,6 @@
 #include "inventoryOwner.h"
+
 void CWeaponRG6::FireStart ()
 {
-
-	if(GetState() == eIdle	&& getRocketCount() ) 
+	if (GetState() == eIdle && getRocketCount() && iAmmoElapsed)
 	{
@@ -147,3 +150,3 @@
 	}
-	return k;
+	return t;
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/WeaponRPG7.cpp xray-monolith/src/xrGame/WeaponRPG7.cpp
--- coc-1.4-xray-64/src/xrGame/WeaponRPG7.cpp	2023-10-20 20:54:50.739326500 +0100
+++ xray-monolith/src/xrGame/WeaponRPG7.cpp	2023-10-20 20:54:32.687035500 +0100
@@ -57,3 +57,3 @@
 	VERIFY						(pWeaponVisual);
-	pWeaponVisual->LL_SetBoneVisible(pWeaponVisual->LL_BoneID("grenade"), vis_weap, TRUE);
+	if (pWeaponVisual) pWeaponVisual->LL_SetBoneVisible(pWeaponVisual->LL_BoneID("grenade"), vis_weap, TRUE);
 }
@@ -71,5 +71,5 @@
 
-void CWeaponRPG7::OnStateSwitch(u32 S) 
+void CWeaponRPG7::OnStateSwitch(u32 S, u32 oldState)
 {
-	inherited::OnStateSwitch(S);
+	inherited::OnStateSwitch(S, oldState);
 	UpdateMissileVisibility();
@@ -165,3 +166,3 @@
 	VERIFY(GetState()==eReload);
-	PlayHUDMotion("anm_reload", FALSE, this, GetState());
+	PlayHUDMotion("anm_reload", TRUE, this, GetState());
 }
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/WeaponRPG7.h xray-monolith/src/xrGame/WeaponRPG7.h
--- coc-1.4-xray-64/src/xrGame/WeaponRPG7.h	2023-10-20 20:54:50.739326500 +0100
+++ xray-monolith/src/xrGame/WeaponRPG7.h	2023-10-20 20:54:32.687035500 +0100
@@ -17,3 +17,3 @@
 	virtual BOOL net_Spawn		(CSE_Abstract* DC);
-	virtual void OnStateSwitch	(u32 S);
+	virtual void OnStateSwitch(u32 S, u32 oldState);
 	virtual void OnEvent		(NET_Packet& P, u16 type);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/WeaponShotgun.cpp xray-monolith/src/xrGame/WeaponShotgun.cpp
--- coc-1.4-xray-64/src/xrGame/WeaponShotgun.cpp	2023-10-20 20:54:50.741326500 +0100
+++ xray-monolith/src/xrGame/WeaponShotgun.cpp	2023-10-20 20:54:32.690035900 +0100
@@ -8,2 +8,3 @@
 #include "actor.h"
+#include "script_game_object.h"
 
@@ -28,6 +29,12 @@
 
-	if(pSettings->line_exist(section, "tri_state_reload")){
+	if (pSettings->line_exist(section, "tri_state_reload"))
+	{
 		m_bTriStateReload = !!pSettings->r_bool(section, "tri_state_reload");
 	};
-	if(m_bTriStateReload){
+	if (pSettings->line_exist(section, "bas_state_reload"))
+	{
+		IsCustomReloadAvaible = !!pSettings->r_bool(section, "bas_state_reload");
+	}
+	if (m_bTriStateReload)
+	{
 		m_sounds.LoadSound(section, "snd_open_weapon", "sndOpen", false, m_eSoundOpen);
@@ -37,4 +44,5 @@
 		m_sounds.LoadSound(section, "snd_close_weapon", "sndClose", false, m_eSoundClose);
-	};
 
+		m_sounds.LoadSound(section, "snd_close_weapon_empty", "sndCloseEmpty", false, m_eSoundClose);
+	};
 }
@@ -54,3 +62,3 @@
 		cmd==kWPN_FIRE && flags&CMD_START &&
-		m_sub_state==eSubstateReloadInProcess		)//îñòàíîâèòü ïåðåçàãðóçêó
+		m_sub_state == eSubstateReloadInProcess || m_sub_state == eSubstateReloadInProcessEmptyEnd) //ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
 	{
@@ -68,20 +76,38 @@
 
-	switch(m_sub_state){
-		case eSubstateReloadBegin:{
+	switch (m_sub_state)
+	{
+	case eSubstateReloadBegin:
+		{
 			m_sub_state = eSubstateReloadInProcess;
 			SwitchState(eReload);
-		}break;
+		}
+		break;
 
-		case eSubstateReloadInProcess:{
-			if( 0 != AddCartridge(1) ){
+	case eSubstateReloadInProcess:
+		{
+			if (0 != AddCartridge(1))
+			{
 				m_sub_state = eSubstateReloadEnd;
 			}
+			else if (BeginReloadWasEmpty && IsCustomReloadAvaible)
+			{
+				m_sub_state = eSubstateReloadInProcessEmptyEnd;
+			}
 			SwitchState(eReload);
-		}break;
+		}
+		break;
 
-		case eSubstateReloadEnd:{
+	case eSubstateReloadEnd:
+		{
+			BeginReloadWasEmpty = false;
 			m_sub_state = eSubstateReloadBegin;
 			SwitchState(eIdle);
-		}break;
-		
+		}
+		break;
+	case eSubstateReloadInProcessEmptyEnd:
+		{	
+			m_sub_state = eSubstateReloadBegin;
+			SwitchState(eReload);
+		}
+		break;
 	};
@@ -105,6 +133,7 @@
 
-void CWeaponShotgun::OnStateSwitch	(u32 S)
+void CWeaponShotgun::OnStateSwitch(u32 S, u32 oldState)
+{
+	if (!m_bTriStateReload || S != eReload)
 {
-	if(!m_bTriStateReload || S != eReload){
-		inherited::OnStateSwitch(S);
+		inherited::OnStateSwitch(S, oldState);
 		return;
@@ -112,5 +141,6 @@
 
-	CWeapon::OnStateSwitch(S);
+	CWeapon::OnStateSwitch(S, oldState);
 
-	if( m_magazine.size() == (u32)iMagazineSize || !HaveCartridgeInInventory(1) ){
+	if (m_magazine.size() == (u32)iMagazineSize || !HaveCartridgeInInventory(1))
+	{
 			switch2_EndReload		();
@@ -133,2 +163,5 @@
 		break;
+	case eSubstateReloadInProcessEmptyEnd:
+		switch2_EndReload();
+		break;
 	};
@@ -138,2 +171,3 @@
 {
+	BeginReloadWasEmpty = !m_magazine.size();
 	PlaySound			("sndOpen",get_LastFP());
@@ -145,2 +179,3 @@
 {
+	if (ParentIsActor()) Actor()->callback(GameObject::eWeaponNoAmmoAvailable)(lua_game_object(), GetSuitableAmmoTotal());
 	PlaySound	("sndAddCartridge",get_LastFP());
@@ -153,2 +188,6 @@
 	SetPending			(FALSE);
+
+	if (BeginReloadWasEmpty && m_sounds.FindSoundItem("sndCloseEmpty", false))
+		PlaySound("sndCloseEmpty", get_LastFP());
+	else
 	PlaySound			("sndClose",get_LastFP());
@@ -160,3 +200,3 @@
 	VERIFY(GetState()==eReload);
-	PlayHUDMotion("anm_open",FALSE,this,GetState());
+	PlayHUDMotion("anm_open",TRUE, this, GetState());
 }
@@ -171,2 +213,5 @@
 
+	if (BeginReloadWasEmpty && HudAnimationExist("anm_close_empty"))
+		PlayHUDMotion("anm_close_empty", FALSE, this, GetState());
+	else
 	PlayHUDMotion("anm_close",FALSE,this,GetState());
@@ -206,3 +251,3 @@
 
-	if( !HaveCartridgeInInventory(1) )
+	if (!HaveCartridgeInInventory(1) || iAmmoElapsed >= iMagazineSize)
 		return 0;
@@ -214,3 +259,3 @@
 	if (m_DefaultCartridge.m_LocalAmmoType != m_ammoType)
-		m_DefaultCartridge.Load(m_ammoTypes[m_ammoType].c_str(), m_ammoType);
+		m_DefaultCartridge.Load(m_ammoTypes[m_ammoType].c_str(), m_ammoType, m_APk);
 
@@ -232,3 +277,3 @@
 
-	//âûêèíóòü êîðîáêó ïàòðîíîâ, åñëè îíà ïóñòàÿ
+	//ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½, ï¿½ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
 	if(m_pCurrentAmmo && !m_pCurrentAmmo->m_boxCurr && OnServer()) 
@@ -263,3 +308,3 @@
 #endif
-		l_cartridge.Load( m_ammoTypes[LocalAmmoType].c_str(), LocalAmmoType );
+		l_cartridge.Load(m_ammoTypes[LocalAmmoType].c_str(), LocalAmmoType, m_APk);
 	}
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/WeaponShotgun.h xray-monolith/src/xrGame/WeaponShotgun.h
--- coc-1.4-xray-64/src/xrGame/WeaponShotgun.h	2023-10-20 20:54:50.742327800 +0100
+++ xray-monolith/src/xrGame/WeaponShotgun.h	2023-10-20 20:54:32.690035900 +0100
@@ -33,5 +33,6 @@
 	void			TriStateReload		();
-	virtual void	OnStateSwitch		(u32 S);
+	virtual void OnStateSwitch(u32 S, u32 oldState);
 
 	bool			HaveCartridgeInInventory(u8 cnt);
+	bool BeginReloadWasEmpty;
 	virtual u8		AddCartridge		(u8 cnt);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/WeaponStatMgun.cpp xray-monolith/src/xrGame/WeaponStatMgun.cpp
--- coc-1.4-xray-64/src/xrGame/WeaponStatMgun.cpp	2023-10-20 20:54:50.742327800 +0100
+++ xray-monolith/src/xrGame/WeaponStatMgun.cpp	2023-10-20 20:54:32.690035900 +0100
@@ -302,2 +314,6 @@
 {
+	if (Owner())
+		return false;
+
+	actor->setVisible(0);
 	inheritedHolder::attach_Actor	(actor);
@@ -310,2 +326,3 @@
 {
+	Owner()->setVisible(1);
 	inheritedHolder::detach_Actor	();
@@ -314 +331,9 @@
 }
+
+Fvector CWeaponStatMgun::ExitPosition()
+{
+	Fvector pos; pos.set(0.f, 0.f, 0.f);
+	pos.sub(camera->Direction()).normalize();
+	pos.y = 0.f;
+	return Fvector(XFORM().c).add(pos);
+}
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/WeaponStatMgun.h xray-monolith/src/xrGame/WeaponStatMgun.h
--- coc-1.4-xray-64/src/xrGame/WeaponStatMgun.h	2023-10-20 20:54:50.742327800 +0100
+++ xray-monolith/src/xrGame/WeaponStatMgun.h	2023-10-20 20:54:32.690035900 +0100
@@ -28,3 +28,3 @@
 
-	HUD_SOUND_COLLECTION	m_sounds;
+	HUD_SOUND_COLLECTION_LAYERED m_sounds;
 
@@ -105,3 +105,3 @@
 	virtual bool			HUDView				()	const				{return true;};
-	virtual Fvector			ExitPosition		()						{return Fvector().set(0.0f,0.0f,0.0f);};
+	virtual Fvector ExitPosition();
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/WeaponUpgrade.cpp xray-monolith/src/xrGame/WeaponUpgrade.cpp
--- coc-1.4-xray-64/src/xrGame/WeaponUpgrade.cpp	2023-10-20 20:54:50.744327000 +0100
+++ xray-monolith/src/xrGame/WeaponUpgrade.cpp	2023-10-20 20:54:32.692035500 +0100
@@ -32,2 +31,3 @@
 	result |= install_upgrade_addon     ( section, test );
+	result |= install_upgrade_hud(section, test);
 	return result;
@@ -41,2 +41,4 @@
 
+	result |= process_if_exists(section, "ap_modifier", &CInifile::r_float, m_APk, test);
+
 	//	ammo_class = ammo_5.45x39_fmj, ammo_5.45x39_ap  // name of the ltx-section of used ammo
@@ -110,5 +114,8 @@
 	result |= process_if_exists( section, "PDM_disp_vel_factor",    &CInifile::r_float, m_pdm.m_fPDM_disp_vel_factor,    test );
-	result |= process_if_exists( section, "PDM_disp_accel_factor",  &CInifile::r_float, m_pdm.m_fPDM_disp_accel_factor,  test );
+	result |= process_if_exists(section, "PDM_disp_accel_factor", &CInifile::r_float, m_pdm.m_fPDM_disp_accel_factor,
+	                            test);
 	result |= process_if_exists( section, "PDM_disp_crouch",        &CInifile::r_float, m_pdm.m_fPDM_disp_crouch,        test );
-	result |= process_if_exists( section, "PDM_disp_crouch_no_acc", &CInifile::r_float, m_pdm.m_fPDM_disp_crouch_no_acc, test );
+	result |= process_if_exists(section, "PDM_disp_crouch_no_acc", &CInifile::r_float, m_pdm.m_fPDM_disp_crouch_no_acc,
+	                            test);
+	result |= process_if_exists(section, "PDM_disp_buckshot", &CInifile::r_float, m_pdm.m_fPDM_disp_buckShot, test);
 
@@ -122,2 +130,3 @@
 	result |= process_if_exists( section, "misfire_end_prob",			&CInifile::r_float, misfireEndProbability,			test );
+	result |= process_if_exists(section, "zoom_rotate_time", &CInifile::r_float, m_zoom_params.m_fZoomRotateTime, test);
 
@@ -134,2 +143,18 @@
 
+#include "player_hud.h"
+
+bool CWeapon::install_upgrade_hud(LPCSTR section, bool test)
+{
+	if (!HudItemData())
+		return false;
+
+	bool result = false;
+	//	Inertion additions
+	result |= process_if_exists(section, "inertion_tendto_speed", &CInifile::r_float, HudItemData()->m_measures.m_inertion_params.m_tendto_speed,
+	                            test);
+	result |= process_if_exists(section, "inertion_tendto_aim_speed", &CInifile::r_float,
+		HudItemData()->m_measures.m_inertion_params.m_tendto_speed_aim, test);
+	return result;
+}
+
 bool CWeapon::install_upgrade_hit( LPCSTR section, bool test )
@@ -178,3 +213,3 @@
 
-	result |= process_if_exists_set( section, "use_aim_bullet",  &CInifile::r_bool, m_bUseAimBullet, test );
+	/*result |= process_if_exists_set(section, "use_aim_bullet", &CInifile::r_bool, m_bUseAimBullet, test);
 	if ( m_bUseAimBullet ) // first super bullet
@@ -182,3 +217,3 @@
 		result |= process_if_exists( section, "time_to_aim",  &CInifile::r_float, m_fTimeToAim, test );
-	}
+	}*/
 
@@ -239,5 +276,12 @@
 	}
-	result |= process_if_exists_set( section, "scope_dynamic_zoom", &CInifile::r_bool, m_zoom_params.m_bUseDynamicZoom, test );
-	result |= process_if_exists_set( section, "scope_nightvision", &CInifile::r_string_wb, m_zoom_params.m_sUseZoomPostprocess, test );
-	result |= process_if_exists_set( section, "scope_alive_detector", &CInifile::r_string_wb, m_zoom_params.m_sUseBinocularVision, test );
+	result |= process_if_exists_set(section, "scope_dynamic_zoom", &CInifile::r_bool, m_zoom_params.m_bUseDynamicZoom,
+	                                test);
+	result |= process_if_exists_set(section, "scope_nightvision", &CInifile::r_string_wb,
+	                                m_zoom_params.m_sUseZoomPostprocess, test);
+	result |= process_if_exists_set(section, "scope_alive_detector", &CInifile::r_string_wb,
+	                                m_zoom_params.m_sUseBinocularVision, test);
+
+	process_if_exists_set(section, "scope_dynamic_zoom", &CInifile::r_bool, m_zoom_params.m_bUseDynamicZoom_Primary, test);
+	process_if_exists_set(section, "scope_dynamic_zoom_alt", &CInifile::r_bool, m_zoom_params.m_bUseDynamicZoom_Alt, test);
+	process_if_exists_set(section, "scope_dynamic_zoom_gl", &CInifile::r_bool, m_zoom_params.m_bUseDynamicZoom_GL, test);
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/Wound.cpp xray-monolith/src/xrGame/Wound.cpp
--- coc-1.4-xray-64/src/xrGame/Wound.cpp	2023-10-20 20:54:50.746326700 +0100
+++ xray-monolith/src/xrGame/Wound.cpp	2023-10-20 20:54:32.694036100 +0100
@@ -10,2 +10,3 @@
 {
+	m_sParticleName = "";
 	m_bToBeDestroy = false;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/wrapper_abstract.h xray-monolith/src/xrGame/wrapper_abstract.h
--- coc-1.4-xray-64/src/xrGame/wrapper_abstract.h	2023-10-20 20:54:51.522326300 +0100
+++ xray-monolith/src/xrGame/wrapper_abstract.h	2023-10-20 20:54:33.421035700 +0100
@@ -33,3 +34,3 @@
 	virtual void	setup				(CScriptGameObject *object);
-	IC		_object_type &object		() const;
+	_object_type& object() const;
 };
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/wrapper_abstract_inline.h xray-monolith/src/xrGame/wrapper_abstract_inline.h
--- coc-1.4-xray-64/src/xrGame/wrapper_abstract_inline.h	2023-10-20 20:54:51.523326400 +0100
+++ xray-monolith/src/xrGame/wrapper_abstract_inline.h	2023-10-20 20:54:33.421035700 +0100
@@ -67,3 +67,3 @@
 TEMPLATE_SPECIALIZATION
-IC	_object_type &CWrapper::object	() const
+_object_type&CWrapper::object() const
 {
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/xr_level_controller.cpp xray-monolith/src/xrGame/xr_level_controller.cpp
--- coc-1.4-xray-64/src/xrGame/xr_level_controller.cpp	2023-10-20 20:54:51.542326700 +0100
+++ xray-monolith/src/xrGame/xr_level_controller.cpp	2023-10-20 20:54:33.437036100 +0100
@@ -106,2 +106,14 @@
 	{ "custom15", kCUSTOM15, _sp },
+	{"custom16", kCUSTOM16, _sp },
+	{"custom17", kCUSTOM17, _sp },
+	{"custom18", kCUSTOM18, _sp },
+	{"custom19", kCUSTOM19, _sp },
+	{"custom20", kCUSTOM20, _sp },
+	{"custom21", kCUSTOM21, _sp },
+	{"custom22", kCUSTOM22, _sp },
+	{"custom23", kCUSTOM23, _sp },
+	{"custom24", kCUSTOM24, _sp },
+	{"custom25", kCUSTOM25, _sp },
+	{"safemode", kSAFEMODE, _both},
+	{"freelook", kFREELOOK, _both},
 	{ "cam_autoaim", kCAM_AUTOAIM, _sp },
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/xr_level_controller.h xray-monolith/src/xrGame/xr_level_controller.h
--- coc-1.4-xray-64/src/xrGame/xr_level_controller.h	2023-10-20 20:54:51.542326700 +0100
+++ xray-monolith/src/xrGame/xr_level_controller.h	2023-10-20 20:54:33.437036100 +0100
@@ -98,2 +98,14 @@
 	kCUSTOM15,
+	kCUSTOM16,
+	kCUSTOM17,
+	kCUSTOM18,
+	kCUSTOM19,
+	kCUSTOM20,
+	kCUSTOM21,
+	kCUSTOM22,
+	kCUSTOM23,
+	kCUSTOM24,
+	kCUSTOM25,
+	kSAFEMODE,
+	kFREELOOK,
 
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/xrGame.cpp xray-monolith/src/xrGame/xrGame.cpp
--- coc-1.4-xray-64/src/xrGame/xrGame.cpp	2023-10-20 20:54:51.524327600 +0100
+++ xray-monolith/src/xrGame/xrGame.cpp	2023-10-20 20:54:33.422036000 +0100
@@ -25,3 +25,3 @@
 //#pragma comment(lib,"ode.lib")
-#pragma comment(lib,"xrEngine.lib")
+//#pragma comment(lib,"xrEngine.lib")
 
@@ -48,6 +48,9 @@
 
-BOOL APIENTRY DllMain(HANDLE hModule, u32 ul_reason_for_call, LPVOID lpReserved)
+//BOOL APIENTRY DllMain(HANDLE hModule, u32 ul_reason_for_call, LPVOID lpReserved)
+BOOL DllMainXrGame(HANDLE hModule, u32 ul_reason_for_call, LPVOID lpReserved)
+{
+	switch (ul_reason_for_call)
+	{
+	case DLL_PROCESS_ATTACH:
 {
-	switch (ul_reason_for_call) {
-		case DLL_PROCESS_ATTACH: {
 			// register console commands
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/xrGame.vcxproj xray-monolith/src/xrGame/xrGame.vcxproj
--- coc-1.4-xray-64/src/xrGame/xrGame.vcxproj	2023-10-20 20:54:51.525326700 +0100
+++ xray-monolith/src/xrGame/xrGame.vcxproj	2023-10-20 20:54:33.423035500 +0100
@@ -1,40 +1,8 @@
-ï»¿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug_NEW|Win32">
-      <Configuration>Debug_NEW</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Debug_NEW|x64">
-      <Configuration>Debug_NEW</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Debug|Win32">
-      <Configuration>Debug</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Debug|x64">
-      <Configuration>Debug</Configuration>
+    <ProjectConfiguration Include="Release-AVX|x64">
+      <Configuration>Release-AVX</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="Mixed|Win32">
-      <Configuration>Mixed</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Mixed|x64">
-      <Configuration>Mixed</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release_LuaJit_one|Win32">
-      <Configuration>Release_LuaJit_one</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release_LuaJit_one|x64">
-      <Configuration>Release_LuaJit_one</Configuration>
-      <Platform>x64</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|Win32">
-      <Configuration>Release</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
     <ProjectConfiguration Include="Release|x64">
@@ -43,2 +11,6 @@
     </ProjectConfiguration>
+    <ProjectConfiguration Include="VerifiedDX11|x64">
+      <Configuration>VerifiedDX11</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
   </ItemGroup>
@@ -47,69 +19,25 @@
     <RootNamespace>xrGame</RootNamespace>
+    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <PlatformToolset>v120</PlatformToolset>
-    <UseOfMfc>false</UseOfMfc>
-    <CharacterSet>MultiByte</CharacterSet>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-  </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <PlatformToolset>v120</PlatformToolset>
-    <UseOfMfc>false</UseOfMfc>
-    <CharacterSet>MultiByte</CharacterSet>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_NEW|Win32'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <PlatformToolset>v120</PlatformToolset>
-    <UseOfMfc>false</UseOfMfc>
-    <CharacterSet>MultiByte</CharacterSet>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_NEW|x64'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <PlatformToolset>v120</PlatformToolset>
-    <UseOfMfc>false</UseOfMfc>
-    <CharacterSet>MultiByte</CharacterSet>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_LuaJit_one|Win32'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <PlatformToolset>v120</PlatformToolset>
-    <UseOfMfc>false</UseOfMfc>
-    <CharacterSet>MultiByte</CharacterSet>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_LuaJit_one|x64'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <PlatformToolset>v120</PlatformToolset>
-    <UseOfMfc>false</UseOfMfc>
-    <CharacterSet>MultiByte</CharacterSet>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Mixed|Win32'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <PlatformToolset>v120</PlatformToolset>
-    <UseOfMfc>false</UseOfMfc>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Mixed|x64'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <PlatformToolset>v120</PlatformToolset>
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>false</WholeProgramOptimization>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <PlatformToolset>v120</PlatformToolset>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='VerifiedDX11|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>false</WholeProgramOptimization>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
-    <ConfigurationType>DynamicLibrary</ConfigurationType>
-    <PlatformToolset>v120</PlatformToolset>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release-AVX|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
     <UseOfMfc>false</UseOfMfc>
     <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>false</WholeProgramOptimization>
   </PropertyGroup>
@@ -118,7 +46,2 @@
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
-    <Import Project="$(SolutionDir)Common.props" />
-  </ImportGroup>
   <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
@@ -128,23 +51,3 @@
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_NEW|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
-    <Import Project="$(SolutionDir)Common.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug_NEW|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
-    <Import Project="$(SolutionDir)Common.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_LuaJit_one|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
-    <Import Project="$(SolutionDir)Common.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release_LuaJit_one|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
-    <Import Project="$(SolutionDir)Common.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Mixed|Win32'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='VerifiedDX11|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
@@ -153,13 +56,3 @@
   </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Mixed|x64'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
-    <Import Project="$(SolutionDir)Common.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC71.props" />
-    <Import Project="$(SolutionDir)Common.props" />
-  </ImportGroup>
-  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release-AVX|x64'" Label="PropertySheets">
     <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
@@ -172,299 +65,17 @@
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <OutDir>$(xrGameDir)bin_dbg\</OutDir>
-    <IntDir>$(xrIntDir)$(ProjectName)\</IntDir>
-    <ExtensionsToDeleteOnClean>*.idb%3b*.obj%3b*.ilk%3b*.pdb%3b*.tlb%3b*.tli%3b*.tlh%3b*.tmp%3b*.rsp%3b*.bat%3b$(TargetPath)</ExtensionsToDeleteOnClean>
-    <LinkIncremental>false</LinkIncremental>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <ExtensionsToDeleteOnClean>*.idb%3b*.obj%3b*.ilk%3b*.pdb%3b*.tlb%3b*.tli%3b*.tlh%3b*.tmp%3b*.rsp%3b*.bat%3b$(TargetPath)</ExtensionsToDeleteOnClean>
-    <LinkIncremental>false</LinkIncremental>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Mixed|Win32'">
-    <OutDir>$(xrBinDir)</OutDir>
-    <IntDir>$(xrIntDir)$(ProjectName)\</IntDir>
-    <LinkIncremental>false</LinkIncremental>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Mixed|x64'">
-    <LinkIncremental>false</LinkIncremental>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <OutDir>$(xrGameDir)bin_rel\</OutDir>
-    <IntDir>$(xrIntDir)$(ProjectName)\</IntDir>
-    <LinkIncremental>false</LinkIncremental>
-  </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
     <LinkIncremental>false</LinkIncremental>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_NEW|Win32'">
-    <OutDir>$(xrGameDir)bin_dbg\</OutDir>
+    <OutDir>$(xrGameDir)bin_dbg\$(Platform)\$(Configuration)\</OutDir>
     <IntDir>$(xrIntDir)$(ProjectName)\</IntDir>
-    <LinkIncremental>false</LinkIncremental>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug_NEW|x64'">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='VerifiedDX11|x64'">
     <LinkIncremental>false</LinkIncremental>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_LuaJit_one|Win32'">
-    <OutDir>$(xrGameDir)bin_rel\</OutDir>
+    <OutDir>$(xrGameDir)bin_dbg\$(Platform)\$(Configuration)\</OutDir>
     <IntDir>$(xrIntDir)$(ProjectName)\</IntDir>
-    <LinkIncremental>false</LinkIncremental>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release_LuaJit_one|x64'">
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release-AVX|x64'">
     <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(xrGameDir)bin_dbg\$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(xrIntDir)$(ProjectName)\</IntDir>
   </PropertyGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <Midl>
-      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MkTypLibCompatible>true</MkTypLibCompatible>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <TargetEnvironment>Win32</TargetEnvironment>
-      <TypeLibraryName>$(OutDir)$(TargetName).tlb</TypeLibraryName>
-    </Midl>
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <IntrinsicFunctions>false</IntrinsicFunctions>
-      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
-      <EnableFiberSafeOptimizations>true</EnableFiberSafeOptimizations>
-      <AdditionalIncludeDirectories>.;$(SolutionDir);$(SolutionDir)xrServerEntities;$(SolutionDir)3rd party\luajit-2\src\;$(SolutionDir)3rd party\luabind\;$(xrSdkDir)include;$(xrSdkDir)include\loki;$(XRAY_16X_LIBS)OpenAutomate\inc;$(SolutionDir)3rd party\CxImage;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>USE_LUAJIT_ONE;WIN32;DEBUG;XRGAME_EXPORTS;_WINDOWS;_USRDLL;MSVC;_SECURE_SCL=0;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>false</StringPooling>
-      <MinimalRebuild>false</MinimalRebuild>
-      <ExceptionHandling>Sync</ExceptionHandling>
-      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
-      <SmallerTypeCheck>true</SmallerTypeCheck>
-      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <BufferSecurityCheck>true</BufferSecurityCheck>
-      <FunctionLevelLinking>false</FunctionLevelLinking>
-      <FloatingPointModel>Fast</FloatingPointModel>
-      <ForceConformanceInForLoopScope>false</ForceConformanceInForLoopScope>
-      <RuntimeTypeInfo>true</RuntimeTypeInfo>
-      <PrecompiledHeader>Use</PrecompiledHeader>
-      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
-      <BrowseInformation />
-      <WarningLevel>Level4</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-      <DisableSpecificWarnings>4237;%(DisableSpecificWarnings)</DisableSpecificWarnings>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-    </ClCompile>
-    <ResourceCompile>
-      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <Culture>0x0419</Culture>
-    </ResourceCompile>
-    <Link>
-      <AdditionalOptions>
-/ignore:4075 %(AdditionalOptions)</AdditionalOptions>
-      <ShowProgress>NotSet</ShowProgress>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <AdditionalLibraryDirectories>$(SolutionDir)3rd party\luajit-2\src\;$(xrSdkDir)libraries;$(xrLibDir);$(XRAY_16X_LIBS)OpenAutomate\libraries;$(XRAY_16X_LIBS)jpeg\libraries\Release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <MapExports>false</MapExports>
-      <LargeAddressAware>true</LargeAddressAware>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <ImportLibrary>$(xrLibDir)$(TargetName).lib</ImportLibrary>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
-    <Midl>
-      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MkTypLibCompatible>true</MkTypLibCompatible>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <TypeLibraryName>$(OutDir)$(TargetName).tlb</TypeLibraryName>
-    </Midl>
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <IntrinsicFunctions>false</IntrinsicFunctions>
-      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
-      <EnableFiberSafeOptimizations>true</EnableFiberSafeOptimizations>
-      <AdditionalIncludeDirectories>.;$(SolutionDir);$(SolutionDir)xrServerEntities;$(SolutionDir)3rd party\luajit-2\src\;$(SolutionDir)3rd party\luabind\;$(xrSdkDir)include;$(xrSdkDir)include\loki;$(XRAY_16X_LIBS)OpenAutomate\inc;$(SolutionDir)3rd party\CxImage;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>USE_LUAJIT_ONE;WIN32;DEBUG;XRGAME_EXPORTS;_WINDOWS;_USRDLL;MSVC;_SECURE_SCL=0;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>false</StringPooling>
-      <MinimalRebuild>false</MinimalRebuild>
-      <ExceptionHandling>Sync</ExceptionHandling>
-      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
-      <SmallerTypeCheck>true</SmallerTypeCheck>
-      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <BufferSecurityCheck>true</BufferSecurityCheck>
-      <FunctionLevelLinking>false</FunctionLevelLinking>
-      <FloatingPointModel>Fast</FloatingPointModel>
-      <ForceConformanceInForLoopScope>false</ForceConformanceInForLoopScope>
-      <RuntimeTypeInfo>true</RuntimeTypeInfo>
-      <PrecompiledHeader>Use</PrecompiledHeader>
-      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
-      <BrowseInformation>
-      </BrowseInformation>
-      <WarningLevel>Level4</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-      <DisableSpecificWarnings>4237;%(DisableSpecificWarnings)</DisableSpecificWarnings>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-    </ClCompile>
-    <ResourceCompile>
-      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <Culture>0x0419</Culture>
-    </ResourceCompile>
-    <Link>
-      <AdditionalOptions>
-/ignore:4075 %(AdditionalOptions)</AdditionalOptions>
-      <ShowProgress>NotSet</ShowProgress>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <AdditionalLibraryDirectories>$(SolutionDir)3rd party\luajit-2\src\;$(xrSdkDir)libraries;$(xrLibDir);$(XRAY_16X_LIBS)OpenAutomate\libraries;$(XRAY_16X_LIBS)jpeg\libraries\Release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <MapExports>false</MapExports>
-      <LargeAddressAware>true</LargeAddressAware>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <ImportLibrary>$(xrLibDir)$(TargetName).lib</ImportLibrary>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Mixed|Win32'">
-    <Midl>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MkTypLibCompatible>true</MkTypLibCompatible>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <TargetEnvironment>Win32</TargetEnvironment>
-      <TypeLibraryName>$(OutDir)$(TargetName).tlb</TypeLibraryName>
-    </Midl>
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
-      <OmitFramePointers>false</OmitFramePointers>
-      <EnableFiberSafeOptimizations>true</EnableFiberSafeOptimizations>
-      <AdditionalIncludeDirectories>.;$(SolutionDir);$(SolutionDir)xrServerEntities;$(xrSdkDir)include;$(XRAY_16X_LIBS)OpenAutomate\inc;$(SolutionDir)3rd party\CxImage;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>DEBUG;MIXED;WIN32;_WINDOWS;_USRDLL;XRGAME_EXPORTS;dSINGLE;MSVC;_SECURE_SCL=0;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <BufferSecurityCheck>true</BufferSecurityCheck>
-      <FunctionLevelLinking>false</FunctionLevelLinking>
-      <FloatingPointModel>Fast</FloatingPointModel>
-      <ForceConformanceInForLoopScope>false</ForceConformanceInForLoopScope>
-      <RuntimeTypeInfo>true</RuntimeTypeInfo>
-      <PrecompiledHeader>Use</PrecompiledHeader>
-      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
-      <BrowseInformation />
-      <WarningLevel>Level4</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-      <DisableSpecificWarnings>4237;%(DisableSpecificWarnings)</DisableSpecificWarnings>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-    </ClCompile>
-    <ResourceCompile>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <Culture>0x0419</Culture>
-    </ResourceCompile>
-    <Link>
-      <AdditionalOptions>/MACHINE:I386 %(AdditionalOptions)</AdditionalOptions>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <AdditionalLibraryDirectories>$(xrSdkDir)libraries;$(xrLibDir);$(XRAY_16X_LIBS)OpenAutomate\libraries;$(XRAY_16X_LIBS)jpeg\libraries\Release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <LargeAddressAware>true</LargeAddressAware>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <ImportLibrary>$(xrLibDir)$(TargetName).lib</ImportLibrary>
-      <TargetMachine>MachineX86</TargetMachine>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Mixed|x64'">
-    <Midl>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MkTypLibCompatible>true</MkTypLibCompatible>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <TypeLibraryName>$(OutDir)$(TargetName).tlb</TypeLibraryName>
-    </Midl>
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
-      <OmitFramePointers>false</OmitFramePointers>
-      <EnableFiberSafeOptimizations>true</EnableFiberSafeOptimizations>
-      <AdditionalIncludeDirectories>.;$(SolutionDir);$(SolutionDir)xrServerEntities;$(xrSdkDir)include;$(XRAY_16X_LIBS)OpenAutomate\inc;$(SolutionDir)3rd party\CxImage;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>DEBUG;MIXED;WIN32;_WINDOWS;_USRDLL;XRGAME_EXPORTS;dSINGLE;MSVC;_SECURE_SCL=0;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <BufferSecurityCheck>true</BufferSecurityCheck>
-      <FunctionLevelLinking>false</FunctionLevelLinking>
-      <FloatingPointModel>Fast</FloatingPointModel>
-      <ForceConformanceInForLoopScope>false</ForceConformanceInForLoopScope>
-      <RuntimeTypeInfo>true</RuntimeTypeInfo>
-      <PrecompiledHeader>Use</PrecompiledHeader>
-      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
-      <BrowseInformation>
-      </BrowseInformation>
-      <WarningLevel>Level4</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-      <DisableSpecificWarnings>4237;%(DisableSpecificWarnings)</DisableSpecificWarnings>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-    </ClCompile>
-    <ResourceCompile>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <Culture>0x0419</Culture>
-    </ResourceCompile>
-    <Link>
-      <AdditionalOptions>/MACHINE:I386 %(AdditionalOptions)</AdditionalOptions>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <AdditionalLibraryDirectories>$(xrSdkDir)libraries;$(xrLibDir);$(XRAY_16X_LIBS)OpenAutomate\libraries;$(XRAY_16X_LIBS)jpeg\libraries\Release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <LargeAddressAware>true</LargeAddressAware>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <ImportLibrary>$(xrLibDir)$(TargetName).lib</ImportLibrary>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <Midl>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MkTypLibCompatible>true</MkTypLibCompatible>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <TargetEnvironment>Win32</TargetEnvironment>
-      <TypeLibraryName>$(OutDir)$(TargetName).tlb</TypeLibraryName>
-    </Midl>
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
-      <OmitFramePointers>true</OmitFramePointers>
-      <EnableFiberSafeOptimizations>true</EnableFiberSafeOptimizations>
-      <WholeProgramOptimization>false</WholeProgramOptimization>
-      <AdditionalIncludeDirectories>.;$(SolutionDir);$(SolutionDir)xrServerEntities;$(SolutionDir)3rd party\luajit-2\src\;$(SolutionDir)3rd party\luabind\;$(xrSdkDir)include;$(XRAY_16X_LIBS)OpenAutomate\inc;$(SolutionDir)3rd party\CxImage;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;XRGAME_EXPORTS;dSINGLE;MSVC;_SECURE_SCL=0;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <ExceptionHandling />
-      <SmallerTypeCheck>false</SmallerTypeCheck>
-      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
-      <FloatingPointModel>Precise</FloatingPointModel>
-      <ForceConformanceInForLoopScope>false</ForceConformanceInForLoopScope>
-      <RuntimeTypeInfo>true</RuntimeTypeInfo>
-      <PrecompiledHeader>Use</PrecompiledHeader>
-      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
-      <BrowseInformation />
-      <WarningLevel>Level4</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <DebugInformationFormat>None</DebugInformationFormat>
-      <DisableSpecificWarnings>4995;4005;4237;%(DisableSpecificWarnings)</DisableSpecificWarnings>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-      <UndefinePreprocessorDefinitions>USE_LUAJIT_ONE</UndefinePreprocessorDefinitions>
-      <MinimalRebuild>false</MinimalRebuild>
-    </ClCompile>
-    <ResourceCompile>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <Culture>0x0419</Culture>
-    </ResourceCompile>
-    <Link>
-      <AdditionalOptions>/ignore:4099</AdditionalOptions>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <AdditionalLibraryDirectories>$(SolutionDir)3rd party\luajit-2\src\;$(xrSdkDir)libraries;$(xrLibDir);$(XRAY_16X_LIBS)OpenAutomate\libraries;$(XRAY_16X_LIBS)jpeg\libraries\Release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
-      <SubSystem>NotSet</SubSystem>
-      <LargeAddressAware>true</LargeAddressAware>
-      <OptimizeReferences>true</OptimizeReferences>
-      <EnableCOMDATFolding>true</EnableCOMDATFolding>
-      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <ImportLibrary>$(xrLibDir)$(TargetName).lib</ImportLibrary>
-    </Link>
-  </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
@@ -493,3 +104,3 @@
       <FunctionLevelLinking>true</FunctionLevelLinking>
-      <EnableEnhancedInstructionSet>AdvancedVectorExtensions</EnableEnhancedInstructionSet>
+      <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
       <FloatingPointModel>Precise</FloatingPointModel>
@@ -503,59 +114,2 @@
       <SuppressStartupBanner>true</SuppressStartupBanner>
-      <DebugInformationFormat>None</DebugInformationFormat>
-      <DisableSpecificWarnings>4995;4005;4237;%(DisableSpecificWarnings)</DisableSpecificWarnings>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-      <UndefinePreprocessorDefinitions>USE_LUAJIT_ONE</UndefinePreprocessorDefinitions>
-      <MinimalRebuild>false</MinimalRebuild>
-    </ClCompile>
-    <ResourceCompile>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <Culture>0x0419</Culture>
-    </ResourceCompile>
-    <Link>
-      <AdditionalOptions>/ignore:4099</AdditionalOptions>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <AdditionalLibraryDirectories>$(SolutionDir)3rd party\luajit-2\src\;$(xrSdkDir)libraries;$(xrLibDir);$(XRAY_16X_LIBS)OpenAutomate\libraries;$(XRAY_16X_LIBS)jpeg\libraries\Release;$(xrGameDir)bin_dbg;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
-      <SubSystem>NotSet</SubSystem>
-      <LargeAddressAware>true</LargeAddressAware>
-      <OptimizeReferences>true</OptimizeReferences>
-      <EnableCOMDATFolding>true</EnableCOMDATFolding>
-      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <ImportLibrary>$(xrLibDir)$(TargetName).lib</ImportLibrary>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_NEW|Win32'">
-    <Midl>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MkTypLibCompatible>true</MkTypLibCompatible>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <TargetEnvironment>Win32</TargetEnvironment>
-      <TypeLibraryName>$(OutDir)$(TargetName).tlb</TypeLibraryName>
-    </Midl>
-    <ClCompile>
-      <Optimization>Disabled</Optimization>
-      <InlineFunctionExpansion>Disabled</InlineFunctionExpansion>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
-      <OmitFramePointers>true</OmitFramePointers>
-      <EnableFiberSafeOptimizations>true</EnableFiberSafeOptimizations>
-      <WholeProgramOptimization>false</WholeProgramOptimization>
-      <AdditionalIncludeDirectories>.;$(SolutionDir);$(SolutionDir)xrServerEntities;$(SolutionDir)3rd party\luajit-2\src\;$(SolutionDir)3rd party\luabind\;$(xrSdkDir)include;$(XRAY_16X_LIBS)OpenAutomate\inc;$(SolutionDir)3rd party\CxImage;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;DEBUG;_WINDOWS;_USRDLL;XRGAME_EXPORTS;dSINGLE;MSVC;_SECURE_SCL=0;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <ExceptionHandling>Sync</ExceptionHandling>
-      <SmallerTypeCheck>false</SmallerTypeCheck>
-      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>false</FunctionLevelLinking>
-      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
-      <FloatingPointModel>Fast</FloatingPointModel>
-      <ForceConformanceInForLoopScope>false</ForceConformanceInForLoopScope>
-      <RuntimeTypeInfo>true</RuntimeTypeInfo>
-      <PrecompiledHeader>Use</PrecompiledHeader>
-      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
-      <BrowseInformation>
-      </BrowseInformation>
-      <WarningLevel>Level4</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
       <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
@@ -573,4 +127,3 @@
       <SuppressStartupBanner>true</SuppressStartupBanner>
-      <AdditionalLibraryDirectories>$(SolutionDir)3rd party\luajit-2\src\;$(xrSdkDir)libraries;$(xrLibDir);$(XRAY_16X_LIBS)OpenAutomate\libraries;$(XRAY_16X_LIBS)jpeg\libraries\Release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(SolutionDir)3rd party\luajit-2\src\;$(xrSdkDir)libraries;$(xrLibDir);$(XRAY_16X_LIBS)OpenAutomate\libraries;$(XRAY_16X_LIBS)jpeg\libraries\Release;$(xrGameDir)bin_dbg;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
       <SubSystem>NotSet</SubSystem>
@@ -582,5 +135,6 @@
       <ImportLibrary>$(xrLibDir)$(TargetName).lib</ImportLibrary>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug_NEW|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='VerifiedDX11|x64'">
     <Midl>
@@ -594,17 +148,16 @@
       <InlineFunctionExpansion>Disabled</InlineFunctionExpansion>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
-      <OmitFramePointers>true</OmitFramePointers>
-      <EnableFiberSafeOptimizations>true</EnableFiberSafeOptimizations>
+      <IntrinsicFunctions>false</IntrinsicFunctions>
+      <FavorSizeOrSpeed>Neither</FavorSizeOrSpeed>
+      <OmitFramePointers>false</OmitFramePointers>
+      <EnableFiberSafeOptimizations>false</EnableFiberSafeOptimizations>
       <WholeProgramOptimization>false</WholeProgramOptimization>
       <AdditionalIncludeDirectories>.;$(SolutionDir);$(SolutionDir)xrServerEntities;$(SolutionDir)3rd party\luajit-2\src\;$(SolutionDir)3rd party\luabind\;$(xrSdkDir)include;$(XRAY_16X_LIBS)OpenAutomate\inc;$(SolutionDir)3rd party\CxImage;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>WIN32;DEBUG;_WINDOWS;_USRDLL;XRGAME_EXPORTS;dSINGLE;MSVC;_SECURE_SCL=0;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <ExceptionHandling>Sync</ExceptionHandling>
-      <SmallerTypeCheck>false</SmallerTypeCheck>
+      <PreprocessorDefinitions>USE_VERIFY_IN_RELEASE;WIN32;NDEBUG;_WINDOWS;_USRDLL;XRGAME_EXPORTS;dSINGLE;MSVC;_SECURE_SCL=0;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <ExceptionHandling>
+      </ExceptionHandling>
       <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>false</FunctionLevelLinking>
-      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
-      <FloatingPointModel>Fast</FloatingPointModel>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <EnableEnhancedInstructionSet>NotSet</EnableEnhancedInstructionSet>
+      <FloatingPointModel>Precise</FloatingPointModel>
       <ForceConformanceInForLoopScope>false</ForceConformanceInForLoopScope>
@@ -621,3 +174,4 @@
       <UndefinePreprocessorDefinitions>USE_LUAJIT_ONE</UndefinePreprocessorDefinitions>
-      <MinimalRebuild>false</MinimalRebuild>
+      <MinimalRebuild>true</MinimalRebuild>
+      <RemoveUnreferencedCodeData>false</RemoveUnreferencedCodeData>
     </ClCompile>
@@ -630,4 +184,3 @@
       <SuppressStartupBanner>true</SuppressStartupBanner>
-      <AdditionalLibraryDirectories>$(SolutionDir)3rd party\luajit-2\src\;$(xrSdkDir)libraries;$(xrLibDir);$(XRAY_16X_LIBS)OpenAutomate\libraries;$(XRAY_16X_LIBS)jpeg\libraries\Release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(SolutionDir)3rd party\luajit-2\src\;$(xrSdkDir)libraries;$(xrLibDir);$(XRAY_16X_LIBS)OpenAutomate\libraries;$(XRAY_16X_LIBS)jpeg\libraries\Release;$(xrGameDir)bin_dbg;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
       <SubSystem>NotSet</SubSystem>
@@ -639,62 +192,6 @@
       <ImportLibrary>$(xrLibDir)$(TargetName).lib</ImportLibrary>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_LuaJit_one|Win32'">
-    <Midl>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <MkTypLibCompatible>true</MkTypLibCompatible>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <TargetEnvironment>Win32</TargetEnvironment>
-      <TypeLibraryName>$(OutDir)$(TargetName).tlb</TypeLibraryName>
-    </Midl>
-    <ClCompile>
-      <Optimization>MaxSpeed</Optimization>
-      <InlineFunctionExpansion>AnySuitable</InlineFunctionExpansion>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
-      <OmitFramePointers>true</OmitFramePointers>
-      <EnableFiberSafeOptimizations>true</EnableFiberSafeOptimizations>
-      <WholeProgramOptimization>false</WholeProgramOptimization>
-      <AdditionalIncludeDirectories>.;$(SolutionDir)3rd party\LuaJIT-1.1.8\etc\;$(SolutionDir)3rd party\luabind\;$(SolutionDir);$(SolutionDir)xrServerEntities;$(xrSdkDir)include;$(XRAY_16X_LIBS)OpenAutomate\inc;$(SolutionDir)3rd party\CxImage;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>USE_LUAJIT_ONE;WIN32;NDEBUG;_WINDOWS;_USRDLL;XRGAME_EXPORTS;dSINGLE;MSVC;_SECURE_SCL=0;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <StringPooling>true</StringPooling>
-      <ExceptionHandling>
-      </ExceptionHandling>
-      <SmallerTypeCheck>false</SmallerTypeCheck>
-      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
-      <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>false</FunctionLevelLinking>
-      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
-      <FloatingPointModel>Fast</FloatingPointModel>
-      <ForceConformanceInForLoopScope>false</ForceConformanceInForLoopScope>
-      <RuntimeTypeInfo>true</RuntimeTypeInfo>
-      <PrecompiledHeader>Use</PrecompiledHeader>
-      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
-      <BrowseInformation>
-      </BrowseInformation>
-      <WarningLevel>Level4</WarningLevel>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-      <DisableSpecificWarnings>4005;4237;%(DisableSpecificWarnings)</DisableSpecificWarnings>
-      <MultiProcessorCompilation>true</MultiProcessorCompilation>
-    </ClCompile>
-    <ResourceCompile>
-      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <Culture>0x0419</Culture>
-    </ResourceCompile>
-    <Link>
-      <AdditionalOptions>/ignore:4099</AdditionalOptions>
-      <SuppressStartupBanner>true</SuppressStartupBanner>
-      <AdditionalLibraryDirectories>$(xrSdkDir)libraries;$(xrLibDir);$(XRAY_16X_LIBS)OpenAutomate\libraries;$(XRAY_16X_LIBS)jpeg\libraries\Release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
       <GenerateDebugInformation>true</GenerateDebugInformation>
-      <SubSystem>NotSet</SubSystem>
-      <LargeAddressAware>true</LargeAddressAware>
-      <OptimizeReferences>true</OptimizeReferences>
-      <EnableCOMDATFolding>true</EnableCOMDATFolding>
-      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
-      <RandomizedBaseAddress>false</RandomizedBaseAddress>
-      <ImportLibrary>$(xrLibDir)$(TargetName).lib</ImportLibrary>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release_LuaJit_one|x64'">
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release-AVX|x64'">
     <Midl>
@@ -713,4 +210,4 @@
       <WholeProgramOptimization>false</WholeProgramOptimization>
-      <AdditionalIncludeDirectories>.;$(SolutionDir)3rd party\LuaJIT-1.1.8\etc\;$(SolutionDir)3rd party\luabind\;$(SolutionDir);$(SolutionDir)xrServerEntities;$(xrSdkDir)include;$(XRAY_16X_LIBS)OpenAutomate\inc;$(SolutionDir)3rd party\CxImage;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <PreprocessorDefinitions>USE_LUAJIT_ONE;WIN32;NDEBUG;_WINDOWS;_USRDLL;XRGAME_EXPORTS;dSINGLE;MSVC;_SECURE_SCL=0;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>.;$(SolutionDir);$(SolutionDir)xrServerEntities;$(SolutionDir)3rd party\luajit-2\src\;$(SolutionDir)3rd party\luabind\;$(xrSdkDir)include;$(XRAY_16X_LIBS)OpenAutomate\inc;$(SolutionDir)3rd party\CxImage;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;XRGAME_EXPORTS;dSINGLE;MSVC;_SECURE_SCL=0;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <StringPooling>true</StringPooling>
@@ -721,5 +218,5 @@
       <BufferSecurityCheck>false</BufferSecurityCheck>
-      <FunctionLevelLinking>false</FunctionLevelLinking>
-      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
-      <FloatingPointModel>Fast</FloatingPointModel>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <EnableEnhancedInstructionSet>AdvancedVectorExtensions</EnableEnhancedInstructionSet>
+      <FloatingPointModel>Precise</FloatingPointModel>
       <ForceConformanceInForLoopScope>false</ForceConformanceInForLoopScope>
@@ -733,4 +230,6 @@
       <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
-      <DisableSpecificWarnings>4005;4237;%(DisableSpecificWarnings)</DisableSpecificWarnings>
+      <DisableSpecificWarnings>4995;4005;4237;%(DisableSpecificWarnings)</DisableSpecificWarnings>
       <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <UndefinePreprocessorDefinitions>USE_LUAJIT_ONE</UndefinePreprocessorDefinitions>
+      <MinimalRebuild>false</MinimalRebuild>
     </ClCompile>
@@ -743,4 +242,3 @@
       <SuppressStartupBanner>true</SuppressStartupBanner>
-      <AdditionalLibraryDirectories>$(xrSdkDir)libraries;$(xrLibDir);$(XRAY_16X_LIBS)OpenAutomate\libraries;$(XRAY_16X_LIBS)jpeg\libraries\Release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(SolutionDir)3rd party\luajit-2\src\;$(xrSdkDir)libraries;$(xrLibDir);$(XRAY_16X_LIBS)OpenAutomate\libraries;$(XRAY_16X_LIBS)jpeg\libraries\Release;$(xrGameDir)bin_dbg;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
       <SubSystem>NotSet</SubSystem>
@@ -749,5 +247,6 @@
       <EnableCOMDATFolding>true</EnableCOMDATFolding>
-      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
+      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
       <RandomizedBaseAddress>false</RandomizedBaseAddress>
       <ImportLibrary>$(xrLibDir)$(TargetName).lib</ImportLibrary>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
     </Link>
@@ -755,3 +254,3 @@
   <ItemGroup>
-    <ClInclude Include="..\xrGameSpy\gamespy\md5.h" />
+    <ClInclude Include="..\xrCore\ChooseTypes.H" />
     <ClInclude Include="..\xrServerEntities\ai_sounds.h" />
@@ -770,4 +269,4 @@
     <ClInclude Include="..\xrServerEntities\clsid_game.h" />
-    <ClInclude Include="..\xrServerEntities\DrawUtils.h" />
-    <ClInclude Include="..\xrServerEntities\FastDelegate.h" />
+    <ClInclude Include="..\Include\xrRender\DrawUtils.h" />
+    <ClInclude Include="..\xrCore\FastDelegate.h" />
     <ClInclude Include="..\xrServerEntities\gametype_chooser.h" />
@@ -802,2 +301,3 @@
     <ClInclude Include="..\xrServerEntities\PHNetState.h" />
+    <ClInclude Include="..\xrServerEntities\PHSynchronize.h" />
     <ClInclude Include="..\xrServerEntities\PropertiesListTypes.h" />
@@ -809,2 +309,3 @@
     <ClInclude Include="..\xrServerEntities\script_engine.h" />
+    <ClInclude Include="..\xrServerEntities\script_engine_export.h" />
     <ClInclude Include="..\xrServerEntities\script_engine_inline.h" />
@@ -883,2 +384,3 @@
     <ClInclude Include="ActorAnimation.h" />
+    <ClInclude Include="ActorBackpack.h" />
     <ClInclude Include="ActorCondition.h" />
@@ -886,2 +388,3 @@
     <ClInclude Include="ActorHelmet.h" />
+    <ClInclude Include="ActorNightVision.h" />
     <ClInclude Include="actor_anim_defs.h" />
@@ -1362,3 +865,2 @@
     <ClInclude Include="bone_groups.h" />
-    <ClInclude Include="bone_utils.h" />
     <ClInclude Include="BottleItem.h" />
@@ -1408,2 +910,3 @@
     <ClInclude Include="CustomDetector.h" />
+    <ClInclude Include="CustomDevice.h" />
     <ClInclude Include="CustomMonster.h" />
@@ -1460,2 +963,3 @@
     <ClInclude Include="doors_manager.h" />
+    <ClInclude Include="Dosimeter.h" />
     <ClInclude Include="double_shot_double_kill.h" />
@@ -1492,8 +996,5 @@
     <CustomBuild Include="Explosive.h">
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug_NEW|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug_NEW|x64'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LuaJit_one|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LuaJit_one|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='VerifiedDX11|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-AVX|x64'">true</ExcludedFromBuild>
     </CustomBuild>
@@ -1508,2 +1009,3 @@
     <ClInclude Include="file_transfer.h" />
+    <ClInclude Include="firedeps.h" />
     <ClInclude Include="fire_disp_controller.h" />
@@ -1511,2 +1013,3 @@
     <ClInclude Include="flare.h" />
+    <ClInclude Include="Flashlight.h" />
     <ClInclude Include="FoodItem.h" />
@@ -1519,17 +1022,2 @@
     <ClInclude Include="gamespy\CdkeyDecode\cdkeydecode.h" />
-    <ClInclude Include="gamespy\GameSpy_ATLAS.h" />
-    <ClInclude Include="GameSpy\GameSpy_Available.h" />
-    <ClInclude Include="GameSpy\GameSpy_Base_Defs.h" />
-    <ClInclude Include="GameSpy\GameSpy_Browser.h" />
-    <ClInclude Include="gamespy\GameSpy_Full.h" />
-    <ClInclude Include="GameSpy\GameSpy_FuncDefs.h" />
-    <ClInclude Include="GameSpy\GameSpy_GCD_Client.h" />
-    <ClInclude Include="GameSpy\GameSpy_GCD_Server.h" />
-    <ClInclude Include="gamespy\GameSpy_GP.h" />
-    <ClInclude Include="gamespy\GameSpy_HTTP.h" />
-    <ClInclude Include="GameSpy\GameSpy_Keys.h" />
-    <ClInclude Include="GameSpy\GameSpy_Patching.h" />
-    <ClInclude Include="GameSpy\GameSpy_QR2.h" />
-    <ClInclude Include="GameSpy\GameSpy_QR2_callbacks.h" />
-    <ClInclude Include="gamespy\GameSpy_SAKE.h" />
     <ClInclude Include="GameTask.h" />
@@ -1674,2 +1162,3 @@
     <ClInclude Include="Level.h" />
+    <ClInclude Include="LevelDebugScript.h" />
     <ClInclude Include="Level_Bullet_Manager.h" />
@@ -1742,2 +1231,4 @@
     <ClInclude Include="NET_Queue.h" />
+    <ClInclude Include="NewZoomFlag.h" />
+    <ClInclude Include="new_sds.h" />
     <ClInclude Include="NoGravityZone.h" />
@@ -1836,2 +1327,3 @@
     <ClInclude Include="physic_item_inline.h" />
+    <ClInclude Include="ph_shell_interface.h" />
     <ClInclude Include="player_account.h" />
@@ -1868,3 +1360,2 @@
     <ClInclude Include="profile_store.h" />
-    <ClInclude Include="PropertiesListHelper.h" />
     <ClInclude Include="property_evaluator.h" />
@@ -1889,2 +1380,3 @@
     <ClInclude Include="rat_state_manager_inline.h" />
+    <ClInclude Include="raypick.h" />
     <ClInclude Include="refreshable_obstacles_query.h" />
@@ -1917,2 +1409,3 @@
     <ClInclude Include="screenshot_server.h" />
+    <ClInclude Include="script_light_inline.h" />
     <ClInclude Include="ScriptXMLInit.h" />
@@ -1954,2 +1447,3 @@
     <ClInclude Include="script_lanim.h" />
+    <ClInclude Include="script_light.h" />
     <ClInclude Include="script_monster_action.h" />
@@ -1975,2 +1469,3 @@
     <ClInclude Include="script_ui_registrator.h" />
+    <ClInclude Include="script_wallmarks_manager.h" />
     <ClInclude Include="script_watch_action.h" />
@@ -2171,2 +1666,3 @@
     <ClInclude Include="UIDialogHolder.h" />
+    <ClInclude Include="UIDosimeter.h" />
     <ClInclude Include="UIGameAHunt.h" />
@@ -2399,14 +1895,2 @@
   <ItemGroup>
-    <ClCompile Include="..\xrGameSpy\gamespy\md5c.c">
-      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
-      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
-      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Mixed|Win32'">NotUsing</PrecompiledHeader>
-      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Mixed|x64'">NotUsing</PrecompiledHeader>
-      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
-      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
-      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_NEW|Win32'">NotUsing</PrecompiledHeader>
-      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug_NEW|x64'">NotUsing</PrecompiledHeader>
-      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_LuaJit_one|Win32'">NotUsing</PrecompiledHeader>
-      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release_LuaJit_one|x64'">NotUsing</PrecompiledHeader>
-    </ClCompile>
     <ClCompile Include="..\xrServerEntities\alife_human_brain.cpp" />
@@ -2604,2 +2088,3 @@
     <ClCompile Include="ActorAnimation.cpp" />
+    <ClCompile Include="ActorBackpack.cpp" />
     <ClCompile Include="ActorCameras.cpp" />
@@ -2609,2 +2094,6 @@
     </ClCompile>
+    <ClCompile Include="ActorCondition_script.cpp">
+      <PrecompiledHeaderFile>pch_script.h</PrecompiledHeaderFile>
+      <PrecompiledHeaderOutputFile>$(IntDir)$(ProjectName)_script.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
     <ClCompile Include="ActorEffector.cpp" />
@@ -2616,4 +2105,3 @@
     <ClCompile Include="ActorInput.cpp" />
-    <ClCompile Include="ActorMountedWeapon.cpp" />
-    <ClCompile Include="ActorVehicle.cpp" />
+    <ClCompile Include="ActorNightVision.cpp" />
     <ClCompile Include="actor_communication.cpp">
@@ -2849,8 +2337,3 @@
     </ClCompile>
-    <ClCompile Include="ai\monsters\rats\ai_rat_templates.cpp">
-      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">stdafx.h</PrecompiledHeaderFile>
-      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">stdafx.h</PrecompiledHeaderFile>
-      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(ProjectName).pch</PrecompiledHeaderOutputFile>
-      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(ProjectName).pch</PrecompiledHeaderOutputFile>
-    </ClCompile>
+    <ClCompile Include="ai\monsters\rats\ai_rat_templates.cpp" />
     <ClCompile Include="ai\monsters\rats\rat_state_activation.cpp">
@@ -2933,8 +2416,3 @@
     </ClCompile>
-    <ClCompile Include="ai_debug_variables.cpp">
-      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">stdafx.h</PrecompiledHeaderFile>
-      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">stdafx.h</PrecompiledHeaderFile>
-      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(ProjectName).pch</PrecompiledHeaderOutputFile>
-      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(ProjectName).pch</PrecompiledHeaderOutputFile>
-    </ClCompile>
+    <ClCompile Include="ai_debug_variables.cpp" />
     <ClCompile Include="ai_obstacle.cpp" />
@@ -3027,2 +2505,6 @@
     <ClCompile Include="antirad.cpp" />
+    <ClCompile Include="antirad_script.cpp">
+      <PrecompiledHeaderFile>pch_script.h</PrecompiledHeaderFile>
+      <PrecompiledHeaderOutputFile>$(IntDir)$(ProjectName)_script.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
     <ClCompile Include="Artefact.cpp" />
@@ -3056,2 +2538,6 @@
     <ClCompile Include="BottleItem.cpp" />
+    <ClCompile Include="BottleItem_script.cpp">
+      <PrecompiledHeaderFile>pch_script.h</PrecompiledHeaderFile>
+      <PrecompiledHeaderOutputFile>$(IntDir)$(ProjectName)_script.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
     <ClCompile Include="BreakableObject.cpp" />
@@ -3112,2 +2598,3 @@
     <ClCompile Include="CustomDetector.cpp" />
+    <ClCompile Include="CustomDevice.cpp" />
     <ClCompile Include="CustomMonster.cpp">
@@ -3118,4 +2605,12 @@
     <ClCompile Include="CustomOutfit.cpp" />
+    <ClCompile Include="CustomOutfit_script.cpp">
+      <PrecompiledHeaderFile>pch_script.h</PrecompiledHeaderFile>
+      <PrecompiledHeaderOutputFile>$(IntDir)$(ProjectName)_script.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
     <ClCompile Include="CustomRocket.cpp" />
     <ClCompile Include="CustomZone.cpp" />
+    <ClCompile Include="CustomZone_script.cpp">
+      <PrecompiledHeaderFile>pch_script.h</PrecompiledHeaderFile>
+      <PrecompiledHeaderOutputFile>$(IntDir)$(ProjectName)_script.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
     <ClCompile Include="DamagableItem.cpp" />
@@ -3157,2 +2652,3 @@
     <ClCompile Include="doors_manager.cpp" />
+    <ClCompile Include="Dosimeter.cpp" />
     <ClCompile Include="double_shot_double_kill.cpp" />
@@ -3165,2 +2661,6 @@
     <ClCompile Include="eatable_item_object.cpp" />
+    <ClCompile Include="eatable_item_script.cpp">
+      <PrecompiledHeaderFile>pch_script.h</PrecompiledHeaderFile>
+      <PrecompiledHeaderOutputFile>$(IntDir)$(ProjectName)_script.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
     <ClCompile Include="EffectorBobbing.cpp" />
@@ -3211,3 +2711,8 @@
     <ClCompile Include="flare.cpp" />
+    <ClCompile Include="Flashlight.cpp" />
     <ClCompile Include="FoodItem.cpp" />
+    <ClCompile Include="FoodItem_script.cpp">
+      <PrecompiledHeaderFile>pch_script.h</PrecompiledHeaderFile>
+      <PrecompiledHeaderOutputFile>$(IntDir)$(ProjectName)_script.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
     <ClCompile Include="FryupZone.cpp" />
@@ -3234,14 +2739,2 @@
     </ClCompile>
-    <ClCompile Include="gamespy\GameSpy_ATLAS.cpp" />
-    <ClCompile Include="GameSpy\GameSpy_Available.cpp" />
-    <ClCompile Include="GameSpy\GameSpy_Browser.cpp" />
-    <ClCompile Include="gamespy\GameSpy_Full.cpp" />
-    <ClCompile Include="GameSpy\GameSpy_GCD_Client.cpp" />
-    <ClCompile Include="GameSpy\GameSpy_GCD_Server.cpp" />
-    <ClCompile Include="gamespy\GameSpy_GP.cpp" />
-    <ClCompile Include="gamespy\GameSpy_HTTP.cpp" />
-    <ClCompile Include="GameSpy\GameSpy_Patching.cpp" />
-    <ClCompile Include="GameSpy\GameSpy_QR2.cpp" />
-    <ClCompile Include="GameSpy\GameSpy_QR2_callbacks.cpp" />
-    <ClCompile Include="gamespy\GameSpy_SAKE.cpp" />
     <ClCompile Include="GameTask.cpp">
@@ -3396,2 +2889,6 @@
     </ClCompile>
+    <ClCompile Include="InventoryBox_script.cpp">
+      <PrecompiledHeaderFile>pch_script.h</PrecompiledHeaderFile>
+      <PrecompiledHeaderOutputFile>$(IntDir)$(ProjectName)_script.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
     <ClCompile Include="InventoryOwner.cpp">
@@ -3400,2 +2897,6 @@
     </ClCompile>
+    <ClCompile Include="InventoryOwner_script.cpp">
+      <PrecompiledHeaderFile>pch_script.h</PrecompiledHeaderFile>
+      <PrecompiledHeaderOutputFile>$(IntDir)$(ProjectName)_script.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
     <ClCompile Include="inventory_item.cpp">
@@ -3408,2 +2909,6 @@
     </ClCompile>
+    <ClCompile Include="inventory_item_script.cpp">
+      <PrecompiledHeaderFile>pch_script.h</PrecompiledHeaderFile>
+      <PrecompiledHeaderOutputFile>$(IntDir)$(ProjectName)_script.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
     <ClCompile Include="inventory_item_upgrade.cpp">
@@ -3453,2 +2958,3 @@
     </ClCompile>
+    <ClCompile Include="LevelDebugScript.cpp" />
     <ClCompile Include="Level_Bullet_Manager.cpp" />
@@ -3467,6 +2973,3 @@
     <ClCompile Include="Level_load.cpp" />
-    <ClCompile Include="level_map_locations.cpp">
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
-    </ClCompile>
+    <ClCompile Include="level_map_locations.cpp" />
     <ClCompile Include="Level_network.cpp">
@@ -3509,2 +3012,6 @@
     <ClCompile Include="medkit.cpp" />
+    <ClCompile Include="medkit_script.cpp">
+      <PrecompiledHeaderFile>pch_script.h</PrecompiledHeaderFile>
+      <PrecompiledHeaderOutputFile>$(IntDir)$(ProjectName)_script.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
     <ClCompile Include="memory_manager.cpp">
@@ -3659,2 +3166,6 @@
     <ClCompile Include="player_hud.cpp" />
+    <ClCompile Include="player_hud_script.cpp">
+      <PrecompiledHeaderFile>pch_script.h</PrecompiledHeaderFile>
+      <PrecompiledHeaderOutputFile>$(IntDir)$(ProjectName)_script.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
     <ClCompile Include="player_hud_tune.cpp" />
@@ -3684,8 +3195,5 @@
     <ClCompile Include="profiler.cpp">
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug_NEW|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug_NEW|x64'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LuaJit_one|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LuaJit_one|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='VerifiedDX11|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-AVX|x64'">true</ExcludedFromBuild>
     </ClCompile>
@@ -3918,2 +3426,7 @@
     </ClCompile>
+    <ClCompile Include="script_wallmarks_manager.cpp" />
+    <ClCompile Include="script_wallmarks_script.cpp">
+      <PrecompiledHeaderFile>pch_script.h</PrecompiledHeaderFile>
+      <PrecompiledHeaderOutputFile>$(IntDir)$(ProjectName)_script.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
     <ClCompile Include="script_watch_action.cpp" />
@@ -3943,2 +3456,6 @@
     <ClCompile Include="server_entity_wrapper.cpp" />
+    <ClCompile Include="script_light_script.cpp">
+      <PrecompiledHeaderFile>pch_script.h</PrecompiledHeaderFile>
+      <PrecompiledHeaderOutputFile>$(IntDir)$(ProjectName)_script.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
     <ClCompile Include="ShootingObject.cpp" />
@@ -4210,2 +3727,3 @@
     <ClCompile Include="UIDialogHolder.cpp" />
+    <ClCompile Include="UIDosimeter.cpp" />
     <ClCompile Include="UIGameAHunt.cpp" />
@@ -4296,8 +3814,5 @@
     <ClCompile Include="ui\UIDebugFonts.cpp">
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug_NEW|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug_NEW|x64'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LuaJit_one|Win32'">true</ExcludedFromBuild>
-      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release_LuaJit_one|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='VerifiedDX11|x64'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release-AVX|x64'">true</ExcludedFromBuild>
     </ClCompile>
@@ -4529,2 +4044,6 @@
     <ClCompile Include="WeaponAmmo.cpp" />
+    <ClCompile Include="WeaponAmmo_script.cpp">
+      <PrecompiledHeaderFile>pch_script.h</PrecompiledHeaderFile>
+      <PrecompiledHeaderOutputFile>$(IntDir)$(ProjectName)_script.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
     <ClCompile Include="WeaponAutomaticShotgun.cpp" />
@@ -4579,2 +4098,3 @@
     <ClCompile Include="WeaponMagazinedWGrenade.cpp" />
+    <ClCompile Include="WeaponMagazineExtended.cpp" />
     <ClCompile Include="WeaponPistol.cpp" />
@@ -4696,10 +4216,2 @@
     </ProjectReference>
-    <ProjectReference Include="$(SolutionDir)xrEngine\xrEngine.vcxproj">
-      <Project>{2578c6d8-660d-48ae-9322-7422f8664f06}</Project>
-      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
-    </ProjectReference>
-    <ProjectReference Include="$(SolutionDir)xrGameSpy\xrGameSpy.vcxproj">
-      <Project>{5535f6b4-7ae6-4b66-8aea-cc31c14d7ab7}</Project>
-      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>
-    </ProjectReference>
     <ProjectReference Include="$(SolutionDir)xrNetServer\xrNetServer.vcxproj">
@@ -4723,6 +4235,2 @@
   </ItemGroup>
-  <ItemGroup>
-    <None Include="Players.cd" />
-    <None Include="Weapons.cd" />
-  </ItemGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/xrGame.vcxproj.filters xray-monolith/src/xrGame/xrGame.vcxproj.filters
--- coc-1.4-xray-64/src/xrGame/xrGame.vcxproj.filters	2023-10-20 20:54:51.527326400 +0100
+++ xray-monolith/src/xrGame/xrGame.vcxproj.filters	2023-10-20 20:54:33.423035500 +0100
@@ -1389,5 +1389,2 @@
     </Filter>
-    <Filter Include="Core\Client\Effectors\monsters_%3f%3f%3f">
-      <UniqueIdentifier>{b1a00ac3-9c32-43d4-a698-33d5f830e0d2}</UniqueIdentifier>
-    </Filter>
     <Filter Include="Core\Client\Effectors\Postprocess">
@@ -2409,5 +2406,2 @@
     </Filter>
-    <Filter Include="Class Diagrams">
-      <UniqueIdentifier>{3c08723e-1b59-45e4-958f-3a1c5590cfa9}</UniqueIdentifier>
-    </Filter>
     <Filter Include="AI\AMonsters\common\script\monster states">
@@ -2496,2 +2490,5 @@
     </Filter>
+    <Filter Include="Core\Client\Effectors\monsters">
+      <UniqueIdentifier>{b1a00ac3-9c32-43d4-a698-33d5f830e0d2}</UniqueIdentifier>
+    </Filter>
   </ItemGroup>
@@ -5264,5 +5261,2 @@
     </ClInclude>
-    <ClInclude Include="bone_utils.h">
-      <Filter>Core</Filter>
-    </ClInclude>
     <ClInclude Include="..\xrServerEntities\pch_script.h">
@@ -5292,9 +5286,9 @@
     <ClInclude Include="ai\Monsters\ai_monster_effector.h">
-      <Filter>Core\Client\Effectors\monsters_%3f%3f%3f</Filter>
+      <Filter>Core\Client\Effectors\monsters</Filter>
     </ClInclude>
     <ClInclude Include="pp_effector_custom.h">
-      <Filter>Core\Client\Effectors\monsters_%3f%3f%3f</Filter>
+      <Filter>Core\Client\Effectors\monsters</Filter>
     </ClInclude>
     <ClInclude Include="pp_effector_distance.h">
-      <Filter>Core\Client\Effectors\monsters_%3f%3f%3f</Filter>
+      <Filter>Core\Client\Effectors\monsters</Filter>
     </ClInclude>
@@ -5387,5 +5381,2 @@
     </ClInclude>
-    <ClInclude Include="..\xrGameSpy\gamespy\md5.h">
-      <Filter>Core\Client\Level\ClientDigestComputer</Filter>
-    </ClInclude>
     <ClInclude Include="DemoInfo.h">
@@ -6251,8 +6242,2 @@
     </ClInclude>
-    <ClInclude Include="..\xrServerEntities\DrawUtils.h">
-      <Filter>Core\Server\Editor</Filter>
-    </ClInclude>
-    <ClInclude Include="..\xrServerEntities\FastDelegate.h">
-      <Filter>Core\Server\Editor</Filter>
-    </ClInclude>
     <ClInclude Include="..\xrServerEntities\ItemListTypes.h">
@@ -6260,5 +6245,2 @@
     </ClInclude>
-    <ClInclude Include="PropertiesListHelper.h">
-      <Filter>Core\Server\Editor</Filter>
-    </ClInclude>
     <ClInclude Include="..\xrServerEntities\WaveForm.h">
@@ -6581,47 +6563,2 @@
     </ClInclude>
-    <ClInclude Include="gamespy\GameSpy_ATLAS.h">
-      <Filter>Core\Server\GameSpy</Filter>
-    </ClInclude>
-    <ClInclude Include="GameSpy\GameSpy_Available.h">
-      <Filter>Core\Server\GameSpy</Filter>
-    </ClInclude>
-    <ClInclude Include="GameSpy\GameSpy_Base_Defs.h">
-      <Filter>Core\Server\GameSpy</Filter>
-    </ClInclude>
-    <ClInclude Include="GameSpy\GameSpy_Browser.h">
-      <Filter>Core\Server\GameSpy</Filter>
-    </ClInclude>
-    <ClInclude Include="gamespy\GameSpy_Full.h">
-      <Filter>Core\Server\GameSpy</Filter>
-    </ClInclude>
-    <ClInclude Include="GameSpy\GameSpy_FuncDefs.h">
-      <Filter>Core\Server\GameSpy</Filter>
-    </ClInclude>
-    <ClInclude Include="GameSpy\GameSpy_GCD_Client.h">
-      <Filter>Core\Server\GameSpy</Filter>
-    </ClInclude>
-    <ClInclude Include="GameSpy\GameSpy_GCD_Server.h">
-      <Filter>Core\Server\GameSpy</Filter>
-    </ClInclude>
-    <ClInclude Include="gamespy\GameSpy_GP.h">
-      <Filter>Core\Server\GameSpy</Filter>
-    </ClInclude>
-    <ClInclude Include="gamespy\GameSpy_HTTP.h">
-      <Filter>Core\Server\GameSpy</Filter>
-    </ClInclude>
-    <ClInclude Include="GameSpy\GameSpy_Keys.h">
-      <Filter>Core\Server\GameSpy</Filter>
-    </ClInclude>
-    <ClInclude Include="GameSpy\GameSpy_Patching.h">
-      <Filter>Core\Server\GameSpy</Filter>
-    </ClInclude>
-    <ClInclude Include="GameSpy\GameSpy_QR2.h">
-      <Filter>Core\Server\GameSpy</Filter>
-    </ClInclude>
-    <ClInclude Include="GameSpy\GameSpy_QR2_callbacks.h">
-      <Filter>Core\Server\GameSpy</Filter>
-    </ClInclude>
-    <ClInclude Include="gamespy\GameSpy_SAKE.h">
-      <Filter>Core\Server\GameSpy</Filter>
-    </ClInclude>
     <ClInclude Include="gamespy\CdkeyDecode\base32.h">
@@ -7386,2 +7323,58 @@
     <ClInclude Include="HolderEntityObject.h" />
+    <ClInclude Include="ActorNightVision.h">
+      <Filter>Core\Client\Effectors\Actor</Filter>
+    </ClInclude>
+    <ClInclude Include="Flashlight.h">
+      <Filter>Core\Client\Objects\items &amp; weapons\Devices</Filter>
+    </ClInclude>
+    <ClInclude Include="Dosimeter.h">
+      <Filter>Core\Client\Objects\items &amp; weapons\Devices</Filter>
+    </ClInclude>
+    <ClInclude Include="UIDosimeter.h">
+      <Filter>UI</Filter>
+    </ClInclude>
+    <ClInclude Include="..\xrCore\ChooseTypes.H">
+      <Filter>Core\Server\ServerEntities</Filter>
+    </ClInclude>
+    <ClInclude Include="ActorBackpack.h">
+      <Filter>Core\Client\Objects\actor\base</Filter>
+    </ClInclude>
+    <ClInclude Include="firedeps.h">
+      <Filter>Core\Client\Objects\items &amp; weapons\Weapons\Custom Weapon\Weapon Generic</Filter>
+    </ClInclude>
+    <ClInclude Include="ph_shell_interface.h">
+      <Filter>Physics</Filter>
+    </ClInclude>
+    <ClInclude Include="..\xrServerEntities\PHSynchronize.h">
+      <Filter>Core\Server\ServerEntities\objects_alife_items</Filter>
+    </ClInclude>
+    <ClInclude Include="raypick.h">
+      <Filter>Core\Common</Filter>
+    </ClInclude>
+    <ClInclude Include="..\xrServerEntities\script_engine_export.h">
+      <Filter>AI\AScript\ScriptEngine</Filter>
+    </ClInclude>
+    <ClInclude Include="..\Include\xrRender\DrawUtils.h">
+      <Filter>Core\Server\Editor</Filter>
+    </ClInclude>
+    <ClInclude Include="..\xrCore\FastDelegate.h">
+      <Filter>Core\Server\Editor</Filter>
+    </ClInclude>
+    <ClInclude Include="CustomDevice.h">
+      <Filter>Core\Client\Objects\items &amp; weapons\Devices</Filter>
+    </ClInclude>
+    <ClInclude Include="script_light.h">
+      <Filter>Core\Client\Objects\hanging_lamp</Filter>
+    </ClInclude>
+    <ClInclude Include="script_light_inline.h">
+      <Filter>Core\Client\Objects\hanging_lamp</Filter>
+    </ClInclude>
+    <ClInclude Include="script_wallmarks_manager.h">
+      <Filter>Core\Client\Effects</Filter>
+    </ClInclude>
+    <ClInclude Include="NewZoomFlag.h" />
+    <ClInclude Include="new_sds.h" />
+    <ClInclude Include="LevelDebugScript.h">
+      <Filter>Core\Client\Level</Filter>
+    </ClInclude>
   </ItemGroup>
@@ -8853,9 +8846,9 @@
     <ClCompile Include="ai\Monsters\ai_monster_effector.cpp">
-      <Filter>Core\Client\Effectors\monsters_%3f%3f%3f</Filter>
+      <Filter>Core\Client\Effectors\monsters</Filter>
     </ClCompile>
     <ClCompile Include="pp_effector_custom.cpp">
-      <Filter>Core\Client\Effectors\monsters_%3f%3f%3f</Filter>
+      <Filter>Core\Client\Effectors\monsters</Filter>
     </ClCompile>
     <ClCompile Include="pp_effector_distance.cpp">
-      <Filter>Core\Client\Effectors\monsters_%3f%3f%3f</Filter>
+      <Filter>Core\Client\Effectors\monsters</Filter>
     </ClCompile>
@@ -8978,5 +8971,2 @@
     </ClCompile>
-    <ClCompile Include="..\xrGameSpy\gamespy\md5c.c">
-      <Filter>Core\Client\Level\ClientDigestComputer</Filter>
-    </ClCompile>
     <ClCompile Include="DemoInfo.cpp">
@@ -9062,9 +9052,6 @@
     </ClCompile>
-    <ClCompile Include="ActorInput.cpp">
-      <Filter>Core\Client\Objects\actor\base</Filter>
-    </ClCompile>
-    <ClCompile Include="ActorMountedWeapon.cpp">
+    <ClCompile Include="ActorCondition_script.cpp">
       <Filter>Core\Client\Objects\actor\base</Filter>
     </ClCompile>
-    <ClCompile Include="ActorVehicle.cpp">
+    <ClCompile Include="ActorInput.cpp">
       <Filter>Core\Client\Objects\actor\base</Filter>
@@ -10106,38 +10093,2 @@
     </ClCompile>
-    <ClCompile Include="gamespy\GameSpy_ATLAS.cpp">
-      <Filter>Core\Server\GameSpy</Filter>
-    </ClCompile>
-    <ClCompile Include="GameSpy\GameSpy_Available.cpp">
-      <Filter>Core\Server\GameSpy</Filter>
-    </ClCompile>
-    <ClCompile Include="GameSpy\GameSpy_Browser.cpp">
-      <Filter>Core\Server\GameSpy</Filter>
-    </ClCompile>
-    <ClCompile Include="gamespy\GameSpy_Full.cpp">
-      <Filter>Core\Server\GameSpy</Filter>
-    </ClCompile>
-    <ClCompile Include="GameSpy\GameSpy_GCD_Client.cpp">
-      <Filter>Core\Server\GameSpy</Filter>
-    </ClCompile>
-    <ClCompile Include="GameSpy\GameSpy_GCD_Server.cpp">
-      <Filter>Core\Server\GameSpy</Filter>
-    </ClCompile>
-    <ClCompile Include="gamespy\GameSpy_GP.cpp">
-      <Filter>Core\Server\GameSpy</Filter>
-    </ClCompile>
-    <ClCompile Include="gamespy\GameSpy_HTTP.cpp">
-      <Filter>Core\Server\GameSpy</Filter>
-    </ClCompile>
-    <ClCompile Include="GameSpy\GameSpy_Patching.cpp">
-      <Filter>Core\Server\GameSpy</Filter>
-    </ClCompile>
-    <ClCompile Include="GameSpy\GameSpy_QR2.cpp">
-      <Filter>Core\Server\GameSpy</Filter>
-    </ClCompile>
-    <ClCompile Include="GameSpy\GameSpy_QR2_callbacks.cpp">
-      <Filter>Core\Server\GameSpy</Filter>
-    </ClCompile>
-    <ClCompile Include="gamespy\GameSpy_SAKE.cpp">
-      <Filter>Core\Server\GameSpy</Filter>
-    </ClCompile>
     <ClCompile Include="gamespy\CdkeyDecode\base32.c">
@@ -11037,2 +10988,67 @@
     <ClCompile Include="HolderEntityObject.cpp" />
+    <ClCompile Include="CustomOutfit_script.cpp">
+      <Filter>Core\Client\Objects\items &amp; weapons\Outfit</Filter>
+    </ClCompile>
+    <ClCompile Include="medkit_script.cpp" />
+    <ClCompile Include="WeaponAmmo_script.cpp">
+      <Filter>Core\Client\Objects\items &amp; weapons\Weapons\Custom Weapon\Ammo</Filter>
+    </ClCompile>
+    <ClCompile Include="eatable_item_script.cpp">
+      <Filter>Core\Client\Objects\inventory\EatableItem</Filter>
+    </ClCompile>
+    <ClCompile Include="antirad_script.cpp" />
+    <ClCompile Include="FoodItem_script.cpp">
+      <Filter>Core\Client\Objects\items &amp; weapons\Food &amp; Drugs</Filter>
+    </ClCompile>
+    <ClCompile Include="BottleItem_script.cpp">
+      <Filter>Core\Client\Objects\items &amp; weapons\Food &amp; Drugs</Filter>
+    </ClCompile>
+    <ClCompile Include="InventoryBox_script.cpp">
+      <Filter>Core\Client\Objects\inventory_box</Filter>
+    </ClCompile>
+    <ClCompile Include="InventoryOwner_script.cpp">
+      <Filter>Core\Client\Objects\inventory\InventoryOwner</Filter>
+    </ClCompile>
+    <ClCompile Include="CustomZone_script.cpp">
+      <Filter>Core\Client\Objects\zones\CustomZone</Filter>
+    </ClCompile>
+    <ClCompile Include="inventory_item_script.cpp">
+      <Filter>Core\Client\Objects\inventory\InventoryItem</Filter>
+    </ClCompile>
+    <ClCompile Include="ActorBackpack.cpp">
+      <Filter>Core\Client\Objects\actor\base</Filter>
+    </ClCompile>
+    <ClCompile Include="ActorNightVision.cpp">
+      <Filter>Core\Client\Effectors\Actor</Filter>
+    </ClCompile>
+    <ClCompile Include="Flashlight.cpp">
+      <Filter>Core\Client\Objects\items &amp; weapons\Devices</Filter>
+    </ClCompile>
+    <ClCompile Include="Dosimeter.cpp">
+      <Filter>Core\Client\Objects\items &amp; weapons\Devices</Filter>
+    </ClCompile>
+    <ClCompile Include="UIDosimeter.cpp">
+      <Filter>UI</Filter>
+    </ClCompile>
+    <ClCompile Include="CustomDevice.cpp">
+      <Filter>Core\Client\Objects\items &amp; weapons\Devices</Filter>
+    </ClCompile>
+    <ClCompile Include="script_light_script.cpp">
+      <Filter>Core\Client\Objects\hanging_lamp</Filter>
+    </ClCompile>
+    <ClCompile Include="script_wallmarks_script.cpp">
+      <Filter>Core\Client\Effects</Filter>
+    </ClCompile>
+    <ClCompile Include="script_wallmarks_manager.cpp">
+      <Filter>Core\Client\Effects</Filter>
+    </ClCompile>
+    <ClCompile Include="WeaponMagazineExtended.cpp">
+      <Filter>Core\Client\Objects\items &amp; weapons\Weapons\Custom Weapon\Automatic</Filter>
+    </ClCompile>
+    <ClCompile Include="player_hud_script.cpp">
+      <Filter>Core\Client\Objects\items &amp; weapons\HudItem</Filter>
+    </ClCompile>
+    <ClCompile Include="LevelDebugScript.cpp">
+      <Filter>Core\Client\Level</Filter>
+    </ClCompile>
   </ItemGroup>
@@ -11055,10 +11071,2 @@
   </ItemGroup>
-  <ItemGroup>
-    <None Include="Weapons.cd">
-      <Filter>Class Diagrams</Filter>
-    </None>
-    <None Include="Players.cd">
-      <Filter>Class Diagrams</Filter>
-    </None>
-  </ItemGroup>
 </Project>
\ No newline at end of file
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/xrGameSpy_GameSpyFuncs.cpp xray-monolith/src/xrGame/xrGameSpy_GameSpyFuncs.cpp
--- coc-1.4-xray-64/src/xrGame/xrGameSpy_GameSpyFuncs.cpp	2023-10-20 20:54:51.529326500 +0100
+++ xray-monolith/src/xrGame/xrGameSpy_GameSpyFuncs.cpp	2023-10-20 20:54:33.425035700 +0100
@@ -7,3 +7,3 @@
 {	
-	if (!m_QR2.Init(PortID, m_iReportToMasterServer, this)) return;
+	//if (!m_QR2.Init(PortID, m_iReportToMasterServer, this)) return;
 	m_bQR2_Initialized = TRUE;
@@ -14,3 +14,3 @@
 	m_bQR2_Initialized = FALSE;
-	m_QR2.ShutDown(NULL);
+	//m_QR2.ShutDown(NULL);
 };
@@ -21,3 +21,3 @@
 {
-	if (!m_GCDServer.Init()) return;
+	//if (!m_GCDServer.Init()) return;
 	m_bCDKey_Initialized = TRUE;
@@ -27,3 +27,3 @@
 {
-	m_GCDServer.ShutDown();
+	//m_GCDServer.ShutDown();
 	m_bCDKey_Initialized = FALSE;
@@ -38,3 +38,3 @@
 
-    m_GCDServer.CreateRandomChallenge(pClient->m_pChallengeString, 8);
+	//m_GCDServer.CreateRandomChallenge(pClient->m_pChallengeString, 8);
 	//--------- Send Respond ---------------------------------------------
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/xrGameSpyServer.cpp xray-monolith/src/xrGame/xrGameSpyServer.cpp
--- coc-1.4-xray-64/src/xrGame/xrGameSpyServer.cpp	2023-10-20 20:54:51.527326400 +0100
+++ xray-monolith/src/xrGame/xrGameSpyServer.cpp	2023-10-20 20:54:33.424037000 +0100
@@ -5,5 +5,2 @@
 
-#include "GameSpy/GameSpy_Base_Defs.h"
-#include "GameSpy/GameSpy_Available.h"
-
 //#define DEMO_BUILD
@@ -82,3 +82,3 @@
 //	m_bCheckCDKey = game->get_option_i		(*session_name,"cdkey",0) != 0;
-	m_bCheckCDKey = game->get_option_i		(*session_name,"public",0) != 0;
+	//	m_bCheckCDKey = game->get_option_i		(*session_name,"public",0) != 0;
 	//--------------------------------------------//
@@ -87,8 +87,8 @@
 		//----- Check for Backend Services ---
-		CGameSpy_Available GSA;
-		shared_str result_string;
-		if (!GSA.CheckAvailableServices(result_string))
-		{
-			Msg(*result_string);
-		};
+		//CGameSpy_Available GSA;
+		//shared_str result_string;
+		//if (!GSA.CheckAvailableServices(result_string))
+		//{
+		//	Msg(*result_string);
+		//};
 
@@ -117,11 +117,11 @@
 
-	if (m_bQR2_Initialized)
-	{
-		m_QR2.Think(NULL);
-	};
-
-	if (m_bCDKey_Initialized)
-	{
-		m_GCDServer.Think();
-	};
+	//if (m_bQR2_Initialized)
+	//{
+	//	m_QR2.Think(NULL);
+	//};
+
+	//if (m_bCDKey_Initialized)
+	//{
+	//	m_GCDServer.Think();
+	//};
 }
@@ -154,3 +154,3 @@
 		Msg("Server : Disconnecting Client");
-		m_GCDServer.DisconnectUser(int(_CL->ID.value()));
+		//m_GCDServer.DisconnectUser(int(_CL->ID.value()));
 	};
@@ -186,4 +186,4 @@
 #endif // #ifndef MASTER_GOLD
-				m_GCDServer.AuthUser(int(CL->ID.value()), CL->m_cAddress.m_data.data, CL->m_pChallengeString, ResponseStr, this);
-				xr_strcpy(CL->m_guid,128,this->GCD_Server()->GetKeyHash(CL->ID.value()));
+				//m_GCDServer.AuthUser(int(CL->ID.value()), CL->m_cAddress.m_data.data, CL->m_pChallengeString, ResponseStr, this);
+				//xr_strcpy(CL->m_guid,128,this->GCD_Server()->GetKeyHash(CL->ID.value()));
 			}
@@ -192,3 +192,3 @@
 				Msg("Server : Respond accepted, ReAuthenticate client.");
-				m_GCDServer.ReAuthUser(int(CL->ID.value()), CL->m_iCDKeyReauthHint, ResponseStr);
+				//m_GCDServer.ReAuthUser(int(CL->ID.value()), CL->m_iCDKeyReauthHint, ResponseStr);
 			}
@@ -257,3 +264,3 @@
 	string256 res;
-	si->AddItem( "Game version", QR2()->GetGameVersion( res ), RGB(0,158,255) );
+	//si->AddItem( "Game version", QR2()->GetGameVersion( res ), RGB(0,158,255) );
 	
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/xrGameSpyServer.h xray-monolith/src/xrGame/xrGameSpyServer.h
--- coc-1.4-xray-64/src/xrGame/xrGameSpyServer.h	2023-10-20 20:54:51.528326500 +0100
+++ xray-monolith/src/xrGame/xrGameSpyServer.h	2023-10-20 20:54:33.424037000 +0100
@@ -3,4 +3,2 @@
 #include "xrServer.h"
-#include "GameSpy/GameSpy_GCD_Server.h"
-#include "GameSpy/GameSpy_QR2.h"
 
@@ -51,4 +49,4 @@
 	
-	CGameSpy_GCD_Server				m_GCDServer;
-	CGameSpy_QR2					m_QR2;
+	//CGameSpy_GCD_Server				m_GCDServer;
+	//CGameSpy_QR2					m_QR2;
 	int							iGameSpyBasePort;
@@ -72,5 +70,5 @@
 	void							OnCDKey_ReValidation			(int LocalID, int hint, char* challenge);
-	CGameSpy_QR2*					QR2() {return &m_QR2;} ;
+	//CGameSpy_QR2*					QR2() {return &m_QR2;} ;
 
-	CGameSpy_GCD_Server*		GCD_Server()					{ return &m_GCDServer; }
+	//CGameSpy_GCD_Server*		GCD_Server()					{ return &m_GCDServer; }
 	
@@ -94,4 +92,5 @@
 
-	virtual u32				OnMessage			(NET_Packet& P, ClientID/*DPNID*/ sender);	// Non-Zero means broadcasting with "flags" as returned
-	virtual void			OnError_Add			(qr2_error_t error) {};
+	virtual u32 OnMessage(NET_Packet& P, ClientID/*DPNID*/ sender);
+	// Non-Zero means broadcasting with "flags" as returned
+	//virtual void			OnError_Add			(qr2_error_t error) {};
 };
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/xrGameSpyServer_callbacks.h xray-monolith/src/xrGame/xrGameSpyServer_callbacks.h
--- coc-1.4-xray-64/src/xrGame/xrGameSpyServer_callbacks.h	2023-10-20 20:54:51.528326500 +0100
+++ xray-monolith/src/xrGame/xrGameSpyServer_callbacks.h	2023-10-20 20:54:33.424037000 +0100
@@ -1 +0,0 @@
-#include "GameSpy/GameSpy_Keys.h"
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/xrServer.cpp xray-monolith/src/xrGame/xrServer.cpp
--- coc-1.4-xray-64/src/xrGame/xrServer.cpp	2023-10-20 20:54:51.529326500 +0100
+++ xray-monolith/src/xrGame/xrServer.cpp	2023-10-20 20:54:33.425035700 +0100
@@ -214,5 +218,5 @@
 	NET_Packet		Packet;
-
+#ifdef DEBUG
 	VERIFY						(verify_entities());
-
+#endif
 	ProceedDelayedPackets();
@@ -246,4 +250,5 @@
 	if (game->sv_force_sync)	Perform_game_export();
-
+#ifdef DEBUG
 	VERIFY						(verify_entities());
+#endif
 	//-----------------------------------------------------
@@ -362,3 +368,5 @@
 		if (game->sv_force_sync)	Perform_game_export();
+#ifdef DEBUG
 		VERIFY						(verify_entities());
+#endif
 		m_last_update_time			= Device.dwTimeGlobal;
@@ -384,4 +393,5 @@
 	//csPlayers.Enter			();
-
+#ifdef DEBUG
 	VERIFY							(verify_entities());
+#endif
 	xrClientData* CL				= ID_to_client(sender);
@@ -433,6 +446,8 @@
 			m_file_transfers->on_message(&P, sender);
-		}break;
 	}
+		break;
+	}
+#ifdef DEBUG
 	VERIFY							(verify_entities());
-
+#endif
 	//csPlayers.Leave					();
@@ -454,4 +470,5 @@
 	P.r_begin	(type);
-
+#ifdef DEBUG
 	VERIFY							(verify_entities());
+#endif
 	xrClientData* CL				= ID_to_client(sender);
@@ -463,4 +480,7 @@
 			Process_update			(P,sender);						// No broadcast
+#ifdef DEBUG
 			VERIFY					(verify_entities());
-		}break;
+#endif
+		}
+		break;
 	case M_SPAWN:	
@@ -469,5 +489,7 @@
 				Process_spawn		(P,sender);	
-
+#ifdef DEBUG
 			VERIFY					(verify_entities());
-		}break;
+#endif
+		}
+		break;
 	case M_EVENT:	
@@ -475,4 +497,7 @@
 			Process_event			(P,sender);
+#ifdef DEBUG
 			VERIFY					(verify_entities());
-		}break;
+#endif
+		}
+		break;
 	case M_EVENT_PACK:
@@ -502,4 +528,7 @@
 				SendTo	(SV_Client->ID, P, net_flags(TRUE, TRUE));
+#ifdef DEBUG
 			VERIFY					(verify_entities());
-		}break;
+#endif
+		}
+		break;
 	case M_MOVE_PLAYERS_RESPOND:
@@ -517,4 +547,7 @@
 			if (SV_Client) SendTo	(SV_Client->ID, P, net_flags(TRUE, TRUE));
+#ifdef DEBUG
 			VERIFY					(verify_entities());
-		}break;
+#endif
+		}
+		break;
 	case M_GAMEMESSAGE:
@@ -522,4 +555,7 @@
 			SendBroadcast			(BroadcastCID,P,net_flags(TRUE,TRUE));
+#ifdef DEBUG
 			VERIFY					(verify_entities());
-		}break;
+#endif
+		}
+		break;
 	case M_CLIENTREADY:
@@ -528,4 +564,7 @@
 			//game->signal_Syncronize	();
+#ifdef DEBUG
 			VERIFY					(verify_entities());
-		}break;
+#endif
+		}
+		break;
 	case M_SWITCH_DISTANCE:
@@ -533,4 +572,7 @@
 			game->switch_distance	(P,sender);
+#ifdef DEBUG
 			VERIFY					(verify_entities());
-		}break;
+#endif
+		}
+		break;
 	case M_CHANGE_LEVEL:
@@ -541,4 +583,7 @@
 			}
+#ifdef DEBUG
 			VERIFY					(verify_entities());
-		}break;
+#endif
+		}
+		break;
 	case M_SAVE_GAME:
@@ -546,4 +591,7 @@
 			game->save_game			(P,sender);
+#ifdef DEBUG
 			VERIFY					(verify_entities());
-		}break;
+#endif
+		}
+		break;
 	case M_LOAD_GAME:
@@ -552,4 +600,7 @@
 			SendBroadcast			(BroadcastCID,P,net_flags(TRUE,TRUE));
+#ifdef DEBUG
 			VERIFY					(verify_entities());
-		}break;
+#endif
+		}
+		break;
 	case M_RELOAD_GAME:
@@ -557,4 +608,7 @@
 			SendBroadcast			(BroadcastCID,P,net_flags(TRUE,TRUE));
+#ifdef DEBUG
 			VERIFY					(verify_entities());
-		}break;
+#endif
+		}
+		break;
 	case M_SAVE_PACKET:
@@ -562,4 +616,7 @@
 			Process_save			(P,sender);
+#ifdef DEBUG
 			VERIFY					(verify_entities());
-		}break;
+#endif
+		}
+		break;
 	case M_CLIENT_REQUEST_CONNECTION_DATA:
@@ -682,7 +758,8 @@
 			OnSecureMessage(P, CL);
-		}break;
 	}
-
+		break;
+	}
+#ifdef DEBUG
 	VERIFY							(verify_entities());
-
+#endif
 	return							IPureServer::OnMessage(P, sender);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/xrServer_process_event.cpp xray-monolith/src/xrGame/xrServer_process_event.cpp
--- coc-1.4-xray-64/src/xrGame/xrServer_process_event.cpp	2023-10-20 20:54:51.535325900 +0100
+++ xray-monolith/src/xrGame/xrServer_process_event.cpp	2023-10-20 20:54:33.431035200 +0100
@@ -89,4 +91,7 @@
 			Process_event_ownership	(P,sender,timestamp,destination);
+#ifdef DEBUG
 			VERIFY					(verify_entities());
-		}break;
+#endif
+		}
+		break;
 	case GE_OWNERSHIP_TAKE_MP_FORCED:
@@ -94,4 +99,7 @@
 			Process_event_ownership	(P,sender,timestamp,destination,TRUE);
+#ifdef DEBUG
 			VERIFY					(verify_entities());
-		}break;
+#endif
+		}
+		break;
 	case GE_TRADE_SELL:
@@ -101,4 +109,7 @@
 			Process_event_reject	(P,sender,timestamp,destination,P.r_u16());
+#ifdef DEBUG
 			VERIFY					(verify_entities());
-		}break;
+#endif
+		}
+		break;
 	case GE_DESTROY:
@@ -106,3 +117,5 @@
 			Process_event_destroy	(P,sender,timestamp,destination, NULL);
+#ifdef DEBUG
 			VERIFY					(verify_entities());
+#endif
 		}
@@ -126,3 +139,5 @@
 			entity_Destroy		(e_entity	);
+#ifdef DEBUG
 			VERIFY				(verify_entities());
+#endif
 		}
@@ -234,4 +256,5 @@
 			//////////////////////////////////////////////////////////////////////////
-
+#ifdef DEBUG
 			VERIFY					(verify_entities());
+#endif
 		}
@@ -341,4 +377,13 @@
 			pTa->m_dwMoney				= P.r_u32();
-						
-		}break;
+		}
+		break;
+	case GE_TRADER_FLAGS:
+		{
+			CSE_ALifeTraderAbstract* pTa = smart_cast<CSE_ALifeTraderAbstract*>(receiver);
+			if (pTa)
+			{
+				pTa->m_trader_flags.assign(P.r_u32());
+			}
+		}
+		break;
 	case GE_FREEZE_OBJECT:
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/xrServer_process_event_reject.cpp xray-monolith/src/xrGame/xrServer_process_event_reject.cpp
--- coc-1.4-xray-64/src/xrGame/xrServer_process_event_reject.cpp	2023-10-20 20:54:51.536326700 +0100
+++ xray-monolith/src/xrGame/xrServer_process_event_reject.cpp	2023-10-20 20:54:33.432036600 +0100
@@ -32,3 +41,9 @@
 	{
-		Msg("! WARNING: SV: can't find children [%d] of parent [%d]", id_entity, e_parent);
+		xr_string clildrenList;
+		for (const u16& childID : e_parent->children)
+		{
+			clildrenList.append("! ").append(game->get_entity_from_eid(childID)->name_replace()).append("\n");
+		}
+		Msg("! WARNING: SV: can't find child [%s] of parent [%s]! Children list:\n%s", e_entity->name_replace(),
+		    e_parent->name_replace(), clildrenList.c_str());
 		return false;
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/xrServer_process_update.cpp xray-monolith/src/xrGame/xrServer_process_update.cpp
--- coc-1.4-xray-64/src/xrGame/xrServer_process_update.cpp	2023-10-20 20:54:51.537326700 +0100
+++ xray-monolith/src/xrGame/xrServer_process_update.cpp	2023-10-20 20:54:33.433035000 +0100
@@ -39,3 +41,3 @@
 				Debug.fatal	(DEBUG_INFO,
-					"Beer from the creator of '%s'; initiator: 0x%08x, r_tell() = %d, pos = %d, objectID = %d",
+				            "Beer from the creator of '%s'; initiator: 0x%08x, r_tell() = %d, pos = %d, objectID = %d, size = %d",
 					tmp,
@@ -44,3 +46,4 @@
 					_pos,
-					E->ID
+				            E->ID,
+							size
 				);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/xrServer_sls_clear.cpp xray-monolith/src/xrGame/xrServer_sls_clear.cpp
--- coc-1.4-xray-64/src/xrGame/xrServer_sls_clear.cpp	2023-10-20 20:54:51.537326700 +0100
+++ xray-monolith/src/xrGame/xrServer_sls_clear.cpp	2023-10-20 20:54:33.434036400 +0100
@@ -11,2 +11,11 @@
 	R_ASSERT				(object);
+	if (object->ID_Parent != 0xffff)
+	{
+		// LPCSTR name = object->name();
+		// if (name)
+		// 	Msg("Attempt to destroy object %s with parent %d", name, object->ID_Parent);
+		CSE_Abstract* parent = game->get_entity_from_eid(object->ID_Parent);
+		if (parent)
+			Perform_reject(object, parent, 2 * NET_Latency);
+	}
 	R_ASSERT				(object->ID_Parent == 0xffff);
diff -U1 -w -B -r coc-1.4-xray-64/src/xrGame/ZoneVisual.cpp xray-monolith/src/xrGame/ZoneVisual.cpp
--- coc-1.4-xray-64/src/xrGame/ZoneVisual.cpp	2023-10-20 20:54:50.747326700 +0100
+++ xray-monolith/src/xrGame/ZoneVisual.cpp	2023-10-20 20:54:32.695036300 +0100
@@ -25,3 +26,3 @@
 	m_attack_animation			= SA->ID_Cycle_Safe(Z->attack_animation);
-	R_ASSERT2				(
+	VERIFY2(
 		m_attack_animation.valid(),
@@ -36,3 +37,3 @@
 	m_idle_animation			= SA->ID_Cycle_Safe(Z->startup_animation);
-	R_ASSERT2				(
+	VERIFY2(
 		m_idle_animation.valid(),
@@ -46,2 +47,4 @@
 
+//	if (!(m_attack_animation.valid() && m_idle_animation.valid())) return FALSE;
+
 	SA->PlayCycle				(m_idle_animation);
